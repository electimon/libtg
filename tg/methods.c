/* generated by tl_generator */

#include "methods.h"
#include "stb_ds.h"
#include "alloc.h"
#include "../mtx/include/sel.h"

tlo_t * tl_true()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "true");
	int i;
	obj->id = 0x3fedd339;
	return obj;
}

tlo_t * tl_boolFalse()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "boolFalse");
	int i;
	obj->id = 0xbc799737;
	return obj;
}

tlo_t * tl_boolTrue()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "boolTrue");
	int i;
	obj->id = 0x997275b5;
	return obj;
}

tlo_t * tl_vector()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "vector");
	int i;
	obj->id = 0x1cb5c415;
	return obj;
}

tlo_t * tl_error(int arg_code, const char * arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "error");
	int i;
	obj->id = 0xc4b9f9bb;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_code);
	strcpy(obj->objs[0]->name, "code");

	//parse argument string
	if (arg_text){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[1]->name, "text");
	}

	return obj;
}

tlo_t * tl_ipPort(int arg_ipv4, int arg_port)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "ipPort");
	int i;
	obj->id = 0xd433ad73;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_ipv4);
	strcpy(obj->objs[0]->name, "ipv4");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_port);
	strcpy(obj->objs[1]->name, "port");
	return obj;
}

tlo_t * tl_ipPortSecret(int arg_ipv4, int arg_port, unsigned char * arg_secret, int len_arg_secret)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "ipPortSecret");
	int i;
	obj->id = 0x37982646;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_ipv4);
	strcpy(obj->objs[0]->name, "ipv4");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_port);
	strcpy(obj->objs[1]->name, "port");

	//parse argument bytes
	if (arg_secret){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_BYTES;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_secret, len_arg_secret);
		strcpy(obj->objs[2]->name, "secret");
	}

	return obj;
}

tlo_t * tl_accessPointRule(const char * arg_phone_prefix_rules, int arg_dc_id, IpPort *arg_ips, int len_arg_ips)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "accessPointRule");
	int i;
	obj->id = 0x4679b65f;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_phone_prefix_rules){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_phone_prefix_rules, strlen(arg_phone_prefix_rules));
		strcpy(obj->objs[0]->name, "phone_prefix_rules");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_dc_id);
	strcpy(obj->objs[1]->name, "dc_id");

	//parse argument vector<IpPort>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "ips");
	if (arg_ips){
		for(i=0; i<len_arg_ips; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_ips[i]->id);
			buf_cat(obj->objs[2]->value, arg_ips[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_help_configSimple(int arg_date, int arg_expires, AccessPointRule *arg_rules, int len_arg_rules)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_configSimple");
	int i;
	obj->id = 0x5a592a6c;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[0]->name, "date");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_expires);
	strcpy(obj->objs[1]->name, "expires");

	//parse argument vector<AccessPointRule>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "rules");
	if (arg_rules){
		for(i=0; i<len_arg_rules; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_rules[i]->id);
			buf_cat(obj->objs[2]->value, arg_rules[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_inputPeerPhotoFileLocationLegacy(bool arg_big, InputPeer arg_peer, long arg_volume_id, int arg_local_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPeerPhotoFileLocationLegacy");
	int i;
	obj->id = 0x27d69997;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_big);
	strcpy(obj->objs[1]->name, "big");
	if (arg_big)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_volume_id);
	strcpy(obj->objs[3]->name, "volume_id");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_local_id);
	strcpy(obj->objs[4]->name, "local_id");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputStickerSetThumbLegacy(InputStickerSet arg_stickerset, long arg_volume_id, int arg_local_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputStickerSetThumbLegacy");
	int i;
	obj->id = 0x0dbaeae9;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputStickerSet
	if (arg_stickerset){
		obj->objs[0] = arg_stickerset;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "stickerset");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_volume_id);
	strcpy(obj->objs[1]->name, "volume_id");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_local_id);
	strcpy(obj->objs[2]->name, "local_id");
	return obj;
}

tlo_t * tl_invokeWithBusinessConnectionPrefix(const char * arg_connection_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "invokeWithBusinessConnectionPrefix");
	int i;
	obj->id = 0xdd289f8e;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_connection_id){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_connection_id, strlen(arg_connection_id));
		strcpy(obj->objs[0]->name, "connection_id");
	}

	return obj;
}

tlo_t * tl_invokeWithGooglePlayIntegrityPrefix(const char * arg_nonce, const char * arg_token)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "invokeWithGooglePlayIntegrityPrefix");
	int i;
	obj->id = 0x1df92984;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_nonce){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_nonce, strlen(arg_nonce));
		strcpy(obj->objs[0]->name, "nonce");
	}


	//parse argument string
	if (arg_token){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_token, strlen(arg_token));
		strcpy(obj->objs[1]->name, "token");
	}

	return obj;
}

tlo_t * tl_invokeWithApnsSecretPrefix(const char * arg_nonce, const char * arg_secret)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "invokeWithApnsSecretPrefix");
	int i;
	obj->id = 0x0dae54f8;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_nonce){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_nonce, strlen(arg_nonce));
		strcpy(obj->objs[0]->name, "nonce");
	}


	//parse argument string
	if (arg_secret){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_secret, strlen(arg_secret));
		strcpy(obj->objs[1]->name, "secret");
	}

	return obj;
}

tlo_t * tl_inputPeerEmpty()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPeerEmpty");
	int i;
	obj->id = 0x7f3b18ea;
	return obj;
}

tlo_t * tl_inputPeerSelf()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPeerSelf");
	int i;
	obj->id = 0x7da07ec9;
	return obj;
}

tlo_t * tl_inputPeerChat(long arg_chat_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPeerChat");
	int i;
	obj->id = 0x35a95cb9;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_chat_id);
	strcpy(obj->objs[0]->name, "chat_id");
	return obj;
}

tlo_t * tl_inputPeerUser(long arg_user_id, long arg_access_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPeerUser");
	int i;
	obj->id = 0xdde8a54c;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[0]->name, "user_id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[1]->name, "access_hash");
	return obj;
}

tlo_t * tl_inputPeerChannel(long arg_channel_id, long arg_access_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPeerChannel");
	int i;
	obj->id = 0x27bcbbfc;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_channel_id);
	strcpy(obj->objs[0]->name, "channel_id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[1]->name, "access_hash");
	return obj;
}

tlo_t * tl_inputPeerUserFromMessage(InputPeer arg_peer, int arg_msg_id, long arg_user_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPeerUserFromMessage");
	int i;
	obj->id = 0xa87b0a1c;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[1]->name, "msg_id");

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[2]->name, "user_id");
	return obj;
}

tlo_t * tl_inputPeerChannelFromMessage(InputPeer arg_peer, int arg_msg_id, long arg_channel_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPeerChannelFromMessage");
	int i;
	obj->id = 0xbd2a0840;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[1]->name, "msg_id");

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_channel_id);
	strcpy(obj->objs[2]->name, "channel_id");
	return obj;
}

tlo_t * tl_inputUserEmpty()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputUserEmpty");
	int i;
	obj->id = 0xb98886cf;
	return obj;
}

tlo_t * tl_inputUserSelf()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputUserSelf");
	int i;
	obj->id = 0xf7c1b13f;
	return obj;
}

tlo_t * tl_inputUser(long arg_user_id, long arg_access_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputUser");
	int i;
	obj->id = 0xf21158c6;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[0]->name, "user_id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[1]->name, "access_hash");
	return obj;
}

tlo_t * tl_inputUserFromMessage(InputPeer arg_peer, int arg_msg_id, long arg_user_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputUserFromMessage");
	int i;
	obj->id = 0x1da448e2;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[1]->name, "msg_id");

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[2]->name, "user_id");
	return obj;
}

tlo_t * tl_inputPhoneContact(long arg_client_id, const char * arg_phone, const char * arg_first_name, const char * arg_last_name)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPhoneContact");
	int i;
	obj->id = 0xf392b7f4;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_client_id);
	strcpy(obj->objs[0]->name, "client_id");

	//parse argument string
	if (arg_phone){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_phone, strlen(arg_phone));
		strcpy(obj->objs[1]->name, "phone");
	}


	//parse argument string
	if (arg_first_name){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_first_name, strlen(arg_first_name));
		strcpy(obj->objs[2]->name, "first_name");
	}


	//parse argument string
	if (arg_last_name){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_last_name, strlen(arg_last_name));
		strcpy(obj->objs[3]->name, "last_name");
	}

	return obj;
}

tlo_t * tl_inputFile(long arg_id, int arg_parts, const char * arg_name, const char * arg_md5_checksum)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputFile");
	int i;
	obj->id = 0xf52ff27f;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_parts);
	strcpy(obj->objs[1]->name, "parts");

	//parse argument string
	if (arg_name){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_name, strlen(arg_name));
		strcpy(obj->objs[2]->name, "name");
	}


	//parse argument string
	if (arg_md5_checksum){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_md5_checksum, strlen(arg_md5_checksum));
		strcpy(obj->objs[3]->name, "md5_checksum");
	}

	return obj;
}

tlo_t * tl_inputFileBig(long arg_id, int arg_parts, const char * arg_name)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputFileBig");
	int i;
	obj->id = 0xfa4f0bb5;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_parts);
	strcpy(obj->objs[1]->name, "parts");

	//parse argument string
	if (arg_name){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_name, strlen(arg_name));
		strcpy(obj->objs[2]->name, "name");
	}

	return obj;
}

tlo_t * tl_inputFileStoryDocument(InputDocument arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputFileStoryDocument");
	int i;
	obj->id = 0x62dc8b48;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputDocument
	if (arg_id){
		obj->objs[0] = arg_id;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "id");
	}

	return obj;
}

tlo_t * tl_inputMediaEmpty()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMediaEmpty");
	int i;
	obj->id = 0x9664f57f;
	return obj;
}

tlo_t * tl_inputMediaUploadedPhoto(bool arg_spoiler, InputFile arg_file, InputDocument *arg_stickers, int len_arg_stickers, int arg_ttl_seconds)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMediaUploadedPhoto");
	int i;
	obj->id = 0x1e287d04;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 2;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_spoiler);
	strcpy(obj->objs[1]->name, "spoiler");
	if (arg_spoiler)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument InputFile
	if (arg_file){
		obj->objs[2] = arg_file;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "file");
	}


	//parse argument Vector<InputDocument>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "stickers");
	if (arg_stickers){
		for(i=0; i<len_arg_stickers; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_stickers[i]->id);
			buf_cat(obj->objs[3]->value, arg_stickers[i]->value);
		}
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 1;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_ttl_seconds);
	strcpy(obj->objs[4]->name, "ttl_seconds");
	if (arg_ttl_seconds)
		flagsv[nflags-1] |= (1 << 1);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputMediaPhoto(bool arg_spoiler, InputPhoto arg_id, int arg_ttl_seconds)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMediaPhoto");
	int i;
	obj->id = 0xb3ba0635;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_spoiler);
	strcpy(obj->objs[1]->name, "spoiler");
	if (arg_spoiler)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument InputPhoto
	if (arg_id){
		obj->objs[2] = arg_id;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "id");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_ttl_seconds);
	strcpy(obj->objs[3]->name, "ttl_seconds");
	if (arg_ttl_seconds)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputMediaGeoPoint(InputGeoPoint arg_geo_point)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMediaGeoPoint");
	int i;
	obj->id = 0xf9c44144;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputGeoPoint
	if (arg_geo_point){
		obj->objs[0] = arg_geo_point;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "geo_point");
	}

	return obj;
}

tlo_t * tl_inputMediaContact(const char * arg_phone_number, const char * arg_first_name, const char * arg_last_name, const char * arg_vcard)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMediaContact");
	int i;
	obj->id = 0xf8ab7dfb;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_phone_number){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_phone_number, strlen(arg_phone_number));
		strcpy(obj->objs[0]->name, "phone_number");
	}


	//parse argument string
	if (arg_first_name){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_first_name, strlen(arg_first_name));
		strcpy(obj->objs[1]->name, "first_name");
	}


	//parse argument string
	if (arg_last_name){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_last_name, strlen(arg_last_name));
		strcpy(obj->objs[2]->name, "last_name");
	}


	//parse argument string
	if (arg_vcard){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_vcard, strlen(arg_vcard));
		strcpy(obj->objs[3]->name, "vcard");
	}

	return obj;
}

tlo_t * tl_inputMediaUploadedDocument(bool arg_nosound_video, bool arg_force_file, bool arg_spoiler, InputFile arg_file, InputFile arg_thumb, const char * arg_mime_type, DocumentAttribute *arg_attributes, int len_arg_attributes, InputDocument *arg_stickers, int len_arg_stickers, int arg_ttl_seconds)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMediaUploadedDocument");
	int i;
	obj->id = 0x5b38c6c1;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 10;
	obj->objs = 
		(tlo_t **)MALLOC(10 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 3;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_nosound_video);
	strcpy(obj->objs[1]->name, "nosound_video");
	if (arg_nosound_video)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 4;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_force_file);
	strcpy(obj->objs[2]->name, "force_file");
	if (arg_force_file)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 5;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_spoiler);
	strcpy(obj->objs[3]->name, "spoiler");
	if (arg_spoiler)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument InputFile
	if (arg_file){
		obj->objs[4] = arg_file;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "file");
	}


	//parse argument InputFile
	if (arg_thumb){
		obj->objs[5] = arg_thumb;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 2;
	strcpy(obj->objs[5]->name, "thumb");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument string
	if (arg_mime_type){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_mime_type, strlen(arg_mime_type));
		strcpy(obj->objs[6]->name, "mime_type");
	}


	//parse argument Vector<DocumentAttribute>
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_VECTOR;
	strcpy(obj->objs[7]->name, "attributes");
	if (arg_attributes){
		for(i=0; i<len_arg_attributes; ++i){
			obj->objs[7]->value = buf_add_ui32(arg_attributes[i]->id);
			buf_cat(obj->objs[7]->value, arg_attributes[i]->value);
		}
	}


	//parse argument Vector<InputDocument>
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 0;
	obj->objs[8]->type = TYPE_VECTOR;
	strcpy(obj->objs[8]->name, "stickers");
	if (arg_stickers){
		for(i=0; i<len_arg_stickers; ++i){
			obj->objs[8]->value = buf_add_ui32(arg_stickers[i]->id);
			buf_cat(obj->objs[8]->value, arg_stickers[i]->value);
		}
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument int
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 1;
	obj->objs[9]->flag_bit = 1;
	obj->objs[9]->type = TYPE_INT;
	obj->objs[9]->value = 
		buf_add_ui32(arg_ttl_seconds);
	strcpy(obj->objs[9]->name, "ttl_seconds");
	if (arg_ttl_seconds)
		flagsv[nflags-1] |= (1 << 1);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputMediaDocument(bool arg_spoiler, InputDocument arg_id, int arg_ttl_seconds, const char * arg_query)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMediaDocument");
	int i;
	obj->id = 0x33473058;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 2;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_spoiler);
	strcpy(obj->objs[1]->name, "spoiler");
	if (arg_spoiler)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument InputDocument
	if (arg_id){
		obj->objs[2] = arg_id;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "id");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_ttl_seconds);
	strcpy(obj->objs[3]->name, "ttl_seconds");
	if (arg_ttl_seconds)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument string
	if (arg_query){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 1;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_query, strlen(arg_query));
		strcpy(obj->objs[4]->name, "query");
		flagsv[nflags-1] |= (1 << 1);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputMediaVenue(InputGeoPoint arg_geo_point, const char * arg_title, const char * arg_address, const char * arg_provider, const char * arg_venue_id, const char * arg_venue_type)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMediaVenue");
	int i;
	obj->id = 0xc13d1c11;
	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument InputGeoPoint
	if (arg_geo_point){
		obj->objs[0] = arg_geo_point;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "geo_point");
	}


	//parse argument string
	if (arg_title){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[1]->name, "title");
	}


	//parse argument string
	if (arg_address){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_address, strlen(arg_address));
		strcpy(obj->objs[2]->name, "address");
	}


	//parse argument string
	if (arg_provider){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_provider, strlen(arg_provider));
		strcpy(obj->objs[3]->name, "provider");
	}


	//parse argument string
	if (arg_venue_id){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_venue_id, strlen(arg_venue_id));
		strcpy(obj->objs[4]->name, "venue_id");
	}


	//parse argument string
	if (arg_venue_type){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_venue_type, strlen(arg_venue_type));
		strcpy(obj->objs[5]->name, "venue_type");
	}

	return obj;
}

tlo_t * tl_inputMediaPhotoExternal(bool arg_spoiler, const char * arg_url, int arg_ttl_seconds)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMediaPhotoExternal");
	int i;
	obj->id = 0xe5bbfe1a;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_spoiler);
	strcpy(obj->objs[1]->name, "spoiler");
	if (arg_spoiler)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument string
	if (arg_url){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[2]->name, "url");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_ttl_seconds);
	strcpy(obj->objs[3]->name, "ttl_seconds");
	if (arg_ttl_seconds)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputMediaDocumentExternal(bool arg_spoiler, const char * arg_url, int arg_ttl_seconds)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMediaDocumentExternal");
	int i;
	obj->id = 0xfb52dc99;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_spoiler);
	strcpy(obj->objs[1]->name, "spoiler");
	if (arg_spoiler)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument string
	if (arg_url){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[2]->name, "url");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_ttl_seconds);
	strcpy(obj->objs[3]->name, "ttl_seconds");
	if (arg_ttl_seconds)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputMediaGame(InputGame arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMediaGame");
	int i;
	obj->id = 0xd33f43f3;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputGame
	if (arg_id){
		obj->objs[0] = arg_id;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "id");
	}

	return obj;
}

tlo_t * tl_inputMediaInvoice(const char * arg_title, const char * arg_description, InputWebDocument arg_photo, Invoice arg_invoice, unsigned char * arg_payload, int len_arg_payload, const char * arg_provider, DataJSON arg_provider_data, const char * arg_start_param, InputMedia arg_extended_media)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMediaInvoice");
	int i;
	obj->id = 0x405fef0d;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 10;
	obj->objs = 
		(tlo_t **)MALLOC(10 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_title){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[1]->name, "title");
	}


	//parse argument string
	if (arg_description){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_description, strlen(arg_description));
		strcpy(obj->objs[2]->name, "description");
	}


	//parse argument InputWebDocument
	if (arg_photo){
		obj->objs[3] = arg_photo;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "photo");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument Invoice
	if (arg_invoice){
		obj->objs[4] = arg_invoice;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "invoice");
	}


	//parse argument bytes
	if (arg_payload){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_BYTES;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_payload, len_arg_payload);
		strcpy(obj->objs[5]->name, "payload");
	}


	//parse argument string
	if (arg_provider){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 3;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_provider, strlen(arg_provider));
		strcpy(obj->objs[6]->name, "provider");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument DataJSON
	if (arg_provider_data){
		obj->objs[7] = arg_provider_data;
		obj->objs[7]->flag_num = 0;
		obj->objs[7]->flag_bit = 0;
	strcpy(obj->objs[7]->name, "provider_data");
	}


	//parse argument string
	if (arg_start_param){
		obj->objs[8] = NEW(tlo_t, return NULL);
		obj->objs[8]->flag_num = 1;
		obj->objs[8]->flag_bit = 1;
		obj->objs[8]->type = TYPE_STRING;
		obj->objs[8]->value = 
			buf_add((ui8_t *)arg_start_param, strlen(arg_start_param));
		strcpy(obj->objs[8]->name, "start_param");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument InputMedia
	if (arg_extended_media){
		obj->objs[9] = arg_extended_media;
		obj->objs[9]->flag_num = 1;
		obj->objs[9]->flag_bit = 2;
	strcpy(obj->objs[9]->name, "extended_media");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputMediaGeoLive(bool arg_stopped, InputGeoPoint arg_geo_point, int arg_heading, int arg_period, int arg_proximity_notification_radius)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMediaGeoLive");
	int i;
	obj->id = 0x971fa843;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_stopped);
	strcpy(obj->objs[1]->name, "stopped");
	if (arg_stopped)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputGeoPoint
	if (arg_geo_point){
		obj->objs[2] = arg_geo_point;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "geo_point");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_heading);
	strcpy(obj->objs[3]->name, "heading");
	if (arg_heading)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 1;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_period);
	strcpy(obj->objs[4]->name, "period");
	if (arg_period)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 3;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_proximity_notification_radius);
	strcpy(obj->objs[5]->name, "proximity_notification_radius");
	if (arg_proximity_notification_radius)
		flagsv[nflags-1] |= (1 << 3);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputMediaPoll(Poll arg_poll, unsigned char * *arg_correct_answers, int len_arg_correct_answers, const char * arg_solution, MessageEntity *arg_solution_entities, int len_arg_solution_entities)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMediaPoll");
	int i;
	obj->id = 0x0f94e5f1;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument Poll
	if (arg_poll){
		obj->objs[1] = arg_poll;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "poll");
	}


	//parse argument Vector<bytes>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "correct_answers");
	if (arg_correct_answers){
		for(i=0; i<len_arg_correct_answers; ++i){
			int len = *(int *)(arg_correct_answers[i]);
			ui8_t *p = &(arg_correct_answers[i][4]);
			buf_t b = buf_add(p, len);
			buf_cat(obj->objs[2]->value, b);
		}
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_solution){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 1;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_solution, strlen(arg_solution));
		strcpy(obj->objs[3]->name, "solution");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument Vector<MessageEntity>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 1;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "solution_entities");
	if (arg_solution_entities){
		for(i=0; i<len_arg_solution_entities; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_solution_entities[i]->id);
			buf_cat(obj->objs[4]->value, arg_solution_entities[i]->value);
		}
		flagsv[nflags-1] |= (1 << 1);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputMediaDice(const char * arg_emoticon)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMediaDice");
	int i;
	obj->id = 0xe66fbf7b;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_emoticon){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_emoticon, strlen(arg_emoticon));
		strcpy(obj->objs[0]->name, "emoticon");
	}

	return obj;
}

tlo_t * tl_inputMediaStory(InputPeer arg_peer, int arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMediaStory");
	int i;
	obj->id = 0x89fdd778;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[1]->name, "id");
	return obj;
}

tlo_t * tl_inputMediaWebPage(bool arg_force_large_media, bool arg_force_small_media, bool arg_optional, const char * arg_url)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMediaWebPage");
	int i;
	obj->id = 0xc21b8849;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_force_large_media);
	strcpy(obj->objs[1]->name, "force_large_media");
	if (arg_force_large_media)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_force_small_media);
	strcpy(obj->objs[2]->name, "force_small_media");
	if (arg_force_small_media)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_optional);
	strcpy(obj->objs[3]->name, "optional");
	if (arg_optional)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument string
	if (arg_url){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[4]->name, "url");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputMediaPaidMedia(long arg_stars_amount, InputMedia *arg_extended_media, int len_arg_extended_media, const char * arg_payload)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMediaPaidMedia");
	int i;
	obj->id = 0xc4103386;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_stars_amount);
	strcpy(obj->objs[1]->name, "stars_amount");

	//parse argument Vector<InputMedia>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "extended_media");
	if (arg_extended_media){
		for(i=0; i<len_arg_extended_media; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_extended_media[i]->id);
			buf_cat(obj->objs[2]->value, arg_extended_media[i]->value);
		}
	}


	//parse argument string
	if (arg_payload){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_payload, strlen(arg_payload));
		strcpy(obj->objs[3]->name, "payload");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputChatPhotoEmpty()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputChatPhotoEmpty");
	int i;
	obj->id = 0x1ca48f57;
	return obj;
}

tlo_t * tl_inputChatUploadedPhoto(InputFile arg_file, InputFile arg_video, double arg_video_start_ts, VideoSize arg_video_emoji_markup)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputChatUploadedPhoto");
	int i;
	obj->id = 0xbdcdaec0;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputFile
	if (arg_file){
		obj->objs[1] = arg_file;
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "file");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument InputFile
	if (arg_video){
		obj->objs[2] = arg_video;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 1;
	strcpy(obj->objs[2]->name, "video");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument double
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_video_start_ts);
	strcpy(obj->objs[3]->name, "video_start_ts");
	if (arg_video_start_ts)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument VideoSize
	if (arg_video_emoji_markup){
		obj->objs[4] = arg_video_emoji_markup;
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 3;
	strcpy(obj->objs[4]->name, "video_emoji_markup");
		flagsv[nflags-1] |= (1 << 3);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputChatPhoto(InputPhoto arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputChatPhoto");
	int i;
	obj->id = 0x8953ad37;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputPhoto
	if (arg_id){
		obj->objs[0] = arg_id;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "id");
	}

	return obj;
}

tlo_t * tl_inputGeoPointEmpty()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputGeoPointEmpty");
	int i;
	obj->id = 0xe4c123d6;
	return obj;
}

tlo_t * tl_inputGeoPoint(double arg_lat, double arg_long, int arg_accuracy_radius)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputGeoPoint");
	int i;
	obj->id = 0x48222faf;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument double
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_lat);
	strcpy(obj->objs[1]->name, "lat");

	//parse argument double
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_long);
	strcpy(obj->objs[2]->name, "long");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_accuracy_radius);
	strcpy(obj->objs[3]->name, "accuracy_radius");
	if (arg_accuracy_radius)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputPhotoEmpty()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPhotoEmpty");
	int i;
	obj->id = 0x1cd7bf0d;
	return obj;
}

tlo_t * tl_inputPhoto(long arg_id, long arg_access_hash, unsigned char * arg_file_reference, int len_arg_file_reference)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPhoto");
	int i;
	obj->id = 0x3bb3b94a;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[1]->name, "access_hash");

	//parse argument bytes
	if (arg_file_reference){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_BYTES;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_file_reference, len_arg_file_reference);
		strcpy(obj->objs[2]->name, "file_reference");
	}

	return obj;
}

tlo_t * tl_inputFileLocation(long arg_volume_id, int arg_local_id, long arg_secret, unsigned char * arg_file_reference, int len_arg_file_reference)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputFileLocation");
	int i;
	obj->id = 0xdfdaabe1;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_volume_id);
	strcpy(obj->objs[0]->name, "volume_id");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_local_id);
	strcpy(obj->objs[1]->name, "local_id");

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_secret);
	strcpy(obj->objs[2]->name, "secret");

	//parse argument bytes
	if (arg_file_reference){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_BYTES;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_file_reference, len_arg_file_reference);
		strcpy(obj->objs[3]->name, "file_reference");
	}

	return obj;
}

tlo_t * tl_inputEncryptedFileLocation(long arg_id, long arg_access_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputEncryptedFileLocation");
	int i;
	obj->id = 0xf5235d55;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[1]->name, "access_hash");
	return obj;
}

tlo_t * tl_inputDocumentFileLocation(long arg_id, long arg_access_hash, unsigned char * arg_file_reference, int len_arg_file_reference, const char * arg_thumb_size)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputDocumentFileLocation");
	int i;
	obj->id = 0xbad07584;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[1]->name, "access_hash");

	//parse argument bytes
	if (arg_file_reference){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_BYTES;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_file_reference, len_arg_file_reference);
		strcpy(obj->objs[2]->name, "file_reference");
	}


	//parse argument string
	if (arg_thumb_size){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_thumb_size, strlen(arg_thumb_size));
		strcpy(obj->objs[3]->name, "thumb_size");
	}

	return obj;
}

tlo_t * tl_inputSecureFileLocation(long arg_id, long arg_access_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputSecureFileLocation");
	int i;
	obj->id = 0xcbc7ee28;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[1]->name, "access_hash");
	return obj;
}

tlo_t * tl_inputTakeoutFileLocation()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputTakeoutFileLocation");
	int i;
	obj->id = 0x29be5899;
	return obj;
}

tlo_t * tl_inputPhotoFileLocation(long arg_id, long arg_access_hash, unsigned char * arg_file_reference, int len_arg_file_reference, const char * arg_thumb_size)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPhotoFileLocation");
	int i;
	obj->id = 0x40181ffe;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[1]->name, "access_hash");

	//parse argument bytes
	if (arg_file_reference){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_BYTES;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_file_reference, len_arg_file_reference);
		strcpy(obj->objs[2]->name, "file_reference");
	}


	//parse argument string
	if (arg_thumb_size){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_thumb_size, strlen(arg_thumb_size));
		strcpy(obj->objs[3]->name, "thumb_size");
	}

	return obj;
}

tlo_t * tl_inputPhotoLegacyFileLocation(long arg_id, long arg_access_hash, unsigned char * arg_file_reference, int len_arg_file_reference, long arg_volume_id, int arg_local_id, long arg_secret)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPhotoLegacyFileLocation");
	int i;
	obj->id = 0xd83466f3;
	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[1]->name, "access_hash");

	//parse argument bytes
	if (arg_file_reference){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_BYTES;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_file_reference, len_arg_file_reference);
		strcpy(obj->objs[2]->name, "file_reference");
	}


	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_volume_id);
	strcpy(obj->objs[3]->name, "volume_id");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_local_id);
	strcpy(obj->objs[4]->name, "local_id");

	//parse argument long
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_LONG;
	obj->objs[5]->value = 
		buf_add_ui64(arg_secret);
	strcpy(obj->objs[5]->name, "secret");
	return obj;
}

tlo_t * tl_inputPeerPhotoFileLocation(bool arg_big, InputPeer arg_peer, long arg_photo_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPeerPhotoFileLocation");
	int i;
	obj->id = 0x37257e99;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_big);
	strcpy(obj->objs[1]->name, "big");
	if (arg_big)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_photo_id);
	strcpy(obj->objs[3]->name, "photo_id");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputStickerSetThumb(InputStickerSet arg_stickerset, int arg_thumb_version)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputStickerSetThumb");
	int i;
	obj->id = 0x9d84f3db;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputStickerSet
	if (arg_stickerset){
		obj->objs[0] = arg_stickerset;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "stickerset");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_thumb_version);
	strcpy(obj->objs[1]->name, "thumb_version");
	return obj;
}

tlo_t * tl_inputGroupCallStream(InputGroupCall arg_call, long arg_time_ms, int arg_scale, int arg_video_channel, int arg_video_quality)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputGroupCallStream");
	int i;
	obj->id = 0x0598a92a;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputGroupCall
	if (arg_call){
		obj->objs[1] = arg_call;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "call");
	}


	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_time_ms);
	strcpy(obj->objs[2]->name, "time_ms");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_scale);
	strcpy(obj->objs[3]->name, "scale");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_video_channel);
	strcpy(obj->objs[4]->name, "video_channel");
	if (arg_video_channel)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_video_quality);
	strcpy(obj->objs[5]->name, "video_quality");
	if (arg_video_quality)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_peerUser(long arg_user_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "peerUser");
	int i;
	obj->id = 0x59511722;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[0]->name, "user_id");
	return obj;
}

tlo_t * tl_peerChat(long arg_chat_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "peerChat");
	int i;
	obj->id = 0x36c6019a;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_chat_id);
	strcpy(obj->objs[0]->name, "chat_id");
	return obj;
}

tlo_t * tl_peerChannel(long arg_channel_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "peerChannel");
	int i;
	obj->id = 0xa2a5371e;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_channel_id);
	strcpy(obj->objs[0]->name, "channel_id");
	return obj;
}

tlo_t * tl_storage_fileUnknown()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "storage_fileUnknown");
	int i;
	obj->id = 0xaa963b05;
	return obj;
}

tlo_t * tl_storage_filePartial()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "storage_filePartial");
	int i;
	obj->id = 0x40bc6f52;
	return obj;
}

tlo_t * tl_storage_fileJpeg()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "storage_fileJpeg");
	int i;
	obj->id = 0x007efe0e;
	return obj;
}

tlo_t * tl_storage_fileGif()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "storage_fileGif");
	int i;
	obj->id = 0xcae1aadf;
	return obj;
}

tlo_t * tl_storage_filePng()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "storage_filePng");
	int i;
	obj->id = 0x0a4f63c0;
	return obj;
}

tlo_t * tl_storage_filePdf()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "storage_filePdf");
	int i;
	obj->id = 0xae1e508d;
	return obj;
}

tlo_t * tl_storage_fileMp3()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "storage_fileMp3");
	int i;
	obj->id = 0x528a0677;
	return obj;
}

tlo_t * tl_storage_fileMov()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "storage_fileMov");
	int i;
	obj->id = 0x4b09ebbc;
	return obj;
}

tlo_t * tl_storage_fileMp4()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "storage_fileMp4");
	int i;
	obj->id = 0xb3cea0e4;
	return obj;
}

tlo_t * tl_storage_fileWebp()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "storage_fileWebp");
	int i;
	obj->id = 0x1081464c;
	return obj;
}

tlo_t * tl_userEmpty(long arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "userEmpty");
	int i;
	obj->id = 0xd3bc4b7a;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");
	return obj;
}

tlo_t * tl_user(bool arg_self, bool arg_contact, bool arg_mutual_contact, bool arg_deleted, bool arg_bot, bool arg_bot_chat_history, bool arg_bot_nochats, bool arg_verified, bool arg_restricted, bool arg_min, bool arg_bot_inline_geo, bool arg_support, bool arg_scam, bool arg_apply_min_photo, bool arg_fake, bool arg_bot_attach_menu, bool arg_premium, bool arg_attach_menu_enabled, bool arg_bot_can_edit, bool arg_close_friend, bool arg_stories_hidden, bool arg_stories_unavailable, bool arg_contact_require_premium, bool arg_bot_business, bool arg_bot_has_main_app, long arg_id, long arg_access_hash, const char * arg_first_name, const char * arg_last_name, const char * arg_username, const char * arg_phone, UserProfilePhoto arg_photo, UserStatus arg_status, int arg_bot_info_version, RestrictionReason *arg_restriction_reason, int len_arg_restriction_reason, const char * arg_bot_inline_placeholder, const char * arg_lang_code, EmojiStatus arg_emoji_status, Username *arg_usernames, int len_arg_usernames, int arg_stories_max_id, PeerColor arg_color, PeerColor arg_profile_color, int arg_bot_active_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "user");
	int i;
	obj->id = 0x83314fca;
	int flags[2]; int nflags = 0; //flags position
 	int flagsv[2]; //flags values
	for (i=0;i<2;++i) flagsv[i]=0;
 	obj->nobjs = 45;
	obj->objs = 
		(tlo_t **)MALLOC(45 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 10;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_self);
	strcpy(obj->objs[1]->name, "self");
	if (arg_self)
		flagsv[nflags-1] |= (1 << 10);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 11;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_contact);
	strcpy(obj->objs[2]->name, "contact");
	if (arg_contact)
		flagsv[nflags-1] |= (1 << 11);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 12;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_mutual_contact);
	strcpy(obj->objs[3]->name, "mutual_contact");
	if (arg_mutual_contact)
		flagsv[nflags-1] |= (1 << 12);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 13;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_deleted);
	strcpy(obj->objs[4]->name, "deleted");
	if (arg_deleted)
		flagsv[nflags-1] |= (1 << 13);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 14;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_bot);
	strcpy(obj->objs[5]->name, "bot");
	if (arg_bot)
		flagsv[nflags-1] |= (1 << 14);

	//parse argument true
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 15;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_bot_chat_history);
	strcpy(obj->objs[6]->name, "bot_chat_history");
	if (arg_bot_chat_history)
		flagsv[nflags-1] |= (1 << 15);

	//parse argument true
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 16;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_bot_nochats);
	strcpy(obj->objs[7]->name, "bot_nochats");
	if (arg_bot_nochats)
		flagsv[nflags-1] |= (1 << 16);

	//parse argument true
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 17;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_verified);
	strcpy(obj->objs[8]->name, "verified");
	if (arg_verified)
		flagsv[nflags-1] |= (1 << 17);

	//parse argument true
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 1;
	obj->objs[9]->flag_bit = 18;
	obj->objs[9]->type = TYPE_INT;
	obj->objs[9]->value = 
		buf_add_ui32(arg_restricted);
	strcpy(obj->objs[9]->name, "restricted");
	if (arg_restricted)
		flagsv[nflags-1] |= (1 << 18);

	//parse argument true
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 1;
	obj->objs[10]->flag_bit = 20;
	obj->objs[10]->type = TYPE_INT;
	obj->objs[10]->value = 
		buf_add_ui32(arg_min);
	strcpy(obj->objs[10]->name, "min");
	if (arg_min)
		flagsv[nflags-1] |= (1 << 20);

	//parse argument true
	obj->objs[11] = NEW(tlo_t, return NULL);
	obj->objs[11]->flag_num = 1;
	obj->objs[11]->flag_bit = 21;
	obj->objs[11]->type = TYPE_INT;
	obj->objs[11]->value = 
		buf_add_ui32(arg_bot_inline_geo);
	strcpy(obj->objs[11]->name, "bot_inline_geo");
	if (arg_bot_inline_geo)
		flagsv[nflags-1] |= (1 << 21);

	//parse argument true
	obj->objs[12] = NEW(tlo_t, return NULL);
	obj->objs[12]->flag_num = 1;
	obj->objs[12]->flag_bit = 23;
	obj->objs[12]->type = TYPE_INT;
	obj->objs[12]->value = 
		buf_add_ui32(arg_support);
	strcpy(obj->objs[12]->name, "support");
	if (arg_support)
		flagsv[nflags-1] |= (1 << 23);

	//parse argument true
	obj->objs[13] = NEW(tlo_t, return NULL);
	obj->objs[13]->flag_num = 1;
	obj->objs[13]->flag_bit = 24;
	obj->objs[13]->type = TYPE_INT;
	obj->objs[13]->value = 
		buf_add_ui32(arg_scam);
	strcpy(obj->objs[13]->name, "scam");
	if (arg_scam)
		flagsv[nflags-1] |= (1 << 24);

	//parse argument true
	obj->objs[14] = NEW(tlo_t, return NULL);
	obj->objs[14]->flag_num = 1;
	obj->objs[14]->flag_bit = 25;
	obj->objs[14]->type = TYPE_INT;
	obj->objs[14]->value = 
		buf_add_ui32(arg_apply_min_photo);
	strcpy(obj->objs[14]->name, "apply_min_photo");
	if (arg_apply_min_photo)
		flagsv[nflags-1] |= (1 << 25);

	//parse argument true
	obj->objs[15] = NEW(tlo_t, return NULL);
	obj->objs[15]->flag_num = 1;
	obj->objs[15]->flag_bit = 26;
	obj->objs[15]->type = TYPE_INT;
	obj->objs[15]->value = 
		buf_add_ui32(arg_fake);
	strcpy(obj->objs[15]->name, "fake");
	if (arg_fake)
		flagsv[nflags-1] |= (1 << 26);

	//parse argument true
	obj->objs[16] = NEW(tlo_t, return NULL);
	obj->objs[16]->flag_num = 1;
	obj->objs[16]->flag_bit = 27;
	obj->objs[16]->type = TYPE_INT;
	obj->objs[16]->value = 
		buf_add_ui32(arg_bot_attach_menu);
	strcpy(obj->objs[16]->name, "bot_attach_menu");
	if (arg_bot_attach_menu)
		flagsv[nflags-1] |= (1 << 27);

	//parse argument true
	obj->objs[17] = NEW(tlo_t, return NULL);
	obj->objs[17]->flag_num = 1;
	obj->objs[17]->flag_bit = 28;
	obj->objs[17]->type = TYPE_INT;
	obj->objs[17]->value = 
		buf_add_ui32(arg_premium);
	strcpy(obj->objs[17]->name, "premium");
	if (arg_premium)
		flagsv[nflags-1] |= (1 << 28);

	//parse argument true
	obj->objs[18] = NEW(tlo_t, return NULL);
	obj->objs[18]->flag_num = 1;
	obj->objs[18]->flag_bit = 29;
	obj->objs[18]->type = TYPE_INT;
	obj->objs[18]->value = 
		buf_add_ui32(arg_attach_menu_enabled);
	strcpy(obj->objs[18]->name, "attach_menu_enabled");
	if (arg_attach_menu_enabled)
		flagsv[nflags-1] |= (1 << 29);

	//parse argument (null)
	obj->objs[19] = NEW(tlo_t, return NULL);
	flags[nflags++] = 19;
	obj->objs[19]->type = TYPE_FLAG;
	strcpy(obj->objs[19]->name, "flags2");

	//parse argument true
	obj->objs[20] = NEW(tlo_t, return NULL);
	obj->objs[20]->flag_num = 2;
	obj->objs[20]->flag_bit = 1;
	obj->objs[20]->type = TYPE_INT;
	obj->objs[20]->value = 
		buf_add_ui32(arg_bot_can_edit);
	strcpy(obj->objs[20]->name, "bot_can_edit");
	if (arg_bot_can_edit)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[21] = NEW(tlo_t, return NULL);
	obj->objs[21]->flag_num = 2;
	obj->objs[21]->flag_bit = 2;
	obj->objs[21]->type = TYPE_INT;
	obj->objs[21]->value = 
		buf_add_ui32(arg_close_friend);
	strcpy(obj->objs[21]->name, "close_friend");
	if (arg_close_friend)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[22] = NEW(tlo_t, return NULL);
	obj->objs[22]->flag_num = 2;
	obj->objs[22]->flag_bit = 3;
	obj->objs[22]->type = TYPE_INT;
	obj->objs[22]->value = 
		buf_add_ui32(arg_stories_hidden);
	strcpy(obj->objs[22]->name, "stories_hidden");
	if (arg_stories_hidden)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[23] = NEW(tlo_t, return NULL);
	obj->objs[23]->flag_num = 2;
	obj->objs[23]->flag_bit = 4;
	obj->objs[23]->type = TYPE_INT;
	obj->objs[23]->value = 
		buf_add_ui32(arg_stories_unavailable);
	strcpy(obj->objs[23]->name, "stories_unavailable");
	if (arg_stories_unavailable)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument true
	obj->objs[24] = NEW(tlo_t, return NULL);
	obj->objs[24]->flag_num = 2;
	obj->objs[24]->flag_bit = 10;
	obj->objs[24]->type = TYPE_INT;
	obj->objs[24]->value = 
		buf_add_ui32(arg_contact_require_premium);
	strcpy(obj->objs[24]->name, "contact_require_premium");
	if (arg_contact_require_premium)
		flagsv[nflags-1] |= (1 << 10);

	//parse argument true
	obj->objs[25] = NEW(tlo_t, return NULL);
	obj->objs[25]->flag_num = 2;
	obj->objs[25]->flag_bit = 11;
	obj->objs[25]->type = TYPE_INT;
	obj->objs[25]->value = 
		buf_add_ui32(arg_bot_business);
	strcpy(obj->objs[25]->name, "bot_business");
	if (arg_bot_business)
		flagsv[nflags-1] |= (1 << 11);

	//parse argument true
	obj->objs[26] = NEW(tlo_t, return NULL);
	obj->objs[26]->flag_num = 2;
	obj->objs[26]->flag_bit = 13;
	obj->objs[26]->type = TYPE_INT;
	obj->objs[26]->value = 
		buf_add_ui32(arg_bot_has_main_app);
	strcpy(obj->objs[26]->name, "bot_has_main_app");
	if (arg_bot_has_main_app)
		flagsv[nflags-1] |= (1 << 13);

	//parse argument long
	obj->objs[27] = NEW(tlo_t, return NULL);
	obj->objs[27]->flag_num = 0;
	obj->objs[27]->flag_bit = 0;
	obj->objs[27]->type = TYPE_LONG;
	obj->objs[27]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[27]->name, "id");

	//parse argument long
	obj->objs[28] = NEW(tlo_t, return NULL);
	obj->objs[28]->flag_num = 1;
	obj->objs[28]->flag_bit = 0;
	obj->objs[28]->type = TYPE_LONG;
	obj->objs[28]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[28]->name, "access_hash");
	if (arg_access_hash)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument string
	if (arg_first_name){
		obj->objs[29] = NEW(tlo_t, return NULL);
		obj->objs[29]->flag_num = 1;
		obj->objs[29]->flag_bit = 1;
		obj->objs[29]->type = TYPE_STRING;
		obj->objs[29]->value = 
			buf_add((ui8_t *)arg_first_name, strlen(arg_first_name));
		strcpy(obj->objs[29]->name, "first_name");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument string
	if (arg_last_name){
		obj->objs[30] = NEW(tlo_t, return NULL);
		obj->objs[30]->flag_num = 1;
		obj->objs[30]->flag_bit = 2;
		obj->objs[30]->type = TYPE_STRING;
		obj->objs[30]->value = 
			buf_add((ui8_t *)arg_last_name, strlen(arg_last_name));
		strcpy(obj->objs[30]->name, "last_name");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument string
	if (arg_username){
		obj->objs[31] = NEW(tlo_t, return NULL);
		obj->objs[31]->flag_num = 1;
		obj->objs[31]->flag_bit = 3;
		obj->objs[31]->type = TYPE_STRING;
		obj->objs[31]->value = 
			buf_add((ui8_t *)arg_username, strlen(arg_username));
		strcpy(obj->objs[31]->name, "username");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument string
	if (arg_phone){
		obj->objs[32] = NEW(tlo_t, return NULL);
		obj->objs[32]->flag_num = 1;
		obj->objs[32]->flag_bit = 4;
		obj->objs[32]->type = TYPE_STRING;
		obj->objs[32]->value = 
			buf_add((ui8_t *)arg_phone, strlen(arg_phone));
		strcpy(obj->objs[32]->name, "phone");
		flagsv[nflags-1] |= (1 << 4);
	}


	//parse argument UserProfilePhoto
	if (arg_photo){
		obj->objs[33] = arg_photo;
		obj->objs[33]->flag_num = 1;
		obj->objs[33]->flag_bit = 5;
	strcpy(obj->objs[33]->name, "photo");
		flagsv[nflags-1] |= (1 << 5);
	}


	//parse argument UserStatus
	if (arg_status){
		obj->objs[34] = arg_status;
		obj->objs[34]->flag_num = 1;
		obj->objs[34]->flag_bit = 6;
	strcpy(obj->objs[34]->name, "status");
		flagsv[nflags-1] |= (1 << 6);
	}


	//parse argument int
	obj->objs[35] = NEW(tlo_t, return NULL);
	obj->objs[35]->flag_num = 1;
	obj->objs[35]->flag_bit = 14;
	obj->objs[35]->type = TYPE_INT;
	obj->objs[35]->value = 
		buf_add_ui32(arg_bot_info_version);
	strcpy(obj->objs[35]->name, "bot_info_version");
	if (arg_bot_info_version)
		flagsv[nflags-1] |= (1 << 14);

	//parse argument Vector<RestrictionReason>
	obj->objs[36] = NEW(tlo_t, return NULL);
	obj->objs[36]->flag_num = 1;
	obj->objs[36]->flag_bit = 18;
	obj->objs[36]->type = TYPE_VECTOR;
	strcpy(obj->objs[36]->name, "restriction_reason");
	if (arg_restriction_reason){
		for(i=0; i<len_arg_restriction_reason; ++i){
			obj->objs[36]->value = buf_add_ui32(arg_restriction_reason[i]->id);
			buf_cat(obj->objs[36]->value, arg_restriction_reason[i]->value);
		}
		flagsv[nflags-1] |= (1 << 18);
	}


	//parse argument string
	if (arg_bot_inline_placeholder){
		obj->objs[37] = NEW(tlo_t, return NULL);
		obj->objs[37]->flag_num = 1;
		obj->objs[37]->flag_bit = 19;
		obj->objs[37]->type = TYPE_STRING;
		obj->objs[37]->value = 
			buf_add((ui8_t *)arg_bot_inline_placeholder, strlen(arg_bot_inline_placeholder));
		strcpy(obj->objs[37]->name, "bot_inline_placeholder");
		flagsv[nflags-1] |= (1 << 19);
	}


	//parse argument string
	if (arg_lang_code){
		obj->objs[38] = NEW(tlo_t, return NULL);
		obj->objs[38]->flag_num = 1;
		obj->objs[38]->flag_bit = 22;
		obj->objs[38]->type = TYPE_STRING;
		obj->objs[38]->value = 
			buf_add((ui8_t *)arg_lang_code, strlen(arg_lang_code));
		strcpy(obj->objs[38]->name, "lang_code");
		flagsv[nflags-1] |= (1 << 22);
	}


	//parse argument EmojiStatus
	if (arg_emoji_status){
		obj->objs[39] = arg_emoji_status;
		obj->objs[39]->flag_num = 1;
		obj->objs[39]->flag_bit = 30;
	strcpy(obj->objs[39]->name, "emoji_status");
		flagsv[nflags-1] |= (1 << 30);
	}


	//parse argument Vector<Username>
	obj->objs[40] = NEW(tlo_t, return NULL);
	obj->objs[40]->flag_num = 2;
	obj->objs[40]->flag_bit = 0;
	obj->objs[40]->type = TYPE_VECTOR;
	strcpy(obj->objs[40]->name, "usernames");
	if (arg_usernames){
		for(i=0; i<len_arg_usernames; ++i){
			obj->objs[40]->value = buf_add_ui32(arg_usernames[i]->id);
			buf_cat(obj->objs[40]->value, arg_usernames[i]->value);
		}
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument int
	obj->objs[41] = NEW(tlo_t, return NULL);
	obj->objs[41]->flag_num = 2;
	obj->objs[41]->flag_bit = 5;
	obj->objs[41]->type = TYPE_INT;
	obj->objs[41]->value = 
		buf_add_ui32(arg_stories_max_id);
	strcpy(obj->objs[41]->name, "stories_max_id");
	if (arg_stories_max_id)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument PeerColor
	if (arg_color){
		obj->objs[42] = arg_color;
		obj->objs[42]->flag_num = 2;
		obj->objs[42]->flag_bit = 8;
	strcpy(obj->objs[42]->name, "color");
		flagsv[nflags-1] |= (1 << 8);
	}


	//parse argument PeerColor
	if (arg_profile_color){
		obj->objs[43] = arg_profile_color;
		obj->objs[43]->flag_num = 2;
		obj->objs[43]->flag_bit = 9;
	strcpy(obj->objs[43]->name, "profile_color");
		flagsv[nflags-1] |= (1 << 9);
	}


	//parse argument int
	obj->objs[44] = NEW(tlo_t, return NULL);
	obj->objs[44]->flag_num = 2;
	obj->objs[44]->flag_bit = 12;
	obj->objs[44]->type = TYPE_INT;
	obj->objs[44]->value = 
		buf_add_ui32(arg_bot_active_users);
	strcpy(obj->objs[44]->name, "bot_active_users");
	if (arg_bot_active_users)
		flagsv[nflags-1] |= (1 << 12);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	int flag1 = flags[1];
	obj->objs[flag1]->value = buf_add_ui32(flagsv[1]);
	obj->objs[flag1]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_userProfilePhotoEmpty()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "userProfilePhotoEmpty");
	int i;
	obj->id = 0x4f11bae1;
	return obj;
}

tlo_t * tl_userProfilePhoto(bool arg_has_video, bool arg_personal, long arg_photo_id, unsigned char * arg_stripped_thumb, int len_arg_stripped_thumb, int arg_dc_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "userProfilePhoto");
	int i;
	obj->id = 0x82d1f706;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_has_video);
	strcpy(obj->objs[1]->name, "has_video");
	if (arg_has_video)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 2;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_personal);
	strcpy(obj->objs[2]->name, "personal");
	if (arg_personal)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_photo_id);
	strcpy(obj->objs[3]->name, "photo_id");

	//parse argument bytes
	if (arg_stripped_thumb){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 1;
		obj->objs[4]->type = TYPE_BYTES;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_stripped_thumb, len_arg_stripped_thumb);
		strcpy(obj->objs[4]->name, "stripped_thumb");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_dc_id);
	strcpy(obj->objs[5]->name, "dc_id");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_userStatusEmpty()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "userStatusEmpty");
	int i;
	obj->id = 0x09d05049;
	return obj;
}

tlo_t * tl_userStatusOnline(int arg_expires)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "userStatusOnline");
	int i;
	obj->id = 0xedb93949;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_expires);
	strcpy(obj->objs[0]->name, "expires");
	return obj;
}

tlo_t * tl_userStatusOffline(int arg_was_online)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "userStatusOffline");
	int i;
	obj->id = 0x008c703f;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_was_online);
	strcpy(obj->objs[0]->name, "was_online");
	return obj;
}

tlo_t * tl_userStatusRecently(bool arg_by_me)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "userStatusRecently");
	int i;
	obj->id = 0x7b197dc8;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_by_me);
	strcpy(obj->objs[1]->name, "by_me");
	if (arg_by_me)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_userStatusLastWeek(bool arg_by_me)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "userStatusLastWeek");
	int i;
	obj->id = 0x541a1d1a;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_by_me);
	strcpy(obj->objs[1]->name, "by_me");
	if (arg_by_me)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_userStatusLastMonth(bool arg_by_me)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "userStatusLastMonth");
	int i;
	obj->id = 0x65899777;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_by_me);
	strcpy(obj->objs[1]->name, "by_me");
	if (arg_by_me)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_chatEmpty(long arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatEmpty");
	int i;
	obj->id = 0x29562865;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");
	return obj;
}

tlo_t * tl_chat(bool arg_creator, bool arg_left, bool arg_deactivated, bool arg_call_active, bool arg_call_not_empty, bool arg_noforwards, long arg_id, const char * arg_title, ChatPhoto arg_photo, int arg_participants_count, int arg_date, int arg_version, InputChannel arg_migrated_to, ChatAdminRights arg_admin_rights, ChatBannedRights arg_default_banned_rights)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chat");
	int i;
	obj->id = 0x41cbf256;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 16;
	obj->objs = 
		(tlo_t **)MALLOC(16 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_creator);
	strcpy(obj->objs[1]->name, "creator");
	if (arg_creator)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 2;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_left);
	strcpy(obj->objs[2]->name, "left");
	if (arg_left)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 5;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_deactivated);
	strcpy(obj->objs[3]->name, "deactivated");
	if (arg_deactivated)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 23;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_call_active);
	strcpy(obj->objs[4]->name, "call_active");
	if (arg_call_active)
		flagsv[nflags-1] |= (1 << 23);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 24;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_call_not_empty);
	strcpy(obj->objs[5]->name, "call_not_empty");
	if (arg_call_not_empty)
		flagsv[nflags-1] |= (1 << 24);

	//parse argument true
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 25;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_noforwards);
	strcpy(obj->objs[6]->name, "noforwards");
	if (arg_noforwards)
		flagsv[nflags-1] |= (1 << 25);

	//parse argument long
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_LONG;
	obj->objs[7]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[7]->name, "id");

	//parse argument string
	if (arg_title){
		obj->objs[8] = NEW(tlo_t, return NULL);
		obj->objs[8]->flag_num = 0;
		obj->objs[8]->flag_bit = 0;
		obj->objs[8]->type = TYPE_STRING;
		obj->objs[8]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[8]->name, "title");
	}


	//parse argument ChatPhoto
	if (arg_photo){
		obj->objs[9] = arg_photo;
		obj->objs[9]->flag_num = 0;
		obj->objs[9]->flag_bit = 0;
	strcpy(obj->objs[9]->name, "photo");
	}


	//parse argument int
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 0;
	obj->objs[10]->flag_bit = 0;
	obj->objs[10]->type = TYPE_INT;
	obj->objs[10]->value = 
		buf_add_ui32(arg_participants_count);
	strcpy(obj->objs[10]->name, "participants_count");

	//parse argument int
	obj->objs[11] = NEW(tlo_t, return NULL);
	obj->objs[11]->flag_num = 0;
	obj->objs[11]->flag_bit = 0;
	obj->objs[11]->type = TYPE_INT;
	obj->objs[11]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[11]->name, "date");

	//parse argument int
	obj->objs[12] = NEW(tlo_t, return NULL);
	obj->objs[12]->flag_num = 0;
	obj->objs[12]->flag_bit = 0;
	obj->objs[12]->type = TYPE_INT;
	obj->objs[12]->value = 
		buf_add_ui32(arg_version);
	strcpy(obj->objs[12]->name, "version");

	//parse argument InputChannel
	if (arg_migrated_to){
		obj->objs[13] = arg_migrated_to;
		obj->objs[13]->flag_num = 1;
		obj->objs[13]->flag_bit = 6;
	strcpy(obj->objs[13]->name, "migrated_to");
		flagsv[nflags-1] |= (1 << 6);
	}


	//parse argument ChatAdminRights
	if (arg_admin_rights){
		obj->objs[14] = arg_admin_rights;
		obj->objs[14]->flag_num = 1;
		obj->objs[14]->flag_bit = 14;
	strcpy(obj->objs[14]->name, "admin_rights");
		flagsv[nflags-1] |= (1 << 14);
	}


	//parse argument ChatBannedRights
	if (arg_default_banned_rights){
		obj->objs[15] = arg_default_banned_rights;
		obj->objs[15]->flag_num = 1;
		obj->objs[15]->flag_bit = 18;
	strcpy(obj->objs[15]->name, "default_banned_rights");
		flagsv[nflags-1] |= (1 << 18);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_chatForbidden(long arg_id, const char * arg_title)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatForbidden");
	int i;
	obj->id = 0x6592a1a7;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument string
	if (arg_title){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[1]->name, "title");
	}

	return obj;
}

tlo_t * tl_channel(bool arg_creator, bool arg_left, bool arg_broadcast, bool arg_verified, bool arg_megagroup, bool arg_restricted, bool arg_signatures, bool arg_min, bool arg_scam, bool arg_has_link, bool arg_has_geo, bool arg_slowmode_enabled, bool arg_call_active, bool arg_call_not_empty, bool arg_fake, bool arg_gigagroup, bool arg_noforwards, bool arg_join_to_send, bool arg_join_request, bool arg_forum, bool arg_stories_hidden, bool arg_stories_hidden_min, bool arg_stories_unavailable, bool arg_signature_profiles, long arg_id, long arg_access_hash, const char * arg_title, const char * arg_username, ChatPhoto arg_photo, int arg_date, RestrictionReason *arg_restriction_reason, int len_arg_restriction_reason, ChatAdminRights arg_admin_rights, ChatBannedRights arg_banned_rights, ChatBannedRights arg_default_banned_rights, int arg_participants_count, Username *arg_usernames, int len_arg_usernames, int arg_stories_max_id, PeerColor arg_color, PeerColor arg_profile_color, EmojiStatus arg_emoji_status, int arg_level, int arg_subscription_until_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channel");
	int i;
	obj->id = 0xfe4478bd;
	int flags[2]; int nflags = 0; //flags position
 	int flagsv[2]; //flags values
	for (i=0;i<2;++i) flagsv[i]=0;
 	obj->nobjs = 44;
	obj->objs = 
		(tlo_t **)MALLOC(44 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_creator);
	strcpy(obj->objs[1]->name, "creator");
	if (arg_creator)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 2;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_left);
	strcpy(obj->objs[2]->name, "left");
	if (arg_left)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 5;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_broadcast);
	strcpy(obj->objs[3]->name, "broadcast");
	if (arg_broadcast)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 7;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_verified);
	strcpy(obj->objs[4]->name, "verified");
	if (arg_verified)
		flagsv[nflags-1] |= (1 << 7);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 8;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_megagroup);
	strcpy(obj->objs[5]->name, "megagroup");
	if (arg_megagroup)
		flagsv[nflags-1] |= (1 << 8);

	//parse argument true
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 9;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_restricted);
	strcpy(obj->objs[6]->name, "restricted");
	if (arg_restricted)
		flagsv[nflags-1] |= (1 << 9);

	//parse argument true
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 11;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_signatures);
	strcpy(obj->objs[7]->name, "signatures");
	if (arg_signatures)
		flagsv[nflags-1] |= (1 << 11);

	//parse argument true
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 12;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_min);
	strcpy(obj->objs[8]->name, "min");
	if (arg_min)
		flagsv[nflags-1] |= (1 << 12);

	//parse argument true
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 1;
	obj->objs[9]->flag_bit = 19;
	obj->objs[9]->type = TYPE_INT;
	obj->objs[9]->value = 
		buf_add_ui32(arg_scam);
	strcpy(obj->objs[9]->name, "scam");
	if (arg_scam)
		flagsv[nflags-1] |= (1 << 19);

	//parse argument true
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 1;
	obj->objs[10]->flag_bit = 20;
	obj->objs[10]->type = TYPE_INT;
	obj->objs[10]->value = 
		buf_add_ui32(arg_has_link);
	strcpy(obj->objs[10]->name, "has_link");
	if (arg_has_link)
		flagsv[nflags-1] |= (1 << 20);

	//parse argument true
	obj->objs[11] = NEW(tlo_t, return NULL);
	obj->objs[11]->flag_num = 1;
	obj->objs[11]->flag_bit = 21;
	obj->objs[11]->type = TYPE_INT;
	obj->objs[11]->value = 
		buf_add_ui32(arg_has_geo);
	strcpy(obj->objs[11]->name, "has_geo");
	if (arg_has_geo)
		flagsv[nflags-1] |= (1 << 21);

	//parse argument true
	obj->objs[12] = NEW(tlo_t, return NULL);
	obj->objs[12]->flag_num = 1;
	obj->objs[12]->flag_bit = 22;
	obj->objs[12]->type = TYPE_INT;
	obj->objs[12]->value = 
		buf_add_ui32(arg_slowmode_enabled);
	strcpy(obj->objs[12]->name, "slowmode_enabled");
	if (arg_slowmode_enabled)
		flagsv[nflags-1] |= (1 << 22);

	//parse argument true
	obj->objs[13] = NEW(tlo_t, return NULL);
	obj->objs[13]->flag_num = 1;
	obj->objs[13]->flag_bit = 23;
	obj->objs[13]->type = TYPE_INT;
	obj->objs[13]->value = 
		buf_add_ui32(arg_call_active);
	strcpy(obj->objs[13]->name, "call_active");
	if (arg_call_active)
		flagsv[nflags-1] |= (1 << 23);

	//parse argument true
	obj->objs[14] = NEW(tlo_t, return NULL);
	obj->objs[14]->flag_num = 1;
	obj->objs[14]->flag_bit = 24;
	obj->objs[14]->type = TYPE_INT;
	obj->objs[14]->value = 
		buf_add_ui32(arg_call_not_empty);
	strcpy(obj->objs[14]->name, "call_not_empty");
	if (arg_call_not_empty)
		flagsv[nflags-1] |= (1 << 24);

	//parse argument true
	obj->objs[15] = NEW(tlo_t, return NULL);
	obj->objs[15]->flag_num = 1;
	obj->objs[15]->flag_bit = 25;
	obj->objs[15]->type = TYPE_INT;
	obj->objs[15]->value = 
		buf_add_ui32(arg_fake);
	strcpy(obj->objs[15]->name, "fake");
	if (arg_fake)
		flagsv[nflags-1] |= (1 << 25);

	//parse argument true
	obj->objs[16] = NEW(tlo_t, return NULL);
	obj->objs[16]->flag_num = 1;
	obj->objs[16]->flag_bit = 26;
	obj->objs[16]->type = TYPE_INT;
	obj->objs[16]->value = 
		buf_add_ui32(arg_gigagroup);
	strcpy(obj->objs[16]->name, "gigagroup");
	if (arg_gigagroup)
		flagsv[nflags-1] |= (1 << 26);

	//parse argument true
	obj->objs[17] = NEW(tlo_t, return NULL);
	obj->objs[17]->flag_num = 1;
	obj->objs[17]->flag_bit = 27;
	obj->objs[17]->type = TYPE_INT;
	obj->objs[17]->value = 
		buf_add_ui32(arg_noforwards);
	strcpy(obj->objs[17]->name, "noforwards");
	if (arg_noforwards)
		flagsv[nflags-1] |= (1 << 27);

	//parse argument true
	obj->objs[18] = NEW(tlo_t, return NULL);
	obj->objs[18]->flag_num = 1;
	obj->objs[18]->flag_bit = 28;
	obj->objs[18]->type = TYPE_INT;
	obj->objs[18]->value = 
		buf_add_ui32(arg_join_to_send);
	strcpy(obj->objs[18]->name, "join_to_send");
	if (arg_join_to_send)
		flagsv[nflags-1] |= (1 << 28);

	//parse argument true
	obj->objs[19] = NEW(tlo_t, return NULL);
	obj->objs[19]->flag_num = 1;
	obj->objs[19]->flag_bit = 29;
	obj->objs[19]->type = TYPE_INT;
	obj->objs[19]->value = 
		buf_add_ui32(arg_join_request);
	strcpy(obj->objs[19]->name, "join_request");
	if (arg_join_request)
		flagsv[nflags-1] |= (1 << 29);

	//parse argument true
	obj->objs[20] = NEW(tlo_t, return NULL);
	obj->objs[20]->flag_num = 1;
	obj->objs[20]->flag_bit = 30;
	obj->objs[20]->type = TYPE_INT;
	obj->objs[20]->value = 
		buf_add_ui32(arg_forum);
	strcpy(obj->objs[20]->name, "forum");
	if (arg_forum)
		flagsv[nflags-1] |= (1 << 30);

	//parse argument (null)
	obj->objs[21] = NEW(tlo_t, return NULL);
	flags[nflags++] = 21;
	obj->objs[21]->type = TYPE_FLAG;
	strcpy(obj->objs[21]->name, "flags2");

	//parse argument true
	obj->objs[22] = NEW(tlo_t, return NULL);
	obj->objs[22]->flag_num = 2;
	obj->objs[22]->flag_bit = 1;
	obj->objs[22]->type = TYPE_INT;
	obj->objs[22]->value = 
		buf_add_ui32(arg_stories_hidden);
	strcpy(obj->objs[22]->name, "stories_hidden");
	if (arg_stories_hidden)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[23] = NEW(tlo_t, return NULL);
	obj->objs[23]->flag_num = 2;
	obj->objs[23]->flag_bit = 2;
	obj->objs[23]->type = TYPE_INT;
	obj->objs[23]->value = 
		buf_add_ui32(arg_stories_hidden_min);
	strcpy(obj->objs[23]->name, "stories_hidden_min");
	if (arg_stories_hidden_min)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[24] = NEW(tlo_t, return NULL);
	obj->objs[24]->flag_num = 2;
	obj->objs[24]->flag_bit = 3;
	obj->objs[24]->type = TYPE_INT;
	obj->objs[24]->value = 
		buf_add_ui32(arg_stories_unavailable);
	strcpy(obj->objs[24]->name, "stories_unavailable");
	if (arg_stories_unavailable)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[25] = NEW(tlo_t, return NULL);
	obj->objs[25]->flag_num = 2;
	obj->objs[25]->flag_bit = 12;
	obj->objs[25]->type = TYPE_INT;
	obj->objs[25]->value = 
		buf_add_ui32(arg_signature_profiles);
	strcpy(obj->objs[25]->name, "signature_profiles");
	if (arg_signature_profiles)
		flagsv[nflags-1] |= (1 << 12);

	//parse argument long
	obj->objs[26] = NEW(tlo_t, return NULL);
	obj->objs[26]->flag_num = 0;
	obj->objs[26]->flag_bit = 0;
	obj->objs[26]->type = TYPE_LONG;
	obj->objs[26]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[26]->name, "id");

	//parse argument long
	obj->objs[27] = NEW(tlo_t, return NULL);
	obj->objs[27]->flag_num = 1;
	obj->objs[27]->flag_bit = 13;
	obj->objs[27]->type = TYPE_LONG;
	obj->objs[27]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[27]->name, "access_hash");
	if (arg_access_hash)
		flagsv[nflags-1] |= (1 << 13);

	//parse argument string
	if (arg_title){
		obj->objs[28] = NEW(tlo_t, return NULL);
		obj->objs[28]->flag_num = 0;
		obj->objs[28]->flag_bit = 0;
		obj->objs[28]->type = TYPE_STRING;
		obj->objs[28]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[28]->name, "title");
	}


	//parse argument string
	if (arg_username){
		obj->objs[29] = NEW(tlo_t, return NULL);
		obj->objs[29]->flag_num = 1;
		obj->objs[29]->flag_bit = 6;
		obj->objs[29]->type = TYPE_STRING;
		obj->objs[29]->value = 
			buf_add((ui8_t *)arg_username, strlen(arg_username));
		strcpy(obj->objs[29]->name, "username");
		flagsv[nflags-1] |= (1 << 6);
	}


	//parse argument ChatPhoto
	if (arg_photo){
		obj->objs[30] = arg_photo;
		obj->objs[30]->flag_num = 0;
		obj->objs[30]->flag_bit = 0;
	strcpy(obj->objs[30]->name, "photo");
	}


	//parse argument int
	obj->objs[31] = NEW(tlo_t, return NULL);
	obj->objs[31]->flag_num = 0;
	obj->objs[31]->flag_bit = 0;
	obj->objs[31]->type = TYPE_INT;
	obj->objs[31]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[31]->name, "date");

	//parse argument Vector<RestrictionReason>
	obj->objs[32] = NEW(tlo_t, return NULL);
	obj->objs[32]->flag_num = 1;
	obj->objs[32]->flag_bit = 9;
	obj->objs[32]->type = TYPE_VECTOR;
	strcpy(obj->objs[32]->name, "restriction_reason");
	if (arg_restriction_reason){
		for(i=0; i<len_arg_restriction_reason; ++i){
			obj->objs[32]->value = buf_add_ui32(arg_restriction_reason[i]->id);
			buf_cat(obj->objs[32]->value, arg_restriction_reason[i]->value);
		}
		flagsv[nflags-1] |= (1 << 9);
	}


	//parse argument ChatAdminRights
	if (arg_admin_rights){
		obj->objs[33] = arg_admin_rights;
		obj->objs[33]->flag_num = 1;
		obj->objs[33]->flag_bit = 14;
	strcpy(obj->objs[33]->name, "admin_rights");
		flagsv[nflags-1] |= (1 << 14);
	}


	//parse argument ChatBannedRights
	if (arg_banned_rights){
		obj->objs[34] = arg_banned_rights;
		obj->objs[34]->flag_num = 1;
		obj->objs[34]->flag_bit = 15;
	strcpy(obj->objs[34]->name, "banned_rights");
		flagsv[nflags-1] |= (1 << 15);
	}


	//parse argument ChatBannedRights
	if (arg_default_banned_rights){
		obj->objs[35] = arg_default_banned_rights;
		obj->objs[35]->flag_num = 1;
		obj->objs[35]->flag_bit = 18;
	strcpy(obj->objs[35]->name, "default_banned_rights");
		flagsv[nflags-1] |= (1 << 18);
	}


	//parse argument int
	obj->objs[36] = NEW(tlo_t, return NULL);
	obj->objs[36]->flag_num = 1;
	obj->objs[36]->flag_bit = 17;
	obj->objs[36]->type = TYPE_INT;
	obj->objs[36]->value = 
		buf_add_ui32(arg_participants_count);
	strcpy(obj->objs[36]->name, "participants_count");
	if (arg_participants_count)
		flagsv[nflags-1] |= (1 << 17);

	//parse argument Vector<Username>
	obj->objs[37] = NEW(tlo_t, return NULL);
	obj->objs[37]->flag_num = 2;
	obj->objs[37]->flag_bit = 0;
	obj->objs[37]->type = TYPE_VECTOR;
	strcpy(obj->objs[37]->name, "usernames");
	if (arg_usernames){
		for(i=0; i<len_arg_usernames; ++i){
			obj->objs[37]->value = buf_add_ui32(arg_usernames[i]->id);
			buf_cat(obj->objs[37]->value, arg_usernames[i]->value);
		}
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument int
	obj->objs[38] = NEW(tlo_t, return NULL);
	obj->objs[38]->flag_num = 2;
	obj->objs[38]->flag_bit = 4;
	obj->objs[38]->type = TYPE_INT;
	obj->objs[38]->value = 
		buf_add_ui32(arg_stories_max_id);
	strcpy(obj->objs[38]->name, "stories_max_id");
	if (arg_stories_max_id)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument PeerColor
	if (arg_color){
		obj->objs[39] = arg_color;
		obj->objs[39]->flag_num = 2;
		obj->objs[39]->flag_bit = 7;
	strcpy(obj->objs[39]->name, "color");
		flagsv[nflags-1] |= (1 << 7);
	}


	//parse argument PeerColor
	if (arg_profile_color){
		obj->objs[40] = arg_profile_color;
		obj->objs[40]->flag_num = 2;
		obj->objs[40]->flag_bit = 8;
	strcpy(obj->objs[40]->name, "profile_color");
		flagsv[nflags-1] |= (1 << 8);
	}


	//parse argument EmojiStatus
	if (arg_emoji_status){
		obj->objs[41] = arg_emoji_status;
		obj->objs[41]->flag_num = 2;
		obj->objs[41]->flag_bit = 9;
	strcpy(obj->objs[41]->name, "emoji_status");
		flagsv[nflags-1] |= (1 << 9);
	}


	//parse argument int
	obj->objs[42] = NEW(tlo_t, return NULL);
	obj->objs[42]->flag_num = 2;
	obj->objs[42]->flag_bit = 10;
	obj->objs[42]->type = TYPE_INT;
	obj->objs[42]->value = 
		buf_add_ui32(arg_level);
	strcpy(obj->objs[42]->name, "level");
	if (arg_level)
		flagsv[nflags-1] |= (1 << 10);

	//parse argument int
	obj->objs[43] = NEW(tlo_t, return NULL);
	obj->objs[43]->flag_num = 2;
	obj->objs[43]->flag_bit = 11;
	obj->objs[43]->type = TYPE_INT;
	obj->objs[43]->value = 
		buf_add_ui32(arg_subscription_until_date);
	strcpy(obj->objs[43]->name, "subscription_until_date");
	if (arg_subscription_until_date)
		flagsv[nflags-1] |= (1 << 11);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	int flag1 = flags[1];
	obj->objs[flag1]->value = buf_add_ui32(flagsv[1]);
	obj->objs[flag1]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_channelForbidden(bool arg_broadcast, bool arg_megagroup, long arg_id, long arg_access_hash, const char * arg_title, int arg_until_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelForbidden");
	int i;
	obj->id = 0x17d493d5;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 5;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_broadcast);
	strcpy(obj->objs[1]->name, "broadcast");
	if (arg_broadcast)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 8;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_megagroup);
	strcpy(obj->objs[2]->name, "megagroup");
	if (arg_megagroup)
		flagsv[nflags-1] |= (1 << 8);

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[3]->name, "id");

	//parse argument long
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[4]->name, "access_hash");

	//parse argument string
	if (arg_title){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[5]->name, "title");
	}


	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 16;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_until_date);
	strcpy(obj->objs[6]->name, "until_date");
	if (arg_until_date)
		flagsv[nflags-1] |= (1 << 16);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_chatFull(bool arg_can_set_username, bool arg_has_scheduled, bool arg_translations_disabled, long arg_id, const char * arg_about, ChatParticipants arg_participants, Photo arg_chat_photo, PeerNotifySettings arg_notify_settings, ExportedChatInvite arg_exported_invite, BotInfo *arg_bot_info, int len_arg_bot_info, int arg_pinned_msg_id, int arg_folder_id, InputGroupCall arg_call, int arg_ttl_period, Peer arg_groupcall_default_join_as, const char * arg_theme_emoticon, int arg_requests_pending, long *arg_recent_requesters, int len_arg_recent_requesters, ChatReactions arg_available_reactions, int arg_reactions_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatFull");
	int i;
	obj->id = 0x2633421b;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 21;
	obj->objs = 
		(tlo_t **)MALLOC(21 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 7;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_can_set_username);
	strcpy(obj->objs[1]->name, "can_set_username");
	if (arg_can_set_username)
		flagsv[nflags-1] |= (1 << 7);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 8;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_has_scheduled);
	strcpy(obj->objs[2]->name, "has_scheduled");
	if (arg_has_scheduled)
		flagsv[nflags-1] |= (1 << 8);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 19;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_translations_disabled);
	strcpy(obj->objs[3]->name, "translations_disabled");
	if (arg_translations_disabled)
		flagsv[nflags-1] |= (1 << 19);

	//parse argument long
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[4]->name, "id");

	//parse argument string
	if (arg_about){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_about, strlen(arg_about));
		strcpy(obj->objs[5]->name, "about");
	}


	//parse argument ChatParticipants
	if (arg_participants){
		obj->objs[6] = arg_participants;
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
	strcpy(obj->objs[6]->name, "participants");
	}


	//parse argument Photo
	if (arg_chat_photo){
		obj->objs[7] = arg_chat_photo;
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 2;
	strcpy(obj->objs[7]->name, "chat_photo");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument PeerNotifySettings
	if (arg_notify_settings){
		obj->objs[8] = arg_notify_settings;
		obj->objs[8]->flag_num = 0;
		obj->objs[8]->flag_bit = 0;
	strcpy(obj->objs[8]->name, "notify_settings");
	}


	//parse argument ExportedChatInvite
	if (arg_exported_invite){
		obj->objs[9] = arg_exported_invite;
		obj->objs[9]->flag_num = 1;
		obj->objs[9]->flag_bit = 13;
	strcpy(obj->objs[9]->name, "exported_invite");
		flagsv[nflags-1] |= (1 << 13);
	}


	//parse argument Vector<BotInfo>
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 1;
	obj->objs[10]->flag_bit = 3;
	obj->objs[10]->type = TYPE_VECTOR;
	strcpy(obj->objs[10]->name, "bot_info");
	if (arg_bot_info){
		for(i=0; i<len_arg_bot_info; ++i){
			obj->objs[10]->value = buf_add_ui32(arg_bot_info[i]->id);
			buf_cat(obj->objs[10]->value, arg_bot_info[i]->value);
		}
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument int
	obj->objs[11] = NEW(tlo_t, return NULL);
	obj->objs[11]->flag_num = 1;
	obj->objs[11]->flag_bit = 6;
	obj->objs[11]->type = TYPE_INT;
	obj->objs[11]->value = 
		buf_add_ui32(arg_pinned_msg_id);
	strcpy(obj->objs[11]->name, "pinned_msg_id");
	if (arg_pinned_msg_id)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument int
	obj->objs[12] = NEW(tlo_t, return NULL);
	obj->objs[12]->flag_num = 1;
	obj->objs[12]->flag_bit = 11;
	obj->objs[12]->type = TYPE_INT;
	obj->objs[12]->value = 
		buf_add_ui32(arg_folder_id);
	strcpy(obj->objs[12]->name, "folder_id");
	if (arg_folder_id)
		flagsv[nflags-1] |= (1 << 11);

	//parse argument InputGroupCall
	if (arg_call){
		obj->objs[13] = arg_call;
		obj->objs[13]->flag_num = 1;
		obj->objs[13]->flag_bit = 12;
	strcpy(obj->objs[13]->name, "call");
		flagsv[nflags-1] |= (1 << 12);
	}


	//parse argument int
	obj->objs[14] = NEW(tlo_t, return NULL);
	obj->objs[14]->flag_num = 1;
	obj->objs[14]->flag_bit = 14;
	obj->objs[14]->type = TYPE_INT;
	obj->objs[14]->value = 
		buf_add_ui32(arg_ttl_period);
	strcpy(obj->objs[14]->name, "ttl_period");
	if (arg_ttl_period)
		flagsv[nflags-1] |= (1 << 14);

	//parse argument Peer
	if (arg_groupcall_default_join_as){
		obj->objs[15] = arg_groupcall_default_join_as;
		obj->objs[15]->flag_num = 1;
		obj->objs[15]->flag_bit = 15;
	strcpy(obj->objs[15]->name, "groupcall_default_join_as");
		flagsv[nflags-1] |= (1 << 15);
	}


	//parse argument string
	if (arg_theme_emoticon){
		obj->objs[16] = NEW(tlo_t, return NULL);
		obj->objs[16]->flag_num = 1;
		obj->objs[16]->flag_bit = 16;
		obj->objs[16]->type = TYPE_STRING;
		obj->objs[16]->value = 
			buf_add((ui8_t *)arg_theme_emoticon, strlen(arg_theme_emoticon));
		strcpy(obj->objs[16]->name, "theme_emoticon");
		flagsv[nflags-1] |= (1 << 16);
	}


	//parse argument int
	obj->objs[17] = NEW(tlo_t, return NULL);
	obj->objs[17]->flag_num = 1;
	obj->objs[17]->flag_bit = 17;
	obj->objs[17]->type = TYPE_INT;
	obj->objs[17]->value = 
		buf_add_ui32(arg_requests_pending);
	strcpy(obj->objs[17]->name, "requests_pending");
	if (arg_requests_pending)
		flagsv[nflags-1] |= (1 << 17);

	//parse argument Vector<long>
	obj->objs[18] = NEW(tlo_t, return NULL);
	obj->objs[18]->flag_num = 1;
	obj->objs[18]->flag_bit = 17;
	obj->objs[18]->type = TYPE_VECTOR;
	strcpy(obj->objs[18]->name, "recent_requesters");
	if (arg_recent_requesters){
		for(i=0; i<len_arg_recent_requesters; ++i){
			buf_t b = buf_add_ui64(arg_recent_requesters[i]);
			buf_cat(obj->objs[18]->value, b);
		}
		flagsv[nflags-1] |= (1 << 17);
	}


	//parse argument ChatReactions
	if (arg_available_reactions){
		obj->objs[19] = arg_available_reactions;
		obj->objs[19]->flag_num = 1;
		obj->objs[19]->flag_bit = 18;
	strcpy(obj->objs[19]->name, "available_reactions");
		flagsv[nflags-1] |= (1 << 18);
	}


	//parse argument int
	obj->objs[20] = NEW(tlo_t, return NULL);
	obj->objs[20]->flag_num = 1;
	obj->objs[20]->flag_bit = 20;
	obj->objs[20]->type = TYPE_INT;
	obj->objs[20]->value = 
		buf_add_ui32(arg_reactions_limit);
	strcpy(obj->objs[20]->name, "reactions_limit");
	if (arg_reactions_limit)
		flagsv[nflags-1] |= (1 << 20);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_channelFull(bool arg_can_view_participants, bool arg_can_set_username, bool arg_can_set_stickers, bool arg_hidden_prehistory, bool arg_can_set_location, bool arg_has_scheduled, bool arg_can_view_stats, bool arg_blocked, bool arg_can_delete_channel, bool arg_antispam, bool arg_participants_hidden, bool arg_translations_disabled, bool arg_stories_pinned_available, bool arg_view_forum_as_messages, bool arg_restricted_sponsored, bool arg_can_view_revenue, bool arg_paid_media_allowed, bool arg_can_view_stars_revenue, bool arg_paid_reactions_available, long arg_id, const char * arg_about, int arg_participants_count, int arg_admins_count, int arg_kicked_count, int arg_banned_count, int arg_online_count, int arg_read_inbox_max_id, int arg_read_outbox_max_id, int arg_unread_count, Photo arg_chat_photo, PeerNotifySettings arg_notify_settings, ExportedChatInvite arg_exported_invite, BotInfo *arg_bot_info, int len_arg_bot_info, long arg_migrated_from_chat_id, int arg_migrated_from_max_id, int arg_pinned_msg_id, StickerSet arg_stickerset, int arg_available_min_id, int arg_folder_id, long arg_linked_chat_id, ChannelLocation arg_location, int arg_slowmode_seconds, int arg_slowmode_next_send_date, int arg_stats_dc, int arg_pts, InputGroupCall arg_call, int arg_ttl_period, const char * *arg_pending_suggestions, int len_arg_pending_suggestions, Peer arg_groupcall_default_join_as, const char * arg_theme_emoticon, int arg_requests_pending, long *arg_recent_requesters, int len_arg_recent_requesters, Peer arg_default_send_as, ChatReactions arg_available_reactions, int arg_reactions_limit, PeerStories arg_stories, WallPaper arg_wallpaper, int arg_boosts_applied, int arg_boosts_unrestrict, StickerSet arg_emojiset)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelFull");
	int i;
	obj->id = 0xbbab348d;
	int flags[2]; int nflags = 0; //flags position
 	int flagsv[2]; //flags values
	for (i=0;i<2;++i) flagsv[i]=0;
 	obj->nobjs = 62;
	obj->objs = 
		(tlo_t **)MALLOC(62 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 3;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_can_view_participants);
	strcpy(obj->objs[1]->name, "can_view_participants");
	if (arg_can_view_participants)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 6;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_can_set_username);
	strcpy(obj->objs[2]->name, "can_set_username");
	if (arg_can_set_username)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 7;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_can_set_stickers);
	strcpy(obj->objs[3]->name, "can_set_stickers");
	if (arg_can_set_stickers)
		flagsv[nflags-1] |= (1 << 7);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 10;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_hidden_prehistory);
	strcpy(obj->objs[4]->name, "hidden_prehistory");
	if (arg_hidden_prehistory)
		flagsv[nflags-1] |= (1 << 10);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 16;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_can_set_location);
	strcpy(obj->objs[5]->name, "can_set_location");
	if (arg_can_set_location)
		flagsv[nflags-1] |= (1 << 16);

	//parse argument true
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 19;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_has_scheduled);
	strcpy(obj->objs[6]->name, "has_scheduled");
	if (arg_has_scheduled)
		flagsv[nflags-1] |= (1 << 19);

	//parse argument true
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 20;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_can_view_stats);
	strcpy(obj->objs[7]->name, "can_view_stats");
	if (arg_can_view_stats)
		flagsv[nflags-1] |= (1 << 20);

	//parse argument true
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 22;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_blocked);
	strcpy(obj->objs[8]->name, "blocked");
	if (arg_blocked)
		flagsv[nflags-1] |= (1 << 22);

	//parse argument (null)
	obj->objs[9] = NEW(tlo_t, return NULL);
	flags[nflags++] = 9;
	obj->objs[9]->type = TYPE_FLAG;
	strcpy(obj->objs[9]->name, "flags2");

	//parse argument true
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 2;
	obj->objs[10]->flag_bit = 0;
	obj->objs[10]->type = TYPE_INT;
	obj->objs[10]->value = 
		buf_add_ui32(arg_can_delete_channel);
	strcpy(obj->objs[10]->name, "can_delete_channel");
	if (arg_can_delete_channel)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[11] = NEW(tlo_t, return NULL);
	obj->objs[11]->flag_num = 2;
	obj->objs[11]->flag_bit = 1;
	obj->objs[11]->type = TYPE_INT;
	obj->objs[11]->value = 
		buf_add_ui32(arg_antispam);
	strcpy(obj->objs[11]->name, "antispam");
	if (arg_antispam)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[12] = NEW(tlo_t, return NULL);
	obj->objs[12]->flag_num = 2;
	obj->objs[12]->flag_bit = 2;
	obj->objs[12]->type = TYPE_INT;
	obj->objs[12]->value = 
		buf_add_ui32(arg_participants_hidden);
	strcpy(obj->objs[12]->name, "participants_hidden");
	if (arg_participants_hidden)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[13] = NEW(tlo_t, return NULL);
	obj->objs[13]->flag_num = 2;
	obj->objs[13]->flag_bit = 3;
	obj->objs[13]->type = TYPE_INT;
	obj->objs[13]->value = 
		buf_add_ui32(arg_translations_disabled);
	strcpy(obj->objs[13]->name, "translations_disabled");
	if (arg_translations_disabled)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[14] = NEW(tlo_t, return NULL);
	obj->objs[14]->flag_num = 2;
	obj->objs[14]->flag_bit = 5;
	obj->objs[14]->type = TYPE_INT;
	obj->objs[14]->value = 
		buf_add_ui32(arg_stories_pinned_available);
	strcpy(obj->objs[14]->name, "stories_pinned_available");
	if (arg_stories_pinned_available)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument true
	obj->objs[15] = NEW(tlo_t, return NULL);
	obj->objs[15]->flag_num = 2;
	obj->objs[15]->flag_bit = 6;
	obj->objs[15]->type = TYPE_INT;
	obj->objs[15]->value = 
		buf_add_ui32(arg_view_forum_as_messages);
	strcpy(obj->objs[15]->name, "view_forum_as_messages");
	if (arg_view_forum_as_messages)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument true
	obj->objs[16] = NEW(tlo_t, return NULL);
	obj->objs[16]->flag_num = 2;
	obj->objs[16]->flag_bit = 11;
	obj->objs[16]->type = TYPE_INT;
	obj->objs[16]->value = 
		buf_add_ui32(arg_restricted_sponsored);
	strcpy(obj->objs[16]->name, "restricted_sponsored");
	if (arg_restricted_sponsored)
		flagsv[nflags-1] |= (1 << 11);

	//parse argument true
	obj->objs[17] = NEW(tlo_t, return NULL);
	obj->objs[17]->flag_num = 2;
	obj->objs[17]->flag_bit = 12;
	obj->objs[17]->type = TYPE_INT;
	obj->objs[17]->value = 
		buf_add_ui32(arg_can_view_revenue);
	strcpy(obj->objs[17]->name, "can_view_revenue");
	if (arg_can_view_revenue)
		flagsv[nflags-1] |= (1 << 12);

	//parse argument true
	obj->objs[18] = NEW(tlo_t, return NULL);
	obj->objs[18]->flag_num = 2;
	obj->objs[18]->flag_bit = 14;
	obj->objs[18]->type = TYPE_INT;
	obj->objs[18]->value = 
		buf_add_ui32(arg_paid_media_allowed);
	strcpy(obj->objs[18]->name, "paid_media_allowed");
	if (arg_paid_media_allowed)
		flagsv[nflags-1] |= (1 << 14);

	//parse argument true
	obj->objs[19] = NEW(tlo_t, return NULL);
	obj->objs[19]->flag_num = 2;
	obj->objs[19]->flag_bit = 15;
	obj->objs[19]->type = TYPE_INT;
	obj->objs[19]->value = 
		buf_add_ui32(arg_can_view_stars_revenue);
	strcpy(obj->objs[19]->name, "can_view_stars_revenue");
	if (arg_can_view_stars_revenue)
		flagsv[nflags-1] |= (1 << 15);

	//parse argument true
	obj->objs[20] = NEW(tlo_t, return NULL);
	obj->objs[20]->flag_num = 2;
	obj->objs[20]->flag_bit = 16;
	obj->objs[20]->type = TYPE_INT;
	obj->objs[20]->value = 
		buf_add_ui32(arg_paid_reactions_available);
	strcpy(obj->objs[20]->name, "paid_reactions_available");
	if (arg_paid_reactions_available)
		flagsv[nflags-1] |= (1 << 16);

	//parse argument long
	obj->objs[21] = NEW(tlo_t, return NULL);
	obj->objs[21]->flag_num = 0;
	obj->objs[21]->flag_bit = 0;
	obj->objs[21]->type = TYPE_LONG;
	obj->objs[21]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[21]->name, "id");

	//parse argument string
	if (arg_about){
		obj->objs[22] = NEW(tlo_t, return NULL);
		obj->objs[22]->flag_num = 0;
		obj->objs[22]->flag_bit = 0;
		obj->objs[22]->type = TYPE_STRING;
		obj->objs[22]->value = 
			buf_add((ui8_t *)arg_about, strlen(arg_about));
		strcpy(obj->objs[22]->name, "about");
	}


	//parse argument int
	obj->objs[23] = NEW(tlo_t, return NULL);
	obj->objs[23]->flag_num = 1;
	obj->objs[23]->flag_bit = 0;
	obj->objs[23]->type = TYPE_INT;
	obj->objs[23]->value = 
		buf_add_ui32(arg_participants_count);
	strcpy(obj->objs[23]->name, "participants_count");
	if (arg_participants_count)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[24] = NEW(tlo_t, return NULL);
	obj->objs[24]->flag_num = 1;
	obj->objs[24]->flag_bit = 1;
	obj->objs[24]->type = TYPE_INT;
	obj->objs[24]->value = 
		buf_add_ui32(arg_admins_count);
	strcpy(obj->objs[24]->name, "admins_count");
	if (arg_admins_count)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument int
	obj->objs[25] = NEW(tlo_t, return NULL);
	obj->objs[25]->flag_num = 1;
	obj->objs[25]->flag_bit = 2;
	obj->objs[25]->type = TYPE_INT;
	obj->objs[25]->value = 
		buf_add_ui32(arg_kicked_count);
	strcpy(obj->objs[25]->name, "kicked_count");
	if (arg_kicked_count)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument int
	obj->objs[26] = NEW(tlo_t, return NULL);
	obj->objs[26]->flag_num = 1;
	obj->objs[26]->flag_bit = 2;
	obj->objs[26]->type = TYPE_INT;
	obj->objs[26]->value = 
		buf_add_ui32(arg_banned_count);
	strcpy(obj->objs[26]->name, "banned_count");
	if (arg_banned_count)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument int
	obj->objs[27] = NEW(tlo_t, return NULL);
	obj->objs[27]->flag_num = 1;
	obj->objs[27]->flag_bit = 13;
	obj->objs[27]->type = TYPE_INT;
	obj->objs[27]->value = 
		buf_add_ui32(arg_online_count);
	strcpy(obj->objs[27]->name, "online_count");
	if (arg_online_count)
		flagsv[nflags-1] |= (1 << 13);

	//parse argument int
	obj->objs[28] = NEW(tlo_t, return NULL);
	obj->objs[28]->flag_num = 0;
	obj->objs[28]->flag_bit = 0;
	obj->objs[28]->type = TYPE_INT;
	obj->objs[28]->value = 
		buf_add_ui32(arg_read_inbox_max_id);
	strcpy(obj->objs[28]->name, "read_inbox_max_id");

	//parse argument int
	obj->objs[29] = NEW(tlo_t, return NULL);
	obj->objs[29]->flag_num = 0;
	obj->objs[29]->flag_bit = 0;
	obj->objs[29]->type = TYPE_INT;
	obj->objs[29]->value = 
		buf_add_ui32(arg_read_outbox_max_id);
	strcpy(obj->objs[29]->name, "read_outbox_max_id");

	//parse argument int
	obj->objs[30] = NEW(tlo_t, return NULL);
	obj->objs[30]->flag_num = 0;
	obj->objs[30]->flag_bit = 0;
	obj->objs[30]->type = TYPE_INT;
	obj->objs[30]->value = 
		buf_add_ui32(arg_unread_count);
	strcpy(obj->objs[30]->name, "unread_count");

	//parse argument Photo
	if (arg_chat_photo){
		obj->objs[31] = arg_chat_photo;
		obj->objs[31]->flag_num = 0;
		obj->objs[31]->flag_bit = 0;
	strcpy(obj->objs[31]->name, "chat_photo");
	}


	//parse argument PeerNotifySettings
	if (arg_notify_settings){
		obj->objs[32] = arg_notify_settings;
		obj->objs[32]->flag_num = 0;
		obj->objs[32]->flag_bit = 0;
	strcpy(obj->objs[32]->name, "notify_settings");
	}


	//parse argument ExportedChatInvite
	if (arg_exported_invite){
		obj->objs[33] = arg_exported_invite;
		obj->objs[33]->flag_num = 1;
		obj->objs[33]->flag_bit = 23;
	strcpy(obj->objs[33]->name, "exported_invite");
		flagsv[nflags-1] |= (1 << 23);
	}


	//parse argument Vector<BotInfo>
	obj->objs[34] = NEW(tlo_t, return NULL);
	obj->objs[34]->flag_num = 0;
	obj->objs[34]->flag_bit = 0;
	obj->objs[34]->type = TYPE_VECTOR;
	strcpy(obj->objs[34]->name, "bot_info");
	if (arg_bot_info){
		for(i=0; i<len_arg_bot_info; ++i){
			obj->objs[34]->value = buf_add_ui32(arg_bot_info[i]->id);
			buf_cat(obj->objs[34]->value, arg_bot_info[i]->value);
		}
	}


	//parse argument long
	obj->objs[35] = NEW(tlo_t, return NULL);
	obj->objs[35]->flag_num = 1;
	obj->objs[35]->flag_bit = 4;
	obj->objs[35]->type = TYPE_LONG;
	obj->objs[35]->value = 
		buf_add_ui64(arg_migrated_from_chat_id);
	strcpy(obj->objs[35]->name, "migrated_from_chat_id");
	if (arg_migrated_from_chat_id)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument int
	obj->objs[36] = NEW(tlo_t, return NULL);
	obj->objs[36]->flag_num = 1;
	obj->objs[36]->flag_bit = 4;
	obj->objs[36]->type = TYPE_INT;
	obj->objs[36]->value = 
		buf_add_ui32(arg_migrated_from_max_id);
	strcpy(obj->objs[36]->name, "migrated_from_max_id");
	if (arg_migrated_from_max_id)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument int
	obj->objs[37] = NEW(tlo_t, return NULL);
	obj->objs[37]->flag_num = 1;
	obj->objs[37]->flag_bit = 5;
	obj->objs[37]->type = TYPE_INT;
	obj->objs[37]->value = 
		buf_add_ui32(arg_pinned_msg_id);
	strcpy(obj->objs[37]->name, "pinned_msg_id");
	if (arg_pinned_msg_id)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument StickerSet
	if (arg_stickerset){
		obj->objs[38] = arg_stickerset;
		obj->objs[38]->flag_num = 1;
		obj->objs[38]->flag_bit = 8;
	strcpy(obj->objs[38]->name, "stickerset");
		flagsv[nflags-1] |= (1 << 8);
	}


	//parse argument int
	obj->objs[39] = NEW(tlo_t, return NULL);
	obj->objs[39]->flag_num = 1;
	obj->objs[39]->flag_bit = 9;
	obj->objs[39]->type = TYPE_INT;
	obj->objs[39]->value = 
		buf_add_ui32(arg_available_min_id);
	strcpy(obj->objs[39]->name, "available_min_id");
	if (arg_available_min_id)
		flagsv[nflags-1] |= (1 << 9);

	//parse argument int
	obj->objs[40] = NEW(tlo_t, return NULL);
	obj->objs[40]->flag_num = 1;
	obj->objs[40]->flag_bit = 11;
	obj->objs[40]->type = TYPE_INT;
	obj->objs[40]->value = 
		buf_add_ui32(arg_folder_id);
	strcpy(obj->objs[40]->name, "folder_id");
	if (arg_folder_id)
		flagsv[nflags-1] |= (1 << 11);

	//parse argument long
	obj->objs[41] = NEW(tlo_t, return NULL);
	obj->objs[41]->flag_num = 1;
	obj->objs[41]->flag_bit = 14;
	obj->objs[41]->type = TYPE_LONG;
	obj->objs[41]->value = 
		buf_add_ui64(arg_linked_chat_id);
	strcpy(obj->objs[41]->name, "linked_chat_id");
	if (arg_linked_chat_id)
		flagsv[nflags-1] |= (1 << 14);

	//parse argument ChannelLocation
	if (arg_location){
		obj->objs[42] = arg_location;
		obj->objs[42]->flag_num = 1;
		obj->objs[42]->flag_bit = 15;
	strcpy(obj->objs[42]->name, "location");
		flagsv[nflags-1] |= (1 << 15);
	}


	//parse argument int
	obj->objs[43] = NEW(tlo_t, return NULL);
	obj->objs[43]->flag_num = 1;
	obj->objs[43]->flag_bit = 17;
	obj->objs[43]->type = TYPE_INT;
	obj->objs[43]->value = 
		buf_add_ui32(arg_slowmode_seconds);
	strcpy(obj->objs[43]->name, "slowmode_seconds");
	if (arg_slowmode_seconds)
		flagsv[nflags-1] |= (1 << 17);

	//parse argument int
	obj->objs[44] = NEW(tlo_t, return NULL);
	obj->objs[44]->flag_num = 1;
	obj->objs[44]->flag_bit = 18;
	obj->objs[44]->type = TYPE_INT;
	obj->objs[44]->value = 
		buf_add_ui32(arg_slowmode_next_send_date);
	strcpy(obj->objs[44]->name, "slowmode_next_send_date");
	if (arg_slowmode_next_send_date)
		flagsv[nflags-1] |= (1 << 18);

	//parse argument int
	obj->objs[45] = NEW(tlo_t, return NULL);
	obj->objs[45]->flag_num = 1;
	obj->objs[45]->flag_bit = 12;
	obj->objs[45]->type = TYPE_INT;
	obj->objs[45]->value = 
		buf_add_ui32(arg_stats_dc);
	strcpy(obj->objs[45]->name, "stats_dc");
	if (arg_stats_dc)
		flagsv[nflags-1] |= (1 << 12);

	//parse argument int
	obj->objs[46] = NEW(tlo_t, return NULL);
	obj->objs[46]->flag_num = 0;
	obj->objs[46]->flag_bit = 0;
	obj->objs[46]->type = TYPE_INT;
	obj->objs[46]->value = 
		buf_add_ui32(arg_pts);
	strcpy(obj->objs[46]->name, "pts");

	//parse argument InputGroupCall
	if (arg_call){
		obj->objs[47] = arg_call;
		obj->objs[47]->flag_num = 1;
		obj->objs[47]->flag_bit = 21;
	strcpy(obj->objs[47]->name, "call");
		flagsv[nflags-1] |= (1 << 21);
	}


	//parse argument int
	obj->objs[48] = NEW(tlo_t, return NULL);
	obj->objs[48]->flag_num = 1;
	obj->objs[48]->flag_bit = 24;
	obj->objs[48]->type = TYPE_INT;
	obj->objs[48]->value = 
		buf_add_ui32(arg_ttl_period);
	strcpy(obj->objs[48]->name, "ttl_period");
	if (arg_ttl_period)
		flagsv[nflags-1] |= (1 << 24);

	//parse argument Vector<string>
	obj->objs[49] = NEW(tlo_t, return NULL);
	obj->objs[49]->flag_num = 1;
	obj->objs[49]->flag_bit = 25;
	obj->objs[49]->type = TYPE_VECTOR;
	strcpy(obj->objs[49]->name, "pending_suggestions");
	if (arg_pending_suggestions){
		for(i=0; i<len_arg_pending_suggestions; ++i){
			int len = strlen(arg_pending_suggestions[i]);
			buf_t b = buf_add((ui8_t *)arg_pending_suggestions[i], len);
			buf_cat(obj->objs[49]->value, b);
		}
		flagsv[nflags-1] |= (1 << 25);
	}


	//parse argument Peer
	if (arg_groupcall_default_join_as){
		obj->objs[50] = arg_groupcall_default_join_as;
		obj->objs[50]->flag_num = 1;
		obj->objs[50]->flag_bit = 26;
	strcpy(obj->objs[50]->name, "groupcall_default_join_as");
		flagsv[nflags-1] |= (1 << 26);
	}


	//parse argument string
	if (arg_theme_emoticon){
		obj->objs[51] = NEW(tlo_t, return NULL);
		obj->objs[51]->flag_num = 1;
		obj->objs[51]->flag_bit = 27;
		obj->objs[51]->type = TYPE_STRING;
		obj->objs[51]->value = 
			buf_add((ui8_t *)arg_theme_emoticon, strlen(arg_theme_emoticon));
		strcpy(obj->objs[51]->name, "theme_emoticon");
		flagsv[nflags-1] |= (1 << 27);
	}


	//parse argument int
	obj->objs[52] = NEW(tlo_t, return NULL);
	obj->objs[52]->flag_num = 1;
	obj->objs[52]->flag_bit = 28;
	obj->objs[52]->type = TYPE_INT;
	obj->objs[52]->value = 
		buf_add_ui32(arg_requests_pending);
	strcpy(obj->objs[52]->name, "requests_pending");
	if (arg_requests_pending)
		flagsv[nflags-1] |= (1 << 28);

	//parse argument Vector<long>
	obj->objs[53] = NEW(tlo_t, return NULL);
	obj->objs[53]->flag_num = 1;
	obj->objs[53]->flag_bit = 28;
	obj->objs[53]->type = TYPE_VECTOR;
	strcpy(obj->objs[53]->name, "recent_requesters");
	if (arg_recent_requesters){
		for(i=0; i<len_arg_recent_requesters; ++i){
			buf_t b = buf_add_ui64(arg_recent_requesters[i]);
			buf_cat(obj->objs[53]->value, b);
		}
		flagsv[nflags-1] |= (1 << 28);
	}


	//parse argument Peer
	if (arg_default_send_as){
		obj->objs[54] = arg_default_send_as;
		obj->objs[54]->flag_num = 1;
		obj->objs[54]->flag_bit = 29;
	strcpy(obj->objs[54]->name, "default_send_as");
		flagsv[nflags-1] |= (1 << 29);
	}


	//parse argument ChatReactions
	if (arg_available_reactions){
		obj->objs[55] = arg_available_reactions;
		obj->objs[55]->flag_num = 1;
		obj->objs[55]->flag_bit = 30;
	strcpy(obj->objs[55]->name, "available_reactions");
		flagsv[nflags-1] |= (1 << 30);
	}


	//parse argument int
	obj->objs[56] = NEW(tlo_t, return NULL);
	obj->objs[56]->flag_num = 2;
	obj->objs[56]->flag_bit = 13;
	obj->objs[56]->type = TYPE_INT;
	obj->objs[56]->value = 
		buf_add_ui32(arg_reactions_limit);
	strcpy(obj->objs[56]->name, "reactions_limit");
	if (arg_reactions_limit)
		flagsv[nflags-1] |= (1 << 13);

	//parse argument PeerStories
	if (arg_stories){
		obj->objs[57] = arg_stories;
		obj->objs[57]->flag_num = 2;
		obj->objs[57]->flag_bit = 4;
	strcpy(obj->objs[57]->name, "stories");
		flagsv[nflags-1] |= (1 << 4);
	}


	//parse argument WallPaper
	if (arg_wallpaper){
		obj->objs[58] = arg_wallpaper;
		obj->objs[58]->flag_num = 2;
		obj->objs[58]->flag_bit = 7;
	strcpy(obj->objs[58]->name, "wallpaper");
		flagsv[nflags-1] |= (1 << 7);
	}


	//parse argument int
	obj->objs[59] = NEW(tlo_t, return NULL);
	obj->objs[59]->flag_num = 2;
	obj->objs[59]->flag_bit = 8;
	obj->objs[59]->type = TYPE_INT;
	obj->objs[59]->value = 
		buf_add_ui32(arg_boosts_applied);
	strcpy(obj->objs[59]->name, "boosts_applied");
	if (arg_boosts_applied)
		flagsv[nflags-1] |= (1 << 8);

	//parse argument int
	obj->objs[60] = NEW(tlo_t, return NULL);
	obj->objs[60]->flag_num = 2;
	obj->objs[60]->flag_bit = 9;
	obj->objs[60]->type = TYPE_INT;
	obj->objs[60]->value = 
		buf_add_ui32(arg_boosts_unrestrict);
	strcpy(obj->objs[60]->name, "boosts_unrestrict");
	if (arg_boosts_unrestrict)
		flagsv[nflags-1] |= (1 << 9);

	//parse argument StickerSet
	if (arg_emojiset){
		obj->objs[61] = arg_emojiset;
		obj->objs[61]->flag_num = 2;
		obj->objs[61]->flag_bit = 10;
	strcpy(obj->objs[61]->name, "emojiset");
		flagsv[nflags-1] |= (1 << 10);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	int flag1 = flags[1];
	obj->objs[flag1]->value = buf_add_ui32(flagsv[1]);
	obj->objs[flag1]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_chatParticipant(long arg_user_id, long arg_inviter_id, int arg_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatParticipant");
	int i;
	obj->id = 0xc02d4007;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[0]->name, "user_id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_inviter_id);
	strcpy(obj->objs[1]->name, "inviter_id");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[2]->name, "date");
	return obj;
}

tlo_t * tl_chatParticipantCreator(long arg_user_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatParticipantCreator");
	int i;
	obj->id = 0xe46bcee4;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[0]->name, "user_id");
	return obj;
}

tlo_t * tl_chatParticipantAdmin(long arg_user_id, long arg_inviter_id, int arg_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatParticipantAdmin");
	int i;
	obj->id = 0xa0933f5b;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[0]->name, "user_id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_inviter_id);
	strcpy(obj->objs[1]->name, "inviter_id");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[2]->name, "date");
	return obj;
}

tlo_t * tl_chatParticipantsForbidden(long arg_chat_id, ChatParticipant arg_self_participant)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatParticipantsForbidden");
	int i;
	obj->id = 0x8763d3e1;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_chat_id);
	strcpy(obj->objs[1]->name, "chat_id");

	//parse argument ChatParticipant
	if (arg_self_participant){
		obj->objs[2] = arg_self_participant;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "self_participant");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_chatParticipants(long arg_chat_id, ChatParticipant *arg_participants, int len_arg_participants, int arg_version)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatParticipants");
	int i;
	obj->id = 0x3cbc93f8;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_chat_id);
	strcpy(obj->objs[0]->name, "chat_id");

	//parse argument Vector<ChatParticipant>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "participants");
	if (arg_participants){
		for(i=0; i<len_arg_participants; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_participants[i]->id);
			buf_cat(obj->objs[1]->value, arg_participants[i]->value);
		}
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_version);
	strcpy(obj->objs[2]->name, "version");
	return obj;
}

tlo_t * tl_chatPhotoEmpty()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatPhotoEmpty");
	int i;
	obj->id = 0x37c1011c;
	return obj;
}

tlo_t * tl_chatPhoto(bool arg_has_video, long arg_photo_id, unsigned char * arg_stripped_thumb, int len_arg_stripped_thumb, int arg_dc_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatPhoto");
	int i;
	obj->id = 0x1c6e1c11;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_has_video);
	strcpy(obj->objs[1]->name, "has_video");
	if (arg_has_video)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_photo_id);
	strcpy(obj->objs[2]->name, "photo_id");

	//parse argument bytes
	if (arg_stripped_thumb){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 1;
		obj->objs[3]->type = TYPE_BYTES;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_stripped_thumb, len_arg_stripped_thumb);
		strcpy(obj->objs[3]->name, "stripped_thumb");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_dc_id);
	strcpy(obj->objs[4]->name, "dc_id");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messageEmpty(int arg_id, Peer arg_peer_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageEmpty");
	int i;
	obj->id = 0x90a6ca84;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[1]->name, "id");

	//parse argument Peer
	if (arg_peer_id){
		obj->objs[2] = arg_peer_id;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer_id");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_message(bool arg_out, bool arg_mentioned, bool arg_media_unread, bool arg_silent, bool arg_post, bool arg_from_scheduled, bool arg_legacy, bool arg_edit_hide, bool arg_pinned, bool arg_noforwards, bool arg_invert_media, bool arg_offline, int arg_id, Peer arg_from_id, int arg_from_boosts_applied, Peer arg_peer_id, Peer arg_saved_peer_id, MessageFwdHeader arg_fwd_from, long arg_via_bot_id, long arg_via_business_bot_id, MessageReplyHeader arg_reply_to, int arg_date, const char * arg_message, MessageMedia arg_media, ReplyMarkup arg_reply_markup, MessageEntity *arg_entities, int len_arg_entities, int arg_views, int arg_forwards, MessageReplies arg_replies, int arg_edit_date, const char * arg_post_author, long arg_grouped_id, MessageReactions arg_reactions, RestrictionReason *arg_restriction_reason, int len_arg_restriction_reason, int arg_ttl_period, int arg_quick_reply_shortcut_id, long arg_effect, FactCheck arg_factcheck)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "message");
	int i;
	obj->id = 0x94345242;
	int flags[2]; int nflags = 0; //flags position
 	int flagsv[2]; //flags values
	for (i=0;i<2;++i) flagsv[i]=0;
 	obj->nobjs = 40;
	obj->objs = 
		(tlo_t **)MALLOC(40 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_out);
	strcpy(obj->objs[1]->name, "out");
	if (arg_out)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 4;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_mentioned);
	strcpy(obj->objs[2]->name, "mentioned");
	if (arg_mentioned)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 5;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_media_unread);
	strcpy(obj->objs[3]->name, "media_unread");
	if (arg_media_unread)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 13;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_silent);
	strcpy(obj->objs[4]->name, "silent");
	if (arg_silent)
		flagsv[nflags-1] |= (1 << 13);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 14;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_post);
	strcpy(obj->objs[5]->name, "post");
	if (arg_post)
		flagsv[nflags-1] |= (1 << 14);

	//parse argument true
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 18;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_from_scheduled);
	strcpy(obj->objs[6]->name, "from_scheduled");
	if (arg_from_scheduled)
		flagsv[nflags-1] |= (1 << 18);

	//parse argument true
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 19;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_legacy);
	strcpy(obj->objs[7]->name, "legacy");
	if (arg_legacy)
		flagsv[nflags-1] |= (1 << 19);

	//parse argument true
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 21;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_edit_hide);
	strcpy(obj->objs[8]->name, "edit_hide");
	if (arg_edit_hide)
		flagsv[nflags-1] |= (1 << 21);

	//parse argument true
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 1;
	obj->objs[9]->flag_bit = 24;
	obj->objs[9]->type = TYPE_INT;
	obj->objs[9]->value = 
		buf_add_ui32(arg_pinned);
	strcpy(obj->objs[9]->name, "pinned");
	if (arg_pinned)
		flagsv[nflags-1] |= (1 << 24);

	//parse argument true
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 1;
	obj->objs[10]->flag_bit = 26;
	obj->objs[10]->type = TYPE_INT;
	obj->objs[10]->value = 
		buf_add_ui32(arg_noforwards);
	strcpy(obj->objs[10]->name, "noforwards");
	if (arg_noforwards)
		flagsv[nflags-1] |= (1 << 26);

	//parse argument true
	obj->objs[11] = NEW(tlo_t, return NULL);
	obj->objs[11]->flag_num = 1;
	obj->objs[11]->flag_bit = 27;
	obj->objs[11]->type = TYPE_INT;
	obj->objs[11]->value = 
		buf_add_ui32(arg_invert_media);
	strcpy(obj->objs[11]->name, "invert_media");
	if (arg_invert_media)
		flagsv[nflags-1] |= (1 << 27);

	//parse argument (null)
	obj->objs[12] = NEW(tlo_t, return NULL);
	flags[nflags++] = 12;
	obj->objs[12]->type = TYPE_FLAG;
	strcpy(obj->objs[12]->name, "flags2");

	//parse argument true
	obj->objs[13] = NEW(tlo_t, return NULL);
	obj->objs[13]->flag_num = 2;
	obj->objs[13]->flag_bit = 1;
	obj->objs[13]->type = TYPE_INT;
	obj->objs[13]->value = 
		buf_add_ui32(arg_offline);
	strcpy(obj->objs[13]->name, "offline");
	if (arg_offline)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument int
	obj->objs[14] = NEW(tlo_t, return NULL);
	obj->objs[14]->flag_num = 0;
	obj->objs[14]->flag_bit = 0;
	obj->objs[14]->type = TYPE_INT;
	obj->objs[14]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[14]->name, "id");

	//parse argument Peer
	if (arg_from_id){
		obj->objs[15] = arg_from_id;
		obj->objs[15]->flag_num = 1;
		obj->objs[15]->flag_bit = 8;
	strcpy(obj->objs[15]->name, "from_id");
		flagsv[nflags-1] |= (1 << 8);
	}


	//parse argument int
	obj->objs[16] = NEW(tlo_t, return NULL);
	obj->objs[16]->flag_num = 1;
	obj->objs[16]->flag_bit = 29;
	obj->objs[16]->type = TYPE_INT;
	obj->objs[16]->value = 
		buf_add_ui32(arg_from_boosts_applied);
	strcpy(obj->objs[16]->name, "from_boosts_applied");
	if (arg_from_boosts_applied)
		flagsv[nflags-1] |= (1 << 29);

	//parse argument Peer
	if (arg_peer_id){
		obj->objs[17] = arg_peer_id;
		obj->objs[17]->flag_num = 0;
		obj->objs[17]->flag_bit = 0;
	strcpy(obj->objs[17]->name, "peer_id");
	}


	//parse argument Peer
	if (arg_saved_peer_id){
		obj->objs[18] = arg_saved_peer_id;
		obj->objs[18]->flag_num = 1;
		obj->objs[18]->flag_bit = 28;
	strcpy(obj->objs[18]->name, "saved_peer_id");
		flagsv[nflags-1] |= (1 << 28);
	}


	//parse argument MessageFwdHeader
	if (arg_fwd_from){
		obj->objs[19] = arg_fwd_from;
		obj->objs[19]->flag_num = 1;
		obj->objs[19]->flag_bit = 2;
	strcpy(obj->objs[19]->name, "fwd_from");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument long
	obj->objs[20] = NEW(tlo_t, return NULL);
	obj->objs[20]->flag_num = 1;
	obj->objs[20]->flag_bit = 11;
	obj->objs[20]->type = TYPE_LONG;
	obj->objs[20]->value = 
		buf_add_ui64(arg_via_bot_id);
	strcpy(obj->objs[20]->name, "via_bot_id");
	if (arg_via_bot_id)
		flagsv[nflags-1] |= (1 << 11);

	//parse argument long
	obj->objs[21] = NEW(tlo_t, return NULL);
	obj->objs[21]->flag_num = 2;
	obj->objs[21]->flag_bit = 0;
	obj->objs[21]->type = TYPE_LONG;
	obj->objs[21]->value = 
		buf_add_ui64(arg_via_business_bot_id);
	strcpy(obj->objs[21]->name, "via_business_bot_id");
	if (arg_via_business_bot_id)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument MessageReplyHeader
	if (arg_reply_to){
		obj->objs[22] = arg_reply_to;
		obj->objs[22]->flag_num = 1;
		obj->objs[22]->flag_bit = 3;
	strcpy(obj->objs[22]->name, "reply_to");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument int
	obj->objs[23] = NEW(tlo_t, return NULL);
	obj->objs[23]->flag_num = 0;
	obj->objs[23]->flag_bit = 0;
	obj->objs[23]->type = TYPE_INT;
	obj->objs[23]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[23]->name, "date");

	//parse argument string
	if (arg_message){
		obj->objs[24] = NEW(tlo_t, return NULL);
		obj->objs[24]->flag_num = 0;
		obj->objs[24]->flag_bit = 0;
		obj->objs[24]->type = TYPE_STRING;
		obj->objs[24]->value = 
			buf_add((ui8_t *)arg_message, strlen(arg_message));
		strcpy(obj->objs[24]->name, "message");
	}


	//parse argument MessageMedia
	if (arg_media){
		obj->objs[25] = arg_media;
		obj->objs[25]->flag_num = 1;
		obj->objs[25]->flag_bit = 9;
	strcpy(obj->objs[25]->name, "media");
		flagsv[nflags-1] |= (1 << 9);
	}


	//parse argument ReplyMarkup
	if (arg_reply_markup){
		obj->objs[26] = arg_reply_markup;
		obj->objs[26]->flag_num = 1;
		obj->objs[26]->flag_bit = 6;
	strcpy(obj->objs[26]->name, "reply_markup");
		flagsv[nflags-1] |= (1 << 6);
	}


	//parse argument Vector<MessageEntity>
	obj->objs[27] = NEW(tlo_t, return NULL);
	obj->objs[27]->flag_num = 1;
	obj->objs[27]->flag_bit = 7;
	obj->objs[27]->type = TYPE_VECTOR;
	strcpy(obj->objs[27]->name, "entities");
	if (arg_entities){
		for(i=0; i<len_arg_entities; ++i){
			obj->objs[27]->value = buf_add_ui32(arg_entities[i]->id);
			buf_cat(obj->objs[27]->value, arg_entities[i]->value);
		}
		flagsv[nflags-1] |= (1 << 7);
	}


	//parse argument int
	obj->objs[28] = NEW(tlo_t, return NULL);
	obj->objs[28]->flag_num = 1;
	obj->objs[28]->flag_bit = 10;
	obj->objs[28]->type = TYPE_INT;
	obj->objs[28]->value = 
		buf_add_ui32(arg_views);
	strcpy(obj->objs[28]->name, "views");
	if (arg_views)
		flagsv[nflags-1] |= (1 << 10);

	//parse argument int
	obj->objs[29] = NEW(tlo_t, return NULL);
	obj->objs[29]->flag_num = 1;
	obj->objs[29]->flag_bit = 10;
	obj->objs[29]->type = TYPE_INT;
	obj->objs[29]->value = 
		buf_add_ui32(arg_forwards);
	strcpy(obj->objs[29]->name, "forwards");
	if (arg_forwards)
		flagsv[nflags-1] |= (1 << 10);

	//parse argument MessageReplies
	if (arg_replies){
		obj->objs[30] = arg_replies;
		obj->objs[30]->flag_num = 1;
		obj->objs[30]->flag_bit = 23;
	strcpy(obj->objs[30]->name, "replies");
		flagsv[nflags-1] |= (1 << 23);
	}


	//parse argument int
	obj->objs[31] = NEW(tlo_t, return NULL);
	obj->objs[31]->flag_num = 1;
	obj->objs[31]->flag_bit = 15;
	obj->objs[31]->type = TYPE_INT;
	obj->objs[31]->value = 
		buf_add_ui32(arg_edit_date);
	strcpy(obj->objs[31]->name, "edit_date");
	if (arg_edit_date)
		flagsv[nflags-1] |= (1 << 15);

	//parse argument string
	if (arg_post_author){
		obj->objs[32] = NEW(tlo_t, return NULL);
		obj->objs[32]->flag_num = 1;
		obj->objs[32]->flag_bit = 16;
		obj->objs[32]->type = TYPE_STRING;
		obj->objs[32]->value = 
			buf_add((ui8_t *)arg_post_author, strlen(arg_post_author));
		strcpy(obj->objs[32]->name, "post_author");
		flagsv[nflags-1] |= (1 << 16);
	}


	//parse argument long
	obj->objs[33] = NEW(tlo_t, return NULL);
	obj->objs[33]->flag_num = 1;
	obj->objs[33]->flag_bit = 17;
	obj->objs[33]->type = TYPE_LONG;
	obj->objs[33]->value = 
		buf_add_ui64(arg_grouped_id);
	strcpy(obj->objs[33]->name, "grouped_id");
	if (arg_grouped_id)
		flagsv[nflags-1] |= (1 << 17);

	//parse argument MessageReactions
	if (arg_reactions){
		obj->objs[34] = arg_reactions;
		obj->objs[34]->flag_num = 1;
		obj->objs[34]->flag_bit = 20;
	strcpy(obj->objs[34]->name, "reactions");
		flagsv[nflags-1] |= (1 << 20);
	}


	//parse argument Vector<RestrictionReason>
	obj->objs[35] = NEW(tlo_t, return NULL);
	obj->objs[35]->flag_num = 1;
	obj->objs[35]->flag_bit = 22;
	obj->objs[35]->type = TYPE_VECTOR;
	strcpy(obj->objs[35]->name, "restriction_reason");
	if (arg_restriction_reason){
		for(i=0; i<len_arg_restriction_reason; ++i){
			obj->objs[35]->value = buf_add_ui32(arg_restriction_reason[i]->id);
			buf_cat(obj->objs[35]->value, arg_restriction_reason[i]->value);
		}
		flagsv[nflags-1] |= (1 << 22);
	}


	//parse argument int
	obj->objs[36] = NEW(tlo_t, return NULL);
	obj->objs[36]->flag_num = 1;
	obj->objs[36]->flag_bit = 25;
	obj->objs[36]->type = TYPE_INT;
	obj->objs[36]->value = 
		buf_add_ui32(arg_ttl_period);
	strcpy(obj->objs[36]->name, "ttl_period");
	if (arg_ttl_period)
		flagsv[nflags-1] |= (1 << 25);

	//parse argument int
	obj->objs[37] = NEW(tlo_t, return NULL);
	obj->objs[37]->flag_num = 1;
	obj->objs[37]->flag_bit = 30;
	obj->objs[37]->type = TYPE_INT;
	obj->objs[37]->value = 
		buf_add_ui32(arg_quick_reply_shortcut_id);
	strcpy(obj->objs[37]->name, "quick_reply_shortcut_id");
	if (arg_quick_reply_shortcut_id)
		flagsv[nflags-1] |= (1 << 30);

	//parse argument long
	obj->objs[38] = NEW(tlo_t, return NULL);
	obj->objs[38]->flag_num = 2;
	obj->objs[38]->flag_bit = 2;
	obj->objs[38]->type = TYPE_LONG;
	obj->objs[38]->value = 
		buf_add_ui64(arg_effect);
	strcpy(obj->objs[38]->name, "effect");
	if (arg_effect)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument FactCheck
	if (arg_factcheck){
		obj->objs[39] = arg_factcheck;
		obj->objs[39]->flag_num = 2;
		obj->objs[39]->flag_bit = 3;
	strcpy(obj->objs[39]->name, "factcheck");
		flagsv[nflags-1] |= (1 << 3);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	int flag1 = flags[1];
	obj->objs[flag1]->value = buf_add_ui32(flagsv[1]);
	obj->objs[flag1]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messageService(bool arg_out, bool arg_mentioned, bool arg_media_unread, bool arg_silent, bool arg_post, bool arg_legacy, int arg_id, Peer arg_from_id, Peer arg_peer_id, MessageReplyHeader arg_reply_to, int arg_date, MessageAction arg_action, int arg_ttl_period)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageService");
	int i;
	obj->id = 0x2b085862;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 14;
	obj->objs = 
		(tlo_t **)MALLOC(14 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_out);
	strcpy(obj->objs[1]->name, "out");
	if (arg_out)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 4;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_mentioned);
	strcpy(obj->objs[2]->name, "mentioned");
	if (arg_mentioned)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 5;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_media_unread);
	strcpy(obj->objs[3]->name, "media_unread");
	if (arg_media_unread)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 13;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_silent);
	strcpy(obj->objs[4]->name, "silent");
	if (arg_silent)
		flagsv[nflags-1] |= (1 << 13);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 14;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_post);
	strcpy(obj->objs[5]->name, "post");
	if (arg_post)
		flagsv[nflags-1] |= (1 << 14);

	//parse argument true
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 19;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_legacy);
	strcpy(obj->objs[6]->name, "legacy");
	if (arg_legacy)
		flagsv[nflags-1] |= (1 << 19);

	//parse argument int
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[7]->name, "id");

	//parse argument Peer
	if (arg_from_id){
		obj->objs[8] = arg_from_id;
		obj->objs[8]->flag_num = 1;
		obj->objs[8]->flag_bit = 8;
	strcpy(obj->objs[8]->name, "from_id");
		flagsv[nflags-1] |= (1 << 8);
	}


	//parse argument Peer
	if (arg_peer_id){
		obj->objs[9] = arg_peer_id;
		obj->objs[9]->flag_num = 0;
		obj->objs[9]->flag_bit = 0;
	strcpy(obj->objs[9]->name, "peer_id");
	}


	//parse argument MessageReplyHeader
	if (arg_reply_to){
		obj->objs[10] = arg_reply_to;
		obj->objs[10]->flag_num = 1;
		obj->objs[10]->flag_bit = 3;
	strcpy(obj->objs[10]->name, "reply_to");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument int
	obj->objs[11] = NEW(tlo_t, return NULL);
	obj->objs[11]->flag_num = 0;
	obj->objs[11]->flag_bit = 0;
	obj->objs[11]->type = TYPE_INT;
	obj->objs[11]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[11]->name, "date");

	//parse argument MessageAction
	if (arg_action){
		obj->objs[12] = arg_action;
		obj->objs[12]->flag_num = 0;
		obj->objs[12]->flag_bit = 0;
	strcpy(obj->objs[12]->name, "action");
	}


	//parse argument int
	obj->objs[13] = NEW(tlo_t, return NULL);
	obj->objs[13]->flag_num = 1;
	obj->objs[13]->flag_bit = 25;
	obj->objs[13]->type = TYPE_INT;
	obj->objs[13]->value = 
		buf_add_ui32(arg_ttl_period);
	strcpy(obj->objs[13]->name, "ttl_period");
	if (arg_ttl_period)
		flagsv[nflags-1] |= (1 << 25);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messageMediaEmpty()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageMediaEmpty");
	int i;
	obj->id = 0x3ded6320;
	return obj;
}

tlo_t * tl_messageMediaPhoto(bool arg_spoiler, Photo arg_photo, int arg_ttl_seconds)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageMediaPhoto");
	int i;
	obj->id = 0x695150d7;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 3;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_spoiler);
	strcpy(obj->objs[1]->name, "spoiler");
	if (arg_spoiler)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument Photo
	if (arg_photo){
		obj->objs[2] = arg_photo;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "photo");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_ttl_seconds);
	strcpy(obj->objs[3]->name, "ttl_seconds");
	if (arg_ttl_seconds)
		flagsv[nflags-1] |= (1 << 2);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messageMediaGeo(GeoPoint arg_geo)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageMediaGeo");
	int i;
	obj->id = 0x56e0d474;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument GeoPoint
	if (arg_geo){
		obj->objs[0] = arg_geo;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "geo");
	}

	return obj;
}

tlo_t * tl_messageMediaContact(const char * arg_phone_number, const char * arg_first_name, const char * arg_last_name, const char * arg_vcard, long arg_user_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageMediaContact");
	int i;
	obj->id = 0x70322949;
	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_phone_number){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_phone_number, strlen(arg_phone_number));
		strcpy(obj->objs[0]->name, "phone_number");
	}


	//parse argument string
	if (arg_first_name){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_first_name, strlen(arg_first_name));
		strcpy(obj->objs[1]->name, "first_name");
	}


	//parse argument string
	if (arg_last_name){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_last_name, strlen(arg_last_name));
		strcpy(obj->objs[2]->name, "last_name");
	}


	//parse argument string
	if (arg_vcard){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_vcard, strlen(arg_vcard));
		strcpy(obj->objs[3]->name, "vcard");
	}


	//parse argument long
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[4]->name, "user_id");
	return obj;
}

tlo_t * tl_messageMediaUnsupported()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageMediaUnsupported");
	int i;
	obj->id = 0x9f84f49e;
	return obj;
}

tlo_t * tl_messageMediaDocument(bool arg_nopremium, bool arg_spoiler, bool arg_video, bool arg_round, bool arg_voice, Document arg_document, Document *arg_alt_documents, int len_arg_alt_documents, int arg_ttl_seconds)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageMediaDocument");
	int i;
	obj->id = 0xdd570bd5;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 3;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_nopremium);
	strcpy(obj->objs[1]->name, "nopremium");
	if (arg_nopremium)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 4;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_spoiler);
	strcpy(obj->objs[2]->name, "spoiler");
	if (arg_spoiler)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 6;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_video);
	strcpy(obj->objs[3]->name, "video");
	if (arg_video)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 7;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_round);
	strcpy(obj->objs[4]->name, "round");
	if (arg_round)
		flagsv[nflags-1] |= (1 << 7);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 8;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_voice);
	strcpy(obj->objs[5]->name, "voice");
	if (arg_voice)
		flagsv[nflags-1] |= (1 << 8);

	//parse argument Document
	if (arg_document){
		obj->objs[6] = arg_document;
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 0;
	strcpy(obj->objs[6]->name, "document");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument Vector<Document>
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 5;
	obj->objs[7]->type = TYPE_VECTOR;
	strcpy(obj->objs[7]->name, "alt_documents");
	if (arg_alt_documents){
		for(i=0; i<len_arg_alt_documents; ++i){
			obj->objs[7]->value = buf_add_ui32(arg_alt_documents[i]->id);
			buf_cat(obj->objs[7]->value, arg_alt_documents[i]->value);
		}
		flagsv[nflags-1] |= (1 << 5);
	}


	//parse argument int
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 2;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_ttl_seconds);
	strcpy(obj->objs[8]->name, "ttl_seconds");
	if (arg_ttl_seconds)
		flagsv[nflags-1] |= (1 << 2);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messageMediaWebPage(bool arg_force_large_media, bool arg_force_small_media, bool arg_manual, bool arg_safe, WebPage arg_webpage)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageMediaWebPage");
	int i;
	obj->id = 0xddf10c3b;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_force_large_media);
	strcpy(obj->objs[1]->name, "force_large_media");
	if (arg_force_large_media)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_force_small_media);
	strcpy(obj->objs[2]->name, "force_small_media");
	if (arg_force_small_media)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 3;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_manual);
	strcpy(obj->objs[3]->name, "manual");
	if (arg_manual)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 4;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_safe);
	strcpy(obj->objs[4]->name, "safe");
	if (arg_safe)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument WebPage
	if (arg_webpage){
		obj->objs[5] = arg_webpage;
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
	strcpy(obj->objs[5]->name, "webpage");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messageMediaVenue(GeoPoint arg_geo, const char * arg_title, const char * arg_address, const char * arg_provider, const char * arg_venue_id, const char * arg_venue_type)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageMediaVenue");
	int i;
	obj->id = 0x2ec0533f;
	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument GeoPoint
	if (arg_geo){
		obj->objs[0] = arg_geo;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "geo");
	}


	//parse argument string
	if (arg_title){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[1]->name, "title");
	}


	//parse argument string
	if (arg_address){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_address, strlen(arg_address));
		strcpy(obj->objs[2]->name, "address");
	}


	//parse argument string
	if (arg_provider){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_provider, strlen(arg_provider));
		strcpy(obj->objs[3]->name, "provider");
	}


	//parse argument string
	if (arg_venue_id){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_venue_id, strlen(arg_venue_id));
		strcpy(obj->objs[4]->name, "venue_id");
	}


	//parse argument string
	if (arg_venue_type){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_venue_type, strlen(arg_venue_type));
		strcpy(obj->objs[5]->name, "venue_type");
	}

	return obj;
}

tlo_t * tl_messageMediaGame(Game arg_game)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageMediaGame");
	int i;
	obj->id = 0xfdb19008;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Game
	if (arg_game){
		obj->objs[0] = arg_game;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "game");
	}

	return obj;
}

tlo_t * tl_messageMediaInvoice(bool arg_shipping_address_requested, bool arg_test, const char * arg_title, const char * arg_description, WebDocument arg_photo, int arg_receipt_msg_id, const char * arg_currency, long arg_total_amount, const char * arg_start_param, MessageExtendedMedia arg_extended_media)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageMediaInvoice");
	int i;
	obj->id = 0xf6a548d3;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 11;
	obj->objs = 
		(tlo_t **)MALLOC(11 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_shipping_address_requested);
	strcpy(obj->objs[1]->name, "shipping_address_requested");
	if (arg_shipping_address_requested)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 3;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_test);
	strcpy(obj->objs[2]->name, "test");
	if (arg_test)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument string
	if (arg_title){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[3]->name, "title");
	}


	//parse argument string
	if (arg_description){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_description, strlen(arg_description));
		strcpy(obj->objs[4]->name, "description");
	}


	//parse argument WebDocument
	if (arg_photo){
		obj->objs[5] = arg_photo;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 0;
	strcpy(obj->objs[5]->name, "photo");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 2;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_receipt_msg_id);
	strcpy(obj->objs[6]->name, "receipt_msg_id");
	if (arg_receipt_msg_id)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument string
	if (arg_currency){
		obj->objs[7] = NEW(tlo_t, return NULL);
		obj->objs[7]->flag_num = 0;
		obj->objs[7]->flag_bit = 0;
		obj->objs[7]->type = TYPE_STRING;
		obj->objs[7]->value = 
			buf_add((ui8_t *)arg_currency, strlen(arg_currency));
		strcpy(obj->objs[7]->name, "currency");
	}


	//parse argument long
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 0;
	obj->objs[8]->flag_bit = 0;
	obj->objs[8]->type = TYPE_LONG;
	obj->objs[8]->value = 
		buf_add_ui64(arg_total_amount);
	strcpy(obj->objs[8]->name, "total_amount");

	//parse argument string
	if (arg_start_param){
		obj->objs[9] = NEW(tlo_t, return NULL);
		obj->objs[9]->flag_num = 0;
		obj->objs[9]->flag_bit = 0;
		obj->objs[9]->type = TYPE_STRING;
		obj->objs[9]->value = 
			buf_add((ui8_t *)arg_start_param, strlen(arg_start_param));
		strcpy(obj->objs[9]->name, "start_param");
	}


	//parse argument MessageExtendedMedia
	if (arg_extended_media){
		obj->objs[10] = arg_extended_media;
		obj->objs[10]->flag_num = 1;
		obj->objs[10]->flag_bit = 4;
	strcpy(obj->objs[10]->name, "extended_media");
		flagsv[nflags-1] |= (1 << 4);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messageMediaGeoLive(GeoPoint arg_geo, int arg_heading, int arg_period, int arg_proximity_notification_radius)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageMediaGeoLive");
	int i;
	obj->id = 0xb940c666;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument GeoPoint
	if (arg_geo){
		obj->objs[1] = arg_geo;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "geo");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_heading);
	strcpy(obj->objs[2]->name, "heading");
	if (arg_heading)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_period);
	strcpy(obj->objs[3]->name, "period");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 1;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_proximity_notification_radius);
	strcpy(obj->objs[4]->name, "proximity_notification_radius");
	if (arg_proximity_notification_radius)
		flagsv[nflags-1] |= (1 << 1);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messageMediaPoll(Poll arg_poll, PollResults arg_results)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageMediaPoll");
	int i;
	obj->id = 0x4bd6e798;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Poll
	if (arg_poll){
		obj->objs[0] = arg_poll;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "poll");
	}


	//parse argument PollResults
	if (arg_results){
		obj->objs[1] = arg_results;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "results");
	}

	return obj;
}

tlo_t * tl_messageMediaDice(int arg_value, const char * arg_emoticon)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageMediaDice");
	int i;
	obj->id = 0x3f7ee58b;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_value);
	strcpy(obj->objs[0]->name, "value");

	//parse argument string
	if (arg_emoticon){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_emoticon, strlen(arg_emoticon));
		strcpy(obj->objs[1]->name, "emoticon");
	}

	return obj;
}

tlo_t * tl_messageMediaStory(bool arg_via_mention, Peer arg_peer, int arg_id, StoryItem arg_story)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageMediaStory");
	int i;
	obj->id = 0x68cb6283;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_via_mention);
	strcpy(obj->objs[1]->name, "via_mention");
	if (arg_via_mention)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument Peer
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[3]->name, "id");

	//parse argument StoryItem
	if (arg_story){
		obj->objs[4] = arg_story;
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "story");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messageMediaGiveaway(bool arg_only_new_subscribers, bool arg_winners_are_visible, long *arg_channels, int len_arg_channels, const char * *arg_countries_iso2, int len_arg_countries_iso2, const char * arg_prize_description, int arg_quantity, int arg_months, long arg_stars, int arg_until_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageMediaGiveaway");
	int i;
	obj->id = 0xaa073beb;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 10;
	obj->objs = 
		(tlo_t **)MALLOC(10 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_only_new_subscribers);
	strcpy(obj->objs[1]->name, "only_new_subscribers");
	if (arg_only_new_subscribers)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 2;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_winners_are_visible);
	strcpy(obj->objs[2]->name, "winners_are_visible");
	if (arg_winners_are_visible)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument Vector<long>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "channels");
	if (arg_channels){
		for(i=0; i<len_arg_channels; ++i){
			buf_t b = buf_add_ui64(arg_channels[i]);
			buf_cat(obj->objs[3]->value, b);
		}
	}


	//parse argument Vector<string>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 1;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "countries_iso2");
	if (arg_countries_iso2){
		for(i=0; i<len_arg_countries_iso2; ++i){
			int len = strlen(arg_countries_iso2[i]);
			buf_t b = buf_add((ui8_t *)arg_countries_iso2[i], len);
			buf_cat(obj->objs[4]->value, b);
		}
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument string
	if (arg_prize_description){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 3;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_prize_description, strlen(arg_prize_description));
		strcpy(obj->objs[5]->name, "prize_description");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_quantity);
	strcpy(obj->objs[6]->name, "quantity");

	//parse argument int
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 4;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_months);
	strcpy(obj->objs[7]->name, "months");
	if (arg_months)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument long
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 5;
	obj->objs[8]->type = TYPE_LONG;
	obj->objs[8]->value = 
		buf_add_ui64(arg_stars);
	strcpy(obj->objs[8]->name, "stars");
	if (arg_stars)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument int
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 0;
	obj->objs[9]->flag_bit = 0;
	obj->objs[9]->type = TYPE_INT;
	obj->objs[9]->value = 
		buf_add_ui32(arg_until_date);
	strcpy(obj->objs[9]->name, "until_date");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messageMediaGiveawayResults(bool arg_only_new_subscribers, bool arg_refunded, long arg_channel_id, int arg_additional_peers_count, int arg_launch_msg_id, int arg_winners_count, int arg_unclaimed_count, long *arg_winners, int len_arg_winners, int arg_months, long arg_stars, const char * arg_prize_description, int arg_until_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageMediaGiveawayResults");
	int i;
	obj->id = 0xceaa3ea1;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 13;
	obj->objs = 
		(tlo_t **)MALLOC(13 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_only_new_subscribers);
	strcpy(obj->objs[1]->name, "only_new_subscribers");
	if (arg_only_new_subscribers)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 2;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_refunded);
	strcpy(obj->objs[2]->name, "refunded");
	if (arg_refunded)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_channel_id);
	strcpy(obj->objs[3]->name, "channel_id");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 3;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_additional_peers_count);
	strcpy(obj->objs[4]->name, "additional_peers_count");
	if (arg_additional_peers_count)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_launch_msg_id);
	strcpy(obj->objs[5]->name, "launch_msg_id");

	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_winners_count);
	strcpy(obj->objs[6]->name, "winners_count");

	//parse argument int
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_unclaimed_count);
	strcpy(obj->objs[7]->name, "unclaimed_count");

	//parse argument Vector<long>
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 0;
	obj->objs[8]->flag_bit = 0;
	obj->objs[8]->type = TYPE_VECTOR;
	strcpy(obj->objs[8]->name, "winners");
	if (arg_winners){
		for(i=0; i<len_arg_winners; ++i){
			buf_t b = buf_add_ui64(arg_winners[i]);
			buf_cat(obj->objs[8]->value, b);
		}
	}


	//parse argument int
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 1;
	obj->objs[9]->flag_bit = 4;
	obj->objs[9]->type = TYPE_INT;
	obj->objs[9]->value = 
		buf_add_ui32(arg_months);
	strcpy(obj->objs[9]->name, "months");
	if (arg_months)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument long
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 1;
	obj->objs[10]->flag_bit = 5;
	obj->objs[10]->type = TYPE_LONG;
	obj->objs[10]->value = 
		buf_add_ui64(arg_stars);
	strcpy(obj->objs[10]->name, "stars");
	if (arg_stars)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument string
	if (arg_prize_description){
		obj->objs[11] = NEW(tlo_t, return NULL);
		obj->objs[11]->flag_num = 1;
		obj->objs[11]->flag_bit = 1;
		obj->objs[11]->type = TYPE_STRING;
		obj->objs[11]->value = 
			buf_add((ui8_t *)arg_prize_description, strlen(arg_prize_description));
		strcpy(obj->objs[11]->name, "prize_description");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument int
	obj->objs[12] = NEW(tlo_t, return NULL);
	obj->objs[12]->flag_num = 0;
	obj->objs[12]->flag_bit = 0;
	obj->objs[12]->type = TYPE_INT;
	obj->objs[12]->value = 
		buf_add_ui32(arg_until_date);
	strcpy(obj->objs[12]->name, "until_date");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messageMediaPaidMedia(long arg_stars_amount, MessageExtendedMedia *arg_extended_media, int len_arg_extended_media)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageMediaPaidMedia");
	int i;
	obj->id = 0xa8852491;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_stars_amount);
	strcpy(obj->objs[0]->name, "stars_amount");

	//parse argument Vector<MessageExtendedMedia>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "extended_media");
	if (arg_extended_media){
		for(i=0; i<len_arg_extended_media; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_extended_media[i]->id);
			buf_cat(obj->objs[1]->value, arg_extended_media[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_messageActionEmpty()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionEmpty");
	int i;
	obj->id = 0xb6aef7b0;
	return obj;
}

tlo_t * tl_messageActionChatCreate(const char * arg_title, long *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionChatCreate");
	int i;
	obj->id = 0xbd47cbad;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_title){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[0]->name, "title");
	}


	//parse argument Vector<long>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			buf_t b = buf_add_ui64(arg_users[i]);
			buf_cat(obj->objs[1]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_messageActionChatEditTitle(const char * arg_title)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionChatEditTitle");
	int i;
	obj->id = 0xb5a1ce5a;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_title){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[0]->name, "title");
	}

	return obj;
}

tlo_t * tl_messageActionChatEditPhoto(Photo arg_photo)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionChatEditPhoto");
	int i;
	obj->id = 0x7fcb13a8;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Photo
	if (arg_photo){
		obj->objs[0] = arg_photo;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "photo");
	}

	return obj;
}

tlo_t * tl_messageActionChatDeletePhoto()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionChatDeletePhoto");
	int i;
	obj->id = 0x95e3fbef;
	return obj;
}

tlo_t * tl_messageActionChatAddUser(long *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionChatAddUser");
	int i;
	obj->id = 0x15cefd00;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<long>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			buf_t b = buf_add_ui64(arg_users[i]);
			buf_cat(obj->objs[0]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_messageActionChatDeleteUser(long arg_user_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionChatDeleteUser");
	int i;
	obj->id = 0xa43f30cc;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[0]->name, "user_id");
	return obj;
}

tlo_t * tl_messageActionChatJoinedByLink(long arg_inviter_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionChatJoinedByLink");
	int i;
	obj->id = 0x031224c3;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_inviter_id);
	strcpy(obj->objs[0]->name, "inviter_id");
	return obj;
}

tlo_t * tl_messageActionChannelCreate(const char * arg_title)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionChannelCreate");
	int i;
	obj->id = 0x95d2ac92;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_title){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[0]->name, "title");
	}

	return obj;
}

tlo_t * tl_messageActionChatMigrateTo(long arg_channel_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionChatMigrateTo");
	int i;
	obj->id = 0xe1037f92;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_channel_id);
	strcpy(obj->objs[0]->name, "channel_id");
	return obj;
}

tlo_t * tl_messageActionChannelMigrateFrom(const char * arg_title, long arg_chat_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionChannelMigrateFrom");
	int i;
	obj->id = 0xea3948e9;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_title){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[0]->name, "title");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_chat_id);
	strcpy(obj->objs[1]->name, "chat_id");
	return obj;
}

tlo_t * tl_messageActionPinMessage()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionPinMessage");
	int i;
	obj->id = 0x94bd38ed;
	return obj;
}

tlo_t * tl_messageActionHistoryClear()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionHistoryClear");
	int i;
	obj->id = 0x9fbab604;
	return obj;
}

tlo_t * tl_messageActionGameScore(long arg_game_id, int arg_score)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionGameScore");
	int i;
	obj->id = 0x92a72876;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_game_id);
	strcpy(obj->objs[0]->name, "game_id");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_score);
	strcpy(obj->objs[1]->name, "score");
	return obj;
}

tlo_t * tl_messageActionPaymentSentMe(bool arg_recurring_init, bool arg_recurring_used, const char * arg_currency, long arg_total_amount, unsigned char * arg_payload, int len_arg_payload, PaymentRequestedInfo arg_info, const char * arg_shipping_option_id, PaymentCharge arg_charge)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionPaymentSentMe");
	int i;
	obj->id = 0x8f31b327;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 2;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_recurring_init);
	strcpy(obj->objs[1]->name, "recurring_init");
	if (arg_recurring_init)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 3;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_recurring_used);
	strcpy(obj->objs[2]->name, "recurring_used");
	if (arg_recurring_used)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument string
	if (arg_currency){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_currency, strlen(arg_currency));
		strcpy(obj->objs[3]->name, "currency");
	}


	//parse argument long
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_total_amount);
	strcpy(obj->objs[4]->name, "total_amount");

	//parse argument bytes
	if (arg_payload){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_BYTES;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_payload, len_arg_payload);
		strcpy(obj->objs[5]->name, "payload");
	}


	//parse argument PaymentRequestedInfo
	if (arg_info){
		obj->objs[6] = arg_info;
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 0;
	strcpy(obj->objs[6]->name, "info");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_shipping_option_id){
		obj->objs[7] = NEW(tlo_t, return NULL);
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 1;
		obj->objs[7]->type = TYPE_STRING;
		obj->objs[7]->value = 
			buf_add((ui8_t *)arg_shipping_option_id, strlen(arg_shipping_option_id));
		strcpy(obj->objs[7]->name, "shipping_option_id");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument PaymentCharge
	if (arg_charge){
		obj->objs[8] = arg_charge;
		obj->objs[8]->flag_num = 0;
		obj->objs[8]->flag_bit = 0;
	strcpy(obj->objs[8]->name, "charge");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messageActionPaymentSent(bool arg_recurring_init, bool arg_recurring_used, const char * arg_currency, long arg_total_amount, const char * arg_invoice_slug)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionPaymentSent");
	int i;
	obj->id = 0x96163f56;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 2;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_recurring_init);
	strcpy(obj->objs[1]->name, "recurring_init");
	if (arg_recurring_init)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 3;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_recurring_used);
	strcpy(obj->objs[2]->name, "recurring_used");
	if (arg_recurring_used)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument string
	if (arg_currency){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_currency, strlen(arg_currency));
		strcpy(obj->objs[3]->name, "currency");
	}


	//parse argument long
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_total_amount);
	strcpy(obj->objs[4]->name, "total_amount");

	//parse argument string
	if (arg_invoice_slug){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_invoice_slug, strlen(arg_invoice_slug));
		strcpy(obj->objs[5]->name, "invoice_slug");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messageActionPhoneCall(bool arg_video, long arg_call_id, PhoneCallDiscardReason arg_reason, int arg_duration)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionPhoneCall");
	int i;
	obj->id = 0x80e11a7f;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 2;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_video);
	strcpy(obj->objs[1]->name, "video");
	if (arg_video)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_call_id);
	strcpy(obj->objs[2]->name, "call_id");

	//parse argument PhoneCallDiscardReason
	if (arg_reason){
		obj->objs[3] = arg_reason;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "reason");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 1;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_duration);
	strcpy(obj->objs[4]->name, "duration");
	if (arg_duration)
		flagsv[nflags-1] |= (1 << 1);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messageActionScreenshotTaken()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionScreenshotTaken");
	int i;
	obj->id = 0x4792929b;
	return obj;
}

tlo_t * tl_messageActionCustomAction(const char * arg_message)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionCustomAction");
	int i;
	obj->id = 0xfae69f56;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_message){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_message, strlen(arg_message));
		strcpy(obj->objs[0]->name, "message");
	}

	return obj;
}

tlo_t * tl_messageActionBotAllowed(bool arg_attach_menu, bool arg_from_request, const char * arg_domain, BotApp arg_app)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionBotAllowed");
	int i;
	obj->id = 0xc516d679;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_attach_menu);
	strcpy(obj->objs[1]->name, "attach_menu");
	if (arg_attach_menu)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 3;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_from_request);
	strcpy(obj->objs[2]->name, "from_request");
	if (arg_from_request)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument string
	if (arg_domain){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_domain, strlen(arg_domain));
		strcpy(obj->objs[3]->name, "domain");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument BotApp
	if (arg_app){
		obj->objs[4] = arg_app;
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 2;
	strcpy(obj->objs[4]->name, "app");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messageActionSecureValuesSentMe(SecureValue *arg_values, int len_arg_values, SecureCredentialsEncrypted arg_credentials)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionSecureValuesSentMe");
	int i;
	obj->id = 0x1b287353;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<SecureValue>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "values");
	if (arg_values){
		for(i=0; i<len_arg_values; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_values[i]->id);
			buf_cat(obj->objs[0]->value, arg_values[i]->value);
		}
	}


	//parse argument SecureCredentialsEncrypted
	if (arg_credentials){
		obj->objs[1] = arg_credentials;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "credentials");
	}

	return obj;
}

tlo_t * tl_messageActionSecureValuesSent(SecureValueType *arg_types, int len_arg_types)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionSecureValuesSent");
	int i;
	obj->id = 0xd95c6154;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<SecureValueType>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "types");
	if (arg_types){
		for(i=0; i<len_arg_types; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_types[i]->id);
			buf_cat(obj->objs[0]->value, arg_types[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_messageActionContactSignUp()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionContactSignUp");
	int i;
	obj->id = 0xf3f25f76;
	return obj;
}

tlo_t * tl_messageActionGeoProximityReached(Peer arg_from_id, Peer arg_to_id, int arg_distance)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionGeoProximityReached");
	int i;
	obj->id = 0x98e0d697;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_from_id){
		obj->objs[0] = arg_from_id;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "from_id");
	}


	//parse argument Peer
	if (arg_to_id){
		obj->objs[1] = arg_to_id;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "to_id");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_distance);
	strcpy(obj->objs[2]->name, "distance");
	return obj;
}

tlo_t * tl_messageActionGroupCall(InputGroupCall arg_call, int arg_duration)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionGroupCall");
	int i;
	obj->id = 0x7a0d7f42;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputGroupCall
	if (arg_call){
		obj->objs[1] = arg_call;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "call");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_duration);
	strcpy(obj->objs[2]->name, "duration");
	if (arg_duration)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messageActionInviteToGroupCall(InputGroupCall arg_call, long *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionInviteToGroupCall");
	int i;
	obj->id = 0x502f92f7;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputGroupCall
	if (arg_call){
		obj->objs[0] = arg_call;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "call");
	}


	//parse argument Vector<long>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			buf_t b = buf_add_ui64(arg_users[i]);
			buf_cat(obj->objs[1]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_messageActionSetMessagesTTL(int arg_period, long arg_auto_setting_from)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionSetMessagesTTL");
	int i;
	obj->id = 0x3c134d7b;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_period);
	strcpy(obj->objs[1]->name, "period");

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_auto_setting_from);
	strcpy(obj->objs[2]->name, "auto_setting_from");
	if (arg_auto_setting_from)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messageActionGroupCallScheduled(InputGroupCall arg_call, int arg_schedule_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionGroupCallScheduled");
	int i;
	obj->id = 0xb3a07661;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputGroupCall
	if (arg_call){
		obj->objs[0] = arg_call;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "call");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_schedule_date);
	strcpy(obj->objs[1]->name, "schedule_date");
	return obj;
}

tlo_t * tl_messageActionSetChatTheme(const char * arg_emoticon)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionSetChatTheme");
	int i;
	obj->id = 0xaa786345;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_emoticon){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_emoticon, strlen(arg_emoticon));
		strcpy(obj->objs[0]->name, "emoticon");
	}

	return obj;
}

tlo_t * tl_messageActionChatJoinedByRequest()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionChatJoinedByRequest");
	int i;
	obj->id = 0xebbca3cb;
	return obj;
}

tlo_t * tl_messageActionWebViewDataSentMe(const char * arg_text, const char * arg_data)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionWebViewDataSentMe");
	int i;
	obj->id = 0x47dd8079;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_text){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[0]->name, "text");
	}


	//parse argument string
	if (arg_data){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_data, strlen(arg_data));
		strcpy(obj->objs[1]->name, "data");
	}

	return obj;
}

tlo_t * tl_messageActionWebViewDataSent(const char * arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionWebViewDataSent");
	int i;
	obj->id = 0xb4c38cb5;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_text){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[0]->name, "text");
	}

	return obj;
}

tlo_t * tl_messageActionGiftPremium(const char * arg_currency, long arg_amount, int arg_months, const char * arg_crypto_currency, long arg_crypto_amount)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionGiftPremium");
	int i;
	obj->id = 0xc83d6aec;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_currency){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_currency, strlen(arg_currency));
		strcpy(obj->objs[1]->name, "currency");
	}


	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_amount);
	strcpy(obj->objs[2]->name, "amount");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_months);
	strcpy(obj->objs[3]->name, "months");

	//parse argument string
	if (arg_crypto_currency){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_crypto_currency, strlen(arg_crypto_currency));
		strcpy(obj->objs[4]->name, "crypto_currency");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument long
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_LONG;
	obj->objs[5]->value = 
		buf_add_ui64(arg_crypto_amount);
	strcpy(obj->objs[5]->name, "crypto_amount");
	if (arg_crypto_amount)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messageActionTopicCreate(const char * arg_title, int arg_icon_color, long arg_icon_emoji_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionTopicCreate");
	int i;
	obj->id = 0x0d999256;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_title){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[1]->name, "title");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_icon_color);
	strcpy(obj->objs[2]->name, "icon_color");

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_icon_emoji_id);
	strcpy(obj->objs[3]->name, "icon_emoji_id");
	if (arg_icon_emoji_id)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messageActionTopicEdit(const char * arg_title, long arg_icon_emoji_id, Bool arg_closed, Bool arg_hidden)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionTopicEdit");
	int i;
	obj->id = 0xc0944820;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_title){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[1]->name, "title");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_icon_emoji_id);
	strcpy(obj->objs[2]->name, "icon_emoji_id");
	if (arg_icon_emoji_id)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument Bool
	if (arg_closed){
		obj->objs[3] = arg_closed;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 2;
	strcpy(obj->objs[3]->name, "closed");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument Bool
	if (arg_hidden){
		obj->objs[4] = arg_hidden;
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 3;
	strcpy(obj->objs[4]->name, "hidden");
		flagsv[nflags-1] |= (1 << 3);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messageActionSuggestProfilePhoto(Photo arg_photo)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionSuggestProfilePhoto");
	int i;
	obj->id = 0x57de635e;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Photo
	if (arg_photo){
		obj->objs[0] = arg_photo;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "photo");
	}

	return obj;
}

tlo_t * tl_messageActionRequestedPeer(int arg_button_id, Peer *arg_peers, int len_arg_peers)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionRequestedPeer");
	int i;
	obj->id = 0x31518e9b;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_button_id);
	strcpy(obj->objs[0]->name, "button_id");

	//parse argument Vector<Peer>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "peers");
	if (arg_peers){
		for(i=0; i<len_arg_peers; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_peers[i]->id);
			buf_cat(obj->objs[1]->value, arg_peers[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_messageActionSetChatWallPaper(bool arg_same, bool arg_for_both, WallPaper arg_wallpaper)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionSetChatWallPaper");
	int i;
	obj->id = 0x5060a3f4;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_same);
	strcpy(obj->objs[1]->name, "same");
	if (arg_same)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_for_both);
	strcpy(obj->objs[2]->name, "for_both");
	if (arg_for_both)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument WallPaper
	if (arg_wallpaper){
		obj->objs[3] = arg_wallpaper;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "wallpaper");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messageActionGiftCode(bool arg_via_giveaway, bool arg_unclaimed, Peer arg_boost_peer, int arg_months, const char * arg_slug, const char * arg_currency, long arg_amount, const char * arg_crypto_currency, long arg_crypto_amount)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionGiftCode");
	int i;
	obj->id = 0x678c2e09;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 10;
	obj->objs = 
		(tlo_t **)MALLOC(10 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_via_giveaway);
	strcpy(obj->objs[1]->name, "via_giveaway");
	if (arg_via_giveaway)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 2;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_unclaimed);
	strcpy(obj->objs[2]->name, "unclaimed");
	if (arg_unclaimed)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument Peer
	if (arg_boost_peer){
		obj->objs[3] = arg_boost_peer;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 1;
	strcpy(obj->objs[3]->name, "boost_peer");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_months);
	strcpy(obj->objs[4]->name, "months");

	//parse argument string
	if (arg_slug){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_slug, strlen(arg_slug));
		strcpy(obj->objs[5]->name, "slug");
	}


	//parse argument string
	if (arg_currency){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 2;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_currency, strlen(arg_currency));
		strcpy(obj->objs[6]->name, "currency");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument long
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 2;
	obj->objs[7]->type = TYPE_LONG;
	obj->objs[7]->value = 
		buf_add_ui64(arg_amount);
	strcpy(obj->objs[7]->name, "amount");
	if (arg_amount)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument string
	if (arg_crypto_currency){
		obj->objs[8] = NEW(tlo_t, return NULL);
		obj->objs[8]->flag_num = 1;
		obj->objs[8]->flag_bit = 3;
		obj->objs[8]->type = TYPE_STRING;
		obj->objs[8]->value = 
			buf_add((ui8_t *)arg_crypto_currency, strlen(arg_crypto_currency));
		strcpy(obj->objs[8]->name, "crypto_currency");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument long
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 1;
	obj->objs[9]->flag_bit = 3;
	obj->objs[9]->type = TYPE_LONG;
	obj->objs[9]->value = 
		buf_add_ui64(arg_crypto_amount);
	strcpy(obj->objs[9]->name, "crypto_amount");
	if (arg_crypto_amount)
		flagsv[nflags-1] |= (1 << 3);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messageActionGiveawayLaunch(long arg_stars)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionGiveawayLaunch");
	int i;
	obj->id = 0xa80f51e4;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_stars);
	strcpy(obj->objs[1]->name, "stars");
	if (arg_stars)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messageActionGiveawayResults(bool arg_stars, int arg_winners_count, int arg_unclaimed_count)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionGiveawayResults");
	int i;
	obj->id = 0x87e2f155;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_stars);
	strcpy(obj->objs[1]->name, "stars");
	if (arg_stars)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_winners_count);
	strcpy(obj->objs[2]->name, "winners_count");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_unclaimed_count);
	strcpy(obj->objs[3]->name, "unclaimed_count");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messageActionBoostApply(int arg_boosts)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionBoostApply");
	int i;
	obj->id = 0xcc02aa6d;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_boosts);
	strcpy(obj->objs[0]->name, "boosts");
	return obj;
}

tlo_t * tl_messageActionRequestedPeerSentMe(int arg_button_id, RequestedPeer *arg_peers, int len_arg_peers)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionRequestedPeerSentMe");
	int i;
	obj->id = 0x93b31848;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_button_id);
	strcpy(obj->objs[0]->name, "button_id");

	//parse argument Vector<RequestedPeer>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "peers");
	if (arg_peers){
		for(i=0; i<len_arg_peers; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_peers[i]->id);
			buf_cat(obj->objs[1]->value, arg_peers[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_messageActionPaymentRefunded(Peer arg_peer, const char * arg_currency, long arg_total_amount, unsigned char * arg_payload, int len_arg_payload, PaymentCharge arg_charge)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionPaymentRefunded");
	int i;
	obj->id = 0x41b3e202;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument Peer
	if (arg_peer){
		obj->objs[1] = arg_peer;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "peer");
	}


	//parse argument string
	if (arg_currency){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_currency, strlen(arg_currency));
		strcpy(obj->objs[2]->name, "currency");
	}


	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_total_amount);
	strcpy(obj->objs[3]->name, "total_amount");

	//parse argument bytes
	if (arg_payload){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_BYTES;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_payload, len_arg_payload);
		strcpy(obj->objs[4]->name, "payload");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument PaymentCharge
	if (arg_charge){
		obj->objs[5] = arg_charge;
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
	strcpy(obj->objs[5]->name, "charge");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messageActionGiftStars(const char * arg_currency, long arg_amount, long arg_stars, const char * arg_crypto_currency, long arg_crypto_amount, const char * arg_transaction_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionGiftStars");
	int i;
	obj->id = 0x45d5b021;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_currency){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_currency, strlen(arg_currency));
		strcpy(obj->objs[1]->name, "currency");
	}


	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_amount);
	strcpy(obj->objs[2]->name, "amount");

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_stars);
	strcpy(obj->objs[3]->name, "stars");

	//parse argument string
	if (arg_crypto_currency){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_crypto_currency, strlen(arg_crypto_currency));
		strcpy(obj->objs[4]->name, "crypto_currency");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument long
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_LONG;
	obj->objs[5]->value = 
		buf_add_ui64(arg_crypto_amount);
	strcpy(obj->objs[5]->name, "crypto_amount");
	if (arg_crypto_amount)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument string
	if (arg_transaction_id){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 1;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_transaction_id, strlen(arg_transaction_id));
		strcpy(obj->objs[6]->name, "transaction_id");
		flagsv[nflags-1] |= (1 << 1);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messageActionPrizeStars(bool arg_unclaimed, long arg_stars, const char * arg_transaction_id, Peer arg_boost_peer, int arg_giveaway_msg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionPrizeStars");
	int i;
	obj->id = 0xb00c47a2;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_unclaimed);
	strcpy(obj->objs[1]->name, "unclaimed");
	if (arg_unclaimed)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_stars);
	strcpy(obj->objs[2]->name, "stars");

	//parse argument string
	if (arg_transaction_id){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_transaction_id, strlen(arg_transaction_id));
		strcpy(obj->objs[3]->name, "transaction_id");
	}


	//parse argument Peer
	if (arg_boost_peer){
		obj->objs[4] = arg_boost_peer;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "boost_peer");
	}


	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_giveaway_msg_id);
	strcpy(obj->objs[5]->name, "giveaway_msg_id");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messageActionStarGift(bool arg_name_hidden, bool arg_saved, bool arg_converted, StarGift arg_gift, TextWithEntities arg_message, long arg_convert_stars)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageActionStarGift");
	int i;
	obj->id = 0x9bb3ef44;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_name_hidden);
	strcpy(obj->objs[1]->name, "name_hidden");
	if (arg_name_hidden)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 2;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_saved);
	strcpy(obj->objs[2]->name, "saved");
	if (arg_saved)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 3;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_converted);
	strcpy(obj->objs[3]->name, "converted");
	if (arg_converted)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument StarGift
	if (arg_gift){
		obj->objs[4] = arg_gift;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "gift");
	}


	//parse argument TextWithEntities
	if (arg_message){
		obj->objs[5] = arg_message;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 1;
	strcpy(obj->objs[5]->name, "message");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument long
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_LONG;
	obj->objs[6]->value = 
		buf_add_ui64(arg_convert_stars);
	strcpy(obj->objs[6]->name, "convert_stars");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_dialog(bool arg_pinned, bool arg_unread_mark, bool arg_view_forum_as_messages, Peer arg_peer, int arg_top_message, int arg_read_inbox_max_id, int arg_read_outbox_max_id, int arg_unread_count, int arg_unread_mentions_count, int arg_unread_reactions_count, PeerNotifySettings arg_notify_settings, int arg_pts, DraftMessage arg_draft, int arg_folder_id, int arg_ttl_period)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "dialog");
	int i;
	obj->id = 0xd58a08c6;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 16;
	obj->objs = 
		(tlo_t **)MALLOC(16 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 2;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_pinned);
	strcpy(obj->objs[1]->name, "pinned");
	if (arg_pinned)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 3;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_unread_mark);
	strcpy(obj->objs[2]->name, "unread_mark");
	if (arg_unread_mark)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 6;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_view_forum_as_messages);
	strcpy(obj->objs[3]->name, "view_forum_as_messages");
	if (arg_view_forum_as_messages)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument Peer
	if (arg_peer){
		obj->objs[4] = arg_peer;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "peer");
	}


	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_top_message);
	strcpy(obj->objs[5]->name, "top_message");

	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_read_inbox_max_id);
	strcpy(obj->objs[6]->name, "read_inbox_max_id");

	//parse argument int
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_read_outbox_max_id);
	strcpy(obj->objs[7]->name, "read_outbox_max_id");

	//parse argument int
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 0;
	obj->objs[8]->flag_bit = 0;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_unread_count);
	strcpy(obj->objs[8]->name, "unread_count");

	//parse argument int
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 0;
	obj->objs[9]->flag_bit = 0;
	obj->objs[9]->type = TYPE_INT;
	obj->objs[9]->value = 
		buf_add_ui32(arg_unread_mentions_count);
	strcpy(obj->objs[9]->name, "unread_mentions_count");

	//parse argument int
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 0;
	obj->objs[10]->flag_bit = 0;
	obj->objs[10]->type = TYPE_INT;
	obj->objs[10]->value = 
		buf_add_ui32(arg_unread_reactions_count);
	strcpy(obj->objs[10]->name, "unread_reactions_count");

	//parse argument PeerNotifySettings
	if (arg_notify_settings){
		obj->objs[11] = arg_notify_settings;
		obj->objs[11]->flag_num = 0;
		obj->objs[11]->flag_bit = 0;
	strcpy(obj->objs[11]->name, "notify_settings");
	}


	//parse argument int
	obj->objs[12] = NEW(tlo_t, return NULL);
	obj->objs[12]->flag_num = 1;
	obj->objs[12]->flag_bit = 0;
	obj->objs[12]->type = TYPE_INT;
	obj->objs[12]->value = 
		buf_add_ui32(arg_pts);
	strcpy(obj->objs[12]->name, "pts");
	if (arg_pts)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument DraftMessage
	if (arg_draft){
		obj->objs[13] = arg_draft;
		obj->objs[13]->flag_num = 1;
		obj->objs[13]->flag_bit = 1;
	strcpy(obj->objs[13]->name, "draft");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument int
	obj->objs[14] = NEW(tlo_t, return NULL);
	obj->objs[14]->flag_num = 1;
	obj->objs[14]->flag_bit = 4;
	obj->objs[14]->type = TYPE_INT;
	obj->objs[14]->value = 
		buf_add_ui32(arg_folder_id);
	strcpy(obj->objs[14]->name, "folder_id");
	if (arg_folder_id)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument int
	obj->objs[15] = NEW(tlo_t, return NULL);
	obj->objs[15]->flag_num = 1;
	obj->objs[15]->flag_bit = 5;
	obj->objs[15]->type = TYPE_INT;
	obj->objs[15]->value = 
		buf_add_ui32(arg_ttl_period);
	strcpy(obj->objs[15]->name, "ttl_period");
	if (arg_ttl_period)
		flagsv[nflags-1] |= (1 << 5);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_dialogFolder(bool arg_pinned, Folder arg_folder, Peer arg_peer, int arg_top_message, int arg_unread_muted_peers_count, int arg_unread_unmuted_peers_count, int arg_unread_muted_messages_count, int arg_unread_unmuted_messages_count)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "dialogFolder");
	int i;
	obj->id = 0x71bd134c;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 2;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_pinned);
	strcpy(obj->objs[1]->name, "pinned");
	if (arg_pinned)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument Folder
	if (arg_folder){
		obj->objs[2] = arg_folder;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "folder");
	}


	//parse argument Peer
	if (arg_peer){
		obj->objs[3] = arg_peer;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "peer");
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_top_message);
	strcpy(obj->objs[4]->name, "top_message");

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_unread_muted_peers_count);
	strcpy(obj->objs[5]->name, "unread_muted_peers_count");

	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_unread_unmuted_peers_count);
	strcpy(obj->objs[6]->name, "unread_unmuted_peers_count");

	//parse argument int
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_unread_muted_messages_count);
	strcpy(obj->objs[7]->name, "unread_muted_messages_count");

	//parse argument int
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 0;
	obj->objs[8]->flag_bit = 0;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_unread_unmuted_messages_count);
	strcpy(obj->objs[8]->name, "unread_unmuted_messages_count");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_photoEmpty(long arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "photoEmpty");
	int i;
	obj->id = 0x2331b22d;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");
	return obj;
}

tlo_t * tl_photo(bool arg_has_stickers, long arg_id, long arg_access_hash, unsigned char * arg_file_reference, int len_arg_file_reference, int arg_date, PhotoSize *arg_sizes, int len_arg_sizes, VideoSize *arg_video_sizes, int len_arg_video_sizes, int arg_dc_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "photo");
	int i;
	obj->id = 0xfb197a65;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_has_stickers);
	strcpy(obj->objs[1]->name, "has_stickers");
	if (arg_has_stickers)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[2]->name, "id");

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[3]->name, "access_hash");

	//parse argument bytes
	if (arg_file_reference){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_BYTES;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_file_reference, len_arg_file_reference);
		strcpy(obj->objs[4]->name, "file_reference");
	}


	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[5]->name, "date");

	//parse argument Vector<PhotoSize>
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_VECTOR;
	strcpy(obj->objs[6]->name, "sizes");
	if (arg_sizes){
		for(i=0; i<len_arg_sizes; ++i){
			obj->objs[6]->value = buf_add_ui32(arg_sizes[i]->id);
			buf_cat(obj->objs[6]->value, arg_sizes[i]->value);
		}
	}


	//parse argument Vector<VideoSize>
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 1;
	obj->objs[7]->type = TYPE_VECTOR;
	strcpy(obj->objs[7]->name, "video_sizes");
	if (arg_video_sizes){
		for(i=0; i<len_arg_video_sizes; ++i){
			obj->objs[7]->value = buf_add_ui32(arg_video_sizes[i]->id);
			buf_cat(obj->objs[7]->value, arg_video_sizes[i]->value);
		}
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument int
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 0;
	obj->objs[8]->flag_bit = 0;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_dc_id);
	strcpy(obj->objs[8]->name, "dc_id");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_photoSizeEmpty(const char * arg_type)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "photoSizeEmpty");
	int i;
	obj->id = 0x0e17e23c;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_type){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_type, strlen(arg_type));
		strcpy(obj->objs[0]->name, "type");
	}

	return obj;
}

tlo_t * tl_photoSize(const char * arg_type, int arg_w, int arg_h, int arg_size)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "photoSize");
	int i;
	obj->id = 0x75c78e60;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_type){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_type, strlen(arg_type));
		strcpy(obj->objs[0]->name, "type");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_w);
	strcpy(obj->objs[1]->name, "w");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_h);
	strcpy(obj->objs[2]->name, "h");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_size);
	strcpy(obj->objs[3]->name, "size");
	return obj;
}

tlo_t * tl_photoCachedSize(const char * arg_type, int arg_w, int arg_h, unsigned char * arg_bytes, int len_arg_bytes)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "photoCachedSize");
	int i;
	obj->id = 0x021e1ad6;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_type){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_type, strlen(arg_type));
		strcpy(obj->objs[0]->name, "type");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_w);
	strcpy(obj->objs[1]->name, "w");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_h);
	strcpy(obj->objs[2]->name, "h");

	//parse argument bytes
	if (arg_bytes){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_BYTES;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_bytes, len_arg_bytes);
		strcpy(obj->objs[3]->name, "bytes");
	}

	return obj;
}

tlo_t * tl_photoStrippedSize(const char * arg_type, unsigned char * arg_bytes, int len_arg_bytes)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "photoStrippedSize");
	int i;
	obj->id = 0xe0b0bc2e;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_type){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_type, strlen(arg_type));
		strcpy(obj->objs[0]->name, "type");
	}


	//parse argument bytes
	if (arg_bytes){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_bytes, len_arg_bytes);
		strcpy(obj->objs[1]->name, "bytes");
	}

	return obj;
}

tlo_t * tl_photoSizeProgressive(const char * arg_type, int arg_w, int arg_h, int *arg_sizes, int len_arg_sizes)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "photoSizeProgressive");
	int i;
	obj->id = 0xfa3efb95;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_type){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_type, strlen(arg_type));
		strcpy(obj->objs[0]->name, "type");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_w);
	strcpy(obj->objs[1]->name, "w");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_h);
	strcpy(obj->objs[2]->name, "h");

	//parse argument Vector<int>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "sizes");
	if (arg_sizes){
		for(i=0; i<len_arg_sizes; ++i){
			buf_t b = buf_add_ui32(arg_sizes[i]);
			buf_cat(obj->objs[3]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_photoPathSize(const char * arg_type, unsigned char * arg_bytes, int len_arg_bytes)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "photoPathSize");
	int i;
	obj->id = 0xd8214d41;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_type){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_type, strlen(arg_type));
		strcpy(obj->objs[0]->name, "type");
	}


	//parse argument bytes
	if (arg_bytes){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_bytes, len_arg_bytes);
		strcpy(obj->objs[1]->name, "bytes");
	}

	return obj;
}

tlo_t * tl_geoPointEmpty()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "geoPointEmpty");
	int i;
	obj->id = 0x1117dd5f;
	return obj;
}

tlo_t * tl_geoPoint(double arg_long, double arg_lat, long arg_access_hash, int arg_accuracy_radius)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "geoPoint");
	int i;
	obj->id = 0xb2a2f663;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument double
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_long);
	strcpy(obj->objs[1]->name, "long");

	//parse argument double
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_lat);
	strcpy(obj->objs[2]->name, "lat");

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[3]->name, "access_hash");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_accuracy_radius);
	strcpy(obj->objs[4]->name, "accuracy_radius");
	if (arg_accuracy_radius)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_auth_sentCode(auth_SentCodeType arg_type, const char * arg_phone_code_hash, auth_CodeType arg_next_type, int arg_timeout)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_sentCode");
	int i;
	obj->id = 0x5e002502;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument auth_SentCodeType
	if (arg_type){
		obj->objs[1] = arg_type;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "type");
	}


	//parse argument string
	if (arg_phone_code_hash){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_phone_code_hash, strlen(arg_phone_code_hash));
		strcpy(obj->objs[2]->name, "phone_code_hash");
	}


	//parse argument auth_CodeType
	if (arg_next_type){
		obj->objs[3] = arg_next_type;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 1;
	strcpy(obj->objs[3]->name, "next_type");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 2;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_timeout);
	strcpy(obj->objs[4]->name, "timeout");
	if (arg_timeout)
		flagsv[nflags-1] |= (1 << 2);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_auth_sentCodeSuccess(auth_Authorization arg_authorization)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_sentCodeSuccess");
	int i;
	obj->id = 0x2390fe44;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument auth_Authorization
	if (arg_authorization){
		obj->objs[0] = arg_authorization;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "authorization");
	}

	return obj;
}

tlo_t * tl_auth_authorization(bool arg_setup_password_required, int arg_otherwise_relogin_days, int arg_tmp_sessions, unsigned char * arg_future_auth_token, int len_arg_future_auth_token, User arg_user)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_authorization");
	int i;
	obj->id = 0x2ea2c0d4;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_setup_password_required);
	strcpy(obj->objs[1]->name, "setup_password_required");
	if (arg_setup_password_required)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_otherwise_relogin_days);
	strcpy(obj->objs[2]->name, "otherwise_relogin_days");
	if (arg_otherwise_relogin_days)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_tmp_sessions);
	strcpy(obj->objs[3]->name, "tmp_sessions");
	if (arg_tmp_sessions)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument bytes
	if (arg_future_auth_token){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 2;
		obj->objs[4]->type = TYPE_BYTES;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_future_auth_token, len_arg_future_auth_token);
		strcpy(obj->objs[4]->name, "future_auth_token");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument User
	if (arg_user){
		obj->objs[5] = arg_user;
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
	strcpy(obj->objs[5]->name, "user");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_auth_authorizationSignUpRequired(help_TermsOfService arg_terms_of_service)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_authorizationSignUpRequired");
	int i;
	obj->id = 0x44747e9a;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument help_TermsOfService
	if (arg_terms_of_service){
		obj->objs[1] = arg_terms_of_service;
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "terms_of_service");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_auth_exportedAuthorization(long arg_id, unsigned char * arg_bytes, int len_arg_bytes)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_exportedAuthorization");
	int i;
	obj->id = 0xb434e2b8;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument bytes
	if (arg_bytes){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_bytes, len_arg_bytes);
		strcpy(obj->objs[1]->name, "bytes");
	}

	return obj;
}

tlo_t * tl_inputNotifyPeer(InputPeer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputNotifyPeer");
	int i;
	obj->id = 0xb8bc5b0c;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}

	return obj;
}

tlo_t * tl_inputNotifyUsers()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputNotifyUsers");
	int i;
	obj->id = 0x193b4417;
	return obj;
}

tlo_t * tl_inputNotifyChats()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputNotifyChats");
	int i;
	obj->id = 0x4a95e84e;
	return obj;
}

tlo_t * tl_inputNotifyBroadcasts()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputNotifyBroadcasts");
	int i;
	obj->id = 0xb1db7c7e;
	return obj;
}

tlo_t * tl_inputNotifyForumTopic(InputPeer arg_peer, int arg_top_msg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputNotifyForumTopic");
	int i;
	obj->id = 0x5c467992;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_top_msg_id);
	strcpy(obj->objs[1]->name, "top_msg_id");
	return obj;
}

tlo_t * tl_inputPeerNotifySettings(Bool arg_show_previews, Bool arg_silent, int arg_mute_until, NotificationSound arg_sound, Bool arg_stories_muted, Bool arg_stories_hide_sender, NotificationSound arg_stories_sound)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPeerNotifySettings");
	int i;
	obj->id = 0xcacb6ae2;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument Bool
	if (arg_show_previews){
		obj->objs[1] = arg_show_previews;
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "show_previews");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument Bool
	if (arg_silent){
		obj->objs[2] = arg_silent;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 1;
	strcpy(obj->objs[2]->name, "silent");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_mute_until);
	strcpy(obj->objs[3]->name, "mute_until");
	if (arg_mute_until)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument NotificationSound
	if (arg_sound){
		obj->objs[4] = arg_sound;
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 3;
	strcpy(obj->objs[4]->name, "sound");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument Bool
	if (arg_stories_muted){
		obj->objs[5] = arg_stories_muted;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 6;
	strcpy(obj->objs[5]->name, "stories_muted");
		flagsv[nflags-1] |= (1 << 6);
	}


	//parse argument Bool
	if (arg_stories_hide_sender){
		obj->objs[6] = arg_stories_hide_sender;
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 7;
	strcpy(obj->objs[6]->name, "stories_hide_sender");
		flagsv[nflags-1] |= (1 << 7);
	}


	//parse argument NotificationSound
	if (arg_stories_sound){
		obj->objs[7] = arg_stories_sound;
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 8;
	strcpy(obj->objs[7]->name, "stories_sound");
		flagsv[nflags-1] |= (1 << 8);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_peerNotifySettings(Bool arg_show_previews, Bool arg_silent, int arg_mute_until, NotificationSound arg_ios_sound, NotificationSound arg_android_sound, NotificationSound arg_other_sound, Bool arg_stories_muted, Bool arg_stories_hide_sender, NotificationSound arg_stories_ios_sound, NotificationSound arg_stories_android_sound, NotificationSound arg_stories_other_sound)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "peerNotifySettings");
	int i;
	obj->id = 0x99622c0c;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 12;
	obj->objs = 
		(tlo_t **)MALLOC(12 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument Bool
	if (arg_show_previews){
		obj->objs[1] = arg_show_previews;
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "show_previews");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument Bool
	if (arg_silent){
		obj->objs[2] = arg_silent;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 1;
	strcpy(obj->objs[2]->name, "silent");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_mute_until);
	strcpy(obj->objs[3]->name, "mute_until");
	if (arg_mute_until)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument NotificationSound
	if (arg_ios_sound){
		obj->objs[4] = arg_ios_sound;
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 3;
	strcpy(obj->objs[4]->name, "ios_sound");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument NotificationSound
	if (arg_android_sound){
		obj->objs[5] = arg_android_sound;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 4;
	strcpy(obj->objs[5]->name, "android_sound");
		flagsv[nflags-1] |= (1 << 4);
	}


	//parse argument NotificationSound
	if (arg_other_sound){
		obj->objs[6] = arg_other_sound;
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 5;
	strcpy(obj->objs[6]->name, "other_sound");
		flagsv[nflags-1] |= (1 << 5);
	}


	//parse argument Bool
	if (arg_stories_muted){
		obj->objs[7] = arg_stories_muted;
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 6;
	strcpy(obj->objs[7]->name, "stories_muted");
		flagsv[nflags-1] |= (1 << 6);
	}


	//parse argument Bool
	if (arg_stories_hide_sender){
		obj->objs[8] = arg_stories_hide_sender;
		obj->objs[8]->flag_num = 1;
		obj->objs[8]->flag_bit = 7;
	strcpy(obj->objs[8]->name, "stories_hide_sender");
		flagsv[nflags-1] |= (1 << 7);
	}


	//parse argument NotificationSound
	if (arg_stories_ios_sound){
		obj->objs[9] = arg_stories_ios_sound;
		obj->objs[9]->flag_num = 1;
		obj->objs[9]->flag_bit = 8;
	strcpy(obj->objs[9]->name, "stories_ios_sound");
		flagsv[nflags-1] |= (1 << 8);
	}


	//parse argument NotificationSound
	if (arg_stories_android_sound){
		obj->objs[10] = arg_stories_android_sound;
		obj->objs[10]->flag_num = 1;
		obj->objs[10]->flag_bit = 9;
	strcpy(obj->objs[10]->name, "stories_android_sound");
		flagsv[nflags-1] |= (1 << 9);
	}


	//parse argument NotificationSound
	if (arg_stories_other_sound){
		obj->objs[11] = arg_stories_other_sound;
		obj->objs[11]->flag_num = 1;
		obj->objs[11]->flag_bit = 10;
	strcpy(obj->objs[11]->name, "stories_other_sound");
		flagsv[nflags-1] |= (1 << 10);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_peerSettings(bool arg_report_spam, bool arg_add_contact, bool arg_block_contact, bool arg_share_contact, bool arg_need_contacts_exception, bool arg_report_geo, bool arg_autoarchived, bool arg_invite_members, bool arg_request_chat_broadcast, bool arg_business_bot_paused, bool arg_business_bot_can_reply, int arg_geo_distance, const char * arg_request_chat_title, int arg_request_chat_date, long arg_business_bot_id, const char * arg_business_bot_manage_url)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "peerSettings");
	int i;
	obj->id = 0xacd66c5e;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 17;
	obj->objs = 
		(tlo_t **)MALLOC(17 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_report_spam);
	strcpy(obj->objs[1]->name, "report_spam");
	if (arg_report_spam)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_add_contact);
	strcpy(obj->objs[2]->name, "add_contact");
	if (arg_add_contact)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_block_contact);
	strcpy(obj->objs[3]->name, "block_contact");
	if (arg_block_contact)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 3;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_share_contact);
	strcpy(obj->objs[4]->name, "share_contact");
	if (arg_share_contact)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 4;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_need_contacts_exception);
	strcpy(obj->objs[5]->name, "need_contacts_exception");
	if (arg_need_contacts_exception)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument true
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 5;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_report_geo);
	strcpy(obj->objs[6]->name, "report_geo");
	if (arg_report_geo)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument true
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 7;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_autoarchived);
	strcpy(obj->objs[7]->name, "autoarchived");
	if (arg_autoarchived)
		flagsv[nflags-1] |= (1 << 7);

	//parse argument true
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 8;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_invite_members);
	strcpy(obj->objs[8]->name, "invite_members");
	if (arg_invite_members)
		flagsv[nflags-1] |= (1 << 8);

	//parse argument true
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 1;
	obj->objs[9]->flag_bit = 10;
	obj->objs[9]->type = TYPE_INT;
	obj->objs[9]->value = 
		buf_add_ui32(arg_request_chat_broadcast);
	strcpy(obj->objs[9]->name, "request_chat_broadcast");
	if (arg_request_chat_broadcast)
		flagsv[nflags-1] |= (1 << 10);

	//parse argument true
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 1;
	obj->objs[10]->flag_bit = 11;
	obj->objs[10]->type = TYPE_INT;
	obj->objs[10]->value = 
		buf_add_ui32(arg_business_bot_paused);
	strcpy(obj->objs[10]->name, "business_bot_paused");
	if (arg_business_bot_paused)
		flagsv[nflags-1] |= (1 << 11);

	//parse argument true
	obj->objs[11] = NEW(tlo_t, return NULL);
	obj->objs[11]->flag_num = 1;
	obj->objs[11]->flag_bit = 12;
	obj->objs[11]->type = TYPE_INT;
	obj->objs[11]->value = 
		buf_add_ui32(arg_business_bot_can_reply);
	strcpy(obj->objs[11]->name, "business_bot_can_reply");
	if (arg_business_bot_can_reply)
		flagsv[nflags-1] |= (1 << 12);

	//parse argument int
	obj->objs[12] = NEW(tlo_t, return NULL);
	obj->objs[12]->flag_num = 1;
	obj->objs[12]->flag_bit = 6;
	obj->objs[12]->type = TYPE_INT;
	obj->objs[12]->value = 
		buf_add_ui32(arg_geo_distance);
	strcpy(obj->objs[12]->name, "geo_distance");
	if (arg_geo_distance)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument string
	if (arg_request_chat_title){
		obj->objs[13] = NEW(tlo_t, return NULL);
		obj->objs[13]->flag_num = 1;
		obj->objs[13]->flag_bit = 9;
		obj->objs[13]->type = TYPE_STRING;
		obj->objs[13]->value = 
			buf_add((ui8_t *)arg_request_chat_title, strlen(arg_request_chat_title));
		strcpy(obj->objs[13]->name, "request_chat_title");
		flagsv[nflags-1] |= (1 << 9);
	}


	//parse argument int
	obj->objs[14] = NEW(tlo_t, return NULL);
	obj->objs[14]->flag_num = 1;
	obj->objs[14]->flag_bit = 9;
	obj->objs[14]->type = TYPE_INT;
	obj->objs[14]->value = 
		buf_add_ui32(arg_request_chat_date);
	strcpy(obj->objs[14]->name, "request_chat_date");
	if (arg_request_chat_date)
		flagsv[nflags-1] |= (1 << 9);

	//parse argument long
	obj->objs[15] = NEW(tlo_t, return NULL);
	obj->objs[15]->flag_num = 1;
	obj->objs[15]->flag_bit = 13;
	obj->objs[15]->type = TYPE_LONG;
	obj->objs[15]->value = 
		buf_add_ui64(arg_business_bot_id);
	strcpy(obj->objs[15]->name, "business_bot_id");
	if (arg_business_bot_id)
		flagsv[nflags-1] |= (1 << 13);

	//parse argument string
	if (arg_business_bot_manage_url){
		obj->objs[16] = NEW(tlo_t, return NULL);
		obj->objs[16]->flag_num = 1;
		obj->objs[16]->flag_bit = 13;
		obj->objs[16]->type = TYPE_STRING;
		obj->objs[16]->value = 
			buf_add((ui8_t *)arg_business_bot_manage_url, strlen(arg_business_bot_manage_url));
		strcpy(obj->objs[16]->name, "business_bot_manage_url");
		flagsv[nflags-1] |= (1 << 13);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_wallPaper(long arg_id, bool arg_creator, bool arg_default, bool arg_pattern, bool arg_dark, long arg_access_hash, const char * arg_slug, Document arg_document, WallPaperSettings arg_settings)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "wallPaper");
	int i;
	obj->id = 0xa437c3ed;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 10;
	obj->objs = 
		(tlo_t **)MALLOC(10 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument (null)
	obj->objs[1] = NEW(tlo_t, return NULL);
	flags[nflags++] = 1;
	obj->objs[1]->type = TYPE_FLAG;
	strcpy(obj->objs[1]->name, "flags");

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_creator);
	strcpy(obj->objs[2]->name, "creator");
	if (arg_creator)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 1;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_default);
	strcpy(obj->objs[3]->name, "default");
	if (arg_default)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 3;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_pattern);
	strcpy(obj->objs[4]->name, "pattern");
	if (arg_pattern)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 4;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_dark);
	strcpy(obj->objs[5]->name, "dark");
	if (arg_dark)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument long
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_LONG;
	obj->objs[6]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[6]->name, "access_hash");

	//parse argument string
	if (arg_slug){
		obj->objs[7] = NEW(tlo_t, return NULL);
		obj->objs[7]->flag_num = 0;
		obj->objs[7]->flag_bit = 0;
		obj->objs[7]->type = TYPE_STRING;
		obj->objs[7]->value = 
			buf_add((ui8_t *)arg_slug, strlen(arg_slug));
		strcpy(obj->objs[7]->name, "slug");
	}


	//parse argument Document
	if (arg_document){
		obj->objs[8] = arg_document;
		obj->objs[8]->flag_num = 0;
		obj->objs[8]->flag_bit = 0;
	strcpy(obj->objs[8]->name, "document");
	}


	//parse argument WallPaperSettings
	if (arg_settings){
		obj->objs[9] = arg_settings;
		obj->objs[9]->flag_num = 1;
		obj->objs[9]->flag_bit = 2;
	strcpy(obj->objs[9]->name, "settings");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_wallPaperNoFile(long arg_id, bool arg_default, bool arg_dark, WallPaperSettings arg_settings)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "wallPaperNoFile");
	int i;
	obj->id = 0xe0804116;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument (null)
	obj->objs[1] = NEW(tlo_t, return NULL);
	flags[nflags++] = 1;
	obj->objs[1]->type = TYPE_FLAG;
	strcpy(obj->objs[1]->name, "flags");

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_default);
	strcpy(obj->objs[2]->name, "default");
	if (arg_default)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 4;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_dark);
	strcpy(obj->objs[3]->name, "dark");
	if (arg_dark)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument WallPaperSettings
	if (arg_settings){
		obj->objs[4] = arg_settings;
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 2;
	strcpy(obj->objs[4]->name, "settings");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputReportReasonSpam()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputReportReasonSpam");
	int i;
	obj->id = 0x58dbcab8;
	return obj;
}

tlo_t * tl_inputReportReasonViolence()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputReportReasonViolence");
	int i;
	obj->id = 0x1e22c78d;
	return obj;
}

tlo_t * tl_inputReportReasonPornography()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputReportReasonPornography");
	int i;
	obj->id = 0x2e59d922;
	return obj;
}

tlo_t * tl_inputReportReasonChildAbuse()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputReportReasonChildAbuse");
	int i;
	obj->id = 0xadf44ee3;
	return obj;
}

tlo_t * tl_inputReportReasonOther()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputReportReasonOther");
	int i;
	obj->id = 0xc1e4a2b1;
	return obj;
}

tlo_t * tl_inputReportReasonCopyright()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputReportReasonCopyright");
	int i;
	obj->id = 0x9b89f93a;
	return obj;
}

tlo_t * tl_inputReportReasonGeoIrrelevant()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputReportReasonGeoIrrelevant");
	int i;
	obj->id = 0xdbd4feed;
	return obj;
}

tlo_t * tl_inputReportReasonFake()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputReportReasonFake");
	int i;
	obj->id = 0xf5ddd6e7;
	return obj;
}

tlo_t * tl_inputReportReasonIllegalDrugs()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputReportReasonIllegalDrugs");
	int i;
	obj->id = 0x0a8eb2be;
	return obj;
}

tlo_t * tl_inputReportReasonPersonalDetails()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputReportReasonPersonalDetails");
	int i;
	obj->id = 0x9ec7863d;
	return obj;
}

tlo_t * tl_userFull(bool arg_blocked, bool arg_phone_calls_available, bool arg_phone_calls_private, bool arg_can_pin_message, bool arg_has_scheduled, bool arg_video_calls_available, bool arg_voice_messages_forbidden, bool arg_translations_disabled, bool arg_stories_pinned_available, bool arg_blocked_my_stories_from, bool arg_wallpaper_overridden, bool arg_contact_require_premium, bool arg_read_dates_private, bool arg_sponsored_enabled, long arg_id, const char * arg_about, PeerSettings arg_settings, Photo arg_personal_photo, Photo arg_profile_photo, Photo arg_fallback_photo, PeerNotifySettings arg_notify_settings, BotInfo arg_bot_info, int arg_pinned_msg_id, int arg_common_chats_count, int arg_folder_id, int arg_ttl_period, const char * arg_theme_emoticon, const char * arg_private_forward_name, ChatAdminRights arg_bot_group_admin_rights, ChatAdminRights arg_bot_broadcast_admin_rights, PremiumGiftOption *arg_premium_gifts, int len_arg_premium_gifts, WallPaper arg_wallpaper, PeerStories arg_stories, BusinessWorkHours arg_business_work_hours, BusinessLocation arg_business_location, BusinessGreetingMessage arg_business_greeting_message, BusinessAwayMessage arg_business_away_message, BusinessIntro arg_business_intro, Birthday arg_birthday, long arg_personal_channel_id, int arg_personal_channel_message, int arg_stargifts_count)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "userFull");
	int i;
	obj->id = 0x1f58e369;
	int flags[2]; int nflags = 0; //flags position
 	int flagsv[2]; //flags values
	for (i=0;i<2;++i) flagsv[i]=0;
 	obj->nobjs = 44;
	obj->objs = 
		(tlo_t **)MALLOC(44 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_blocked);
	strcpy(obj->objs[1]->name, "blocked");
	if (arg_blocked)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 4;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_phone_calls_available);
	strcpy(obj->objs[2]->name, "phone_calls_available");
	if (arg_phone_calls_available)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 5;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_phone_calls_private);
	strcpy(obj->objs[3]->name, "phone_calls_private");
	if (arg_phone_calls_private)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 7;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_can_pin_message);
	strcpy(obj->objs[4]->name, "can_pin_message");
	if (arg_can_pin_message)
		flagsv[nflags-1] |= (1 << 7);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 12;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_has_scheduled);
	strcpy(obj->objs[5]->name, "has_scheduled");
	if (arg_has_scheduled)
		flagsv[nflags-1] |= (1 << 12);

	//parse argument true
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 13;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_video_calls_available);
	strcpy(obj->objs[6]->name, "video_calls_available");
	if (arg_video_calls_available)
		flagsv[nflags-1] |= (1 << 13);

	//parse argument true
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 20;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_voice_messages_forbidden);
	strcpy(obj->objs[7]->name, "voice_messages_forbidden");
	if (arg_voice_messages_forbidden)
		flagsv[nflags-1] |= (1 << 20);

	//parse argument true
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 23;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_translations_disabled);
	strcpy(obj->objs[8]->name, "translations_disabled");
	if (arg_translations_disabled)
		flagsv[nflags-1] |= (1 << 23);

	//parse argument true
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 1;
	obj->objs[9]->flag_bit = 26;
	obj->objs[9]->type = TYPE_INT;
	obj->objs[9]->value = 
		buf_add_ui32(arg_stories_pinned_available);
	strcpy(obj->objs[9]->name, "stories_pinned_available");
	if (arg_stories_pinned_available)
		flagsv[nflags-1] |= (1 << 26);

	//parse argument true
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 1;
	obj->objs[10]->flag_bit = 27;
	obj->objs[10]->type = TYPE_INT;
	obj->objs[10]->value = 
		buf_add_ui32(arg_blocked_my_stories_from);
	strcpy(obj->objs[10]->name, "blocked_my_stories_from");
	if (arg_blocked_my_stories_from)
		flagsv[nflags-1] |= (1 << 27);

	//parse argument true
	obj->objs[11] = NEW(tlo_t, return NULL);
	obj->objs[11]->flag_num = 1;
	obj->objs[11]->flag_bit = 28;
	obj->objs[11]->type = TYPE_INT;
	obj->objs[11]->value = 
		buf_add_ui32(arg_wallpaper_overridden);
	strcpy(obj->objs[11]->name, "wallpaper_overridden");
	if (arg_wallpaper_overridden)
		flagsv[nflags-1] |= (1 << 28);

	//parse argument true
	obj->objs[12] = NEW(tlo_t, return NULL);
	obj->objs[12]->flag_num = 1;
	obj->objs[12]->flag_bit = 29;
	obj->objs[12]->type = TYPE_INT;
	obj->objs[12]->value = 
		buf_add_ui32(arg_contact_require_premium);
	strcpy(obj->objs[12]->name, "contact_require_premium");
	if (arg_contact_require_premium)
		flagsv[nflags-1] |= (1 << 29);

	//parse argument true
	obj->objs[13] = NEW(tlo_t, return NULL);
	obj->objs[13]->flag_num = 1;
	obj->objs[13]->flag_bit = 30;
	obj->objs[13]->type = TYPE_INT;
	obj->objs[13]->value = 
		buf_add_ui32(arg_read_dates_private);
	strcpy(obj->objs[13]->name, "read_dates_private");
	if (arg_read_dates_private)
		flagsv[nflags-1] |= (1 << 30);

	//parse argument (null)
	obj->objs[14] = NEW(tlo_t, return NULL);
	flags[nflags++] = 14;
	obj->objs[14]->type = TYPE_FLAG;
	strcpy(obj->objs[14]->name, "flags2");

	//parse argument true
	obj->objs[15] = NEW(tlo_t, return NULL);
	obj->objs[15]->flag_num = 2;
	obj->objs[15]->flag_bit = 7;
	obj->objs[15]->type = TYPE_INT;
	obj->objs[15]->value = 
		buf_add_ui32(arg_sponsored_enabled);
	strcpy(obj->objs[15]->name, "sponsored_enabled");
	if (arg_sponsored_enabled)
		flagsv[nflags-1] |= (1 << 7);

	//parse argument long
	obj->objs[16] = NEW(tlo_t, return NULL);
	obj->objs[16]->flag_num = 0;
	obj->objs[16]->flag_bit = 0;
	obj->objs[16]->type = TYPE_LONG;
	obj->objs[16]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[16]->name, "id");

	//parse argument string
	if (arg_about){
		obj->objs[17] = NEW(tlo_t, return NULL);
		obj->objs[17]->flag_num = 1;
		obj->objs[17]->flag_bit = 1;
		obj->objs[17]->type = TYPE_STRING;
		obj->objs[17]->value = 
			buf_add((ui8_t *)arg_about, strlen(arg_about));
		strcpy(obj->objs[17]->name, "about");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument PeerSettings
	if (arg_settings){
		obj->objs[18] = arg_settings;
		obj->objs[18]->flag_num = 0;
		obj->objs[18]->flag_bit = 0;
	strcpy(obj->objs[18]->name, "settings");
	}


	//parse argument Photo
	if (arg_personal_photo){
		obj->objs[19] = arg_personal_photo;
		obj->objs[19]->flag_num = 1;
		obj->objs[19]->flag_bit = 21;
	strcpy(obj->objs[19]->name, "personal_photo");
		flagsv[nflags-1] |= (1 << 21);
	}


	//parse argument Photo
	if (arg_profile_photo){
		obj->objs[20] = arg_profile_photo;
		obj->objs[20]->flag_num = 1;
		obj->objs[20]->flag_bit = 2;
	strcpy(obj->objs[20]->name, "profile_photo");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument Photo
	if (arg_fallback_photo){
		obj->objs[21] = arg_fallback_photo;
		obj->objs[21]->flag_num = 1;
		obj->objs[21]->flag_bit = 22;
	strcpy(obj->objs[21]->name, "fallback_photo");
		flagsv[nflags-1] |= (1 << 22);
	}


	//parse argument PeerNotifySettings
	if (arg_notify_settings){
		obj->objs[22] = arg_notify_settings;
		obj->objs[22]->flag_num = 0;
		obj->objs[22]->flag_bit = 0;
	strcpy(obj->objs[22]->name, "notify_settings");
	}


	//parse argument BotInfo
	if (arg_bot_info){
		obj->objs[23] = arg_bot_info;
		obj->objs[23]->flag_num = 1;
		obj->objs[23]->flag_bit = 3;
	strcpy(obj->objs[23]->name, "bot_info");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument int
	obj->objs[24] = NEW(tlo_t, return NULL);
	obj->objs[24]->flag_num = 1;
	obj->objs[24]->flag_bit = 6;
	obj->objs[24]->type = TYPE_INT;
	obj->objs[24]->value = 
		buf_add_ui32(arg_pinned_msg_id);
	strcpy(obj->objs[24]->name, "pinned_msg_id");
	if (arg_pinned_msg_id)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument int
	obj->objs[25] = NEW(tlo_t, return NULL);
	obj->objs[25]->flag_num = 0;
	obj->objs[25]->flag_bit = 0;
	obj->objs[25]->type = TYPE_INT;
	obj->objs[25]->value = 
		buf_add_ui32(arg_common_chats_count);
	strcpy(obj->objs[25]->name, "common_chats_count");

	//parse argument int
	obj->objs[26] = NEW(tlo_t, return NULL);
	obj->objs[26]->flag_num = 1;
	obj->objs[26]->flag_bit = 11;
	obj->objs[26]->type = TYPE_INT;
	obj->objs[26]->value = 
		buf_add_ui32(arg_folder_id);
	strcpy(obj->objs[26]->name, "folder_id");
	if (arg_folder_id)
		flagsv[nflags-1] |= (1 << 11);

	//parse argument int
	obj->objs[27] = NEW(tlo_t, return NULL);
	obj->objs[27]->flag_num = 1;
	obj->objs[27]->flag_bit = 14;
	obj->objs[27]->type = TYPE_INT;
	obj->objs[27]->value = 
		buf_add_ui32(arg_ttl_period);
	strcpy(obj->objs[27]->name, "ttl_period");
	if (arg_ttl_period)
		flagsv[nflags-1] |= (1 << 14);

	//parse argument string
	if (arg_theme_emoticon){
		obj->objs[28] = NEW(tlo_t, return NULL);
		obj->objs[28]->flag_num = 1;
		obj->objs[28]->flag_bit = 15;
		obj->objs[28]->type = TYPE_STRING;
		obj->objs[28]->value = 
			buf_add((ui8_t *)arg_theme_emoticon, strlen(arg_theme_emoticon));
		strcpy(obj->objs[28]->name, "theme_emoticon");
		flagsv[nflags-1] |= (1 << 15);
	}


	//parse argument string
	if (arg_private_forward_name){
		obj->objs[29] = NEW(tlo_t, return NULL);
		obj->objs[29]->flag_num = 1;
		obj->objs[29]->flag_bit = 16;
		obj->objs[29]->type = TYPE_STRING;
		obj->objs[29]->value = 
			buf_add((ui8_t *)arg_private_forward_name, strlen(arg_private_forward_name));
		strcpy(obj->objs[29]->name, "private_forward_name");
		flagsv[nflags-1] |= (1 << 16);
	}


	//parse argument ChatAdminRights
	if (arg_bot_group_admin_rights){
		obj->objs[30] = arg_bot_group_admin_rights;
		obj->objs[30]->flag_num = 1;
		obj->objs[30]->flag_bit = 17;
	strcpy(obj->objs[30]->name, "bot_group_admin_rights");
		flagsv[nflags-1] |= (1 << 17);
	}


	//parse argument ChatAdminRights
	if (arg_bot_broadcast_admin_rights){
		obj->objs[31] = arg_bot_broadcast_admin_rights;
		obj->objs[31]->flag_num = 1;
		obj->objs[31]->flag_bit = 18;
	strcpy(obj->objs[31]->name, "bot_broadcast_admin_rights");
		flagsv[nflags-1] |= (1 << 18);
	}


	//parse argument Vector<PremiumGiftOption>
	obj->objs[32] = NEW(tlo_t, return NULL);
	obj->objs[32]->flag_num = 1;
	obj->objs[32]->flag_bit = 19;
	obj->objs[32]->type = TYPE_VECTOR;
	strcpy(obj->objs[32]->name, "premium_gifts");
	if (arg_premium_gifts){
		for(i=0; i<len_arg_premium_gifts; ++i){
			obj->objs[32]->value = buf_add_ui32(arg_premium_gifts[i]->id);
			buf_cat(obj->objs[32]->value, arg_premium_gifts[i]->value);
		}
		flagsv[nflags-1] |= (1 << 19);
	}


	//parse argument WallPaper
	if (arg_wallpaper){
		obj->objs[33] = arg_wallpaper;
		obj->objs[33]->flag_num = 1;
		obj->objs[33]->flag_bit = 24;
	strcpy(obj->objs[33]->name, "wallpaper");
		flagsv[nflags-1] |= (1 << 24);
	}


	//parse argument PeerStories
	if (arg_stories){
		obj->objs[34] = arg_stories;
		obj->objs[34]->flag_num = 1;
		obj->objs[34]->flag_bit = 25;
	strcpy(obj->objs[34]->name, "stories");
		flagsv[nflags-1] |= (1 << 25);
	}


	//parse argument BusinessWorkHours
	if (arg_business_work_hours){
		obj->objs[35] = arg_business_work_hours;
		obj->objs[35]->flag_num = 2;
		obj->objs[35]->flag_bit = 0;
	strcpy(obj->objs[35]->name, "business_work_hours");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument BusinessLocation
	if (arg_business_location){
		obj->objs[36] = arg_business_location;
		obj->objs[36]->flag_num = 2;
		obj->objs[36]->flag_bit = 1;
	strcpy(obj->objs[36]->name, "business_location");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument BusinessGreetingMessage
	if (arg_business_greeting_message){
		obj->objs[37] = arg_business_greeting_message;
		obj->objs[37]->flag_num = 2;
		obj->objs[37]->flag_bit = 2;
	strcpy(obj->objs[37]->name, "business_greeting_message");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument BusinessAwayMessage
	if (arg_business_away_message){
		obj->objs[38] = arg_business_away_message;
		obj->objs[38]->flag_num = 2;
		obj->objs[38]->flag_bit = 3;
	strcpy(obj->objs[38]->name, "business_away_message");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument BusinessIntro
	if (arg_business_intro){
		obj->objs[39] = arg_business_intro;
		obj->objs[39]->flag_num = 2;
		obj->objs[39]->flag_bit = 4;
	strcpy(obj->objs[39]->name, "business_intro");
		flagsv[nflags-1] |= (1 << 4);
	}


	//parse argument Birthday
	if (arg_birthday){
		obj->objs[40] = arg_birthday;
		obj->objs[40]->flag_num = 2;
		obj->objs[40]->flag_bit = 5;
	strcpy(obj->objs[40]->name, "birthday");
		flagsv[nflags-1] |= (1 << 5);
	}


	//parse argument long
	obj->objs[41] = NEW(tlo_t, return NULL);
	obj->objs[41]->flag_num = 2;
	obj->objs[41]->flag_bit = 6;
	obj->objs[41]->type = TYPE_LONG;
	obj->objs[41]->value = 
		buf_add_ui64(arg_personal_channel_id);
	strcpy(obj->objs[41]->name, "personal_channel_id");
	if (arg_personal_channel_id)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument int
	obj->objs[42] = NEW(tlo_t, return NULL);
	obj->objs[42]->flag_num = 2;
	obj->objs[42]->flag_bit = 6;
	obj->objs[42]->type = TYPE_INT;
	obj->objs[42]->value = 
		buf_add_ui32(arg_personal_channel_message);
	strcpy(obj->objs[42]->name, "personal_channel_message");
	if (arg_personal_channel_message)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument int
	obj->objs[43] = NEW(tlo_t, return NULL);
	obj->objs[43]->flag_num = 2;
	obj->objs[43]->flag_bit = 8;
	obj->objs[43]->type = TYPE_INT;
	obj->objs[43]->value = 
		buf_add_ui32(arg_stargifts_count);
	strcpy(obj->objs[43]->name, "stargifts_count");
	if (arg_stargifts_count)
		flagsv[nflags-1] |= (1 << 8);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	int flag1 = flags[1];
	obj->objs[flag1]->value = buf_add_ui32(flagsv[1]);
	obj->objs[flag1]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_contact(long arg_user_id, Bool arg_mutual)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contact");
	int i;
	obj->id = 0x145ade0b;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[0]->name, "user_id");

	//parse argument Bool
	if (arg_mutual){
		obj->objs[1] = arg_mutual;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "mutual");
	}

	return obj;
}

tlo_t * tl_importedContact(long arg_user_id, long arg_client_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "importedContact");
	int i;
	obj->id = 0xc13e3c50;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[0]->name, "user_id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_client_id);
	strcpy(obj->objs[1]->name, "client_id");
	return obj;
}

tlo_t * tl_contactStatus(long arg_user_id, UserStatus arg_status)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contactStatus");
	int i;
	obj->id = 0x16d9703b;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[0]->name, "user_id");

	//parse argument UserStatus
	if (arg_status){
		obj->objs[1] = arg_status;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "status");
	}

	return obj;
}

tlo_t * tl_contacts_contactsNotModified()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_contactsNotModified");
	int i;
	obj->id = 0xb74ba9d2;
	return obj;
}

tlo_t * tl_contacts_contacts(Contact *arg_contacts, int len_arg_contacts, int arg_saved_count, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_contacts");
	int i;
	obj->id = 0xeae87e42;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<Contact>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "contacts");
	if (arg_contacts){
		for(i=0; i<len_arg_contacts; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_contacts[i]->id);
			buf_cat(obj->objs[0]->value, arg_contacts[i]->value);
		}
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_saved_count);
	strcpy(obj->objs[1]->name, "saved_count");

	//parse argument Vector<User>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[2]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_contacts_importedContacts(ImportedContact *arg_imported, int len_arg_imported, PopularContact *arg_popular_invites, int len_arg_popular_invites, long *arg_retry_contacts, int len_arg_retry_contacts, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_importedContacts");
	int i;
	obj->id = 0x77d01c3b;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<ImportedContact>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "imported");
	if (arg_imported){
		for(i=0; i<len_arg_imported; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_imported[i]->id);
			buf_cat(obj->objs[0]->value, arg_imported[i]->value);
		}
	}


	//parse argument Vector<PopularContact>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "popular_invites");
	if (arg_popular_invites){
		for(i=0; i<len_arg_popular_invites; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_popular_invites[i]->id);
			buf_cat(obj->objs[1]->value, arg_popular_invites[i]->value);
		}
	}


	//parse argument Vector<long>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "retry_contacts");
	if (arg_retry_contacts){
		for(i=0; i<len_arg_retry_contacts; ++i){
			buf_t b = buf_add_ui64(arg_retry_contacts[i]);
			buf_cat(obj->objs[2]->value, b);
		}
	}


	//parse argument Vector<User>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[3]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_contacts_blocked(PeerBlocked *arg_blocked, int len_arg_blocked, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_blocked");
	int i;
	obj->id = 0x0ade1591;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<PeerBlocked>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "blocked");
	if (arg_blocked){
		for(i=0; i<len_arg_blocked; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_blocked[i]->id);
			buf_cat(obj->objs[0]->value, arg_blocked[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[1]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[2]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_contacts_blockedSlice(int arg_count, PeerBlocked *arg_blocked, int len_arg_blocked, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_blockedSlice");
	int i;
	obj->id = 0xe1664194;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[0]->name, "count");

	//parse argument Vector<PeerBlocked>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "blocked");
	if (arg_blocked){
		for(i=0; i<len_arg_blocked; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_blocked[i]->id);
			buf_cat(obj->objs[1]->value, arg_blocked[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[2]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[3]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_messages_dialogs(Dialog *arg_dialogs, int len_arg_dialogs, Message *arg_messages, int len_arg_messages, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_dialogs");
	int i;
	obj->id = 0x15ba6c40;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<Dialog>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "dialogs");
	if (arg_dialogs){
		for(i=0; i<len_arg_dialogs; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_dialogs[i]->id);
			buf_cat(obj->objs[0]->value, arg_dialogs[i]->value);
		}
	}


	//parse argument Vector<Message>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "messages");
	if (arg_messages){
		for(i=0; i<len_arg_messages; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_messages[i]->id);
			buf_cat(obj->objs[1]->value, arg_messages[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[2]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[3]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_messages_dialogsSlice(int arg_count, Dialog *arg_dialogs, int len_arg_dialogs, Message *arg_messages, int len_arg_messages, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_dialogsSlice");
	int i;
	obj->id = 0x71e094f3;
	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[0]->name, "count");

	//parse argument Vector<Dialog>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "dialogs");
	if (arg_dialogs){
		for(i=0; i<len_arg_dialogs; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_dialogs[i]->id);
			buf_cat(obj->objs[1]->value, arg_dialogs[i]->value);
		}
	}


	//parse argument Vector<Message>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "messages");
	if (arg_messages){
		for(i=0; i<len_arg_messages; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_messages[i]->id);
			buf_cat(obj->objs[2]->value, arg_messages[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[3]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[4]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_messages_dialogsNotModified(int arg_count)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_dialogsNotModified");
	int i;
	obj->id = 0xf0e3e596;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[0]->name, "count");
	return obj;
}

tlo_t * tl_messages_messages(Message *arg_messages, int len_arg_messages, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_messages");
	int i;
	obj->id = 0x8c718e87;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<Message>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "messages");
	if (arg_messages){
		for(i=0; i<len_arg_messages; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_messages[i]->id);
			buf_cat(obj->objs[0]->value, arg_messages[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[1]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[2]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_messages_messagesSlice(bool arg_inexact, int arg_count, int arg_next_rate, int arg_offset_id_offset, Message *arg_messages, int len_arg_messages, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_messagesSlice");
	int i;
	obj->id = 0x3a54685e;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_inexact);
	strcpy(obj->objs[1]->name, "inexact");
	if (arg_inexact)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[2]->name, "count");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_next_rate);
	strcpy(obj->objs[3]->name, "next_rate");
	if (arg_next_rate)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 2;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_offset_id_offset);
	strcpy(obj->objs[4]->name, "offset_id_offset");
	if (arg_offset_id_offset)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument Vector<Message>
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_VECTOR;
	strcpy(obj->objs[5]->name, "messages");
	if (arg_messages){
		for(i=0; i<len_arg_messages; ++i){
			obj->objs[5]->value = buf_add_ui32(arg_messages[i]->id);
			buf_cat(obj->objs[5]->value, arg_messages[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_VECTOR;
	strcpy(obj->objs[6]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[6]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[6]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_VECTOR;
	strcpy(obj->objs[7]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[7]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[7]->value, arg_users[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_channelMessages(bool arg_inexact, int arg_pts, int arg_count, int arg_offset_id_offset, Message *arg_messages, int len_arg_messages, ForumTopic *arg_topics, int len_arg_topics, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_channelMessages");
	int i;
	obj->id = 0xc776ba4e;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_inexact);
	strcpy(obj->objs[1]->name, "inexact");
	if (arg_inexact)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_pts);
	strcpy(obj->objs[2]->name, "pts");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[3]->name, "count");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 2;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_offset_id_offset);
	strcpy(obj->objs[4]->name, "offset_id_offset");
	if (arg_offset_id_offset)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument Vector<Message>
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_VECTOR;
	strcpy(obj->objs[5]->name, "messages");
	if (arg_messages){
		for(i=0; i<len_arg_messages; ++i){
			obj->objs[5]->value = buf_add_ui32(arg_messages[i]->id);
			buf_cat(obj->objs[5]->value, arg_messages[i]->value);
		}
	}


	//parse argument Vector<ForumTopic>
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_VECTOR;
	strcpy(obj->objs[6]->name, "topics");
	if (arg_topics){
		for(i=0; i<len_arg_topics; ++i){
			obj->objs[6]->value = buf_add_ui32(arg_topics[i]->id);
			buf_cat(obj->objs[6]->value, arg_topics[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_VECTOR;
	strcpy(obj->objs[7]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[7]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[7]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 0;
	obj->objs[8]->flag_bit = 0;
	obj->objs[8]->type = TYPE_VECTOR;
	strcpy(obj->objs[8]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[8]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[8]->value, arg_users[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_messagesNotModified(int arg_count)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_messagesNotModified");
	int i;
	obj->id = 0x74535f21;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[0]->name, "count");
	return obj;
}

tlo_t * tl_messages_chats(Chat *arg_chats, int len_arg_chats)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_chats");
	int i;
	obj->id = 0x64ff9fd5;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<Chat>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[0]->value, arg_chats[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_messages_chatsSlice(int arg_count, Chat *arg_chats, int len_arg_chats)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_chatsSlice");
	int i;
	obj->id = 0x9cd81144;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[0]->name, "count");

	//parse argument Vector<Chat>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[1]->value, arg_chats[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_messages_chatFull(ChatFull arg_full_chat, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_chatFull");
	int i;
	obj->id = 0xe5d7d19c;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument ChatFull
	if (arg_full_chat){
		obj->objs[0] = arg_full_chat;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "full_chat");
	}


	//parse argument Vector<Chat>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[1]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[2]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_messages_affectedHistory(int arg_pts, int arg_pts_count, int arg_offset)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_affectedHistory");
	int i;
	obj->id = 0xb45c69d1;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_pts);
	strcpy(obj->objs[0]->name, "pts");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_pts_count);
	strcpy(obj->objs[1]->name, "pts_count");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_offset);
	strcpy(obj->objs[2]->name, "offset");
	return obj;
}

tlo_t * tl_inputMessagesFilterEmpty()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMessagesFilterEmpty");
	int i;
	obj->id = 0x57e2f66c;
	return obj;
}

tlo_t * tl_inputMessagesFilterPhotos()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMessagesFilterPhotos");
	int i;
	obj->id = 0x9609a51c;
	return obj;
}

tlo_t * tl_inputMessagesFilterVideo()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMessagesFilterVideo");
	int i;
	obj->id = 0x9fc00e65;
	return obj;
}

tlo_t * tl_inputMessagesFilterPhotoVideo()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMessagesFilterPhotoVideo");
	int i;
	obj->id = 0x56e9f0e4;
	return obj;
}

tlo_t * tl_inputMessagesFilterDocument()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMessagesFilterDocument");
	int i;
	obj->id = 0x9eddf188;
	return obj;
}

tlo_t * tl_inputMessagesFilterUrl()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMessagesFilterUrl");
	int i;
	obj->id = 0x7ef0dd87;
	return obj;
}

tlo_t * tl_inputMessagesFilterGif()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMessagesFilterGif");
	int i;
	obj->id = 0xffc86587;
	return obj;
}

tlo_t * tl_inputMessagesFilterVoice()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMessagesFilterVoice");
	int i;
	obj->id = 0x50f5c392;
	return obj;
}

tlo_t * tl_inputMessagesFilterMusic()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMessagesFilterMusic");
	int i;
	obj->id = 0x3751b49e;
	return obj;
}

tlo_t * tl_inputMessagesFilterChatPhotos()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMessagesFilterChatPhotos");
	int i;
	obj->id = 0x3a20ecb8;
	return obj;
}

tlo_t * tl_inputMessagesFilterPhoneCalls(bool arg_missed)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMessagesFilterPhoneCalls");
	int i;
	obj->id = 0x80c99768;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_missed);
	strcpy(obj->objs[1]->name, "missed");
	if (arg_missed)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputMessagesFilterRoundVoice()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMessagesFilterRoundVoice");
	int i;
	obj->id = 0x7a7c17a4;
	return obj;
}

tlo_t * tl_inputMessagesFilterRoundVideo()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMessagesFilterRoundVideo");
	int i;
	obj->id = 0xb549da53;
	return obj;
}

tlo_t * tl_inputMessagesFilterMyMentions()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMessagesFilterMyMentions");
	int i;
	obj->id = 0xc1f8e69a;
	return obj;
}

tlo_t * tl_inputMessagesFilterGeo()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMessagesFilterGeo");
	int i;
	obj->id = 0xe7026d0d;
	return obj;
}

tlo_t * tl_inputMessagesFilterContacts()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMessagesFilterContacts");
	int i;
	obj->id = 0xe062db83;
	return obj;
}

tlo_t * tl_inputMessagesFilterPinned()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMessagesFilterPinned");
	int i;
	obj->id = 0x1bb00451;
	return obj;
}

tlo_t * tl_updateNewMessage(Message arg_message, int arg_pts, int arg_pts_count)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateNewMessage");
	int i;
	obj->id = 0x1f2b0afd;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument Message
	if (arg_message){
		obj->objs[0] = arg_message;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "message");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_pts);
	strcpy(obj->objs[1]->name, "pts");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_pts_count);
	strcpy(obj->objs[2]->name, "pts_count");
	return obj;
}

tlo_t * tl_updateMessageID(int arg_id, long arg_random_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateMessageID");
	int i;
	obj->id = 0x4e90bfd6;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_random_id);
	strcpy(obj->objs[1]->name, "random_id");
	return obj;
}

tlo_t * tl_updateDeleteMessages(int *arg_messages, int len_arg_messages, int arg_pts, int arg_pts_count)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateDeleteMessages");
	int i;
	obj->id = 0xa20db0e5;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<int>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "messages");
	if (arg_messages){
		for(i=0; i<len_arg_messages; ++i){
			buf_t b = buf_add_ui32(arg_messages[i]);
			buf_cat(obj->objs[0]->value, b);
		}
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_pts);
	strcpy(obj->objs[1]->name, "pts");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_pts_count);
	strcpy(obj->objs[2]->name, "pts_count");
	return obj;
}

tlo_t * tl_updateUserTyping(long arg_user_id, SendMessageAction arg_action)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateUserTyping");
	int i;
	obj->id = 0xc01e857f;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[0]->name, "user_id");

	//parse argument SendMessageAction
	if (arg_action){
		obj->objs[1] = arg_action;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "action");
	}

	return obj;
}

tlo_t * tl_updateChatUserTyping(long arg_chat_id, Peer arg_from_id, SendMessageAction arg_action)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateChatUserTyping");
	int i;
	obj->id = 0x83487af0;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_chat_id);
	strcpy(obj->objs[0]->name, "chat_id");

	//parse argument Peer
	if (arg_from_id){
		obj->objs[1] = arg_from_id;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "from_id");
	}


	//parse argument SendMessageAction
	if (arg_action){
		obj->objs[2] = arg_action;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "action");
	}

	return obj;
}

tlo_t * tl_updateChatParticipants(ChatParticipants arg_participants)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateChatParticipants");
	int i;
	obj->id = 0x07761198;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument ChatParticipants
	if (arg_participants){
		obj->objs[0] = arg_participants;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "participants");
	}

	return obj;
}

tlo_t * tl_updateUserStatus(long arg_user_id, UserStatus arg_status)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateUserStatus");
	int i;
	obj->id = 0xe5bdf8de;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[0]->name, "user_id");

	//parse argument UserStatus
	if (arg_status){
		obj->objs[1] = arg_status;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "status");
	}

	return obj;
}

tlo_t * tl_updateUserName(long arg_user_id, const char * arg_first_name, const char * arg_last_name, Username *arg_usernames, int len_arg_usernames)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateUserName");
	int i;
	obj->id = 0xa7848924;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[0]->name, "user_id");

	//parse argument string
	if (arg_first_name){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_first_name, strlen(arg_first_name));
		strcpy(obj->objs[1]->name, "first_name");
	}


	//parse argument string
	if (arg_last_name){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_last_name, strlen(arg_last_name));
		strcpy(obj->objs[2]->name, "last_name");
	}


	//parse argument Vector<Username>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "usernames");
	if (arg_usernames){
		for(i=0; i<len_arg_usernames; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_usernames[i]->id);
			buf_cat(obj->objs[3]->value, arg_usernames[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_updateNewAuthorization(bool arg_unconfirmed, long arg_hash, int arg_date, const char * arg_device, const char * arg_location)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateNewAuthorization");
	int i;
	obj->id = 0x8951abef;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_unconfirmed);
	strcpy(obj->objs[1]->name, "unconfirmed");
	if (arg_unconfirmed)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[2]->name, "hash");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[3]->name, "date");
	if (arg_date)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument string
	if (arg_device){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_device, strlen(arg_device));
		strcpy(obj->objs[4]->name, "device");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_location){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_location, strlen(arg_location));
		strcpy(obj->objs[5]->name, "location");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateNewEncryptedMessage(EncryptedMessage arg_message, int arg_qts)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateNewEncryptedMessage");
	int i;
	obj->id = 0x12bcbd9a;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument EncryptedMessage
	if (arg_message){
		obj->objs[0] = arg_message;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "message");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_qts);
	strcpy(obj->objs[1]->name, "qts");
	return obj;
}

tlo_t * tl_updateEncryptedChatTyping(int arg_chat_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateEncryptedChatTyping");
	int i;
	obj->id = 0x1710f156;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_chat_id);
	strcpy(obj->objs[0]->name, "chat_id");
	return obj;
}

tlo_t * tl_updateEncryption(EncryptedChat arg_chat, int arg_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateEncryption");
	int i;
	obj->id = 0xb4a2e88d;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument EncryptedChat
	if (arg_chat){
		obj->objs[0] = arg_chat;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "chat");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[1]->name, "date");
	return obj;
}

tlo_t * tl_updateEncryptedMessagesRead(int arg_chat_id, int arg_max_date, int arg_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateEncryptedMessagesRead");
	int i;
	obj->id = 0x38fe25b7;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_chat_id);
	strcpy(obj->objs[0]->name, "chat_id");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_max_date);
	strcpy(obj->objs[1]->name, "max_date");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[2]->name, "date");
	return obj;
}

tlo_t * tl_updateChatParticipantAdd(long arg_chat_id, long arg_user_id, long arg_inviter_id, int arg_date, int arg_version)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateChatParticipantAdd");
	int i;
	obj->id = 0x3dda5451;
	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_chat_id);
	strcpy(obj->objs[0]->name, "chat_id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[1]->name, "user_id");

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_inviter_id);
	strcpy(obj->objs[2]->name, "inviter_id");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[3]->name, "date");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_version);
	strcpy(obj->objs[4]->name, "version");
	return obj;
}

tlo_t * tl_updateChatParticipantDelete(long arg_chat_id, long arg_user_id, int arg_version)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateChatParticipantDelete");
	int i;
	obj->id = 0xe32f3d77;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_chat_id);
	strcpy(obj->objs[0]->name, "chat_id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[1]->name, "user_id");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_version);
	strcpy(obj->objs[2]->name, "version");
	return obj;
}

tlo_t * tl_updateDcOptions(DcOption *arg_dc_options, int len_arg_dc_options)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateDcOptions");
	int i;
	obj->id = 0x8e5e9873;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<DcOption>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "dc_options");
	if (arg_dc_options){
		for(i=0; i<len_arg_dc_options; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_dc_options[i]->id);
			buf_cat(obj->objs[0]->value, arg_dc_options[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_updateNotifySettings(NotifyPeer arg_peer, PeerNotifySettings arg_notify_settings)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateNotifySettings");
	int i;
	obj->id = 0xbec268ef;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument NotifyPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument PeerNotifySettings
	if (arg_notify_settings){
		obj->objs[1] = arg_notify_settings;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "notify_settings");
	}

	return obj;
}

tlo_t * tl_updateServiceNotification(bool arg_popup, bool arg_invert_media, int arg_inbox_date, const char * arg_type, const char * arg_message, MessageMedia arg_media, MessageEntity *arg_entities, int len_arg_entities)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateServiceNotification");
	int i;
	obj->id = 0xebe46819;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_popup);
	strcpy(obj->objs[1]->name, "popup");
	if (arg_popup)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 2;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_invert_media);
	strcpy(obj->objs[2]->name, "invert_media");
	if (arg_invert_media)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 1;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_inbox_date);
	strcpy(obj->objs[3]->name, "inbox_date");
	if (arg_inbox_date)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument string
	if (arg_type){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_type, strlen(arg_type));
		strcpy(obj->objs[4]->name, "type");
	}


	//parse argument string
	if (arg_message){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_message, strlen(arg_message));
		strcpy(obj->objs[5]->name, "message");
	}


	//parse argument MessageMedia
	if (arg_media){
		obj->objs[6] = arg_media;
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
	strcpy(obj->objs[6]->name, "media");
	}


	//parse argument Vector<MessageEntity>
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_VECTOR;
	strcpy(obj->objs[7]->name, "entities");
	if (arg_entities){
		for(i=0; i<len_arg_entities; ++i){
			obj->objs[7]->value = buf_add_ui32(arg_entities[i]->id);
			buf_cat(obj->objs[7]->value, arg_entities[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updatePrivacy(PrivacyKey arg_key, PrivacyRule *arg_rules, int len_arg_rules)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updatePrivacy");
	int i;
	obj->id = 0xee3b272a;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument PrivacyKey
	if (arg_key){
		obj->objs[0] = arg_key;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "key");
	}


	//parse argument Vector<PrivacyRule>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "rules");
	if (arg_rules){
		for(i=0; i<len_arg_rules; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_rules[i]->id);
			buf_cat(obj->objs[1]->value, arg_rules[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_updateUserPhone(long arg_user_id, const char * arg_phone)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateUserPhone");
	int i;
	obj->id = 0x05492a13;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[0]->name, "user_id");

	//parse argument string
	if (arg_phone){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_phone, strlen(arg_phone));
		strcpy(obj->objs[1]->name, "phone");
	}

	return obj;
}

tlo_t * tl_updateReadHistoryInbox(int arg_folder_id, Peer arg_peer, int arg_max_id, int arg_still_unread_count, int arg_pts, int arg_pts_count)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateReadHistoryInbox");
	int i;
	obj->id = 0x9c974fdf;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_folder_id);
	strcpy(obj->objs[1]->name, "folder_id");
	if (arg_folder_id)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument Peer
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_max_id);
	strcpy(obj->objs[3]->name, "max_id");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_still_unread_count);
	strcpy(obj->objs[4]->name, "still_unread_count");

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_pts);
	strcpy(obj->objs[5]->name, "pts");

	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_pts_count);
	strcpy(obj->objs[6]->name, "pts_count");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateReadHistoryOutbox(Peer arg_peer, int arg_max_id, int arg_pts, int arg_pts_count)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateReadHistoryOutbox");
	int i;
	obj->id = 0x2f2f21bf;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_max_id);
	strcpy(obj->objs[1]->name, "max_id");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_pts);
	strcpy(obj->objs[2]->name, "pts");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_pts_count);
	strcpy(obj->objs[3]->name, "pts_count");
	return obj;
}

tlo_t * tl_updateWebPage(WebPage arg_webpage, int arg_pts, int arg_pts_count)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateWebPage");
	int i;
	obj->id = 0x7f891213;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument WebPage
	if (arg_webpage){
		obj->objs[0] = arg_webpage;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "webpage");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_pts);
	strcpy(obj->objs[1]->name, "pts");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_pts_count);
	strcpy(obj->objs[2]->name, "pts_count");
	return obj;
}

tlo_t * tl_updateReadMessagesContents(int *arg_messages, int len_arg_messages, int arg_pts, int arg_pts_count, int arg_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateReadMessagesContents");
	int i;
	obj->id = 0xf8227181;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument Vector<int>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "messages");
	if (arg_messages){
		for(i=0; i<len_arg_messages; ++i){
			buf_t b = buf_add_ui32(arg_messages[i]);
			buf_cat(obj->objs[1]->value, b);
		}
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_pts);
	strcpy(obj->objs[2]->name, "pts");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_pts_count);
	strcpy(obj->objs[3]->name, "pts_count");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[4]->name, "date");
	if (arg_date)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateChannelTooLong(long arg_channel_id, int arg_pts)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateChannelTooLong");
	int i;
	obj->id = 0x108d941f;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_channel_id);
	strcpy(obj->objs[1]->name, "channel_id");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_pts);
	strcpy(obj->objs[2]->name, "pts");
	if (arg_pts)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateChannel(long arg_channel_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateChannel");
	int i;
	obj->id = 0x635b4c09;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_channel_id);
	strcpy(obj->objs[0]->name, "channel_id");
	return obj;
}

tlo_t * tl_updateNewChannelMessage(Message arg_message, int arg_pts, int arg_pts_count)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateNewChannelMessage");
	int i;
	obj->id = 0x62ba04d9;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument Message
	if (arg_message){
		obj->objs[0] = arg_message;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "message");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_pts);
	strcpy(obj->objs[1]->name, "pts");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_pts_count);
	strcpy(obj->objs[2]->name, "pts_count");
	return obj;
}

tlo_t * tl_updateReadChannelInbox(int arg_folder_id, long arg_channel_id, int arg_max_id, int arg_still_unread_count, int arg_pts)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateReadChannelInbox");
	int i;
	obj->id = 0x922e6e10;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_folder_id);
	strcpy(obj->objs[1]->name, "folder_id");
	if (arg_folder_id)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_channel_id);
	strcpy(obj->objs[2]->name, "channel_id");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_max_id);
	strcpy(obj->objs[3]->name, "max_id");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_still_unread_count);
	strcpy(obj->objs[4]->name, "still_unread_count");

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_pts);
	strcpy(obj->objs[5]->name, "pts");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateDeleteChannelMessages(long arg_channel_id, int *arg_messages, int len_arg_messages, int arg_pts, int arg_pts_count)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateDeleteChannelMessages");
	int i;
	obj->id = 0xc32d5b12;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_channel_id);
	strcpy(obj->objs[0]->name, "channel_id");

	//parse argument Vector<int>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "messages");
	if (arg_messages){
		for(i=0; i<len_arg_messages; ++i){
			buf_t b = buf_add_ui32(arg_messages[i]);
			buf_cat(obj->objs[1]->value, b);
		}
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_pts);
	strcpy(obj->objs[2]->name, "pts");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_pts_count);
	strcpy(obj->objs[3]->name, "pts_count");
	return obj;
}

tlo_t * tl_updateChannelMessageViews(long arg_channel_id, int arg_id, int arg_views)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateChannelMessageViews");
	int i;
	obj->id = 0xf226ac08;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_channel_id);
	strcpy(obj->objs[0]->name, "channel_id");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[1]->name, "id");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_views);
	strcpy(obj->objs[2]->name, "views");
	return obj;
}

tlo_t * tl_updateChatParticipantAdmin(long arg_chat_id, long arg_user_id, Bool arg_is_admin, int arg_version)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateChatParticipantAdmin");
	int i;
	obj->id = 0xd7ca61a2;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_chat_id);
	strcpy(obj->objs[0]->name, "chat_id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[1]->name, "user_id");

	//parse argument Bool
	if (arg_is_admin){
		obj->objs[2] = arg_is_admin;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "is_admin");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_version);
	strcpy(obj->objs[3]->name, "version");
	return obj;
}

tlo_t * tl_updateNewStickerSet(messages_StickerSet arg_stickerset)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateNewStickerSet");
	int i;
	obj->id = 0x688a30aa;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument messages_StickerSet
	if (arg_stickerset){
		obj->objs[0] = arg_stickerset;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "stickerset");
	}

	return obj;
}

tlo_t * tl_updateStickerSetsOrder(bool arg_masks, bool arg_emojis, long *arg_order, int len_arg_order)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateStickerSetsOrder");
	int i;
	obj->id = 0x0bb2d201;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_masks);
	strcpy(obj->objs[1]->name, "masks");
	if (arg_masks)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_emojis);
	strcpy(obj->objs[2]->name, "emojis");
	if (arg_emojis)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument Vector<long>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "order");
	if (arg_order){
		for(i=0; i<len_arg_order; ++i){
			buf_t b = buf_add_ui64(arg_order[i]);
			buf_cat(obj->objs[3]->value, b);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateStickerSets(bool arg_masks, bool arg_emojis)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateStickerSets");
	int i;
	obj->id = 0x31c24808;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_masks);
	strcpy(obj->objs[1]->name, "masks");
	if (arg_masks)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_emojis);
	strcpy(obj->objs[2]->name, "emojis");
	if (arg_emojis)
		flagsv[nflags-1] |= (1 << 1);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateSavedGifs()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateSavedGifs");
	int i;
	obj->id = 0x9375341e;
	return obj;
}

tlo_t * tl_updateBotInlineQuery(long arg_query_id, long arg_user_id, const char * arg_query, GeoPoint arg_geo, InlineQueryPeerType arg_peer_type, const char * arg_offset)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateBotInlineQuery");
	int i;
	obj->id = 0x496f379c;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_query_id);
	strcpy(obj->objs[1]->name, "query_id");

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[2]->name, "user_id");

	//parse argument string
	if (arg_query){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_query, strlen(arg_query));
		strcpy(obj->objs[3]->name, "query");
	}


	//parse argument GeoPoint
	if (arg_geo){
		obj->objs[4] = arg_geo;
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "geo");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument InlineQueryPeerType
	if (arg_peer_type){
		obj->objs[5] = arg_peer_type;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 1;
	strcpy(obj->objs[5]->name, "peer_type");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument string
	if (arg_offset){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_offset, strlen(arg_offset));
		strcpy(obj->objs[6]->name, "offset");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateBotInlineSend(long arg_user_id, const char * arg_query, GeoPoint arg_geo, const char * arg_id, InputBotInlineMessageID arg_msg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateBotInlineSend");
	int i;
	obj->id = 0x12f12a07;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[1]->name, "user_id");

	//parse argument string
	if (arg_query){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_query, strlen(arg_query));
		strcpy(obj->objs[2]->name, "query");
	}


	//parse argument GeoPoint
	if (arg_geo){
		obj->objs[3] = arg_geo;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "geo");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_id){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_id, strlen(arg_id));
		strcpy(obj->objs[4]->name, "id");
	}


	//parse argument InputBotInlineMessageID
	if (arg_msg_id){
		obj->objs[5] = arg_msg_id;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 1;
	strcpy(obj->objs[5]->name, "msg_id");
		flagsv[nflags-1] |= (1 << 1);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateEditChannelMessage(Message arg_message, int arg_pts, int arg_pts_count)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateEditChannelMessage");
	int i;
	obj->id = 0x1b3f4df7;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument Message
	if (arg_message){
		obj->objs[0] = arg_message;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "message");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_pts);
	strcpy(obj->objs[1]->name, "pts");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_pts_count);
	strcpy(obj->objs[2]->name, "pts_count");
	return obj;
}

tlo_t * tl_updateBotCallbackQuery(long arg_query_id, long arg_user_id, Peer arg_peer, int arg_msg_id, long arg_chat_instance, unsigned char * arg_data, int len_arg_data, const char * arg_game_short_name)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateBotCallbackQuery");
	int i;
	obj->id = 0xb9cfc48d;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_query_id);
	strcpy(obj->objs[1]->name, "query_id");

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[2]->name, "user_id");

	//parse argument Peer
	if (arg_peer){
		obj->objs[3] = arg_peer;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "peer");
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[4]->name, "msg_id");

	//parse argument long
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_LONG;
	obj->objs[5]->value = 
		buf_add_ui64(arg_chat_instance);
	strcpy(obj->objs[5]->name, "chat_instance");

	//parse argument bytes
	if (arg_data){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 0;
		obj->objs[6]->type = TYPE_BYTES;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_data, len_arg_data);
		strcpy(obj->objs[6]->name, "data");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_game_short_name){
		obj->objs[7] = NEW(tlo_t, return NULL);
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 1;
		obj->objs[7]->type = TYPE_STRING;
		obj->objs[7]->value = 
			buf_add((ui8_t *)arg_game_short_name, strlen(arg_game_short_name));
		strcpy(obj->objs[7]->name, "game_short_name");
		flagsv[nflags-1] |= (1 << 1);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateEditMessage(Message arg_message, int arg_pts, int arg_pts_count)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateEditMessage");
	int i;
	obj->id = 0xe40370a3;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument Message
	if (arg_message){
		obj->objs[0] = arg_message;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "message");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_pts);
	strcpy(obj->objs[1]->name, "pts");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_pts_count);
	strcpy(obj->objs[2]->name, "pts_count");
	return obj;
}

tlo_t * tl_updateInlineBotCallbackQuery(long arg_query_id, long arg_user_id, InputBotInlineMessageID arg_msg_id, long arg_chat_instance, unsigned char * arg_data, int len_arg_data, const char * arg_game_short_name)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateInlineBotCallbackQuery");
	int i;
	obj->id = 0x691e9052;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_query_id);
	strcpy(obj->objs[1]->name, "query_id");

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[2]->name, "user_id");

	//parse argument InputBotInlineMessageID
	if (arg_msg_id){
		obj->objs[3] = arg_msg_id;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "msg_id");
	}


	//parse argument long
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_chat_instance);
	strcpy(obj->objs[4]->name, "chat_instance");

	//parse argument bytes
	if (arg_data){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_BYTES;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_data, len_arg_data);
		strcpy(obj->objs[5]->name, "data");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_game_short_name){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 1;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_game_short_name, strlen(arg_game_short_name));
		strcpy(obj->objs[6]->name, "game_short_name");
		flagsv[nflags-1] |= (1 << 1);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateReadChannelOutbox(long arg_channel_id, int arg_max_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateReadChannelOutbox");
	int i;
	obj->id = 0xb75f99a9;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_channel_id);
	strcpy(obj->objs[0]->name, "channel_id");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_max_id);
	strcpy(obj->objs[1]->name, "max_id");
	return obj;
}

tlo_t * tl_updateDraftMessage(Peer arg_peer, int arg_top_msg_id, DraftMessage arg_draft)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateDraftMessage");
	int i;
	obj->id = 0x1b49ec6d;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument Peer
	if (arg_peer){
		obj->objs[1] = arg_peer;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "peer");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_top_msg_id);
	strcpy(obj->objs[2]->name, "top_msg_id");
	if (arg_top_msg_id)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument DraftMessage
	if (arg_draft){
		obj->objs[3] = arg_draft;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "draft");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateReadFeaturedStickers()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateReadFeaturedStickers");
	int i;
	obj->id = 0x571d2742;
	return obj;
}

tlo_t * tl_updateRecentStickers()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateRecentStickers");
	int i;
	obj->id = 0x9a422c20;
	return obj;
}

tlo_t * tl_updateConfig()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateConfig");
	int i;
	obj->id = 0xa229dd06;
	return obj;
}

tlo_t * tl_updatePtsChanged()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updatePtsChanged");
	int i;
	obj->id = 0x3354678f;
	return obj;
}

tlo_t * tl_updateChannelWebPage(long arg_channel_id, WebPage arg_webpage, int arg_pts, int arg_pts_count)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateChannelWebPage");
	int i;
	obj->id = 0x2f2ba99f;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_channel_id);
	strcpy(obj->objs[0]->name, "channel_id");

	//parse argument WebPage
	if (arg_webpage){
		obj->objs[1] = arg_webpage;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "webpage");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_pts);
	strcpy(obj->objs[2]->name, "pts");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_pts_count);
	strcpy(obj->objs[3]->name, "pts_count");
	return obj;
}

tlo_t * tl_updateDialogPinned(bool arg_pinned, int arg_folder_id, DialogPeer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateDialogPinned");
	int i;
	obj->id = 0x6e6fe51c;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_pinned);
	strcpy(obj->objs[1]->name, "pinned");
	if (arg_pinned)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_folder_id);
	strcpy(obj->objs[2]->name, "folder_id");
	if (arg_folder_id)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument DialogPeer
	if (arg_peer){
		obj->objs[3] = arg_peer;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "peer");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updatePinnedDialogs(int arg_folder_id, DialogPeer *arg_order, int len_arg_order)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updatePinnedDialogs");
	int i;
	obj->id = 0xfa0f3ca2;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_folder_id);
	strcpy(obj->objs[1]->name, "folder_id");
	if (arg_folder_id)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument Vector<DialogPeer>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "order");
	if (arg_order){
		for(i=0; i<len_arg_order; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_order[i]->id);
			buf_cat(obj->objs[2]->value, arg_order[i]->value);
		}
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateBotWebhookJSON(DataJSON arg_data)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateBotWebhookJSON");
	int i;
	obj->id = 0x8317c0c3;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument DataJSON
	if (arg_data){
		obj->objs[0] = arg_data;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "data");
	}

	return obj;
}

tlo_t * tl_updateBotWebhookJSONQuery(long arg_query_id, DataJSON arg_data, int arg_timeout)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateBotWebhookJSONQuery");
	int i;
	obj->id = 0x9b9240a6;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_query_id);
	strcpy(obj->objs[0]->name, "query_id");

	//parse argument DataJSON
	if (arg_data){
		obj->objs[1] = arg_data;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "data");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_timeout);
	strcpy(obj->objs[2]->name, "timeout");
	return obj;
}

tlo_t * tl_updateBotShippingQuery(long arg_query_id, long arg_user_id, unsigned char * arg_payload, int len_arg_payload, PostAddress arg_shipping_address)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateBotShippingQuery");
	int i;
	obj->id = 0xb5aefd7d;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_query_id);
	strcpy(obj->objs[0]->name, "query_id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[1]->name, "user_id");

	//parse argument bytes
	if (arg_payload){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_BYTES;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_payload, len_arg_payload);
		strcpy(obj->objs[2]->name, "payload");
	}


	//parse argument PostAddress
	if (arg_shipping_address){
		obj->objs[3] = arg_shipping_address;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "shipping_address");
	}

	return obj;
}

tlo_t * tl_updateBotPrecheckoutQuery(long arg_query_id, long arg_user_id, unsigned char * arg_payload, int len_arg_payload, PaymentRequestedInfo arg_info, const char * arg_shipping_option_id, const char * arg_currency, long arg_total_amount)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateBotPrecheckoutQuery");
	int i;
	obj->id = 0x8caa9a96;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_query_id);
	strcpy(obj->objs[1]->name, "query_id");

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[2]->name, "user_id");

	//parse argument bytes
	if (arg_payload){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_BYTES;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_payload, len_arg_payload);
		strcpy(obj->objs[3]->name, "payload");
	}


	//parse argument PaymentRequestedInfo
	if (arg_info){
		obj->objs[4] = arg_info;
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "info");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_shipping_option_id){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 1;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_shipping_option_id, strlen(arg_shipping_option_id));
		strcpy(obj->objs[5]->name, "shipping_option_id");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument string
	if (arg_currency){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_currency, strlen(arg_currency));
		strcpy(obj->objs[6]->name, "currency");
	}


	//parse argument long
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_LONG;
	obj->objs[7]->value = 
		buf_add_ui64(arg_total_amount);
	strcpy(obj->objs[7]->name, "total_amount");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updatePhoneCall(PhoneCall arg_phone_call)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updatePhoneCall");
	int i;
	obj->id = 0xab0f6b1e;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument PhoneCall
	if (arg_phone_call){
		obj->objs[0] = arg_phone_call;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "phone_call");
	}

	return obj;
}

tlo_t * tl_updateLangPackTooLong(const char * arg_lang_code)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateLangPackTooLong");
	int i;
	obj->id = 0x46560264;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_lang_code){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_lang_code, strlen(arg_lang_code));
		strcpy(obj->objs[0]->name, "lang_code");
	}

	return obj;
}

tlo_t * tl_updateLangPack(LangPackDifference arg_difference)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateLangPack");
	int i;
	obj->id = 0x56022f4d;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument LangPackDifference
	if (arg_difference){
		obj->objs[0] = arg_difference;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "difference");
	}

	return obj;
}

tlo_t * tl_updateFavedStickers()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateFavedStickers");
	int i;
	obj->id = 0xe511996d;
	return obj;
}

tlo_t * tl_updateChannelReadMessagesContents(long arg_channel_id, int arg_top_msg_id, int *arg_messages, int len_arg_messages)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateChannelReadMessagesContents");
	int i;
	obj->id = 0xea29055d;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_channel_id);
	strcpy(obj->objs[1]->name, "channel_id");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_top_msg_id);
	strcpy(obj->objs[2]->name, "top_msg_id");
	if (arg_top_msg_id)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument Vector<int>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "messages");
	if (arg_messages){
		for(i=0; i<len_arg_messages; ++i){
			buf_t b = buf_add_ui32(arg_messages[i]);
			buf_cat(obj->objs[3]->value, b);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateContactsReset()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateContactsReset");
	int i;
	obj->id = 0x7084a7be;
	return obj;
}

tlo_t * tl_updateChannelAvailableMessages(long arg_channel_id, int arg_available_min_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateChannelAvailableMessages");
	int i;
	obj->id = 0xb23fc698;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_channel_id);
	strcpy(obj->objs[0]->name, "channel_id");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_available_min_id);
	strcpy(obj->objs[1]->name, "available_min_id");
	return obj;
}

tlo_t * tl_updateDialogUnreadMark(bool arg_unread, DialogPeer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateDialogUnreadMark");
	int i;
	obj->id = 0xe16459c3;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_unread);
	strcpy(obj->objs[1]->name, "unread");
	if (arg_unread)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument DialogPeer
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateMessagePoll(long arg_poll_id, Poll arg_poll, PollResults arg_results)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateMessagePoll");
	int i;
	obj->id = 0xaca1657b;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_poll_id);
	strcpy(obj->objs[1]->name, "poll_id");

	//parse argument Poll
	if (arg_poll){
		obj->objs[2] = arg_poll;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "poll");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument PollResults
	if (arg_results){
		obj->objs[3] = arg_results;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "results");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateChatDefaultBannedRights(Peer arg_peer, ChatBannedRights arg_default_banned_rights, int arg_version)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateChatDefaultBannedRights");
	int i;
	obj->id = 0x54c01850;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument ChatBannedRights
	if (arg_default_banned_rights){
		obj->objs[1] = arg_default_banned_rights;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "default_banned_rights");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_version);
	strcpy(obj->objs[2]->name, "version");
	return obj;
}

tlo_t * tl_updateFolderPeers(FolderPeer *arg_folder_peers, int len_arg_folder_peers, int arg_pts, int arg_pts_count)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateFolderPeers");
	int i;
	obj->id = 0x19360dc0;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<FolderPeer>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "folder_peers");
	if (arg_folder_peers){
		for(i=0; i<len_arg_folder_peers; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_folder_peers[i]->id);
			buf_cat(obj->objs[0]->value, arg_folder_peers[i]->value);
		}
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_pts);
	strcpy(obj->objs[1]->name, "pts");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_pts_count);
	strcpy(obj->objs[2]->name, "pts_count");
	return obj;
}

tlo_t * tl_updatePeerSettings(Peer arg_peer, PeerSettings arg_settings)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updatePeerSettings");
	int i;
	obj->id = 0x6a7e7366;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument PeerSettings
	if (arg_settings){
		obj->objs[1] = arg_settings;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "settings");
	}

	return obj;
}

tlo_t * tl_updatePeerLocated(PeerLocated *arg_peers, int len_arg_peers)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updatePeerLocated");
	int i;
	obj->id = 0xb4afcfb0;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<PeerLocated>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "peers");
	if (arg_peers){
		for(i=0; i<len_arg_peers; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_peers[i]->id);
			buf_cat(obj->objs[0]->value, arg_peers[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_updateNewScheduledMessage(Message arg_message)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateNewScheduledMessage");
	int i;
	obj->id = 0x39a51dfb;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Message
	if (arg_message){
		obj->objs[0] = arg_message;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "message");
	}

	return obj;
}

tlo_t * tl_updateDeleteScheduledMessages(Peer arg_peer, int *arg_messages, int len_arg_messages)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateDeleteScheduledMessages");
	int i;
	obj->id = 0x90866cee;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument Vector<int>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "messages");
	if (arg_messages){
		for(i=0; i<len_arg_messages; ++i){
			buf_t b = buf_add_ui32(arg_messages[i]);
			buf_cat(obj->objs[1]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_updateTheme(Theme arg_theme)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateTheme");
	int i;
	obj->id = 0x8216fba3;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Theme
	if (arg_theme){
		obj->objs[0] = arg_theme;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "theme");
	}

	return obj;
}

tlo_t * tl_updateGeoLiveViewed(Peer arg_peer, int arg_msg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateGeoLiveViewed");
	int i;
	obj->id = 0x871fb939;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[1]->name, "msg_id");
	return obj;
}

tlo_t * tl_updateLoginToken()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateLoginToken");
	int i;
	obj->id = 0x564fe691;
	return obj;
}

tlo_t * tl_updateMessagePollVote(long arg_poll_id, Peer arg_peer, unsigned char * *arg_options, int len_arg_options, int arg_qts)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateMessagePollVote");
	int i;
	obj->id = 0x24f40e77;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_poll_id);
	strcpy(obj->objs[0]->name, "poll_id");

	//parse argument Peer
	if (arg_peer){
		obj->objs[1] = arg_peer;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "peer");
	}


	//parse argument Vector<bytes>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "options");
	if (arg_options){
		for(i=0; i<len_arg_options; ++i){
			int len = *(int *)(arg_options[i]);
			ui8_t *p = &(arg_options[i][4]);
			buf_t b = buf_add(p, len);
			buf_cat(obj->objs[2]->value, b);
		}
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_qts);
	strcpy(obj->objs[3]->name, "qts");
	return obj;
}

tlo_t * tl_updateDialogFilter(int arg_id, DialogFilter arg_filter)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateDialogFilter");
	int i;
	obj->id = 0x26ffde7d;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[1]->name, "id");

	//parse argument DialogFilter
	if (arg_filter){
		obj->objs[2] = arg_filter;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "filter");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateDialogFilterOrder(int *arg_order, int len_arg_order)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateDialogFilterOrder");
	int i;
	obj->id = 0xa5d72105;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<int>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "order");
	if (arg_order){
		for(i=0; i<len_arg_order; ++i){
			buf_t b = buf_add_ui32(arg_order[i]);
			buf_cat(obj->objs[0]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_updateDialogFilters()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateDialogFilters");
	int i;
	obj->id = 0x3504914f;
	return obj;
}

tlo_t * tl_updatePhoneCallSignalingData(long arg_phone_call_id, unsigned char * arg_data, int len_arg_data)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updatePhoneCallSignalingData");
	int i;
	obj->id = 0x2661bf09;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_phone_call_id);
	strcpy(obj->objs[0]->name, "phone_call_id");

	//parse argument bytes
	if (arg_data){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_data, len_arg_data);
		strcpy(obj->objs[1]->name, "data");
	}

	return obj;
}

tlo_t * tl_updateChannelMessageForwards(long arg_channel_id, int arg_id, int arg_forwards)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateChannelMessageForwards");
	int i;
	obj->id = 0xd29a27f4;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_channel_id);
	strcpy(obj->objs[0]->name, "channel_id");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[1]->name, "id");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_forwards);
	strcpy(obj->objs[2]->name, "forwards");
	return obj;
}

tlo_t * tl_updateReadChannelDiscussionInbox(long arg_channel_id, int arg_top_msg_id, int arg_read_max_id, long arg_broadcast_id, int arg_broadcast_post)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateReadChannelDiscussionInbox");
	int i;
	obj->id = 0xd6b19546;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_channel_id);
	strcpy(obj->objs[1]->name, "channel_id");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_top_msg_id);
	strcpy(obj->objs[2]->name, "top_msg_id");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_read_max_id);
	strcpy(obj->objs[3]->name, "read_max_id");

	//parse argument long
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_broadcast_id);
	strcpy(obj->objs[4]->name, "broadcast_id");
	if (arg_broadcast_id)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_broadcast_post);
	strcpy(obj->objs[5]->name, "broadcast_post");
	if (arg_broadcast_post)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateReadChannelDiscussionOutbox(long arg_channel_id, int arg_top_msg_id, int arg_read_max_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateReadChannelDiscussionOutbox");
	int i;
	obj->id = 0x695c9e7c;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_channel_id);
	strcpy(obj->objs[0]->name, "channel_id");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_top_msg_id);
	strcpy(obj->objs[1]->name, "top_msg_id");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_read_max_id);
	strcpy(obj->objs[2]->name, "read_max_id");
	return obj;
}

tlo_t * tl_updatePeerBlocked(bool arg_blocked, bool arg_blocked_my_stories_from, Peer arg_peer_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updatePeerBlocked");
	int i;
	obj->id = 0xebe07752;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_blocked);
	strcpy(obj->objs[1]->name, "blocked");
	if (arg_blocked)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_blocked_my_stories_from);
	strcpy(obj->objs[2]->name, "blocked_my_stories_from");
	if (arg_blocked_my_stories_from)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument Peer
	if (arg_peer_id){
		obj->objs[3] = arg_peer_id;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "peer_id");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateChannelUserTyping(long arg_channel_id, int arg_top_msg_id, Peer arg_from_id, SendMessageAction arg_action)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateChannelUserTyping");
	int i;
	obj->id = 0x8c88c923;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_channel_id);
	strcpy(obj->objs[1]->name, "channel_id");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_top_msg_id);
	strcpy(obj->objs[2]->name, "top_msg_id");
	if (arg_top_msg_id)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument Peer
	if (arg_from_id){
		obj->objs[3] = arg_from_id;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "from_id");
	}


	//parse argument SendMessageAction
	if (arg_action){
		obj->objs[4] = arg_action;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "action");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updatePinnedMessages(bool arg_pinned, Peer arg_peer, int *arg_messages, int len_arg_messages, int arg_pts, int arg_pts_count)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updatePinnedMessages");
	int i;
	obj->id = 0xed85eab5;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_pinned);
	strcpy(obj->objs[1]->name, "pinned");
	if (arg_pinned)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument Peer
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//parse argument Vector<int>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "messages");
	if (arg_messages){
		for(i=0; i<len_arg_messages; ++i){
			buf_t b = buf_add_ui32(arg_messages[i]);
			buf_cat(obj->objs[3]->value, b);
		}
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_pts);
	strcpy(obj->objs[4]->name, "pts");

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_pts_count);
	strcpy(obj->objs[5]->name, "pts_count");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updatePinnedChannelMessages(bool arg_pinned, long arg_channel_id, int *arg_messages, int len_arg_messages, int arg_pts, int arg_pts_count)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updatePinnedChannelMessages");
	int i;
	obj->id = 0x5bb98608;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_pinned);
	strcpy(obj->objs[1]->name, "pinned");
	if (arg_pinned)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_channel_id);
	strcpy(obj->objs[2]->name, "channel_id");

	//parse argument Vector<int>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "messages");
	if (arg_messages){
		for(i=0; i<len_arg_messages; ++i){
			buf_t b = buf_add_ui32(arg_messages[i]);
			buf_cat(obj->objs[3]->value, b);
		}
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_pts);
	strcpy(obj->objs[4]->name, "pts");

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_pts_count);
	strcpy(obj->objs[5]->name, "pts_count");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateChat(long arg_chat_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateChat");
	int i;
	obj->id = 0xf89a6a4e;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_chat_id);
	strcpy(obj->objs[0]->name, "chat_id");
	return obj;
}

tlo_t * tl_updateGroupCallParticipants(InputGroupCall arg_call, GroupCallParticipant *arg_participants, int len_arg_participants, int arg_version)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateGroupCallParticipants");
	int i;
	obj->id = 0xf2ebdb4e;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputGroupCall
	if (arg_call){
		obj->objs[0] = arg_call;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "call");
	}


	//parse argument Vector<GroupCallParticipant>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "participants");
	if (arg_participants){
		for(i=0; i<len_arg_participants; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_participants[i]->id);
			buf_cat(obj->objs[1]->value, arg_participants[i]->value);
		}
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_version);
	strcpy(obj->objs[2]->name, "version");
	return obj;
}

tlo_t * tl_updateGroupCall(long arg_chat_id, GroupCall arg_call)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateGroupCall");
	int i;
	obj->id = 0x14b24500;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_chat_id);
	strcpy(obj->objs[0]->name, "chat_id");

	//parse argument GroupCall
	if (arg_call){
		obj->objs[1] = arg_call;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "call");
	}

	return obj;
}

tlo_t * tl_updatePeerHistoryTTL(Peer arg_peer, int arg_ttl_period)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updatePeerHistoryTTL");
	int i;
	obj->id = 0xbb9bb9a5;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument Peer
	if (arg_peer){
		obj->objs[1] = arg_peer;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "peer");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_ttl_period);
	strcpy(obj->objs[2]->name, "ttl_period");
	if (arg_ttl_period)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateChatParticipant(long arg_chat_id, int arg_date, long arg_actor_id, long arg_user_id, ChatParticipant arg_prev_participant, ChatParticipant arg_new_participant, ExportedChatInvite arg_invite, int arg_qts)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateChatParticipant");
	int i;
	obj->id = 0xd087663a;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_chat_id);
	strcpy(obj->objs[1]->name, "chat_id");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[2]->name, "date");

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_actor_id);
	strcpy(obj->objs[3]->name, "actor_id");

	//parse argument long
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[4]->name, "user_id");

	//parse argument ChatParticipant
	if (arg_prev_participant){
		obj->objs[5] = arg_prev_participant;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 0;
	strcpy(obj->objs[5]->name, "prev_participant");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument ChatParticipant
	if (arg_new_participant){
		obj->objs[6] = arg_new_participant;
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 1;
	strcpy(obj->objs[6]->name, "new_participant");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument ExportedChatInvite
	if (arg_invite){
		obj->objs[7] = arg_invite;
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 2;
	strcpy(obj->objs[7]->name, "invite");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument int
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 0;
	obj->objs[8]->flag_bit = 0;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_qts);
	strcpy(obj->objs[8]->name, "qts");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateChannelParticipant(bool arg_via_chatlist, long arg_channel_id, int arg_date, long arg_actor_id, long arg_user_id, ChannelParticipant arg_prev_participant, ChannelParticipant arg_new_participant, ExportedChatInvite arg_invite, int arg_qts)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateChannelParticipant");
	int i;
	obj->id = 0x985d3abb;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 10;
	obj->objs = 
		(tlo_t **)MALLOC(10 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 3;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_via_chatlist);
	strcpy(obj->objs[1]->name, "via_chatlist");
	if (arg_via_chatlist)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_channel_id);
	strcpy(obj->objs[2]->name, "channel_id");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[3]->name, "date");

	//parse argument long
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_actor_id);
	strcpy(obj->objs[4]->name, "actor_id");

	//parse argument long
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_LONG;
	obj->objs[5]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[5]->name, "user_id");

	//parse argument ChannelParticipant
	if (arg_prev_participant){
		obj->objs[6] = arg_prev_participant;
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 0;
	strcpy(obj->objs[6]->name, "prev_participant");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument ChannelParticipant
	if (arg_new_participant){
		obj->objs[7] = arg_new_participant;
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 1;
	strcpy(obj->objs[7]->name, "new_participant");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument ExportedChatInvite
	if (arg_invite){
		obj->objs[8] = arg_invite;
		obj->objs[8]->flag_num = 1;
		obj->objs[8]->flag_bit = 2;
	strcpy(obj->objs[8]->name, "invite");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument int
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 0;
	obj->objs[9]->flag_bit = 0;
	obj->objs[9]->type = TYPE_INT;
	obj->objs[9]->value = 
		buf_add_ui32(arg_qts);
	strcpy(obj->objs[9]->name, "qts");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateBotStopped(long arg_user_id, int arg_date, Bool arg_stopped, int arg_qts)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateBotStopped");
	int i;
	obj->id = 0xc4870a49;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[0]->name, "user_id");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[1]->name, "date");

	//parse argument Bool
	if (arg_stopped){
		obj->objs[2] = arg_stopped;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "stopped");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_qts);
	strcpy(obj->objs[3]->name, "qts");
	return obj;
}

tlo_t * tl_updateGroupCallConnection(bool arg_presentation, DataJSON arg_params)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateGroupCallConnection");
	int i;
	obj->id = 0x0b783982;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_presentation);
	strcpy(obj->objs[1]->name, "presentation");
	if (arg_presentation)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument DataJSON
	if (arg_params){
		obj->objs[2] = arg_params;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "params");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateBotCommands(Peer arg_peer, long arg_bot_id, BotCommand *arg_commands, int len_arg_commands)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateBotCommands");
	int i;
	obj->id = 0x4d712f2e;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_bot_id);
	strcpy(obj->objs[1]->name, "bot_id");

	//parse argument Vector<BotCommand>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "commands");
	if (arg_commands){
		for(i=0; i<len_arg_commands; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_commands[i]->id);
			buf_cat(obj->objs[2]->value, arg_commands[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_updatePendingJoinRequests(Peer arg_peer, int arg_requests_pending, long *arg_recent_requesters, int len_arg_recent_requesters)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updatePendingJoinRequests");
	int i;
	obj->id = 0x7063c3db;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_requests_pending);
	strcpy(obj->objs[1]->name, "requests_pending");

	//parse argument Vector<long>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "recent_requesters");
	if (arg_recent_requesters){
		for(i=0; i<len_arg_recent_requesters; ++i){
			buf_t b = buf_add_ui64(arg_recent_requesters[i]);
			buf_cat(obj->objs[2]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_updateBotChatInviteRequester(Peer arg_peer, int arg_date, long arg_user_id, const char * arg_about, ExportedChatInvite arg_invite, int arg_qts)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateBotChatInviteRequester");
	int i;
	obj->id = 0x11dfa986;
	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[1]->name, "date");

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[2]->name, "user_id");

	//parse argument string
	if (arg_about){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_about, strlen(arg_about));
		strcpy(obj->objs[3]->name, "about");
	}


	//parse argument ExportedChatInvite
	if (arg_invite){
		obj->objs[4] = arg_invite;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "invite");
	}


	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_qts);
	strcpy(obj->objs[5]->name, "qts");
	return obj;
}

tlo_t * tl_updateMessageReactions(Peer arg_peer, int arg_msg_id, int arg_top_msg_id, MessageReactions arg_reactions)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateMessageReactions");
	int i;
	obj->id = 0x5e1b3cb8;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument Peer
	if (arg_peer){
		obj->objs[1] = arg_peer;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "peer");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[2]->name, "msg_id");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_top_msg_id);
	strcpy(obj->objs[3]->name, "top_msg_id");
	if (arg_top_msg_id)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument MessageReactions
	if (arg_reactions){
		obj->objs[4] = arg_reactions;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "reactions");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateAttachMenuBots()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateAttachMenuBots");
	int i;
	obj->id = 0x17b7a20b;
	return obj;
}

tlo_t * tl_updateWebViewResultSent(long arg_query_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateWebViewResultSent");
	int i;
	obj->id = 0x1592b79d;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_query_id);
	strcpy(obj->objs[0]->name, "query_id");
	return obj;
}

tlo_t * tl_updateBotMenuButton(long arg_bot_id, BotMenuButton arg_button)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateBotMenuButton");
	int i;
	obj->id = 0x14b85813;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_bot_id);
	strcpy(obj->objs[0]->name, "bot_id");

	//parse argument BotMenuButton
	if (arg_button){
		obj->objs[1] = arg_button;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "button");
	}

	return obj;
}

tlo_t * tl_updateSavedRingtones()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateSavedRingtones");
	int i;
	obj->id = 0x74d8be99;
	return obj;
}

tlo_t * tl_updateTranscribedAudio(bool arg_pending, Peer arg_peer, int arg_msg_id, long arg_transcription_id, const char * arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateTranscribedAudio");
	int i;
	obj->id = 0x0084cd5a;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_pending);
	strcpy(obj->objs[1]->name, "pending");
	if (arg_pending)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument Peer
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[3]->name, "msg_id");

	//parse argument long
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_transcription_id);
	strcpy(obj->objs[4]->name, "transcription_id");

	//parse argument string
	if (arg_text){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[5]->name, "text");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateReadFeaturedEmojiStickers()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateReadFeaturedEmojiStickers");
	int i;
	obj->id = 0xfb4c496c;
	return obj;
}

tlo_t * tl_updateUserEmojiStatus(long arg_user_id, EmojiStatus arg_emoji_status)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateUserEmojiStatus");
	int i;
	obj->id = 0x28373599;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[0]->name, "user_id");

	//parse argument EmojiStatus
	if (arg_emoji_status){
		obj->objs[1] = arg_emoji_status;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "emoji_status");
	}

	return obj;
}

tlo_t * tl_updateRecentEmojiStatuses()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateRecentEmojiStatuses");
	int i;
	obj->id = 0x30f443db;
	return obj;
}

tlo_t * tl_updateRecentReactions()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateRecentReactions");
	int i;
	obj->id = 0x6f7863f4;
	return obj;
}

tlo_t * tl_updateMoveStickerSetToTop(bool arg_masks, bool arg_emojis, long arg_stickerset)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateMoveStickerSetToTop");
	int i;
	obj->id = 0x86fccf85;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_masks);
	strcpy(obj->objs[1]->name, "masks");
	if (arg_masks)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_emojis);
	strcpy(obj->objs[2]->name, "emojis");
	if (arg_emojis)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_stickerset);
	strcpy(obj->objs[3]->name, "stickerset");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateMessageExtendedMedia(Peer arg_peer, int arg_msg_id, MessageExtendedMedia *arg_extended_media, int len_arg_extended_media)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateMessageExtendedMedia");
	int i;
	obj->id = 0xd5a41724;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[1]->name, "msg_id");

	//parse argument Vector<MessageExtendedMedia>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "extended_media");
	if (arg_extended_media){
		for(i=0; i<len_arg_extended_media; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_extended_media[i]->id);
			buf_cat(obj->objs[2]->value, arg_extended_media[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_updateChannelPinnedTopic(bool arg_pinned, long arg_channel_id, int arg_topic_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateChannelPinnedTopic");
	int i;
	obj->id = 0x192efbe3;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_pinned);
	strcpy(obj->objs[1]->name, "pinned");
	if (arg_pinned)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_channel_id);
	strcpy(obj->objs[2]->name, "channel_id");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_topic_id);
	strcpy(obj->objs[3]->name, "topic_id");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateChannelPinnedTopics(long arg_channel_id, int *arg_order, int len_arg_order)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateChannelPinnedTopics");
	int i;
	obj->id = 0xfe198602;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_channel_id);
	strcpy(obj->objs[1]->name, "channel_id");

	//parse argument Vector<int>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "order");
	if (arg_order){
		for(i=0; i<len_arg_order; ++i){
			buf_t b = buf_add_ui32(arg_order[i]);
			buf_cat(obj->objs[2]->value, b);
		}
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateUser(long arg_user_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateUser");
	int i;
	obj->id = 0x20529438;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[0]->name, "user_id");
	return obj;
}

tlo_t * tl_updateAutoSaveSettings()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateAutoSaveSettings");
	int i;
	obj->id = 0xec05b097;
	return obj;
}

tlo_t * tl_updateStory(Peer arg_peer, StoryItem arg_story)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateStory");
	int i;
	obj->id = 0x75b3b798;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument StoryItem
	if (arg_story){
		obj->objs[1] = arg_story;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "story");
	}

	return obj;
}

tlo_t * tl_updateReadStories(Peer arg_peer, int arg_max_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateReadStories");
	int i;
	obj->id = 0xf74e932b;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_max_id);
	strcpy(obj->objs[1]->name, "max_id");
	return obj;
}

tlo_t * tl_updateStoryID(int arg_id, long arg_random_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateStoryID");
	int i;
	obj->id = 0x1bf335b9;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_random_id);
	strcpy(obj->objs[1]->name, "random_id");
	return obj;
}

tlo_t * tl_updateStoriesStealthMode(StoriesStealthMode arg_stealth_mode)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateStoriesStealthMode");
	int i;
	obj->id = 0x2c084dc1;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument StoriesStealthMode
	if (arg_stealth_mode){
		obj->objs[0] = arg_stealth_mode;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "stealth_mode");
	}

	return obj;
}

tlo_t * tl_updateSentStoryReaction(Peer arg_peer, int arg_story_id, Reaction arg_reaction)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateSentStoryReaction");
	int i;
	obj->id = 0x7d627683;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_story_id);
	strcpy(obj->objs[1]->name, "story_id");

	//parse argument Reaction
	if (arg_reaction){
		obj->objs[2] = arg_reaction;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "reaction");
	}

	return obj;
}

tlo_t * tl_updateBotChatBoost(Peer arg_peer, Boost arg_boost, int arg_qts)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateBotChatBoost");
	int i;
	obj->id = 0x904dd49c;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument Boost
	if (arg_boost){
		obj->objs[1] = arg_boost;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "boost");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_qts);
	strcpy(obj->objs[2]->name, "qts");
	return obj;
}

tlo_t * tl_updateChannelViewForumAsMessages(long arg_channel_id, Bool arg_enabled)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateChannelViewForumAsMessages");
	int i;
	obj->id = 0x07b68920;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_channel_id);
	strcpy(obj->objs[0]->name, "channel_id");

	//parse argument Bool
	if (arg_enabled){
		obj->objs[1] = arg_enabled;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "enabled");
	}

	return obj;
}

tlo_t * tl_updatePeerWallpaper(bool arg_wallpaper_overridden, Peer arg_peer, WallPaper arg_wallpaper)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updatePeerWallpaper");
	int i;
	obj->id = 0xae3f101d;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_wallpaper_overridden);
	strcpy(obj->objs[1]->name, "wallpaper_overridden");
	if (arg_wallpaper_overridden)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument Peer
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//parse argument WallPaper
	if (arg_wallpaper){
		obj->objs[3] = arg_wallpaper;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "wallpaper");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateBotMessageReaction(Peer arg_peer, int arg_msg_id, int arg_date, Peer arg_actor, Reaction *arg_old_reactions, int len_arg_old_reactions, Reaction *arg_new_reactions, int len_arg_new_reactions, int arg_qts)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateBotMessageReaction");
	int i;
	obj->id = 0xac21d3ce;
	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[1]->name, "msg_id");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[2]->name, "date");

	//parse argument Peer
	if (arg_actor){
		obj->objs[3] = arg_actor;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "actor");
	}


	//parse argument Vector<Reaction>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "old_reactions");
	if (arg_old_reactions){
		for(i=0; i<len_arg_old_reactions; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_old_reactions[i]->id);
			buf_cat(obj->objs[4]->value, arg_old_reactions[i]->value);
		}
	}


	//parse argument Vector<Reaction>
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_VECTOR;
	strcpy(obj->objs[5]->name, "new_reactions");
	if (arg_new_reactions){
		for(i=0; i<len_arg_new_reactions; ++i){
			obj->objs[5]->value = buf_add_ui32(arg_new_reactions[i]->id);
			buf_cat(obj->objs[5]->value, arg_new_reactions[i]->value);
		}
	}


	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_qts);
	strcpy(obj->objs[6]->name, "qts");
	return obj;
}

tlo_t * tl_updateBotMessageReactions(Peer arg_peer, int arg_msg_id, int arg_date, ReactionCount *arg_reactions, int len_arg_reactions, int arg_qts)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateBotMessageReactions");
	int i;
	obj->id = 0x09cb7759;
	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[1]->name, "msg_id");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[2]->name, "date");

	//parse argument Vector<ReactionCount>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "reactions");
	if (arg_reactions){
		for(i=0; i<len_arg_reactions; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_reactions[i]->id);
			buf_cat(obj->objs[3]->value, arg_reactions[i]->value);
		}
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_qts);
	strcpy(obj->objs[4]->name, "qts");
	return obj;
}

tlo_t * tl_updateSavedDialogPinned(bool arg_pinned, DialogPeer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateSavedDialogPinned");
	int i;
	obj->id = 0xaeaf9e74;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_pinned);
	strcpy(obj->objs[1]->name, "pinned");
	if (arg_pinned)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument DialogPeer
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updatePinnedSavedDialogs(DialogPeer *arg_order, int len_arg_order)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updatePinnedSavedDialogs");
	int i;
	obj->id = 0x686c85a6;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument Vector<DialogPeer>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "order");
	if (arg_order){
		for(i=0; i<len_arg_order; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_order[i]->id);
			buf_cat(obj->objs[1]->value, arg_order[i]->value);
		}
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateSavedReactionTags()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateSavedReactionTags");
	int i;
	obj->id = 0x39c67432;
	return obj;
}

tlo_t * tl_updateSmsJob(const char * arg_job_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateSmsJob");
	int i;
	obj->id = 0xf16269d4;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_job_id){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_job_id, strlen(arg_job_id));
		strcpy(obj->objs[0]->name, "job_id");
	}

	return obj;
}

tlo_t * tl_updateQuickReplies(QuickReply *arg_quick_replies, int len_arg_quick_replies)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateQuickReplies");
	int i;
	obj->id = 0xf9470ab2;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<QuickReply>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "quick_replies");
	if (arg_quick_replies){
		for(i=0; i<len_arg_quick_replies; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_quick_replies[i]->id);
			buf_cat(obj->objs[0]->value, arg_quick_replies[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_updateNewQuickReply(QuickReply arg_quick_reply)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateNewQuickReply");
	int i;
	obj->id = 0xf53da717;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument QuickReply
	if (arg_quick_reply){
		obj->objs[0] = arg_quick_reply;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "quick_reply");
	}

	return obj;
}

tlo_t * tl_updateDeleteQuickReply(int arg_shortcut_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateDeleteQuickReply");
	int i;
	obj->id = 0x53e6f1ec;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_shortcut_id);
	strcpy(obj->objs[0]->name, "shortcut_id");
	return obj;
}

tlo_t * tl_updateQuickReplyMessage(Message arg_message)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateQuickReplyMessage");
	int i;
	obj->id = 0x3e050d0f;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Message
	if (arg_message){
		obj->objs[0] = arg_message;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "message");
	}

	return obj;
}

tlo_t * tl_updateDeleteQuickReplyMessages(int arg_shortcut_id, int *arg_messages, int len_arg_messages)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateDeleteQuickReplyMessages");
	int i;
	obj->id = 0x566fe7cd;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_shortcut_id);
	strcpy(obj->objs[0]->name, "shortcut_id");

	//parse argument Vector<int>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "messages");
	if (arg_messages){
		for(i=0; i<len_arg_messages; ++i){
			buf_t b = buf_add_ui32(arg_messages[i]);
			buf_cat(obj->objs[1]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_updateBotBusinessConnect(BotBusinessConnection arg_connection, int arg_qts)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateBotBusinessConnect");
	int i;
	obj->id = 0x8ae5c97a;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument BotBusinessConnection
	if (arg_connection){
		obj->objs[0] = arg_connection;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "connection");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_qts);
	strcpy(obj->objs[1]->name, "qts");
	return obj;
}

tlo_t * tl_updateBotNewBusinessMessage(const char * arg_connection_id, Message arg_message, Message arg_reply_to_message, int arg_qts)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateBotNewBusinessMessage");
	int i;
	obj->id = 0x9ddb347c;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_connection_id){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_connection_id, strlen(arg_connection_id));
		strcpy(obj->objs[1]->name, "connection_id");
	}


	//parse argument Message
	if (arg_message){
		obj->objs[2] = arg_message;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "message");
	}


	//parse argument Message
	if (arg_reply_to_message){
		obj->objs[3] = arg_reply_to_message;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "reply_to_message");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_qts);
	strcpy(obj->objs[4]->name, "qts");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateBotEditBusinessMessage(const char * arg_connection_id, Message arg_message, Message arg_reply_to_message, int arg_qts)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateBotEditBusinessMessage");
	int i;
	obj->id = 0x07df587c;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_connection_id){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_connection_id, strlen(arg_connection_id));
		strcpy(obj->objs[1]->name, "connection_id");
	}


	//parse argument Message
	if (arg_message){
		obj->objs[2] = arg_message;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "message");
	}


	//parse argument Message
	if (arg_reply_to_message){
		obj->objs[3] = arg_reply_to_message;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "reply_to_message");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_qts);
	strcpy(obj->objs[4]->name, "qts");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateBotDeleteBusinessMessage(const char * arg_connection_id, Peer arg_peer, int *arg_messages, int len_arg_messages, int arg_qts)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateBotDeleteBusinessMessage");
	int i;
	obj->id = 0xa02a982e;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_connection_id){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_connection_id, strlen(arg_connection_id));
		strcpy(obj->objs[0]->name, "connection_id");
	}


	//parse argument Peer
	if (arg_peer){
		obj->objs[1] = arg_peer;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "peer");
	}


	//parse argument Vector<int>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "messages");
	if (arg_messages){
		for(i=0; i<len_arg_messages; ++i){
			buf_t b = buf_add_ui32(arg_messages[i]);
			buf_cat(obj->objs[2]->value, b);
		}
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_qts);
	strcpy(obj->objs[3]->name, "qts");
	return obj;
}

tlo_t * tl_updateNewStoryReaction(int arg_story_id, Peer arg_peer, Reaction arg_reaction)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateNewStoryReaction");
	int i;
	obj->id = 0x1824e40b;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_story_id);
	strcpy(obj->objs[0]->name, "story_id");

	//parse argument Peer
	if (arg_peer){
		obj->objs[1] = arg_peer;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "peer");
	}


	//parse argument Reaction
	if (arg_reaction){
		obj->objs[2] = arg_reaction;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "reaction");
	}

	return obj;
}

tlo_t * tl_updateBroadcastRevenueTransactions(Peer arg_peer, BroadcastRevenueBalances arg_balances)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateBroadcastRevenueTransactions");
	int i;
	obj->id = 0xdfd961f5;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument BroadcastRevenueBalances
	if (arg_balances){
		obj->objs[1] = arg_balances;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "balances");
	}

	return obj;
}

tlo_t * tl_updateStarsBalance(long arg_balance)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateStarsBalance");
	int i;
	obj->id = 0x0fb85198;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_balance);
	strcpy(obj->objs[0]->name, "balance");
	return obj;
}

tlo_t * tl_updateBusinessBotCallbackQuery(long arg_query_id, long arg_user_id, const char * arg_connection_id, Message arg_message, Message arg_reply_to_message, long arg_chat_instance, unsigned char * arg_data, int len_arg_data)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateBusinessBotCallbackQuery");
	int i;
	obj->id = 0x1ea2fda7;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_query_id);
	strcpy(obj->objs[1]->name, "query_id");

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[2]->name, "user_id");

	//parse argument string
	if (arg_connection_id){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_connection_id, strlen(arg_connection_id));
		strcpy(obj->objs[3]->name, "connection_id");
	}


	//parse argument Message
	if (arg_message){
		obj->objs[4] = arg_message;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "message");
	}


	//parse argument Message
	if (arg_reply_to_message){
		obj->objs[5] = arg_reply_to_message;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 2;
	strcpy(obj->objs[5]->name, "reply_to_message");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument long
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_LONG;
	obj->objs[6]->value = 
		buf_add_ui64(arg_chat_instance);
	strcpy(obj->objs[6]->name, "chat_instance");

	//parse argument bytes
	if (arg_data){
		obj->objs[7] = NEW(tlo_t, return NULL);
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 0;
		obj->objs[7]->type = TYPE_BYTES;
		obj->objs[7]->value = 
			buf_add((ui8_t *)arg_data, len_arg_data);
		strcpy(obj->objs[7]->name, "data");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateStarsRevenueStatus(Peer arg_peer, StarsRevenueStatus arg_status)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateStarsRevenueStatus");
	int i;
	obj->id = 0xa584b019;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument StarsRevenueStatus
	if (arg_status){
		obj->objs[1] = arg_status;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "status");
	}

	return obj;
}

tlo_t * tl_updateBotPurchasedPaidMedia(long arg_user_id, const char * arg_payload, int arg_qts)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateBotPurchasedPaidMedia");
	int i;
	obj->id = 0x283bd312;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[0]->name, "user_id");

	//parse argument string
	if (arg_payload){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_payload, strlen(arg_payload));
		strcpy(obj->objs[1]->name, "payload");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_qts);
	strcpy(obj->objs[2]->name, "qts");
	return obj;
}

tlo_t * tl_updatePaidReactionPrivacy(Bool arg_private)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updatePaidReactionPrivacy");
	int i;
	obj->id = 0x51ca7aec;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Bool
	if (arg_private){
		obj->objs[0] = arg_private;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "private");
	}

	return obj;
}

tlo_t * tl_updates_state(int arg_pts, int arg_qts, int arg_date, int arg_seq, int arg_unread_count)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updates_state");
	int i;
	obj->id = 0xa56c2a3e;
	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_pts);
	strcpy(obj->objs[0]->name, "pts");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_qts);
	strcpy(obj->objs[1]->name, "qts");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[2]->name, "date");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_seq);
	strcpy(obj->objs[3]->name, "seq");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_unread_count);
	strcpy(obj->objs[4]->name, "unread_count");
	return obj;
}

tlo_t * tl_updates_differenceEmpty(int arg_date, int arg_seq)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updates_differenceEmpty");
	int i;
	obj->id = 0x5d75a138;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[0]->name, "date");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_seq);
	strcpy(obj->objs[1]->name, "seq");
	return obj;
}

tlo_t * tl_updates_difference(Message *arg_new_messages, int len_arg_new_messages, EncryptedMessage *arg_new_encrypted_messages, int len_arg_new_encrypted_messages, Update *arg_other_updates, int len_arg_other_updates, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users, updates_State arg_state)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updates_difference");
	int i;
	obj->id = 0x00f49ca0;
	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<Message>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "new_messages");
	if (arg_new_messages){
		for(i=0; i<len_arg_new_messages; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_new_messages[i]->id);
			buf_cat(obj->objs[0]->value, arg_new_messages[i]->value);
		}
	}


	//parse argument Vector<EncryptedMessage>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "new_encrypted_messages");
	if (arg_new_encrypted_messages){
		for(i=0; i<len_arg_new_encrypted_messages; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_new_encrypted_messages[i]->id);
			buf_cat(obj->objs[1]->value, arg_new_encrypted_messages[i]->value);
		}
	}


	//parse argument Vector<Update>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "other_updates");
	if (arg_other_updates){
		for(i=0; i<len_arg_other_updates; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_other_updates[i]->id);
			buf_cat(obj->objs[2]->value, arg_other_updates[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[3]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[4]->value, arg_users[i]->value);
		}
	}


	//parse argument updates_State
	if (arg_state){
		obj->objs[5] = arg_state;
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
	strcpy(obj->objs[5]->name, "state");
	}

	return obj;
}

tlo_t * tl_updates_differenceSlice(Message *arg_new_messages, int len_arg_new_messages, EncryptedMessage *arg_new_encrypted_messages, int len_arg_new_encrypted_messages, Update *arg_other_updates, int len_arg_other_updates, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users, updates_State arg_intermediate_state)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updates_differenceSlice");
	int i;
	obj->id = 0xa8fb1981;
	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<Message>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "new_messages");
	if (arg_new_messages){
		for(i=0; i<len_arg_new_messages; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_new_messages[i]->id);
			buf_cat(obj->objs[0]->value, arg_new_messages[i]->value);
		}
	}


	//parse argument Vector<EncryptedMessage>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "new_encrypted_messages");
	if (arg_new_encrypted_messages){
		for(i=0; i<len_arg_new_encrypted_messages; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_new_encrypted_messages[i]->id);
			buf_cat(obj->objs[1]->value, arg_new_encrypted_messages[i]->value);
		}
	}


	//parse argument Vector<Update>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "other_updates");
	if (arg_other_updates){
		for(i=0; i<len_arg_other_updates; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_other_updates[i]->id);
			buf_cat(obj->objs[2]->value, arg_other_updates[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[3]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[4]->value, arg_users[i]->value);
		}
	}


	//parse argument updates_State
	if (arg_intermediate_state){
		obj->objs[5] = arg_intermediate_state;
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
	strcpy(obj->objs[5]->name, "intermediate_state");
	}

	return obj;
}

tlo_t * tl_updates_differenceTooLong(int arg_pts)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updates_differenceTooLong");
	int i;
	obj->id = 0x4afe8f6d;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_pts);
	strcpy(obj->objs[0]->name, "pts");
	return obj;
}

tlo_t * tl_updatesTooLong()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updatesTooLong");
	int i;
	obj->id = 0xe317af7e;
	return obj;
}

tlo_t * tl_updateShortMessage(bool arg_out, bool arg_mentioned, bool arg_media_unread, bool arg_silent, int arg_id, long arg_user_id, const char * arg_message, int arg_pts, int arg_pts_count, int arg_date, MessageFwdHeader arg_fwd_from, long arg_via_bot_id, MessageReplyHeader arg_reply_to, MessageEntity *arg_entities, int len_arg_entities, int arg_ttl_period)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateShortMessage");
	int i;
	obj->id = 0x313bc7f8;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 16;
	obj->objs = 
		(tlo_t **)MALLOC(16 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_out);
	strcpy(obj->objs[1]->name, "out");
	if (arg_out)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 4;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_mentioned);
	strcpy(obj->objs[2]->name, "mentioned");
	if (arg_mentioned)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 5;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_media_unread);
	strcpy(obj->objs[3]->name, "media_unread");
	if (arg_media_unread)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 13;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_silent);
	strcpy(obj->objs[4]->name, "silent");
	if (arg_silent)
		flagsv[nflags-1] |= (1 << 13);

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[5]->name, "id");

	//parse argument long
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_LONG;
	obj->objs[6]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[6]->name, "user_id");

	//parse argument string
	if (arg_message){
		obj->objs[7] = NEW(tlo_t, return NULL);
		obj->objs[7]->flag_num = 0;
		obj->objs[7]->flag_bit = 0;
		obj->objs[7]->type = TYPE_STRING;
		obj->objs[7]->value = 
			buf_add((ui8_t *)arg_message, strlen(arg_message));
		strcpy(obj->objs[7]->name, "message");
	}


	//parse argument int
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 0;
	obj->objs[8]->flag_bit = 0;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_pts);
	strcpy(obj->objs[8]->name, "pts");

	//parse argument int
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 0;
	obj->objs[9]->flag_bit = 0;
	obj->objs[9]->type = TYPE_INT;
	obj->objs[9]->value = 
		buf_add_ui32(arg_pts_count);
	strcpy(obj->objs[9]->name, "pts_count");

	//parse argument int
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 0;
	obj->objs[10]->flag_bit = 0;
	obj->objs[10]->type = TYPE_INT;
	obj->objs[10]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[10]->name, "date");

	//parse argument MessageFwdHeader
	if (arg_fwd_from){
		obj->objs[11] = arg_fwd_from;
		obj->objs[11]->flag_num = 1;
		obj->objs[11]->flag_bit = 2;
	strcpy(obj->objs[11]->name, "fwd_from");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument long
	obj->objs[12] = NEW(tlo_t, return NULL);
	obj->objs[12]->flag_num = 1;
	obj->objs[12]->flag_bit = 11;
	obj->objs[12]->type = TYPE_LONG;
	obj->objs[12]->value = 
		buf_add_ui64(arg_via_bot_id);
	strcpy(obj->objs[12]->name, "via_bot_id");
	if (arg_via_bot_id)
		flagsv[nflags-1] |= (1 << 11);

	//parse argument MessageReplyHeader
	if (arg_reply_to){
		obj->objs[13] = arg_reply_to;
		obj->objs[13]->flag_num = 1;
		obj->objs[13]->flag_bit = 3;
	strcpy(obj->objs[13]->name, "reply_to");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument Vector<MessageEntity>
	obj->objs[14] = NEW(tlo_t, return NULL);
	obj->objs[14]->flag_num = 1;
	obj->objs[14]->flag_bit = 7;
	obj->objs[14]->type = TYPE_VECTOR;
	strcpy(obj->objs[14]->name, "entities");
	if (arg_entities){
		for(i=0; i<len_arg_entities; ++i){
			obj->objs[14]->value = buf_add_ui32(arg_entities[i]->id);
			buf_cat(obj->objs[14]->value, arg_entities[i]->value);
		}
		flagsv[nflags-1] |= (1 << 7);
	}


	//parse argument int
	obj->objs[15] = NEW(tlo_t, return NULL);
	obj->objs[15]->flag_num = 1;
	obj->objs[15]->flag_bit = 25;
	obj->objs[15]->type = TYPE_INT;
	obj->objs[15]->value = 
		buf_add_ui32(arg_ttl_period);
	strcpy(obj->objs[15]->name, "ttl_period");
	if (arg_ttl_period)
		flagsv[nflags-1] |= (1 << 25);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateShortChatMessage(bool arg_out, bool arg_mentioned, bool arg_media_unread, bool arg_silent, int arg_id, long arg_from_id, long arg_chat_id, const char * arg_message, int arg_pts, int arg_pts_count, int arg_date, MessageFwdHeader arg_fwd_from, long arg_via_bot_id, MessageReplyHeader arg_reply_to, MessageEntity *arg_entities, int len_arg_entities, int arg_ttl_period)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateShortChatMessage");
	int i;
	obj->id = 0x4d6deea5;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 17;
	obj->objs = 
		(tlo_t **)MALLOC(17 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_out);
	strcpy(obj->objs[1]->name, "out");
	if (arg_out)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 4;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_mentioned);
	strcpy(obj->objs[2]->name, "mentioned");
	if (arg_mentioned)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 5;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_media_unread);
	strcpy(obj->objs[3]->name, "media_unread");
	if (arg_media_unread)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 13;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_silent);
	strcpy(obj->objs[4]->name, "silent");
	if (arg_silent)
		flagsv[nflags-1] |= (1 << 13);

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[5]->name, "id");

	//parse argument long
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_LONG;
	obj->objs[6]->value = 
		buf_add_ui64(arg_from_id);
	strcpy(obj->objs[6]->name, "from_id");

	//parse argument long
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_LONG;
	obj->objs[7]->value = 
		buf_add_ui64(arg_chat_id);
	strcpy(obj->objs[7]->name, "chat_id");

	//parse argument string
	if (arg_message){
		obj->objs[8] = NEW(tlo_t, return NULL);
		obj->objs[8]->flag_num = 0;
		obj->objs[8]->flag_bit = 0;
		obj->objs[8]->type = TYPE_STRING;
		obj->objs[8]->value = 
			buf_add((ui8_t *)arg_message, strlen(arg_message));
		strcpy(obj->objs[8]->name, "message");
	}


	//parse argument int
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 0;
	obj->objs[9]->flag_bit = 0;
	obj->objs[9]->type = TYPE_INT;
	obj->objs[9]->value = 
		buf_add_ui32(arg_pts);
	strcpy(obj->objs[9]->name, "pts");

	//parse argument int
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 0;
	obj->objs[10]->flag_bit = 0;
	obj->objs[10]->type = TYPE_INT;
	obj->objs[10]->value = 
		buf_add_ui32(arg_pts_count);
	strcpy(obj->objs[10]->name, "pts_count");

	//parse argument int
	obj->objs[11] = NEW(tlo_t, return NULL);
	obj->objs[11]->flag_num = 0;
	obj->objs[11]->flag_bit = 0;
	obj->objs[11]->type = TYPE_INT;
	obj->objs[11]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[11]->name, "date");

	//parse argument MessageFwdHeader
	if (arg_fwd_from){
		obj->objs[12] = arg_fwd_from;
		obj->objs[12]->flag_num = 1;
		obj->objs[12]->flag_bit = 2;
	strcpy(obj->objs[12]->name, "fwd_from");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument long
	obj->objs[13] = NEW(tlo_t, return NULL);
	obj->objs[13]->flag_num = 1;
	obj->objs[13]->flag_bit = 11;
	obj->objs[13]->type = TYPE_LONG;
	obj->objs[13]->value = 
		buf_add_ui64(arg_via_bot_id);
	strcpy(obj->objs[13]->name, "via_bot_id");
	if (arg_via_bot_id)
		flagsv[nflags-1] |= (1 << 11);

	//parse argument MessageReplyHeader
	if (arg_reply_to){
		obj->objs[14] = arg_reply_to;
		obj->objs[14]->flag_num = 1;
		obj->objs[14]->flag_bit = 3;
	strcpy(obj->objs[14]->name, "reply_to");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument Vector<MessageEntity>
	obj->objs[15] = NEW(tlo_t, return NULL);
	obj->objs[15]->flag_num = 1;
	obj->objs[15]->flag_bit = 7;
	obj->objs[15]->type = TYPE_VECTOR;
	strcpy(obj->objs[15]->name, "entities");
	if (arg_entities){
		for(i=0; i<len_arg_entities; ++i){
			obj->objs[15]->value = buf_add_ui32(arg_entities[i]->id);
			buf_cat(obj->objs[15]->value, arg_entities[i]->value);
		}
		flagsv[nflags-1] |= (1 << 7);
	}


	//parse argument int
	obj->objs[16] = NEW(tlo_t, return NULL);
	obj->objs[16]->flag_num = 1;
	obj->objs[16]->flag_bit = 25;
	obj->objs[16]->type = TYPE_INT;
	obj->objs[16]->value = 
		buf_add_ui32(arg_ttl_period);
	strcpy(obj->objs[16]->name, "ttl_period");
	if (arg_ttl_period)
		flagsv[nflags-1] |= (1 << 25);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updateShort(Update arg_update, int arg_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateShort");
	int i;
	obj->id = 0x78d4dec1;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Update
	if (arg_update){
		obj->objs[0] = arg_update;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "update");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[1]->name, "date");
	return obj;
}

tlo_t * tl_updatesCombined(Update *arg_updates, int len_arg_updates, User *arg_users, int len_arg_users, Chat *arg_chats, int len_arg_chats, int arg_date, int arg_seq_start, int arg_seq)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updatesCombined");
	int i;
	obj->id = 0x725b04c3;
	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<Update>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "updates");
	if (arg_updates){
		for(i=0; i<len_arg_updates; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_updates[i]->id);
			buf_cat(obj->objs[0]->value, arg_updates[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[1]->value, arg_users[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[2]->value, arg_chats[i]->value);
		}
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[3]->name, "date");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_seq_start);
	strcpy(obj->objs[4]->name, "seq_start");

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_seq);
	strcpy(obj->objs[5]->name, "seq");
	return obj;
}

tlo_t * tl_updates(Update *arg_updates, int len_arg_updates, User *arg_users, int len_arg_users, Chat *arg_chats, int len_arg_chats, int arg_date, int arg_seq)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updates");
	int i;
	obj->id = 0x74ae4240;
	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<Update>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "updates");
	if (arg_updates){
		for(i=0; i<len_arg_updates; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_updates[i]->id);
			buf_cat(obj->objs[0]->value, arg_updates[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[1]->value, arg_users[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[2]->value, arg_chats[i]->value);
		}
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[3]->name, "date");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_seq);
	strcpy(obj->objs[4]->name, "seq");
	return obj;
}

tlo_t * tl_updateShortSentMessage(bool arg_out, int arg_id, int arg_pts, int arg_pts_count, int arg_date, MessageMedia arg_media, MessageEntity *arg_entities, int len_arg_entities, int arg_ttl_period)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updateShortSentMessage");
	int i;
	obj->id = 0x9015e101;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_out);
	strcpy(obj->objs[1]->name, "out");
	if (arg_out)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[2]->name, "id");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_pts);
	strcpy(obj->objs[3]->name, "pts");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_pts_count);
	strcpy(obj->objs[4]->name, "pts_count");

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[5]->name, "date");

	//parse argument MessageMedia
	if (arg_media){
		obj->objs[6] = arg_media;
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 9;
	strcpy(obj->objs[6]->name, "media");
		flagsv[nflags-1] |= (1 << 9);
	}


	//parse argument Vector<MessageEntity>
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 7;
	obj->objs[7]->type = TYPE_VECTOR;
	strcpy(obj->objs[7]->name, "entities");
	if (arg_entities){
		for(i=0; i<len_arg_entities; ++i){
			obj->objs[7]->value = buf_add_ui32(arg_entities[i]->id);
			buf_cat(obj->objs[7]->value, arg_entities[i]->value);
		}
		flagsv[nflags-1] |= (1 << 7);
	}


	//parse argument int
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 25;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_ttl_period);
	strcpy(obj->objs[8]->name, "ttl_period");
	if (arg_ttl_period)
		flagsv[nflags-1] |= (1 << 25);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_photos_photos(Photo *arg_photos, int len_arg_photos, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "photos_photos");
	int i;
	obj->id = 0x8dca6aa5;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<Photo>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "photos");
	if (arg_photos){
		for(i=0; i<len_arg_photos; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_photos[i]->id);
			buf_cat(obj->objs[0]->value, arg_photos[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[1]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_photos_photosSlice(int arg_count, Photo *arg_photos, int len_arg_photos, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "photos_photosSlice");
	int i;
	obj->id = 0x15051f54;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[0]->name, "count");

	//parse argument Vector<Photo>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "photos");
	if (arg_photos){
		for(i=0; i<len_arg_photos; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_photos[i]->id);
			buf_cat(obj->objs[1]->value, arg_photos[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[2]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_photos_photo(Photo arg_photo, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "photos_photo");
	int i;
	obj->id = 0x20212ca8;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Photo
	if (arg_photo){
		obj->objs[0] = arg_photo;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "photo");
	}


	//parse argument Vector<User>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[1]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_upload_file(storage_FileType arg_type, int arg_mtime, unsigned char * arg_bytes, int len_arg_bytes)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "upload_file");
	int i;
	obj->id = 0x096a18d5;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument storage_FileType
	if (arg_type){
		obj->objs[0] = arg_type;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "type");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_mtime);
	strcpy(obj->objs[1]->name, "mtime");

	//parse argument bytes
	if (arg_bytes){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_BYTES;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_bytes, len_arg_bytes);
		strcpy(obj->objs[2]->name, "bytes");
	}

	return obj;
}

tlo_t * tl_upload_fileCdnRedirect(int arg_dc_id, unsigned char * arg_file_token, int len_arg_file_token, unsigned char * arg_encryption_key, int len_arg_encryption_key, unsigned char * arg_encryption_iv, int len_arg_encryption_iv, FileHash *arg_file_hashes, int len_arg_file_hashes)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "upload_fileCdnRedirect");
	int i;
	obj->id = 0xf18cda44;
	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_dc_id);
	strcpy(obj->objs[0]->name, "dc_id");

	//parse argument bytes
	if (arg_file_token){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_file_token, len_arg_file_token);
		strcpy(obj->objs[1]->name, "file_token");
	}


	//parse argument bytes
	if (arg_encryption_key){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_BYTES;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_encryption_key, len_arg_encryption_key);
		strcpy(obj->objs[2]->name, "encryption_key");
	}


	//parse argument bytes
	if (arg_encryption_iv){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_BYTES;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_encryption_iv, len_arg_encryption_iv);
		strcpy(obj->objs[3]->name, "encryption_iv");
	}


	//parse argument Vector<FileHash>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "file_hashes");
	if (arg_file_hashes){
		for(i=0; i<len_arg_file_hashes; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_file_hashes[i]->id);
			buf_cat(obj->objs[4]->value, arg_file_hashes[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_dcOption(bool arg_ipv6, bool arg_media_only, bool arg_tcpo_only, bool arg_cdn, bool arg_static, bool arg_this_port_only, int arg_id, const char * arg_ip_address, int arg_port, unsigned char * arg_secret, int len_arg_secret)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "dcOption");
	int i;
	obj->id = 0x18b7a10d;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 11;
	obj->objs = 
		(tlo_t **)MALLOC(11 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_ipv6);
	strcpy(obj->objs[1]->name, "ipv6");
	if (arg_ipv6)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_media_only);
	strcpy(obj->objs[2]->name, "media_only");
	if (arg_media_only)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_tcpo_only);
	strcpy(obj->objs[3]->name, "tcpo_only");
	if (arg_tcpo_only)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 3;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_cdn);
	strcpy(obj->objs[4]->name, "cdn");
	if (arg_cdn)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 4;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_static);
	strcpy(obj->objs[5]->name, "static");
	if (arg_static)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument true
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 5;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_this_port_only);
	strcpy(obj->objs[6]->name, "this_port_only");
	if (arg_this_port_only)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument int
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[7]->name, "id");

	//parse argument string
	if (arg_ip_address){
		obj->objs[8] = NEW(tlo_t, return NULL);
		obj->objs[8]->flag_num = 0;
		obj->objs[8]->flag_bit = 0;
		obj->objs[8]->type = TYPE_STRING;
		obj->objs[8]->value = 
			buf_add((ui8_t *)arg_ip_address, strlen(arg_ip_address));
		strcpy(obj->objs[8]->name, "ip_address");
	}


	//parse argument int
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 0;
	obj->objs[9]->flag_bit = 0;
	obj->objs[9]->type = TYPE_INT;
	obj->objs[9]->value = 
		buf_add_ui32(arg_port);
	strcpy(obj->objs[9]->name, "port");

	//parse argument bytes
	if (arg_secret){
		obj->objs[10] = NEW(tlo_t, return NULL);
		obj->objs[10]->flag_num = 1;
		obj->objs[10]->flag_bit = 10;
		obj->objs[10]->type = TYPE_BYTES;
		obj->objs[10]->value = 
			buf_add((ui8_t *)arg_secret, len_arg_secret);
		strcpy(obj->objs[10]->name, "secret");
		flagsv[nflags-1] |= (1 << 10);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_config(bool arg_default_p2p_contacts, bool arg_preload_featured_stickers, bool arg_revoke_pm_inbox, bool arg_blocked_mode, bool arg_force_try_ipv6, int arg_date, int arg_expires, Bool arg_test_mode, int arg_this_dc, DcOption *arg_dc_options, int len_arg_dc_options, const char * arg_dc_txt_domain_name, int arg_chat_size_max, int arg_megagroup_size_max, int arg_forwarded_count_max, int arg_online_update_period_ms, int arg_offline_blur_timeout_ms, int arg_offline_idle_timeout_ms, int arg_online_cloud_timeout_ms, int arg_notify_cloud_delay_ms, int arg_notify_default_delay_ms, int arg_push_chat_period_ms, int arg_push_chat_limit, int arg_edit_time_limit, int arg_revoke_time_limit, int arg_revoke_pm_time_limit, int arg_rating_e_decay, int arg_stickers_recent_limit, int arg_channels_read_media_period, int arg_tmp_sessions, int arg_call_receive_timeout_ms, int arg_call_ring_timeout_ms, int arg_call_connect_timeout_ms, int arg_call_packet_timeout_ms, const char * arg_me_url_prefix, const char * arg_autoupdate_url_prefix, const char * arg_gif_search_username, const char * arg_venue_search_username, const char * arg_img_search_username, const char * arg_static_maps_provider, int arg_caption_length_max, int arg_message_length_max, int arg_webfile_dc_id, const char * arg_suggested_lang_code, int arg_lang_pack_version, int arg_base_lang_pack_version, Reaction arg_reactions_default, const char * arg_autologin_token)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "config");
	int i;
	obj->id = 0xcc1a241e;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 48;
	obj->objs = 
		(tlo_t **)MALLOC(48 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 3;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_default_p2p_contacts);
	strcpy(obj->objs[1]->name, "default_p2p_contacts");
	if (arg_default_p2p_contacts)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 4;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_preload_featured_stickers);
	strcpy(obj->objs[2]->name, "preload_featured_stickers");
	if (arg_preload_featured_stickers)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 6;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_revoke_pm_inbox);
	strcpy(obj->objs[3]->name, "revoke_pm_inbox");
	if (arg_revoke_pm_inbox)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 8;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_blocked_mode);
	strcpy(obj->objs[4]->name, "blocked_mode");
	if (arg_blocked_mode)
		flagsv[nflags-1] |= (1 << 8);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 14;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_force_try_ipv6);
	strcpy(obj->objs[5]->name, "force_try_ipv6");
	if (arg_force_try_ipv6)
		flagsv[nflags-1] |= (1 << 14);

	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[6]->name, "date");

	//parse argument int
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_expires);
	strcpy(obj->objs[7]->name, "expires");

	//parse argument Bool
	if (arg_test_mode){
		obj->objs[8] = arg_test_mode;
		obj->objs[8]->flag_num = 0;
		obj->objs[8]->flag_bit = 0;
	strcpy(obj->objs[8]->name, "test_mode");
	}


	//parse argument int
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 0;
	obj->objs[9]->flag_bit = 0;
	obj->objs[9]->type = TYPE_INT;
	obj->objs[9]->value = 
		buf_add_ui32(arg_this_dc);
	strcpy(obj->objs[9]->name, "this_dc");

	//parse argument Vector<DcOption>
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 0;
	obj->objs[10]->flag_bit = 0;
	obj->objs[10]->type = TYPE_VECTOR;
	strcpy(obj->objs[10]->name, "dc_options");
	if (arg_dc_options){
		for(i=0; i<len_arg_dc_options; ++i){
			obj->objs[10]->value = buf_add_ui32(arg_dc_options[i]->id);
			buf_cat(obj->objs[10]->value, arg_dc_options[i]->value);
		}
	}


	//parse argument string
	if (arg_dc_txt_domain_name){
		obj->objs[11] = NEW(tlo_t, return NULL);
		obj->objs[11]->flag_num = 0;
		obj->objs[11]->flag_bit = 0;
		obj->objs[11]->type = TYPE_STRING;
		obj->objs[11]->value = 
			buf_add((ui8_t *)arg_dc_txt_domain_name, strlen(arg_dc_txt_domain_name));
		strcpy(obj->objs[11]->name, "dc_txt_domain_name");
	}


	//parse argument int
	obj->objs[12] = NEW(tlo_t, return NULL);
	obj->objs[12]->flag_num = 0;
	obj->objs[12]->flag_bit = 0;
	obj->objs[12]->type = TYPE_INT;
	obj->objs[12]->value = 
		buf_add_ui32(arg_chat_size_max);
	strcpy(obj->objs[12]->name, "chat_size_max");

	//parse argument int
	obj->objs[13] = NEW(tlo_t, return NULL);
	obj->objs[13]->flag_num = 0;
	obj->objs[13]->flag_bit = 0;
	obj->objs[13]->type = TYPE_INT;
	obj->objs[13]->value = 
		buf_add_ui32(arg_megagroup_size_max);
	strcpy(obj->objs[13]->name, "megagroup_size_max");

	//parse argument int
	obj->objs[14] = NEW(tlo_t, return NULL);
	obj->objs[14]->flag_num = 0;
	obj->objs[14]->flag_bit = 0;
	obj->objs[14]->type = TYPE_INT;
	obj->objs[14]->value = 
		buf_add_ui32(arg_forwarded_count_max);
	strcpy(obj->objs[14]->name, "forwarded_count_max");

	//parse argument int
	obj->objs[15] = NEW(tlo_t, return NULL);
	obj->objs[15]->flag_num = 0;
	obj->objs[15]->flag_bit = 0;
	obj->objs[15]->type = TYPE_INT;
	obj->objs[15]->value = 
		buf_add_ui32(arg_online_update_period_ms);
	strcpy(obj->objs[15]->name, "online_update_period_ms");

	//parse argument int
	obj->objs[16] = NEW(tlo_t, return NULL);
	obj->objs[16]->flag_num = 0;
	obj->objs[16]->flag_bit = 0;
	obj->objs[16]->type = TYPE_INT;
	obj->objs[16]->value = 
		buf_add_ui32(arg_offline_blur_timeout_ms);
	strcpy(obj->objs[16]->name, "offline_blur_timeout_ms");

	//parse argument int
	obj->objs[17] = NEW(tlo_t, return NULL);
	obj->objs[17]->flag_num = 0;
	obj->objs[17]->flag_bit = 0;
	obj->objs[17]->type = TYPE_INT;
	obj->objs[17]->value = 
		buf_add_ui32(arg_offline_idle_timeout_ms);
	strcpy(obj->objs[17]->name, "offline_idle_timeout_ms");

	//parse argument int
	obj->objs[18] = NEW(tlo_t, return NULL);
	obj->objs[18]->flag_num = 0;
	obj->objs[18]->flag_bit = 0;
	obj->objs[18]->type = TYPE_INT;
	obj->objs[18]->value = 
		buf_add_ui32(arg_online_cloud_timeout_ms);
	strcpy(obj->objs[18]->name, "online_cloud_timeout_ms");

	//parse argument int
	obj->objs[19] = NEW(tlo_t, return NULL);
	obj->objs[19]->flag_num = 0;
	obj->objs[19]->flag_bit = 0;
	obj->objs[19]->type = TYPE_INT;
	obj->objs[19]->value = 
		buf_add_ui32(arg_notify_cloud_delay_ms);
	strcpy(obj->objs[19]->name, "notify_cloud_delay_ms");

	//parse argument int
	obj->objs[20] = NEW(tlo_t, return NULL);
	obj->objs[20]->flag_num = 0;
	obj->objs[20]->flag_bit = 0;
	obj->objs[20]->type = TYPE_INT;
	obj->objs[20]->value = 
		buf_add_ui32(arg_notify_default_delay_ms);
	strcpy(obj->objs[20]->name, "notify_default_delay_ms");

	//parse argument int
	obj->objs[21] = NEW(tlo_t, return NULL);
	obj->objs[21]->flag_num = 0;
	obj->objs[21]->flag_bit = 0;
	obj->objs[21]->type = TYPE_INT;
	obj->objs[21]->value = 
		buf_add_ui32(arg_push_chat_period_ms);
	strcpy(obj->objs[21]->name, "push_chat_period_ms");

	//parse argument int
	obj->objs[22] = NEW(tlo_t, return NULL);
	obj->objs[22]->flag_num = 0;
	obj->objs[22]->flag_bit = 0;
	obj->objs[22]->type = TYPE_INT;
	obj->objs[22]->value = 
		buf_add_ui32(arg_push_chat_limit);
	strcpy(obj->objs[22]->name, "push_chat_limit");

	//parse argument int
	obj->objs[23] = NEW(tlo_t, return NULL);
	obj->objs[23]->flag_num = 0;
	obj->objs[23]->flag_bit = 0;
	obj->objs[23]->type = TYPE_INT;
	obj->objs[23]->value = 
		buf_add_ui32(arg_edit_time_limit);
	strcpy(obj->objs[23]->name, "edit_time_limit");

	//parse argument int
	obj->objs[24] = NEW(tlo_t, return NULL);
	obj->objs[24]->flag_num = 0;
	obj->objs[24]->flag_bit = 0;
	obj->objs[24]->type = TYPE_INT;
	obj->objs[24]->value = 
		buf_add_ui32(arg_revoke_time_limit);
	strcpy(obj->objs[24]->name, "revoke_time_limit");

	//parse argument int
	obj->objs[25] = NEW(tlo_t, return NULL);
	obj->objs[25]->flag_num = 0;
	obj->objs[25]->flag_bit = 0;
	obj->objs[25]->type = TYPE_INT;
	obj->objs[25]->value = 
		buf_add_ui32(arg_revoke_pm_time_limit);
	strcpy(obj->objs[25]->name, "revoke_pm_time_limit");

	//parse argument int
	obj->objs[26] = NEW(tlo_t, return NULL);
	obj->objs[26]->flag_num = 0;
	obj->objs[26]->flag_bit = 0;
	obj->objs[26]->type = TYPE_INT;
	obj->objs[26]->value = 
		buf_add_ui32(arg_rating_e_decay);
	strcpy(obj->objs[26]->name, "rating_e_decay");

	//parse argument int
	obj->objs[27] = NEW(tlo_t, return NULL);
	obj->objs[27]->flag_num = 0;
	obj->objs[27]->flag_bit = 0;
	obj->objs[27]->type = TYPE_INT;
	obj->objs[27]->value = 
		buf_add_ui32(arg_stickers_recent_limit);
	strcpy(obj->objs[27]->name, "stickers_recent_limit");

	//parse argument int
	obj->objs[28] = NEW(tlo_t, return NULL);
	obj->objs[28]->flag_num = 0;
	obj->objs[28]->flag_bit = 0;
	obj->objs[28]->type = TYPE_INT;
	obj->objs[28]->value = 
		buf_add_ui32(arg_channels_read_media_period);
	strcpy(obj->objs[28]->name, "channels_read_media_period");

	//parse argument int
	obj->objs[29] = NEW(tlo_t, return NULL);
	obj->objs[29]->flag_num = 1;
	obj->objs[29]->flag_bit = 0;
	obj->objs[29]->type = TYPE_INT;
	obj->objs[29]->value = 
		buf_add_ui32(arg_tmp_sessions);
	strcpy(obj->objs[29]->name, "tmp_sessions");
	if (arg_tmp_sessions)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[30] = NEW(tlo_t, return NULL);
	obj->objs[30]->flag_num = 0;
	obj->objs[30]->flag_bit = 0;
	obj->objs[30]->type = TYPE_INT;
	obj->objs[30]->value = 
		buf_add_ui32(arg_call_receive_timeout_ms);
	strcpy(obj->objs[30]->name, "call_receive_timeout_ms");

	//parse argument int
	obj->objs[31] = NEW(tlo_t, return NULL);
	obj->objs[31]->flag_num = 0;
	obj->objs[31]->flag_bit = 0;
	obj->objs[31]->type = TYPE_INT;
	obj->objs[31]->value = 
		buf_add_ui32(arg_call_ring_timeout_ms);
	strcpy(obj->objs[31]->name, "call_ring_timeout_ms");

	//parse argument int
	obj->objs[32] = NEW(tlo_t, return NULL);
	obj->objs[32]->flag_num = 0;
	obj->objs[32]->flag_bit = 0;
	obj->objs[32]->type = TYPE_INT;
	obj->objs[32]->value = 
		buf_add_ui32(arg_call_connect_timeout_ms);
	strcpy(obj->objs[32]->name, "call_connect_timeout_ms");

	//parse argument int
	obj->objs[33] = NEW(tlo_t, return NULL);
	obj->objs[33]->flag_num = 0;
	obj->objs[33]->flag_bit = 0;
	obj->objs[33]->type = TYPE_INT;
	obj->objs[33]->value = 
		buf_add_ui32(arg_call_packet_timeout_ms);
	strcpy(obj->objs[33]->name, "call_packet_timeout_ms");

	//parse argument string
	if (arg_me_url_prefix){
		obj->objs[34] = NEW(tlo_t, return NULL);
		obj->objs[34]->flag_num = 0;
		obj->objs[34]->flag_bit = 0;
		obj->objs[34]->type = TYPE_STRING;
		obj->objs[34]->value = 
			buf_add((ui8_t *)arg_me_url_prefix, strlen(arg_me_url_prefix));
		strcpy(obj->objs[34]->name, "me_url_prefix");
	}


	//parse argument string
	if (arg_autoupdate_url_prefix){
		obj->objs[35] = NEW(tlo_t, return NULL);
		obj->objs[35]->flag_num = 1;
		obj->objs[35]->flag_bit = 7;
		obj->objs[35]->type = TYPE_STRING;
		obj->objs[35]->value = 
			buf_add((ui8_t *)arg_autoupdate_url_prefix, strlen(arg_autoupdate_url_prefix));
		strcpy(obj->objs[35]->name, "autoupdate_url_prefix");
		flagsv[nflags-1] |= (1 << 7);
	}


	//parse argument string
	if (arg_gif_search_username){
		obj->objs[36] = NEW(tlo_t, return NULL);
		obj->objs[36]->flag_num = 1;
		obj->objs[36]->flag_bit = 9;
		obj->objs[36]->type = TYPE_STRING;
		obj->objs[36]->value = 
			buf_add((ui8_t *)arg_gif_search_username, strlen(arg_gif_search_username));
		strcpy(obj->objs[36]->name, "gif_search_username");
		flagsv[nflags-1] |= (1 << 9);
	}


	//parse argument string
	if (arg_venue_search_username){
		obj->objs[37] = NEW(tlo_t, return NULL);
		obj->objs[37]->flag_num = 1;
		obj->objs[37]->flag_bit = 10;
		obj->objs[37]->type = TYPE_STRING;
		obj->objs[37]->value = 
			buf_add((ui8_t *)arg_venue_search_username, strlen(arg_venue_search_username));
		strcpy(obj->objs[37]->name, "venue_search_username");
		flagsv[nflags-1] |= (1 << 10);
	}


	//parse argument string
	if (arg_img_search_username){
		obj->objs[38] = NEW(tlo_t, return NULL);
		obj->objs[38]->flag_num = 1;
		obj->objs[38]->flag_bit = 11;
		obj->objs[38]->type = TYPE_STRING;
		obj->objs[38]->value = 
			buf_add((ui8_t *)arg_img_search_username, strlen(arg_img_search_username));
		strcpy(obj->objs[38]->name, "img_search_username");
		flagsv[nflags-1] |= (1 << 11);
	}


	//parse argument string
	if (arg_static_maps_provider){
		obj->objs[39] = NEW(tlo_t, return NULL);
		obj->objs[39]->flag_num = 1;
		obj->objs[39]->flag_bit = 12;
		obj->objs[39]->type = TYPE_STRING;
		obj->objs[39]->value = 
			buf_add((ui8_t *)arg_static_maps_provider, strlen(arg_static_maps_provider));
		strcpy(obj->objs[39]->name, "static_maps_provider");
		flagsv[nflags-1] |= (1 << 12);
	}


	//parse argument int
	obj->objs[40] = NEW(tlo_t, return NULL);
	obj->objs[40]->flag_num = 0;
	obj->objs[40]->flag_bit = 0;
	obj->objs[40]->type = TYPE_INT;
	obj->objs[40]->value = 
		buf_add_ui32(arg_caption_length_max);
	strcpy(obj->objs[40]->name, "caption_length_max");

	//parse argument int
	obj->objs[41] = NEW(tlo_t, return NULL);
	obj->objs[41]->flag_num = 0;
	obj->objs[41]->flag_bit = 0;
	obj->objs[41]->type = TYPE_INT;
	obj->objs[41]->value = 
		buf_add_ui32(arg_message_length_max);
	strcpy(obj->objs[41]->name, "message_length_max");

	//parse argument int
	obj->objs[42] = NEW(tlo_t, return NULL);
	obj->objs[42]->flag_num = 0;
	obj->objs[42]->flag_bit = 0;
	obj->objs[42]->type = TYPE_INT;
	obj->objs[42]->value = 
		buf_add_ui32(arg_webfile_dc_id);
	strcpy(obj->objs[42]->name, "webfile_dc_id");

	//parse argument string
	if (arg_suggested_lang_code){
		obj->objs[43] = NEW(tlo_t, return NULL);
		obj->objs[43]->flag_num = 1;
		obj->objs[43]->flag_bit = 2;
		obj->objs[43]->type = TYPE_STRING;
		obj->objs[43]->value = 
			buf_add((ui8_t *)arg_suggested_lang_code, strlen(arg_suggested_lang_code));
		strcpy(obj->objs[43]->name, "suggested_lang_code");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument int
	obj->objs[44] = NEW(tlo_t, return NULL);
	obj->objs[44]->flag_num = 1;
	obj->objs[44]->flag_bit = 2;
	obj->objs[44]->type = TYPE_INT;
	obj->objs[44]->value = 
		buf_add_ui32(arg_lang_pack_version);
	strcpy(obj->objs[44]->name, "lang_pack_version");
	if (arg_lang_pack_version)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument int
	obj->objs[45] = NEW(tlo_t, return NULL);
	obj->objs[45]->flag_num = 1;
	obj->objs[45]->flag_bit = 2;
	obj->objs[45]->type = TYPE_INT;
	obj->objs[45]->value = 
		buf_add_ui32(arg_base_lang_pack_version);
	strcpy(obj->objs[45]->name, "base_lang_pack_version");
	if (arg_base_lang_pack_version)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument Reaction
	if (arg_reactions_default){
		obj->objs[46] = arg_reactions_default;
		obj->objs[46]->flag_num = 1;
		obj->objs[46]->flag_bit = 15;
	strcpy(obj->objs[46]->name, "reactions_default");
		flagsv[nflags-1] |= (1 << 15);
	}


	//parse argument string
	if (arg_autologin_token){
		obj->objs[47] = NEW(tlo_t, return NULL);
		obj->objs[47]->flag_num = 1;
		obj->objs[47]->flag_bit = 16;
		obj->objs[47]->type = TYPE_STRING;
		obj->objs[47]->value = 
			buf_add((ui8_t *)arg_autologin_token, strlen(arg_autologin_token));
		strcpy(obj->objs[47]->name, "autologin_token");
		flagsv[nflags-1] |= (1 << 16);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_nearestDc(const char * arg_country, int arg_this_dc, int arg_nearest_dc)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "nearestDc");
	int i;
	obj->id = 0x8e1a1775;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_country){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_country, strlen(arg_country));
		strcpy(obj->objs[0]->name, "country");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_this_dc);
	strcpy(obj->objs[1]->name, "this_dc");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_nearest_dc);
	strcpy(obj->objs[2]->name, "nearest_dc");
	return obj;
}

tlo_t * tl_help_appUpdate(bool arg_can_not_skip, int arg_id, const char * arg_version, const char * arg_text, MessageEntity *arg_entities, int len_arg_entities, Document arg_document, const char * arg_url, Document arg_sticker)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_appUpdate");
	int i;
	obj->id = 0xccbbce30;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_can_not_skip);
	strcpy(obj->objs[1]->name, "can_not_skip");
	if (arg_can_not_skip)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[2]->name, "id");

	//parse argument string
	if (arg_version){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_version, strlen(arg_version));
		strcpy(obj->objs[3]->name, "version");
	}


	//parse argument string
	if (arg_text){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[4]->name, "text");
	}


	//parse argument Vector<MessageEntity>
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_VECTOR;
	strcpy(obj->objs[5]->name, "entities");
	if (arg_entities){
		for(i=0; i<len_arg_entities; ++i){
			obj->objs[5]->value = buf_add_ui32(arg_entities[i]->id);
			buf_cat(obj->objs[5]->value, arg_entities[i]->value);
		}
	}


	//parse argument Document
	if (arg_document){
		obj->objs[6] = arg_document;
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 1;
	strcpy(obj->objs[6]->name, "document");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument string
	if (arg_url){
		obj->objs[7] = NEW(tlo_t, return NULL);
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 2;
		obj->objs[7]->type = TYPE_STRING;
		obj->objs[7]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[7]->name, "url");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument Document
	if (arg_sticker){
		obj->objs[8] = arg_sticker;
		obj->objs[8]->flag_num = 1;
		obj->objs[8]->flag_bit = 3;
	strcpy(obj->objs[8]->name, "sticker");
		flagsv[nflags-1] |= (1 << 3);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_help_noAppUpdate()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_noAppUpdate");
	int i;
	obj->id = 0xc45a6536;
	return obj;
}

tlo_t * tl_help_inviteText(const char * arg_message)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_inviteText");
	int i;
	obj->id = 0x18cb9f78;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_message){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_message, strlen(arg_message));
		strcpy(obj->objs[0]->name, "message");
	}

	return obj;
}

tlo_t * tl_encryptedChatEmpty(int arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "encryptedChatEmpty");
	int i;
	obj->id = 0xab7ec0a0;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[0]->name, "id");
	return obj;
}

tlo_t * tl_encryptedChatWaiting(int arg_id, long arg_access_hash, int arg_date, long arg_admin_id, long arg_participant_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "encryptedChatWaiting");
	int i;
	obj->id = 0x66b25953;
	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[1]->name, "access_hash");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[2]->name, "date");

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_admin_id);
	strcpy(obj->objs[3]->name, "admin_id");

	//parse argument long
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_participant_id);
	strcpy(obj->objs[4]->name, "participant_id");
	return obj;
}

tlo_t * tl_encryptedChatRequested(int arg_folder_id, int arg_id, long arg_access_hash, int arg_date, long arg_admin_id, long arg_participant_id, unsigned char * arg_g_a, int len_arg_g_a)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "encryptedChatRequested");
	int i;
	obj->id = 0x48f1d94c;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_folder_id);
	strcpy(obj->objs[1]->name, "folder_id");
	if (arg_folder_id)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[2]->name, "id");

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[3]->name, "access_hash");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[4]->name, "date");

	//parse argument long
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_LONG;
	obj->objs[5]->value = 
		buf_add_ui64(arg_admin_id);
	strcpy(obj->objs[5]->name, "admin_id");

	//parse argument long
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_LONG;
	obj->objs[6]->value = 
		buf_add_ui64(arg_participant_id);
	strcpy(obj->objs[6]->name, "participant_id");

	//parse argument bytes
	if (arg_g_a){
		obj->objs[7] = NEW(tlo_t, return NULL);
		obj->objs[7]->flag_num = 0;
		obj->objs[7]->flag_bit = 0;
		obj->objs[7]->type = TYPE_BYTES;
		obj->objs[7]->value = 
			buf_add((ui8_t *)arg_g_a, len_arg_g_a);
		strcpy(obj->objs[7]->name, "g_a");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_encryptedChat(int arg_id, long arg_access_hash, int arg_date, long arg_admin_id, long arg_participant_id, unsigned char * arg_g_a_or_b, int len_arg_g_a_or_b, long arg_key_fingerprint)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "encryptedChat");
	int i;
	obj->id = 0x61f0d4c7;
	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[1]->name, "access_hash");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[2]->name, "date");

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_admin_id);
	strcpy(obj->objs[3]->name, "admin_id");

	//parse argument long
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_participant_id);
	strcpy(obj->objs[4]->name, "participant_id");

	//parse argument bytes
	if (arg_g_a_or_b){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_BYTES;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_g_a_or_b, len_arg_g_a_or_b);
		strcpy(obj->objs[5]->name, "g_a_or_b");
	}


	//parse argument long
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_LONG;
	obj->objs[6]->value = 
		buf_add_ui64(arg_key_fingerprint);
	strcpy(obj->objs[6]->name, "key_fingerprint");
	return obj;
}

tlo_t * tl_encryptedChatDiscarded(bool arg_history_deleted, int arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "encryptedChatDiscarded");
	int i;
	obj->id = 0x1e1c7c45;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_history_deleted);
	strcpy(obj->objs[1]->name, "history_deleted");
	if (arg_history_deleted)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[2]->name, "id");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputEncryptedChat(int arg_chat_id, long arg_access_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputEncryptedChat");
	int i;
	obj->id = 0xf141b5e1;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_chat_id);
	strcpy(obj->objs[0]->name, "chat_id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[1]->name, "access_hash");
	return obj;
}

tlo_t * tl_encryptedFileEmpty()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "encryptedFileEmpty");
	int i;
	obj->id = 0xc21f497e;
	return obj;
}

tlo_t * tl_encryptedFile(long arg_id, long arg_access_hash, long arg_size, int arg_dc_id, int arg_key_fingerprint)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "encryptedFile");
	int i;
	obj->id = 0xa8008cd8;
	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[1]->name, "access_hash");

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_size);
	strcpy(obj->objs[2]->name, "size");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_dc_id);
	strcpy(obj->objs[3]->name, "dc_id");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_key_fingerprint);
	strcpy(obj->objs[4]->name, "key_fingerprint");
	return obj;
}

tlo_t * tl_inputEncryptedFileEmpty()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputEncryptedFileEmpty");
	int i;
	obj->id = 0x1837c364;
	return obj;
}

tlo_t * tl_inputEncryptedFileUploaded(long arg_id, int arg_parts, const char * arg_md5_checksum, int arg_key_fingerprint)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputEncryptedFileUploaded");
	int i;
	obj->id = 0x64bd0306;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_parts);
	strcpy(obj->objs[1]->name, "parts");

	//parse argument string
	if (arg_md5_checksum){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_md5_checksum, strlen(arg_md5_checksum));
		strcpy(obj->objs[2]->name, "md5_checksum");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_key_fingerprint);
	strcpy(obj->objs[3]->name, "key_fingerprint");
	return obj;
}

tlo_t * tl_inputEncryptedFile(long arg_id, long arg_access_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputEncryptedFile");
	int i;
	obj->id = 0x5a17b5e5;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[1]->name, "access_hash");
	return obj;
}

tlo_t * tl_inputEncryptedFileBigUploaded(long arg_id, int arg_parts, int arg_key_fingerprint)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputEncryptedFileBigUploaded");
	int i;
	obj->id = 0x2dc173c8;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_parts);
	strcpy(obj->objs[1]->name, "parts");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_key_fingerprint);
	strcpy(obj->objs[2]->name, "key_fingerprint");
	return obj;
}

tlo_t * tl_encryptedMessage(long arg_random_id, int arg_chat_id, int arg_date, unsigned char * arg_bytes, int len_arg_bytes, EncryptedFile arg_file)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "encryptedMessage");
	int i;
	obj->id = 0xed18c118;
	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_random_id);
	strcpy(obj->objs[0]->name, "random_id");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_chat_id);
	strcpy(obj->objs[1]->name, "chat_id");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[2]->name, "date");

	//parse argument bytes
	if (arg_bytes){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_BYTES;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_bytes, len_arg_bytes);
		strcpy(obj->objs[3]->name, "bytes");
	}


	//parse argument EncryptedFile
	if (arg_file){
		obj->objs[4] = arg_file;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "file");
	}

	return obj;
}

tlo_t * tl_encryptedMessageService(long arg_random_id, int arg_chat_id, int arg_date, unsigned char * arg_bytes, int len_arg_bytes)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "encryptedMessageService");
	int i;
	obj->id = 0x23734b06;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_random_id);
	strcpy(obj->objs[0]->name, "random_id");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_chat_id);
	strcpy(obj->objs[1]->name, "chat_id");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[2]->name, "date");

	//parse argument bytes
	if (arg_bytes){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_BYTES;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_bytes, len_arg_bytes);
		strcpy(obj->objs[3]->name, "bytes");
	}

	return obj;
}

tlo_t * tl_messages_dhConfigNotModified(unsigned char * arg_random, int len_arg_random)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_dhConfigNotModified");
	int i;
	obj->id = 0xc0e24635;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument bytes
	if (arg_random){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_BYTES;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_random, len_arg_random);
		strcpy(obj->objs[0]->name, "random");
	}

	return obj;
}

tlo_t * tl_messages_dhConfig(int arg_g, unsigned char * arg_p, int len_arg_p, int arg_version, unsigned char * arg_random, int len_arg_random)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_dhConfig");
	int i;
	obj->id = 0x2c221edd;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_g);
	strcpy(obj->objs[0]->name, "g");

	//parse argument bytes
	if (arg_p){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_p, len_arg_p);
		strcpy(obj->objs[1]->name, "p");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_version);
	strcpy(obj->objs[2]->name, "version");

	//parse argument bytes
	if (arg_random){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_BYTES;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_random, len_arg_random);
		strcpy(obj->objs[3]->name, "random");
	}

	return obj;
}

tlo_t * tl_messages_sentEncryptedMessage(int arg_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_sentEncryptedMessage");
	int i;
	obj->id = 0x560f8935;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[0]->name, "date");
	return obj;
}

tlo_t * tl_messages_sentEncryptedFile(int arg_date, EncryptedFile arg_file)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_sentEncryptedFile");
	int i;
	obj->id = 0x9493ff32;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[0]->name, "date");

	//parse argument EncryptedFile
	if (arg_file){
		obj->objs[1] = arg_file;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "file");
	}

	return obj;
}

tlo_t * tl_inputDocumentEmpty()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputDocumentEmpty");
	int i;
	obj->id = 0x72f0eaae;
	return obj;
}

tlo_t * tl_inputDocument(long arg_id, long arg_access_hash, unsigned char * arg_file_reference, int len_arg_file_reference)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputDocument");
	int i;
	obj->id = 0x1abfb575;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[1]->name, "access_hash");

	//parse argument bytes
	if (arg_file_reference){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_BYTES;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_file_reference, len_arg_file_reference);
		strcpy(obj->objs[2]->name, "file_reference");
	}

	return obj;
}

tlo_t * tl_documentEmpty(long arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "documentEmpty");
	int i;
	obj->id = 0x36f8c871;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");
	return obj;
}

tlo_t * tl_document(long arg_id, long arg_access_hash, unsigned char * arg_file_reference, int len_arg_file_reference, int arg_date, const char * arg_mime_type, long arg_size, PhotoSize *arg_thumbs, int len_arg_thumbs, VideoSize *arg_video_thumbs, int len_arg_video_thumbs, int arg_dc_id, DocumentAttribute *arg_attributes, int len_arg_attributes)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "document");
	int i;
	obj->id = 0x8fd4c4d8;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 11;
	obj->objs = 
		(tlo_t **)MALLOC(11 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[1]->name, "id");

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[2]->name, "access_hash");

	//parse argument bytes
	if (arg_file_reference){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_BYTES;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_file_reference, len_arg_file_reference);
		strcpy(obj->objs[3]->name, "file_reference");
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[4]->name, "date");

	//parse argument string
	if (arg_mime_type){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_mime_type, strlen(arg_mime_type));
		strcpy(obj->objs[5]->name, "mime_type");
	}


	//parse argument long
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_LONG;
	obj->objs[6]->value = 
		buf_add_ui64(arg_size);
	strcpy(obj->objs[6]->name, "size");

	//parse argument Vector<PhotoSize>
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_VECTOR;
	strcpy(obj->objs[7]->name, "thumbs");
	if (arg_thumbs){
		for(i=0; i<len_arg_thumbs; ++i){
			obj->objs[7]->value = buf_add_ui32(arg_thumbs[i]->id);
			buf_cat(obj->objs[7]->value, arg_thumbs[i]->value);
		}
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument Vector<VideoSize>
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 1;
	obj->objs[8]->type = TYPE_VECTOR;
	strcpy(obj->objs[8]->name, "video_thumbs");
	if (arg_video_thumbs){
		for(i=0; i<len_arg_video_thumbs; ++i){
			obj->objs[8]->value = buf_add_ui32(arg_video_thumbs[i]->id);
			buf_cat(obj->objs[8]->value, arg_video_thumbs[i]->value);
		}
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument int
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 0;
	obj->objs[9]->flag_bit = 0;
	obj->objs[9]->type = TYPE_INT;
	obj->objs[9]->value = 
		buf_add_ui32(arg_dc_id);
	strcpy(obj->objs[9]->name, "dc_id");

	//parse argument Vector<DocumentAttribute>
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 0;
	obj->objs[10]->flag_bit = 0;
	obj->objs[10]->type = TYPE_VECTOR;
	strcpy(obj->objs[10]->name, "attributes");
	if (arg_attributes){
		for(i=0; i<len_arg_attributes; ++i){
			obj->objs[10]->value = buf_add_ui32(arg_attributes[i]->id);
			buf_cat(obj->objs[10]->value, arg_attributes[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_help_support(const char * arg_phone_number, User arg_user)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_support");
	int i;
	obj->id = 0x17c6b5f6;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_phone_number){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_phone_number, strlen(arg_phone_number));
		strcpy(obj->objs[0]->name, "phone_number");
	}


	//parse argument User
	if (arg_user){
		obj->objs[1] = arg_user;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "user");
	}

	return obj;
}

tlo_t * tl_notifyPeer(Peer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "notifyPeer");
	int i;
	obj->id = 0x9fd40bd8;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}

	return obj;
}

tlo_t * tl_notifyUsers()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "notifyUsers");
	int i;
	obj->id = 0xb4c83b4c;
	return obj;
}

tlo_t * tl_notifyChats()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "notifyChats");
	int i;
	obj->id = 0xc007cec3;
	return obj;
}

tlo_t * tl_notifyBroadcasts()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "notifyBroadcasts");
	int i;
	obj->id = 0xd612e8ef;
	return obj;
}

tlo_t * tl_notifyForumTopic(Peer arg_peer, int arg_top_msg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "notifyForumTopic");
	int i;
	obj->id = 0x226e6308;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_top_msg_id);
	strcpy(obj->objs[1]->name, "top_msg_id");
	return obj;
}

tlo_t * tl_sendMessageTypingAction()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "sendMessageTypingAction");
	int i;
	obj->id = 0x16bf744e;
	return obj;
}

tlo_t * tl_sendMessageCancelAction()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "sendMessageCancelAction");
	int i;
	obj->id = 0xfd5ec8f5;
	return obj;
}

tlo_t * tl_sendMessageRecordVideoAction()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "sendMessageRecordVideoAction");
	int i;
	obj->id = 0xa187d66f;
	return obj;
}

tlo_t * tl_sendMessageUploadVideoAction(int arg_progress)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "sendMessageUploadVideoAction");
	int i;
	obj->id = 0xe9763aec;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_progress);
	strcpy(obj->objs[0]->name, "progress");
	return obj;
}

tlo_t * tl_sendMessageRecordAudioAction()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "sendMessageRecordAudioAction");
	int i;
	obj->id = 0xd52f73f7;
	return obj;
}

tlo_t * tl_sendMessageUploadAudioAction(int arg_progress)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "sendMessageUploadAudioAction");
	int i;
	obj->id = 0xf351d7ab;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_progress);
	strcpy(obj->objs[0]->name, "progress");
	return obj;
}

tlo_t * tl_sendMessageUploadPhotoAction(int arg_progress)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "sendMessageUploadPhotoAction");
	int i;
	obj->id = 0xd1d34a26;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_progress);
	strcpy(obj->objs[0]->name, "progress");
	return obj;
}

tlo_t * tl_sendMessageUploadDocumentAction(int arg_progress)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "sendMessageUploadDocumentAction");
	int i;
	obj->id = 0xaa0cd9e4;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_progress);
	strcpy(obj->objs[0]->name, "progress");
	return obj;
}

tlo_t * tl_sendMessageGeoLocationAction()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "sendMessageGeoLocationAction");
	int i;
	obj->id = 0x176f8ba1;
	return obj;
}

tlo_t * tl_sendMessageChooseContactAction()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "sendMessageChooseContactAction");
	int i;
	obj->id = 0x628cbc6f;
	return obj;
}

tlo_t * tl_sendMessageGamePlayAction()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "sendMessageGamePlayAction");
	int i;
	obj->id = 0xdd6a8f48;
	return obj;
}

tlo_t * tl_sendMessageRecordRoundAction()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "sendMessageRecordRoundAction");
	int i;
	obj->id = 0x88f27fbc;
	return obj;
}

tlo_t * tl_sendMessageUploadRoundAction(int arg_progress)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "sendMessageUploadRoundAction");
	int i;
	obj->id = 0x243e1c66;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_progress);
	strcpy(obj->objs[0]->name, "progress");
	return obj;
}

tlo_t * tl_speakingInGroupCallAction()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "speakingInGroupCallAction");
	int i;
	obj->id = 0xd92c2285;
	return obj;
}

tlo_t * tl_sendMessageHistoryImportAction(int arg_progress)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "sendMessageHistoryImportAction");
	int i;
	obj->id = 0xdbda9246;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_progress);
	strcpy(obj->objs[0]->name, "progress");
	return obj;
}

tlo_t * tl_sendMessageChooseStickerAction()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "sendMessageChooseStickerAction");
	int i;
	obj->id = 0xb05ac6b1;
	return obj;
}

tlo_t * tl_sendMessageEmojiInteraction(const char * arg_emoticon, int arg_msg_id, DataJSON arg_interaction)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "sendMessageEmojiInteraction");
	int i;
	obj->id = 0x25972bcb;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_emoticon){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_emoticon, strlen(arg_emoticon));
		strcpy(obj->objs[0]->name, "emoticon");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[1]->name, "msg_id");

	//parse argument DataJSON
	if (arg_interaction){
		obj->objs[2] = arg_interaction;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "interaction");
	}

	return obj;
}

tlo_t * tl_sendMessageEmojiInteractionSeen(const char * arg_emoticon)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "sendMessageEmojiInteractionSeen");
	int i;
	obj->id = 0xb665902e;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_emoticon){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_emoticon, strlen(arg_emoticon));
		strcpy(obj->objs[0]->name, "emoticon");
	}

	return obj;
}

tlo_t * tl_contacts_found(Peer *arg_my_results, int len_arg_my_results, Peer *arg_results, int len_arg_results, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_found");
	int i;
	obj->id = 0xb3134d9d;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<Peer>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "my_results");
	if (arg_my_results){
		for(i=0; i<len_arg_my_results; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_my_results[i]->id);
			buf_cat(obj->objs[0]->value, arg_my_results[i]->value);
		}
	}


	//parse argument Vector<Peer>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "results");
	if (arg_results){
		for(i=0; i<len_arg_results; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_results[i]->id);
			buf_cat(obj->objs[1]->value, arg_results[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[2]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[3]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_inputPrivacyKeyStatusTimestamp()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPrivacyKeyStatusTimestamp");
	int i;
	obj->id = 0x4f96cb18;
	return obj;
}

tlo_t * tl_inputPrivacyKeyChatInvite()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPrivacyKeyChatInvite");
	int i;
	obj->id = 0xbdfb0426;
	return obj;
}

tlo_t * tl_inputPrivacyKeyPhoneCall()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPrivacyKeyPhoneCall");
	int i;
	obj->id = 0xfabadc5f;
	return obj;
}

tlo_t * tl_inputPrivacyKeyPhoneP2P()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPrivacyKeyPhoneP2P");
	int i;
	obj->id = 0xdb9e70d2;
	return obj;
}

tlo_t * tl_inputPrivacyKeyForwards()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPrivacyKeyForwards");
	int i;
	obj->id = 0xa4dd4c08;
	return obj;
}

tlo_t * tl_inputPrivacyKeyProfilePhoto()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPrivacyKeyProfilePhoto");
	int i;
	obj->id = 0x5719bacc;
	return obj;
}

tlo_t * tl_inputPrivacyKeyPhoneNumber()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPrivacyKeyPhoneNumber");
	int i;
	obj->id = 0x0352dafa;
	return obj;
}

tlo_t * tl_inputPrivacyKeyAddedByPhone()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPrivacyKeyAddedByPhone");
	int i;
	obj->id = 0xd1219bdd;
	return obj;
}

tlo_t * tl_inputPrivacyKeyVoiceMessages()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPrivacyKeyVoiceMessages");
	int i;
	obj->id = 0xaee69d68;
	return obj;
}

tlo_t * tl_inputPrivacyKeyAbout()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPrivacyKeyAbout");
	int i;
	obj->id = 0x3823cc40;
	return obj;
}

tlo_t * tl_inputPrivacyKeyBirthday()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPrivacyKeyBirthday");
	int i;
	obj->id = 0xd65a11cc;
	return obj;
}

tlo_t * tl_privacyKeyStatusTimestamp()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "privacyKeyStatusTimestamp");
	int i;
	obj->id = 0xbc2eab30;
	return obj;
}

tlo_t * tl_privacyKeyChatInvite()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "privacyKeyChatInvite");
	int i;
	obj->id = 0x500e6dfa;
	return obj;
}

tlo_t * tl_privacyKeyPhoneCall()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "privacyKeyPhoneCall");
	int i;
	obj->id = 0x3d662b7b;
	return obj;
}

tlo_t * tl_privacyKeyPhoneP2P()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "privacyKeyPhoneP2P");
	int i;
	obj->id = 0x39491cc8;
	return obj;
}

tlo_t * tl_privacyKeyForwards()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "privacyKeyForwards");
	int i;
	obj->id = 0x69ec56a3;
	return obj;
}

tlo_t * tl_privacyKeyProfilePhoto()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "privacyKeyProfilePhoto");
	int i;
	obj->id = 0x96151fed;
	return obj;
}

tlo_t * tl_privacyKeyPhoneNumber()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "privacyKeyPhoneNumber");
	int i;
	obj->id = 0xd19ae46d;
	return obj;
}

tlo_t * tl_privacyKeyAddedByPhone()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "privacyKeyAddedByPhone");
	int i;
	obj->id = 0x42ffd42b;
	return obj;
}

tlo_t * tl_privacyKeyVoiceMessages()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "privacyKeyVoiceMessages");
	int i;
	obj->id = 0x0697f414;
	return obj;
}

tlo_t * tl_privacyKeyAbout()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "privacyKeyAbout");
	int i;
	obj->id = 0xa486b761;
	return obj;
}

tlo_t * tl_privacyKeyBirthday()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "privacyKeyBirthday");
	int i;
	obj->id = 0x2000a518;
	return obj;
}

tlo_t * tl_inputPrivacyValueAllowContacts()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPrivacyValueAllowContacts");
	int i;
	obj->id = 0x0d09e07b;
	return obj;
}

tlo_t * tl_inputPrivacyValueAllowAll()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPrivacyValueAllowAll");
	int i;
	obj->id = 0x184b35ce;
	return obj;
}

tlo_t * tl_inputPrivacyValueAllowUsers(InputUser *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPrivacyValueAllowUsers");
	int i;
	obj->id = 0x131cc67f;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<InputUser>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[0]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_inputPrivacyValueDisallowContacts()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPrivacyValueDisallowContacts");
	int i;
	obj->id = 0x0ba52007;
	return obj;
}

tlo_t * tl_inputPrivacyValueDisallowAll()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPrivacyValueDisallowAll");
	int i;
	obj->id = 0xd66b66c9;
	return obj;
}

tlo_t * tl_inputPrivacyValueDisallowUsers(InputUser *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPrivacyValueDisallowUsers");
	int i;
	obj->id = 0x90110467;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<InputUser>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[0]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_inputPrivacyValueAllowChatParticipants(long *arg_chats, int len_arg_chats)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPrivacyValueAllowChatParticipants");
	int i;
	obj->id = 0x840649cf;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<long>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			buf_t b = buf_add_ui64(arg_chats[i]);
			buf_cat(obj->objs[0]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_inputPrivacyValueDisallowChatParticipants(long *arg_chats, int len_arg_chats)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPrivacyValueDisallowChatParticipants");
	int i;
	obj->id = 0xe94f0f86;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<long>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			buf_t b = buf_add_ui64(arg_chats[i]);
			buf_cat(obj->objs[0]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_inputPrivacyValueAllowCloseFriends()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPrivacyValueAllowCloseFriends");
	int i;
	obj->id = 0x2f453e49;
	return obj;
}

tlo_t * tl_inputPrivacyValueAllowPremium()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPrivacyValueAllowPremium");
	int i;
	obj->id = 0x77cdc9f1;
	return obj;
}

tlo_t * tl_privacyValueAllowContacts()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "privacyValueAllowContacts");
	int i;
	obj->id = 0xfffe1bac;
	return obj;
}

tlo_t * tl_privacyValueAllowAll()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "privacyValueAllowAll");
	int i;
	obj->id = 0x65427b82;
	return obj;
}

tlo_t * tl_privacyValueAllowUsers(long *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "privacyValueAllowUsers");
	int i;
	obj->id = 0xb8905fb2;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<long>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			buf_t b = buf_add_ui64(arg_users[i]);
			buf_cat(obj->objs[0]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_privacyValueDisallowContacts()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "privacyValueDisallowContacts");
	int i;
	obj->id = 0xf888fa1a;
	return obj;
}

tlo_t * tl_privacyValueDisallowAll()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "privacyValueDisallowAll");
	int i;
	obj->id = 0x8b73e763;
	return obj;
}

tlo_t * tl_privacyValueDisallowUsers(long *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "privacyValueDisallowUsers");
	int i;
	obj->id = 0xe4621141;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<long>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			buf_t b = buf_add_ui64(arg_users[i]);
			buf_cat(obj->objs[0]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_privacyValueAllowChatParticipants(long *arg_chats, int len_arg_chats)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "privacyValueAllowChatParticipants");
	int i;
	obj->id = 0x6b134e8e;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<long>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			buf_t b = buf_add_ui64(arg_chats[i]);
			buf_cat(obj->objs[0]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_privacyValueDisallowChatParticipants(long *arg_chats, int len_arg_chats)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "privacyValueDisallowChatParticipants");
	int i;
	obj->id = 0x41c87565;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<long>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			buf_t b = buf_add_ui64(arg_chats[i]);
			buf_cat(obj->objs[0]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_privacyValueAllowCloseFriends()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "privacyValueAllowCloseFriends");
	int i;
	obj->id = 0xf7e8d89b;
	return obj;
}

tlo_t * tl_privacyValueAllowPremium()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "privacyValueAllowPremium");
	int i;
	obj->id = 0xece9814b;
	return obj;
}

tlo_t * tl_account_privacyRules(PrivacyRule *arg_rules, int len_arg_rules, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_privacyRules");
	int i;
	obj->id = 0x50a04e45;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<PrivacyRule>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "rules");
	if (arg_rules){
		for(i=0; i<len_arg_rules; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_rules[i]->id);
			buf_cat(obj->objs[0]->value, arg_rules[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[1]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[2]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_accountDaysTTL(int arg_days)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "accountDaysTTL");
	int i;
	obj->id = 0xb8d0afdf;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_days);
	strcpy(obj->objs[0]->name, "days");
	return obj;
}

tlo_t * tl_documentAttributeImageSize(int arg_w, int arg_h)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "documentAttributeImageSize");
	int i;
	obj->id = 0x6c37c15c;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_w);
	strcpy(obj->objs[0]->name, "w");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_h);
	strcpy(obj->objs[1]->name, "h");
	return obj;
}

tlo_t * tl_documentAttributeAnimated()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "documentAttributeAnimated");
	int i;
	obj->id = 0x11b58939;
	return obj;
}

tlo_t * tl_documentAttributeSticker(bool arg_mask, const char * arg_alt, InputStickerSet arg_stickerset, MaskCoords arg_mask_coords)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "documentAttributeSticker");
	int i;
	obj->id = 0x6319d612;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_mask);
	strcpy(obj->objs[1]->name, "mask");
	if (arg_mask)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument string
	if (arg_alt){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_alt, strlen(arg_alt));
		strcpy(obj->objs[2]->name, "alt");
	}


	//parse argument InputStickerSet
	if (arg_stickerset){
		obj->objs[3] = arg_stickerset;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "stickerset");
	}


	//parse argument MaskCoords
	if (arg_mask_coords){
		obj->objs[4] = arg_mask_coords;
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "mask_coords");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_documentAttributeVideo(bool arg_round_message, bool arg_supports_streaming, bool arg_nosound, double arg_duration, int arg_w, int arg_h, int arg_preload_prefix_size, double arg_video_start_ts, const char * arg_video_codec)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "documentAttributeVideo");
	int i;
	obj->id = 0x43c57c48;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 10;
	obj->objs = 
		(tlo_t **)MALLOC(10 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_round_message);
	strcpy(obj->objs[1]->name, "round_message");
	if (arg_round_message)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_supports_streaming);
	strcpy(obj->objs[2]->name, "supports_streaming");
	if (arg_supports_streaming)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 3;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_nosound);
	strcpy(obj->objs[3]->name, "nosound");
	if (arg_nosound)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument double
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_duration);
	strcpy(obj->objs[4]->name, "duration");

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_w);
	strcpy(obj->objs[5]->name, "w");

	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_h);
	strcpy(obj->objs[6]->name, "h");

	//parse argument int
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 2;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_preload_prefix_size);
	strcpy(obj->objs[7]->name, "preload_prefix_size");
	if (arg_preload_prefix_size)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument double
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 4;
	obj->objs[8]->type = TYPE_LONG;
	obj->objs[8]->value = 
		buf_add_ui64(arg_video_start_ts);
	strcpy(obj->objs[8]->name, "video_start_ts");
	if (arg_video_start_ts)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument string
	if (arg_video_codec){
		obj->objs[9] = NEW(tlo_t, return NULL);
		obj->objs[9]->flag_num = 1;
		obj->objs[9]->flag_bit = 5;
		obj->objs[9]->type = TYPE_STRING;
		obj->objs[9]->value = 
			buf_add((ui8_t *)arg_video_codec, strlen(arg_video_codec));
		strcpy(obj->objs[9]->name, "video_codec");
		flagsv[nflags-1] |= (1 << 5);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_documentAttributeAudio(bool arg_voice, int arg_duration, const char * arg_title, const char * arg_performer, unsigned char * arg_waveform, int len_arg_waveform)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "documentAttributeAudio");
	int i;
	obj->id = 0x9852f9c6;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 10;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_voice);
	strcpy(obj->objs[1]->name, "voice");
	if (arg_voice)
		flagsv[nflags-1] |= (1 << 10);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_duration);
	strcpy(obj->objs[2]->name, "duration");

	//parse argument string
	if (arg_title){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[3]->name, "title");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_performer){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 1;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_performer, strlen(arg_performer));
		strcpy(obj->objs[4]->name, "performer");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument bytes
	if (arg_waveform){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 2;
		obj->objs[5]->type = TYPE_BYTES;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_waveform, len_arg_waveform);
		strcpy(obj->objs[5]->name, "waveform");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_documentAttributeFilename(const char * arg_file_name)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "documentAttributeFilename");
	int i;
	obj->id = 0x15590068;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_file_name){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_file_name, strlen(arg_file_name));
		strcpy(obj->objs[0]->name, "file_name");
	}

	return obj;
}

tlo_t * tl_documentAttributeHasStickers()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "documentAttributeHasStickers");
	int i;
	obj->id = 0x9801d2f7;
	return obj;
}

tlo_t * tl_documentAttributeCustomEmoji(bool arg_free, bool arg_text_color, const char * arg_alt, InputStickerSet arg_stickerset)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "documentAttributeCustomEmoji");
	int i;
	obj->id = 0xfd149899;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_free);
	strcpy(obj->objs[1]->name, "free");
	if (arg_free)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_text_color);
	strcpy(obj->objs[2]->name, "text_color");
	if (arg_text_color)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument string
	if (arg_alt){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_alt, strlen(arg_alt));
		strcpy(obj->objs[3]->name, "alt");
	}


	//parse argument InputStickerSet
	if (arg_stickerset){
		obj->objs[4] = arg_stickerset;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "stickerset");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_stickersNotModified()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_stickersNotModified");
	int i;
	obj->id = 0xf1749a22;
	return obj;
}

tlo_t * tl_messages_stickers(long arg_hash, Document *arg_stickers, int len_arg_stickers)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_stickers");
	int i;
	obj->id = 0x30a6ec7e;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");

	//parse argument Vector<Document>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "stickers");
	if (arg_stickers){
		for(i=0; i<len_arg_stickers; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_stickers[i]->id);
			buf_cat(obj->objs[1]->value, arg_stickers[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_stickerPack(const char * arg_emoticon, long *arg_documents, int len_arg_documents)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stickerPack");
	int i;
	obj->id = 0x12b299d4;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_emoticon){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_emoticon, strlen(arg_emoticon));
		strcpy(obj->objs[0]->name, "emoticon");
	}


	//parse argument Vector<long>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "documents");
	if (arg_documents){
		for(i=0; i<len_arg_documents; ++i){
			buf_t b = buf_add_ui64(arg_documents[i]);
			buf_cat(obj->objs[1]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_messages_allStickersNotModified()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_allStickersNotModified");
	int i;
	obj->id = 0xe86602c3;
	return obj;
}

tlo_t * tl_messages_allStickers(long arg_hash, StickerSet *arg_sets, int len_arg_sets)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_allStickers");
	int i;
	obj->id = 0xcdbbcebb;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");

	//parse argument Vector<StickerSet>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "sets");
	if (arg_sets){
		for(i=0; i<len_arg_sets; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_sets[i]->id);
			buf_cat(obj->objs[1]->value, arg_sets[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_messages_affectedMessages(int arg_pts, int arg_pts_count)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_affectedMessages");
	int i;
	obj->id = 0x84d19185;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_pts);
	strcpy(obj->objs[0]->name, "pts");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_pts_count);
	strcpy(obj->objs[1]->name, "pts_count");
	return obj;
}

tlo_t * tl_webPageEmpty(long arg_id, const char * arg_url)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "webPageEmpty");
	int i;
	obj->id = 0x211a1788;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[1]->name, "id");

	//parse argument string
	if (arg_url){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[2]->name, "url");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_webPagePending(long arg_id, const char * arg_url, int arg_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "webPagePending");
	int i;
	obj->id = 0xb0d13e47;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[1]->name, "id");

	//parse argument string
	if (arg_url){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[2]->name, "url");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[3]->name, "date");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_webPage(bool arg_has_large_media, long arg_id, const char * arg_url, const char * arg_display_url, int arg_hash, const char * arg_type, const char * arg_site_name, const char * arg_title, const char * arg_description, Photo arg_photo, const char * arg_embed_url, const char * arg_embed_type, int arg_embed_width, int arg_embed_height, int arg_duration, const char * arg_author, Document arg_document, Page arg_cached_page, WebPageAttribute *arg_attributes, int len_arg_attributes)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "webPage");
	int i;
	obj->id = 0xe89c45b2;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 20;
	obj->objs = 
		(tlo_t **)MALLOC(20 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 13;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_has_large_media);
	strcpy(obj->objs[1]->name, "has_large_media");
	if (arg_has_large_media)
		flagsv[nflags-1] |= (1 << 13);

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[2]->name, "id");

	//parse argument string
	if (arg_url){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[3]->name, "url");
	}


	//parse argument string
	if (arg_display_url){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_display_url, strlen(arg_display_url));
		strcpy(obj->objs[4]->name, "display_url");
	}


	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_hash);
	strcpy(obj->objs[5]->name, "hash");

	//parse argument string
	if (arg_type){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 0;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_type, strlen(arg_type));
		strcpy(obj->objs[6]->name, "type");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_site_name){
		obj->objs[7] = NEW(tlo_t, return NULL);
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 1;
		obj->objs[7]->type = TYPE_STRING;
		obj->objs[7]->value = 
			buf_add((ui8_t *)arg_site_name, strlen(arg_site_name));
		strcpy(obj->objs[7]->name, "site_name");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument string
	if (arg_title){
		obj->objs[8] = NEW(tlo_t, return NULL);
		obj->objs[8]->flag_num = 1;
		obj->objs[8]->flag_bit = 2;
		obj->objs[8]->type = TYPE_STRING;
		obj->objs[8]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[8]->name, "title");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument string
	if (arg_description){
		obj->objs[9] = NEW(tlo_t, return NULL);
		obj->objs[9]->flag_num = 1;
		obj->objs[9]->flag_bit = 3;
		obj->objs[9]->type = TYPE_STRING;
		obj->objs[9]->value = 
			buf_add((ui8_t *)arg_description, strlen(arg_description));
		strcpy(obj->objs[9]->name, "description");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument Photo
	if (arg_photo){
		obj->objs[10] = arg_photo;
		obj->objs[10]->flag_num = 1;
		obj->objs[10]->flag_bit = 4;
	strcpy(obj->objs[10]->name, "photo");
		flagsv[nflags-1] |= (1 << 4);
	}


	//parse argument string
	if (arg_embed_url){
		obj->objs[11] = NEW(tlo_t, return NULL);
		obj->objs[11]->flag_num = 1;
		obj->objs[11]->flag_bit = 5;
		obj->objs[11]->type = TYPE_STRING;
		obj->objs[11]->value = 
			buf_add((ui8_t *)arg_embed_url, strlen(arg_embed_url));
		strcpy(obj->objs[11]->name, "embed_url");
		flagsv[nflags-1] |= (1 << 5);
	}


	//parse argument string
	if (arg_embed_type){
		obj->objs[12] = NEW(tlo_t, return NULL);
		obj->objs[12]->flag_num = 1;
		obj->objs[12]->flag_bit = 5;
		obj->objs[12]->type = TYPE_STRING;
		obj->objs[12]->value = 
			buf_add((ui8_t *)arg_embed_type, strlen(arg_embed_type));
		strcpy(obj->objs[12]->name, "embed_type");
		flagsv[nflags-1] |= (1 << 5);
	}


	//parse argument int
	obj->objs[13] = NEW(tlo_t, return NULL);
	obj->objs[13]->flag_num = 1;
	obj->objs[13]->flag_bit = 6;
	obj->objs[13]->type = TYPE_INT;
	obj->objs[13]->value = 
		buf_add_ui32(arg_embed_width);
	strcpy(obj->objs[13]->name, "embed_width");
	if (arg_embed_width)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument int
	obj->objs[14] = NEW(tlo_t, return NULL);
	obj->objs[14]->flag_num = 1;
	obj->objs[14]->flag_bit = 6;
	obj->objs[14]->type = TYPE_INT;
	obj->objs[14]->value = 
		buf_add_ui32(arg_embed_height);
	strcpy(obj->objs[14]->name, "embed_height");
	if (arg_embed_height)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument int
	obj->objs[15] = NEW(tlo_t, return NULL);
	obj->objs[15]->flag_num = 1;
	obj->objs[15]->flag_bit = 7;
	obj->objs[15]->type = TYPE_INT;
	obj->objs[15]->value = 
		buf_add_ui32(arg_duration);
	strcpy(obj->objs[15]->name, "duration");
	if (arg_duration)
		flagsv[nflags-1] |= (1 << 7);

	//parse argument string
	if (arg_author){
		obj->objs[16] = NEW(tlo_t, return NULL);
		obj->objs[16]->flag_num = 1;
		obj->objs[16]->flag_bit = 8;
		obj->objs[16]->type = TYPE_STRING;
		obj->objs[16]->value = 
			buf_add((ui8_t *)arg_author, strlen(arg_author));
		strcpy(obj->objs[16]->name, "author");
		flagsv[nflags-1] |= (1 << 8);
	}


	//parse argument Document
	if (arg_document){
		obj->objs[17] = arg_document;
		obj->objs[17]->flag_num = 1;
		obj->objs[17]->flag_bit = 9;
	strcpy(obj->objs[17]->name, "document");
		flagsv[nflags-1] |= (1 << 9);
	}


	//parse argument Page
	if (arg_cached_page){
		obj->objs[18] = arg_cached_page;
		obj->objs[18]->flag_num = 1;
		obj->objs[18]->flag_bit = 10;
	strcpy(obj->objs[18]->name, "cached_page");
		flagsv[nflags-1] |= (1 << 10);
	}


	//parse argument Vector<WebPageAttribute>
	obj->objs[19] = NEW(tlo_t, return NULL);
	obj->objs[19]->flag_num = 1;
	obj->objs[19]->flag_bit = 12;
	obj->objs[19]->type = TYPE_VECTOR;
	strcpy(obj->objs[19]->name, "attributes");
	if (arg_attributes){
		for(i=0; i<len_arg_attributes; ++i){
			obj->objs[19]->value = buf_add_ui32(arg_attributes[i]->id);
			buf_cat(obj->objs[19]->value, arg_attributes[i]->value);
		}
		flagsv[nflags-1] |= (1 << 12);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_webPageNotModified(int arg_cached_page_views)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "webPageNotModified");
	int i;
	obj->id = 0x7311ca11;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_cached_page_views);
	strcpy(obj->objs[1]->name, "cached_page_views");
	if (arg_cached_page_views)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_authorization(bool arg_current, bool arg_official_app, bool arg_password_pending, bool arg_encrypted_requests_disabled, bool arg_call_requests_disabled, bool arg_unconfirmed, long arg_hash, const char * arg_device_model, const char * arg_platform, const char * arg_system_version, int arg_api_id, const char * arg_app_name, const char * arg_app_version, int arg_date_created, int arg_date_active, const char * arg_ip, const char * arg_country, const char * arg_region)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "authorization");
	int i;
	obj->id = 0xad01d61d;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 19;
	obj->objs = 
		(tlo_t **)MALLOC(19 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_current);
	strcpy(obj->objs[1]->name, "current");
	if (arg_current)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_official_app);
	strcpy(obj->objs[2]->name, "official_app");
	if (arg_official_app)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_password_pending);
	strcpy(obj->objs[3]->name, "password_pending");
	if (arg_password_pending)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 3;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_encrypted_requests_disabled);
	strcpy(obj->objs[4]->name, "encrypted_requests_disabled");
	if (arg_encrypted_requests_disabled)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 4;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_call_requests_disabled);
	strcpy(obj->objs[5]->name, "call_requests_disabled");
	if (arg_call_requests_disabled)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument true
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 5;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_unconfirmed);
	strcpy(obj->objs[6]->name, "unconfirmed");
	if (arg_unconfirmed)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument long
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_LONG;
	obj->objs[7]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[7]->name, "hash");

	//parse argument string
	if (arg_device_model){
		obj->objs[8] = NEW(tlo_t, return NULL);
		obj->objs[8]->flag_num = 0;
		obj->objs[8]->flag_bit = 0;
		obj->objs[8]->type = TYPE_STRING;
		obj->objs[8]->value = 
			buf_add((ui8_t *)arg_device_model, strlen(arg_device_model));
		strcpy(obj->objs[8]->name, "device_model");
	}


	//parse argument string
	if (arg_platform){
		obj->objs[9] = NEW(tlo_t, return NULL);
		obj->objs[9]->flag_num = 0;
		obj->objs[9]->flag_bit = 0;
		obj->objs[9]->type = TYPE_STRING;
		obj->objs[9]->value = 
			buf_add((ui8_t *)arg_platform, strlen(arg_platform));
		strcpy(obj->objs[9]->name, "platform");
	}


	//parse argument string
	if (arg_system_version){
		obj->objs[10] = NEW(tlo_t, return NULL);
		obj->objs[10]->flag_num = 0;
		obj->objs[10]->flag_bit = 0;
		obj->objs[10]->type = TYPE_STRING;
		obj->objs[10]->value = 
			buf_add((ui8_t *)arg_system_version, strlen(arg_system_version));
		strcpy(obj->objs[10]->name, "system_version");
	}


	//parse argument int
	obj->objs[11] = NEW(tlo_t, return NULL);
	obj->objs[11]->flag_num = 0;
	obj->objs[11]->flag_bit = 0;
	obj->objs[11]->type = TYPE_INT;
	obj->objs[11]->value = 
		buf_add_ui32(arg_api_id);
	strcpy(obj->objs[11]->name, "api_id");

	//parse argument string
	if (arg_app_name){
		obj->objs[12] = NEW(tlo_t, return NULL);
		obj->objs[12]->flag_num = 0;
		obj->objs[12]->flag_bit = 0;
		obj->objs[12]->type = TYPE_STRING;
		obj->objs[12]->value = 
			buf_add((ui8_t *)arg_app_name, strlen(arg_app_name));
		strcpy(obj->objs[12]->name, "app_name");
	}


	//parse argument string
	if (arg_app_version){
		obj->objs[13] = NEW(tlo_t, return NULL);
		obj->objs[13]->flag_num = 0;
		obj->objs[13]->flag_bit = 0;
		obj->objs[13]->type = TYPE_STRING;
		obj->objs[13]->value = 
			buf_add((ui8_t *)arg_app_version, strlen(arg_app_version));
		strcpy(obj->objs[13]->name, "app_version");
	}


	//parse argument int
	obj->objs[14] = NEW(tlo_t, return NULL);
	obj->objs[14]->flag_num = 0;
	obj->objs[14]->flag_bit = 0;
	obj->objs[14]->type = TYPE_INT;
	obj->objs[14]->value = 
		buf_add_ui32(arg_date_created);
	strcpy(obj->objs[14]->name, "date_created");

	//parse argument int
	obj->objs[15] = NEW(tlo_t, return NULL);
	obj->objs[15]->flag_num = 0;
	obj->objs[15]->flag_bit = 0;
	obj->objs[15]->type = TYPE_INT;
	obj->objs[15]->value = 
		buf_add_ui32(arg_date_active);
	strcpy(obj->objs[15]->name, "date_active");

	//parse argument string
	if (arg_ip){
		obj->objs[16] = NEW(tlo_t, return NULL);
		obj->objs[16]->flag_num = 0;
		obj->objs[16]->flag_bit = 0;
		obj->objs[16]->type = TYPE_STRING;
		obj->objs[16]->value = 
			buf_add((ui8_t *)arg_ip, strlen(arg_ip));
		strcpy(obj->objs[16]->name, "ip");
	}


	//parse argument string
	if (arg_country){
		obj->objs[17] = NEW(tlo_t, return NULL);
		obj->objs[17]->flag_num = 0;
		obj->objs[17]->flag_bit = 0;
		obj->objs[17]->type = TYPE_STRING;
		obj->objs[17]->value = 
			buf_add((ui8_t *)arg_country, strlen(arg_country));
		strcpy(obj->objs[17]->name, "country");
	}


	//parse argument string
	if (arg_region){
		obj->objs[18] = NEW(tlo_t, return NULL);
		obj->objs[18]->flag_num = 0;
		obj->objs[18]->flag_bit = 0;
		obj->objs[18]->type = TYPE_STRING;
		obj->objs[18]->value = 
			buf_add((ui8_t *)arg_region, strlen(arg_region));
		strcpy(obj->objs[18]->name, "region");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_account_authorizations(int arg_authorization_ttl_days, Authorization *arg_authorizations, int len_arg_authorizations)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_authorizations");
	int i;
	obj->id = 0x4bff8ea0;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_authorization_ttl_days);
	strcpy(obj->objs[0]->name, "authorization_ttl_days");

	//parse argument Vector<Authorization>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "authorizations");
	if (arg_authorizations){
		for(i=0; i<len_arg_authorizations; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_authorizations[i]->id);
			buf_cat(obj->objs[1]->value, arg_authorizations[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_account_password(bool arg_has_recovery, bool arg_has_secure_values, bool arg_has_password, PasswordKdfAlgo arg_current_algo, unsigned char * arg_srp_B, int len_arg_srp_B, long arg_srp_id, const char * arg_hint, const char * arg_email_unconfirmed_pattern, PasswordKdfAlgo arg_new_algo, SecurePasswordKdfAlgo arg_new_secure_algo, unsigned char * arg_secure_random, int len_arg_secure_random, int arg_pending_reset_date, const char * arg_login_email_pattern)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_password");
	int i;
	obj->id = 0x957b50fb;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 14;
	obj->objs = 
		(tlo_t **)MALLOC(14 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_has_recovery);
	strcpy(obj->objs[1]->name, "has_recovery");
	if (arg_has_recovery)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_has_secure_values);
	strcpy(obj->objs[2]->name, "has_secure_values");
	if (arg_has_secure_values)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_has_password);
	strcpy(obj->objs[3]->name, "has_password");
	if (arg_has_password)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument PasswordKdfAlgo
	if (arg_current_algo){
		obj->objs[4] = arg_current_algo;
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 2;
	strcpy(obj->objs[4]->name, "current_algo");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument bytes
	if (arg_srp_B){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 2;
		obj->objs[5]->type = TYPE_BYTES;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_srp_B, len_arg_srp_B);
		strcpy(obj->objs[5]->name, "srp_B");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument long
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 2;
	obj->objs[6]->type = TYPE_LONG;
	obj->objs[6]->value = 
		buf_add_ui64(arg_srp_id);
	strcpy(obj->objs[6]->name, "srp_id");
	if (arg_srp_id)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument string
	if (arg_hint){
		obj->objs[7] = NEW(tlo_t, return NULL);
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 3;
		obj->objs[7]->type = TYPE_STRING;
		obj->objs[7]->value = 
			buf_add((ui8_t *)arg_hint, strlen(arg_hint));
		strcpy(obj->objs[7]->name, "hint");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument string
	if (arg_email_unconfirmed_pattern){
		obj->objs[8] = NEW(tlo_t, return NULL);
		obj->objs[8]->flag_num = 1;
		obj->objs[8]->flag_bit = 4;
		obj->objs[8]->type = TYPE_STRING;
		obj->objs[8]->value = 
			buf_add((ui8_t *)arg_email_unconfirmed_pattern, strlen(arg_email_unconfirmed_pattern));
		strcpy(obj->objs[8]->name, "email_unconfirmed_pattern");
		flagsv[nflags-1] |= (1 << 4);
	}


	//parse argument PasswordKdfAlgo
	if (arg_new_algo){
		obj->objs[9] = arg_new_algo;
		obj->objs[9]->flag_num = 0;
		obj->objs[9]->flag_bit = 0;
	strcpy(obj->objs[9]->name, "new_algo");
	}


	//parse argument SecurePasswordKdfAlgo
	if (arg_new_secure_algo){
		obj->objs[10] = arg_new_secure_algo;
		obj->objs[10]->flag_num = 0;
		obj->objs[10]->flag_bit = 0;
	strcpy(obj->objs[10]->name, "new_secure_algo");
	}


	//parse argument bytes
	if (arg_secure_random){
		obj->objs[11] = NEW(tlo_t, return NULL);
		obj->objs[11]->flag_num = 0;
		obj->objs[11]->flag_bit = 0;
		obj->objs[11]->type = TYPE_BYTES;
		obj->objs[11]->value = 
			buf_add((ui8_t *)arg_secure_random, len_arg_secure_random);
		strcpy(obj->objs[11]->name, "secure_random");
	}


	//parse argument int
	obj->objs[12] = NEW(tlo_t, return NULL);
	obj->objs[12]->flag_num = 1;
	obj->objs[12]->flag_bit = 5;
	obj->objs[12]->type = TYPE_INT;
	obj->objs[12]->value = 
		buf_add_ui32(arg_pending_reset_date);
	strcpy(obj->objs[12]->name, "pending_reset_date");
	if (arg_pending_reset_date)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument string
	if (arg_login_email_pattern){
		obj->objs[13] = NEW(tlo_t, return NULL);
		obj->objs[13]->flag_num = 1;
		obj->objs[13]->flag_bit = 6;
		obj->objs[13]->type = TYPE_STRING;
		obj->objs[13]->value = 
			buf_add((ui8_t *)arg_login_email_pattern, strlen(arg_login_email_pattern));
		strcpy(obj->objs[13]->name, "login_email_pattern");
		flagsv[nflags-1] |= (1 << 6);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_account_passwordSettings(const char * arg_email, SecureSecretSettings arg_secure_settings)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_passwordSettings");
	int i;
	obj->id = 0x9a5c33e5;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_email){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_email, strlen(arg_email));
		strcpy(obj->objs[1]->name, "email");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument SecureSecretSettings
	if (arg_secure_settings){
		obj->objs[2] = arg_secure_settings;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 1;
	strcpy(obj->objs[2]->name, "secure_settings");
		flagsv[nflags-1] |= (1 << 1);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_account_passwordInputSettings(PasswordKdfAlgo arg_new_algo, unsigned char * arg_new_password_hash, int len_arg_new_password_hash, const char * arg_hint, const char * arg_email, SecureSecretSettings arg_new_secure_settings)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_passwordInputSettings");
	int i;
	obj->id = 0xc23727c9;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument PasswordKdfAlgo
	if (arg_new_algo){
		obj->objs[1] = arg_new_algo;
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "new_algo");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument bytes
	if (arg_new_password_hash){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_BYTES;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_new_password_hash, len_arg_new_password_hash);
		strcpy(obj->objs[2]->name, "new_password_hash");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_hint){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_hint, strlen(arg_hint));
		strcpy(obj->objs[3]->name, "hint");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_email){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 1;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_email, strlen(arg_email));
		strcpy(obj->objs[4]->name, "email");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument SecureSecretSettings
	if (arg_new_secure_settings){
		obj->objs[5] = arg_new_secure_settings;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 2;
	strcpy(obj->objs[5]->name, "new_secure_settings");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_auth_passwordRecovery(const char * arg_email_pattern)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_passwordRecovery");
	int i;
	obj->id = 0x137948a5;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_email_pattern){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_email_pattern, strlen(arg_email_pattern));
		strcpy(obj->objs[0]->name, "email_pattern");
	}

	return obj;
}

tlo_t * tl_receivedNotifyMessage(int arg_id, int arg_flags)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "receivedNotifyMessage");
	int i;
	obj->id = 0xa384b779;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_flags);
	strcpy(obj->objs[1]->name, "flags");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_chatInviteExported(bool arg_revoked, bool arg_permanent, bool arg_request_needed, const char * arg_link, long arg_admin_id, int arg_date, int arg_start_date, int arg_expire_date, int arg_usage_limit, int arg_usage, int arg_requested, int arg_subscription_expired, const char * arg_title, StarsSubscriptionPricing arg_subscription_pricing)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatInviteExported");
	int i;
	obj->id = 0xa22cbd96;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 15;
	obj->objs = 
		(tlo_t **)MALLOC(15 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_revoked);
	strcpy(obj->objs[1]->name, "revoked");
	if (arg_revoked)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 5;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_permanent);
	strcpy(obj->objs[2]->name, "permanent");
	if (arg_permanent)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 6;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_request_needed);
	strcpy(obj->objs[3]->name, "request_needed");
	if (arg_request_needed)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument string
	if (arg_link){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_link, strlen(arg_link));
		strcpy(obj->objs[4]->name, "link");
	}


	//parse argument long
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_LONG;
	obj->objs[5]->value = 
		buf_add_ui64(arg_admin_id);
	strcpy(obj->objs[5]->name, "admin_id");

	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[6]->name, "date");

	//parse argument int
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 4;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_start_date);
	strcpy(obj->objs[7]->name, "start_date");
	if (arg_start_date)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument int
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 1;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_expire_date);
	strcpy(obj->objs[8]->name, "expire_date");
	if (arg_expire_date)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument int
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 1;
	obj->objs[9]->flag_bit = 2;
	obj->objs[9]->type = TYPE_INT;
	obj->objs[9]->value = 
		buf_add_ui32(arg_usage_limit);
	strcpy(obj->objs[9]->name, "usage_limit");
	if (arg_usage_limit)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument int
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 1;
	obj->objs[10]->flag_bit = 3;
	obj->objs[10]->type = TYPE_INT;
	obj->objs[10]->value = 
		buf_add_ui32(arg_usage);
	strcpy(obj->objs[10]->name, "usage");
	if (arg_usage)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument int
	obj->objs[11] = NEW(tlo_t, return NULL);
	obj->objs[11]->flag_num = 1;
	obj->objs[11]->flag_bit = 7;
	obj->objs[11]->type = TYPE_INT;
	obj->objs[11]->value = 
		buf_add_ui32(arg_requested);
	strcpy(obj->objs[11]->name, "requested");
	if (arg_requested)
		flagsv[nflags-1] |= (1 << 7);

	//parse argument int
	obj->objs[12] = NEW(tlo_t, return NULL);
	obj->objs[12]->flag_num = 1;
	obj->objs[12]->flag_bit = 10;
	obj->objs[12]->type = TYPE_INT;
	obj->objs[12]->value = 
		buf_add_ui32(arg_subscription_expired);
	strcpy(obj->objs[12]->name, "subscription_expired");
	if (arg_subscription_expired)
		flagsv[nflags-1] |= (1 << 10);

	//parse argument string
	if (arg_title){
		obj->objs[13] = NEW(tlo_t, return NULL);
		obj->objs[13]->flag_num = 1;
		obj->objs[13]->flag_bit = 8;
		obj->objs[13]->type = TYPE_STRING;
		obj->objs[13]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[13]->name, "title");
		flagsv[nflags-1] |= (1 << 8);
	}


	//parse argument StarsSubscriptionPricing
	if (arg_subscription_pricing){
		obj->objs[14] = arg_subscription_pricing;
		obj->objs[14]->flag_num = 1;
		obj->objs[14]->flag_bit = 9;
	strcpy(obj->objs[14]->name, "subscription_pricing");
		flagsv[nflags-1] |= (1 << 9);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_chatInvitePublicJoinRequests()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatInvitePublicJoinRequests");
	int i;
	obj->id = 0xed107ab7;
	return obj;
}

tlo_t * tl_chatInviteAlready(Chat arg_chat)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatInviteAlready");
	int i;
	obj->id = 0x5a686d7c;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Chat
	if (arg_chat){
		obj->objs[0] = arg_chat;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "chat");
	}

	return obj;
}

tlo_t * tl_chatInvite(bool arg_channel, bool arg_broadcast, bool arg_public, bool arg_megagroup, bool arg_request_needed, bool arg_verified, bool arg_scam, bool arg_fake, bool arg_can_refulfill_subscription, const char * arg_title, const char * arg_about, Photo arg_photo, int arg_participants_count, User *arg_participants, int len_arg_participants, int arg_color, StarsSubscriptionPricing arg_subscription_pricing, long arg_subscription_form_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatInvite");
	int i;
	obj->id = 0xfe65389d;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 18;
	obj->objs = 
		(tlo_t **)MALLOC(18 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_channel);
	strcpy(obj->objs[1]->name, "channel");
	if (arg_channel)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_broadcast);
	strcpy(obj->objs[2]->name, "broadcast");
	if (arg_broadcast)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_public);
	strcpy(obj->objs[3]->name, "public");
	if (arg_public)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 3;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_megagroup);
	strcpy(obj->objs[4]->name, "megagroup");
	if (arg_megagroup)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 6;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_request_needed);
	strcpy(obj->objs[5]->name, "request_needed");
	if (arg_request_needed)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument true
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 7;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_verified);
	strcpy(obj->objs[6]->name, "verified");
	if (arg_verified)
		flagsv[nflags-1] |= (1 << 7);

	//parse argument true
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 8;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_scam);
	strcpy(obj->objs[7]->name, "scam");
	if (arg_scam)
		flagsv[nflags-1] |= (1 << 8);

	//parse argument true
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 9;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_fake);
	strcpy(obj->objs[8]->name, "fake");
	if (arg_fake)
		flagsv[nflags-1] |= (1 << 9);

	//parse argument true
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 1;
	obj->objs[9]->flag_bit = 11;
	obj->objs[9]->type = TYPE_INT;
	obj->objs[9]->value = 
		buf_add_ui32(arg_can_refulfill_subscription);
	strcpy(obj->objs[9]->name, "can_refulfill_subscription");
	if (arg_can_refulfill_subscription)
		flagsv[nflags-1] |= (1 << 11);

	//parse argument string
	if (arg_title){
		obj->objs[10] = NEW(tlo_t, return NULL);
		obj->objs[10]->flag_num = 0;
		obj->objs[10]->flag_bit = 0;
		obj->objs[10]->type = TYPE_STRING;
		obj->objs[10]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[10]->name, "title");
	}


	//parse argument string
	if (arg_about){
		obj->objs[11] = NEW(tlo_t, return NULL);
		obj->objs[11]->flag_num = 1;
		obj->objs[11]->flag_bit = 5;
		obj->objs[11]->type = TYPE_STRING;
		obj->objs[11]->value = 
			buf_add((ui8_t *)arg_about, strlen(arg_about));
		strcpy(obj->objs[11]->name, "about");
		flagsv[nflags-1] |= (1 << 5);
	}


	//parse argument Photo
	if (arg_photo){
		obj->objs[12] = arg_photo;
		obj->objs[12]->flag_num = 0;
		obj->objs[12]->flag_bit = 0;
	strcpy(obj->objs[12]->name, "photo");
	}


	//parse argument int
	obj->objs[13] = NEW(tlo_t, return NULL);
	obj->objs[13]->flag_num = 0;
	obj->objs[13]->flag_bit = 0;
	obj->objs[13]->type = TYPE_INT;
	obj->objs[13]->value = 
		buf_add_ui32(arg_participants_count);
	strcpy(obj->objs[13]->name, "participants_count");

	//parse argument Vector<User>
	obj->objs[14] = NEW(tlo_t, return NULL);
	obj->objs[14]->flag_num = 1;
	obj->objs[14]->flag_bit = 4;
	obj->objs[14]->type = TYPE_VECTOR;
	strcpy(obj->objs[14]->name, "participants");
	if (arg_participants){
		for(i=0; i<len_arg_participants; ++i){
			obj->objs[14]->value = buf_add_ui32(arg_participants[i]->id);
			buf_cat(obj->objs[14]->value, arg_participants[i]->value);
		}
		flagsv[nflags-1] |= (1 << 4);
	}


	//parse argument int
	obj->objs[15] = NEW(tlo_t, return NULL);
	obj->objs[15]->flag_num = 0;
	obj->objs[15]->flag_bit = 0;
	obj->objs[15]->type = TYPE_INT;
	obj->objs[15]->value = 
		buf_add_ui32(arg_color);
	strcpy(obj->objs[15]->name, "color");

	//parse argument StarsSubscriptionPricing
	if (arg_subscription_pricing){
		obj->objs[16] = arg_subscription_pricing;
		obj->objs[16]->flag_num = 1;
		obj->objs[16]->flag_bit = 10;
	strcpy(obj->objs[16]->name, "subscription_pricing");
		flagsv[nflags-1] |= (1 << 10);
	}


	//parse argument long
	obj->objs[17] = NEW(tlo_t, return NULL);
	obj->objs[17]->flag_num = 1;
	obj->objs[17]->flag_bit = 12;
	obj->objs[17]->type = TYPE_LONG;
	obj->objs[17]->value = 
		buf_add_ui64(arg_subscription_form_id);
	strcpy(obj->objs[17]->name, "subscription_form_id");
	if (arg_subscription_form_id)
		flagsv[nflags-1] |= (1 << 12);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_chatInvitePeek(Chat arg_chat, int arg_expires)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatInvitePeek");
	int i;
	obj->id = 0x61695cb0;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Chat
	if (arg_chat){
		obj->objs[0] = arg_chat;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "chat");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_expires);
	strcpy(obj->objs[1]->name, "expires");
	return obj;
}

tlo_t * tl_inputStickerSetEmpty()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputStickerSetEmpty");
	int i;
	obj->id = 0xffb62b95;
	return obj;
}

tlo_t * tl_inputStickerSetID(long arg_id, long arg_access_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputStickerSetID");
	int i;
	obj->id = 0x9de7a269;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[1]->name, "access_hash");
	return obj;
}

tlo_t * tl_inputStickerSetShortName(const char * arg_short_name)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputStickerSetShortName");
	int i;
	obj->id = 0x861cc8a0;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_short_name){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_short_name, strlen(arg_short_name));
		strcpy(obj->objs[0]->name, "short_name");
	}

	return obj;
}

tlo_t * tl_inputStickerSetAnimatedEmoji()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputStickerSetAnimatedEmoji");
	int i;
	obj->id = 0x028703c8;
	return obj;
}

tlo_t * tl_inputStickerSetDice(const char * arg_emoticon)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputStickerSetDice");
	int i;
	obj->id = 0xe67f520e;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_emoticon){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_emoticon, strlen(arg_emoticon));
		strcpy(obj->objs[0]->name, "emoticon");
	}

	return obj;
}

tlo_t * tl_inputStickerSetAnimatedEmojiAnimations()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputStickerSetAnimatedEmojiAnimations");
	int i;
	obj->id = 0x0cde3739;
	return obj;
}

tlo_t * tl_inputStickerSetPremiumGifts()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputStickerSetPremiumGifts");
	int i;
	obj->id = 0xc88b3b02;
	return obj;
}

tlo_t * tl_inputStickerSetEmojiGenericAnimations()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputStickerSetEmojiGenericAnimations");
	int i;
	obj->id = 0x04c4d4ce;
	return obj;
}

tlo_t * tl_inputStickerSetEmojiDefaultStatuses()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputStickerSetEmojiDefaultStatuses");
	int i;
	obj->id = 0x29d0f5ee;
	return obj;
}

tlo_t * tl_inputStickerSetEmojiDefaultTopicIcons()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputStickerSetEmojiDefaultTopicIcons");
	int i;
	obj->id = 0x44c1f8e9;
	return obj;
}

tlo_t * tl_inputStickerSetEmojiChannelDefaultStatuses()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputStickerSetEmojiChannelDefaultStatuses");
	int i;
	obj->id = 0x49748553;
	return obj;
}

tlo_t * tl_stickerSet(bool arg_archived, bool arg_official, bool arg_masks, bool arg_emojis, bool arg_text_color, bool arg_channel_emoji_status, bool arg_creator, int arg_installed_date, long arg_id, long arg_access_hash, const char * arg_title, const char * arg_short_name, PhotoSize *arg_thumbs, int len_arg_thumbs, int arg_thumb_dc_id, int arg_thumb_version, long arg_thumb_document_id, int arg_count, int arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stickerSet");
	int i;
	obj->id = 0x2dd14edc;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 19;
	obj->objs = 
		(tlo_t **)MALLOC(19 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_archived);
	strcpy(obj->objs[1]->name, "archived");
	if (arg_archived)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 2;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_official);
	strcpy(obj->objs[2]->name, "official");
	if (arg_official)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 3;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_masks);
	strcpy(obj->objs[3]->name, "masks");
	if (arg_masks)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 7;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_emojis);
	strcpy(obj->objs[4]->name, "emojis");
	if (arg_emojis)
		flagsv[nflags-1] |= (1 << 7);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 9;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_text_color);
	strcpy(obj->objs[5]->name, "text_color");
	if (arg_text_color)
		flagsv[nflags-1] |= (1 << 9);

	//parse argument true
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 10;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_channel_emoji_status);
	strcpy(obj->objs[6]->name, "channel_emoji_status");
	if (arg_channel_emoji_status)
		flagsv[nflags-1] |= (1 << 10);

	//parse argument true
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 11;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_creator);
	strcpy(obj->objs[7]->name, "creator");
	if (arg_creator)
		flagsv[nflags-1] |= (1 << 11);

	//parse argument int
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 0;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_installed_date);
	strcpy(obj->objs[8]->name, "installed_date");
	if (arg_installed_date)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument long
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 0;
	obj->objs[9]->flag_bit = 0;
	obj->objs[9]->type = TYPE_LONG;
	obj->objs[9]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[9]->name, "id");

	//parse argument long
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 0;
	obj->objs[10]->flag_bit = 0;
	obj->objs[10]->type = TYPE_LONG;
	obj->objs[10]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[10]->name, "access_hash");

	//parse argument string
	if (arg_title){
		obj->objs[11] = NEW(tlo_t, return NULL);
		obj->objs[11]->flag_num = 0;
		obj->objs[11]->flag_bit = 0;
		obj->objs[11]->type = TYPE_STRING;
		obj->objs[11]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[11]->name, "title");
	}


	//parse argument string
	if (arg_short_name){
		obj->objs[12] = NEW(tlo_t, return NULL);
		obj->objs[12]->flag_num = 0;
		obj->objs[12]->flag_bit = 0;
		obj->objs[12]->type = TYPE_STRING;
		obj->objs[12]->value = 
			buf_add((ui8_t *)arg_short_name, strlen(arg_short_name));
		strcpy(obj->objs[12]->name, "short_name");
	}


	//parse argument Vector<PhotoSize>
	obj->objs[13] = NEW(tlo_t, return NULL);
	obj->objs[13]->flag_num = 1;
	obj->objs[13]->flag_bit = 4;
	obj->objs[13]->type = TYPE_VECTOR;
	strcpy(obj->objs[13]->name, "thumbs");
	if (arg_thumbs){
		for(i=0; i<len_arg_thumbs; ++i){
			obj->objs[13]->value = buf_add_ui32(arg_thumbs[i]->id);
			buf_cat(obj->objs[13]->value, arg_thumbs[i]->value);
		}
		flagsv[nflags-1] |= (1 << 4);
	}


	//parse argument int
	obj->objs[14] = NEW(tlo_t, return NULL);
	obj->objs[14]->flag_num = 1;
	obj->objs[14]->flag_bit = 4;
	obj->objs[14]->type = TYPE_INT;
	obj->objs[14]->value = 
		buf_add_ui32(arg_thumb_dc_id);
	strcpy(obj->objs[14]->name, "thumb_dc_id");
	if (arg_thumb_dc_id)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument int
	obj->objs[15] = NEW(tlo_t, return NULL);
	obj->objs[15]->flag_num = 1;
	obj->objs[15]->flag_bit = 4;
	obj->objs[15]->type = TYPE_INT;
	obj->objs[15]->value = 
		buf_add_ui32(arg_thumb_version);
	strcpy(obj->objs[15]->name, "thumb_version");
	if (arg_thumb_version)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument long
	obj->objs[16] = NEW(tlo_t, return NULL);
	obj->objs[16]->flag_num = 1;
	obj->objs[16]->flag_bit = 8;
	obj->objs[16]->type = TYPE_LONG;
	obj->objs[16]->value = 
		buf_add_ui64(arg_thumb_document_id);
	strcpy(obj->objs[16]->name, "thumb_document_id");
	if (arg_thumb_document_id)
		flagsv[nflags-1] |= (1 << 8);

	//parse argument int
	obj->objs[17] = NEW(tlo_t, return NULL);
	obj->objs[17]->flag_num = 0;
	obj->objs[17]->flag_bit = 0;
	obj->objs[17]->type = TYPE_INT;
	obj->objs[17]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[17]->name, "count");

	//parse argument int
	obj->objs[18] = NEW(tlo_t, return NULL);
	obj->objs[18]->flag_num = 0;
	obj->objs[18]->flag_bit = 0;
	obj->objs[18]->type = TYPE_INT;
	obj->objs[18]->value = 
		buf_add_ui32(arg_hash);
	strcpy(obj->objs[18]->name, "hash");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_stickerSet(StickerSet arg_set, StickerPack *arg_packs, int len_arg_packs, StickerKeyword *arg_keywords, int len_arg_keywords, Document *arg_documents, int len_arg_documents)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_stickerSet");
	int i;
	obj->id = 0x6e153f16;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument StickerSet
	if (arg_set){
		obj->objs[0] = arg_set;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "set");
	}


	//parse argument Vector<StickerPack>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "packs");
	if (arg_packs){
		for(i=0; i<len_arg_packs; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_packs[i]->id);
			buf_cat(obj->objs[1]->value, arg_packs[i]->value);
		}
	}


	//parse argument Vector<StickerKeyword>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "keywords");
	if (arg_keywords){
		for(i=0; i<len_arg_keywords; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_keywords[i]->id);
			buf_cat(obj->objs[2]->value, arg_keywords[i]->value);
		}
	}


	//parse argument Vector<Document>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "documents");
	if (arg_documents){
		for(i=0; i<len_arg_documents; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_documents[i]->id);
			buf_cat(obj->objs[3]->value, arg_documents[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_messages_stickerSetNotModified()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_stickerSetNotModified");
	int i;
	obj->id = 0xd3f924eb;
	return obj;
}

tlo_t * tl_botCommand(const char * arg_command, const char * arg_description)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "botCommand");
	int i;
	obj->id = 0xc27ac8c7;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_command){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_command, strlen(arg_command));
		strcpy(obj->objs[0]->name, "command");
	}


	//parse argument string
	if (arg_description){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_description, strlen(arg_description));
		strcpy(obj->objs[1]->name, "description");
	}

	return obj;
}

tlo_t * tl_botInfo(bool arg_has_preview_medias, long arg_user_id, const char * arg_description, Photo arg_description_photo, Document arg_description_document, BotCommand *arg_commands, int len_arg_commands, BotMenuButton arg_menu_button, const char * arg_privacy_policy_url)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "botInfo");
	int i;
	obj->id = 0x82437e74;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 6;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_has_preview_medias);
	strcpy(obj->objs[1]->name, "has_preview_medias");
	if (arg_has_preview_medias)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[2]->name, "user_id");
	if (arg_user_id)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument string
	if (arg_description){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 1;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_description, strlen(arg_description));
		strcpy(obj->objs[3]->name, "description");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument Photo
	if (arg_description_photo){
		obj->objs[4] = arg_description_photo;
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 4;
	strcpy(obj->objs[4]->name, "description_photo");
		flagsv[nflags-1] |= (1 << 4);
	}


	//parse argument Document
	if (arg_description_document){
		obj->objs[5] = arg_description_document;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 5;
	strcpy(obj->objs[5]->name, "description_document");
		flagsv[nflags-1] |= (1 << 5);
	}


	//parse argument Vector<BotCommand>
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 2;
	obj->objs[6]->type = TYPE_VECTOR;
	strcpy(obj->objs[6]->name, "commands");
	if (arg_commands){
		for(i=0; i<len_arg_commands; ++i){
			obj->objs[6]->value = buf_add_ui32(arg_commands[i]->id);
			buf_cat(obj->objs[6]->value, arg_commands[i]->value);
		}
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument BotMenuButton
	if (arg_menu_button){
		obj->objs[7] = arg_menu_button;
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 3;
	strcpy(obj->objs[7]->name, "menu_button");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument string
	if (arg_privacy_policy_url){
		obj->objs[8] = NEW(tlo_t, return NULL);
		obj->objs[8]->flag_num = 1;
		obj->objs[8]->flag_bit = 7;
		obj->objs[8]->type = TYPE_STRING;
		obj->objs[8]->value = 
			buf_add((ui8_t *)arg_privacy_policy_url, strlen(arg_privacy_policy_url));
		strcpy(obj->objs[8]->name, "privacy_policy_url");
		flagsv[nflags-1] |= (1 << 7);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_keyboardButton(const char * arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "keyboardButton");
	int i;
	obj->id = 0xa2fa4880;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_text){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[0]->name, "text");
	}

	return obj;
}

tlo_t * tl_keyboardButtonUrl(const char * arg_text, const char * arg_url)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "keyboardButtonUrl");
	int i;
	obj->id = 0x258aff05;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_text){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[0]->name, "text");
	}


	//parse argument string
	if (arg_url){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[1]->name, "url");
	}

	return obj;
}

tlo_t * tl_keyboardButtonCallback(bool arg_requires_password, const char * arg_text, unsigned char * arg_data, int len_arg_data)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "keyboardButtonCallback");
	int i;
	obj->id = 0x35bbdb6b;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_requires_password);
	strcpy(obj->objs[1]->name, "requires_password");
	if (arg_requires_password)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument string
	if (arg_text){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[2]->name, "text");
	}


	//parse argument bytes
	if (arg_data){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_BYTES;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_data, len_arg_data);
		strcpy(obj->objs[3]->name, "data");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_keyboardButtonRequestPhone(const char * arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "keyboardButtonRequestPhone");
	int i;
	obj->id = 0xb16a6c29;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_text){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[0]->name, "text");
	}

	return obj;
}

tlo_t * tl_keyboardButtonRequestGeoLocation(const char * arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "keyboardButtonRequestGeoLocation");
	int i;
	obj->id = 0xfc796b3f;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_text){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[0]->name, "text");
	}

	return obj;
}

tlo_t * tl_keyboardButtonSwitchInline(bool arg_same_peer, const char * arg_text, const char * arg_query, InlineQueryPeerType *arg_peer_types, int len_arg_peer_types)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "keyboardButtonSwitchInline");
	int i;
	obj->id = 0x93b9fbb5;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_same_peer);
	strcpy(obj->objs[1]->name, "same_peer");
	if (arg_same_peer)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument string
	if (arg_text){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[2]->name, "text");
	}


	//parse argument string
	if (arg_query){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_query, strlen(arg_query));
		strcpy(obj->objs[3]->name, "query");
	}


	//parse argument Vector<InlineQueryPeerType>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 1;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "peer_types");
	if (arg_peer_types){
		for(i=0; i<len_arg_peer_types; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_peer_types[i]->id);
			buf_cat(obj->objs[4]->value, arg_peer_types[i]->value);
		}
		flagsv[nflags-1] |= (1 << 1);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_keyboardButtonGame(const char * arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "keyboardButtonGame");
	int i;
	obj->id = 0x50f41ccf;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_text){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[0]->name, "text");
	}

	return obj;
}

tlo_t * tl_keyboardButtonBuy(const char * arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "keyboardButtonBuy");
	int i;
	obj->id = 0xafd93fbb;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_text){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[0]->name, "text");
	}

	return obj;
}

tlo_t * tl_keyboardButtonUrlAuth(const char * arg_text, const char * arg_fwd_text, const char * arg_url, int arg_button_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "keyboardButtonUrlAuth");
	int i;
	obj->id = 0x10b78d29;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_text){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[1]->name, "text");
	}


	//parse argument string
	if (arg_fwd_text){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_fwd_text, strlen(arg_fwd_text));
		strcpy(obj->objs[2]->name, "fwd_text");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_url){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[3]->name, "url");
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_button_id);
	strcpy(obj->objs[4]->name, "button_id");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputKeyboardButtonUrlAuth(bool arg_request_write_access, const char * arg_text, const char * arg_fwd_text, const char * arg_url, InputUser arg_bot)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputKeyboardButtonUrlAuth");
	int i;
	obj->id = 0xd02e7fd4;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_request_write_access);
	strcpy(obj->objs[1]->name, "request_write_access");
	if (arg_request_write_access)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument string
	if (arg_text){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[2]->name, "text");
	}


	//parse argument string
	if (arg_fwd_text){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 1;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_fwd_text, strlen(arg_fwd_text));
		strcpy(obj->objs[3]->name, "fwd_text");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument string
	if (arg_url){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[4]->name, "url");
	}


	//parse argument InputUser
	if (arg_bot){
		obj->objs[5] = arg_bot;
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
	strcpy(obj->objs[5]->name, "bot");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_keyboardButtonRequestPoll(Bool arg_quiz, const char * arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "keyboardButtonRequestPoll");
	int i;
	obj->id = 0xbbc7515d;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument Bool
	if (arg_quiz){
		obj->objs[1] = arg_quiz;
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "quiz");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_text){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[2]->name, "text");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputKeyboardButtonUserProfile(const char * arg_text, InputUser arg_user_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputKeyboardButtonUserProfile");
	int i;
	obj->id = 0xe988037b;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_text){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[0]->name, "text");
	}


	//parse argument InputUser
	if (arg_user_id){
		obj->objs[1] = arg_user_id;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "user_id");
	}

	return obj;
}

tlo_t * tl_keyboardButtonUserProfile(const char * arg_text, long arg_user_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "keyboardButtonUserProfile");
	int i;
	obj->id = 0x308660c1;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_text){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[0]->name, "text");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[1]->name, "user_id");
	return obj;
}

tlo_t * tl_keyboardButtonWebView(const char * arg_text, const char * arg_url)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "keyboardButtonWebView");
	int i;
	obj->id = 0x13767230;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_text){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[0]->name, "text");
	}


	//parse argument string
	if (arg_url){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[1]->name, "url");
	}

	return obj;
}

tlo_t * tl_keyboardButtonSimpleWebView(const char * arg_text, const char * arg_url)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "keyboardButtonSimpleWebView");
	int i;
	obj->id = 0xa0c0505c;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_text){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[0]->name, "text");
	}


	//parse argument string
	if (arg_url){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[1]->name, "url");
	}

	return obj;
}

tlo_t * tl_keyboardButtonRequestPeer(const char * arg_text, int arg_button_id, RequestPeerType arg_peer_type, int arg_max_quantity)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "keyboardButtonRequestPeer");
	int i;
	obj->id = 0x53d7bfd8;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_text){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[0]->name, "text");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_button_id);
	strcpy(obj->objs[1]->name, "button_id");

	//parse argument RequestPeerType
	if (arg_peer_type){
		obj->objs[2] = arg_peer_type;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer_type");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_max_quantity);
	strcpy(obj->objs[3]->name, "max_quantity");
	return obj;
}

tlo_t * tl_inputKeyboardButtonRequestPeer(bool arg_name_requested, bool arg_username_requested, bool arg_photo_requested, const char * arg_text, int arg_button_id, RequestPeerType arg_peer_type, int arg_max_quantity)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputKeyboardButtonRequestPeer");
	int i;
	obj->id = 0xc9662d05;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_name_requested);
	strcpy(obj->objs[1]->name, "name_requested");
	if (arg_name_requested)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_username_requested);
	strcpy(obj->objs[2]->name, "username_requested");
	if (arg_username_requested)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_photo_requested);
	strcpy(obj->objs[3]->name, "photo_requested");
	if (arg_photo_requested)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument string
	if (arg_text){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[4]->name, "text");
	}


	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_button_id);
	strcpy(obj->objs[5]->name, "button_id");

	//parse argument RequestPeerType
	if (arg_peer_type){
		obj->objs[6] = arg_peer_type;
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
	strcpy(obj->objs[6]->name, "peer_type");
	}


	//parse argument int
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_max_quantity);
	strcpy(obj->objs[7]->name, "max_quantity");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_keyboardButtonCopy(const char * arg_text, const char * arg_copy_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "keyboardButtonCopy");
	int i;
	obj->id = 0x75d2698e;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_text){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[0]->name, "text");
	}


	//parse argument string
	if (arg_copy_text){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_copy_text, strlen(arg_copy_text));
		strcpy(obj->objs[1]->name, "copy_text");
	}

	return obj;
}

tlo_t * tl_keyboardButtonRow(KeyboardButton *arg_buttons, int len_arg_buttons)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "keyboardButtonRow");
	int i;
	obj->id = 0x77608b83;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<KeyboardButton>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "buttons");
	if (arg_buttons){
		for(i=0; i<len_arg_buttons; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_buttons[i]->id);
			buf_cat(obj->objs[0]->value, arg_buttons[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_replyKeyboardHide(bool arg_selective)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "replyKeyboardHide");
	int i;
	obj->id = 0xa03e5b85;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 2;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_selective);
	strcpy(obj->objs[1]->name, "selective");
	if (arg_selective)
		flagsv[nflags-1] |= (1 << 2);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_replyKeyboardForceReply(bool arg_single_use, bool arg_selective, const char * arg_placeholder)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "replyKeyboardForceReply");
	int i;
	obj->id = 0x86b40b08;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_single_use);
	strcpy(obj->objs[1]->name, "single_use");
	if (arg_single_use)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 2;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_selective);
	strcpy(obj->objs[2]->name, "selective");
	if (arg_selective)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument string
	if (arg_placeholder){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 3;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_placeholder, strlen(arg_placeholder));
		strcpy(obj->objs[3]->name, "placeholder");
		flagsv[nflags-1] |= (1 << 3);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_replyKeyboardMarkup(bool arg_resize, bool arg_single_use, bool arg_selective, bool arg_persistent, KeyboardButtonRow *arg_rows, int len_arg_rows, const char * arg_placeholder)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "replyKeyboardMarkup");
	int i;
	obj->id = 0x85dd99d1;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_resize);
	strcpy(obj->objs[1]->name, "resize");
	if (arg_resize)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_single_use);
	strcpy(obj->objs[2]->name, "single_use");
	if (arg_single_use)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_selective);
	strcpy(obj->objs[3]->name, "selective");
	if (arg_selective)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 4;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_persistent);
	strcpy(obj->objs[4]->name, "persistent");
	if (arg_persistent)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument Vector<KeyboardButtonRow>
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_VECTOR;
	strcpy(obj->objs[5]->name, "rows");
	if (arg_rows){
		for(i=0; i<len_arg_rows; ++i){
			obj->objs[5]->value = buf_add_ui32(arg_rows[i]->id);
			buf_cat(obj->objs[5]->value, arg_rows[i]->value);
		}
	}


	//parse argument string
	if (arg_placeholder){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 3;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_placeholder, strlen(arg_placeholder));
		strcpy(obj->objs[6]->name, "placeholder");
		flagsv[nflags-1] |= (1 << 3);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_replyInlineMarkup(KeyboardButtonRow *arg_rows, int len_arg_rows)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "replyInlineMarkup");
	int i;
	obj->id = 0x48a30254;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<KeyboardButtonRow>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "rows");
	if (arg_rows){
		for(i=0; i<len_arg_rows; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_rows[i]->id);
			buf_cat(obj->objs[0]->value, arg_rows[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_messageEntityUnknown(int arg_offset, int arg_length)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageEntityUnknown");
	int i;
	obj->id = 0xbb92ba95;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_offset);
	strcpy(obj->objs[0]->name, "offset");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_length);
	strcpy(obj->objs[1]->name, "length");
	return obj;
}

tlo_t * tl_messageEntityMention(int arg_offset, int arg_length)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageEntityMention");
	int i;
	obj->id = 0xfa04579d;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_offset);
	strcpy(obj->objs[0]->name, "offset");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_length);
	strcpy(obj->objs[1]->name, "length");
	return obj;
}

tlo_t * tl_messageEntityHashtag(int arg_offset, int arg_length)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageEntityHashtag");
	int i;
	obj->id = 0x6f635b0d;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_offset);
	strcpy(obj->objs[0]->name, "offset");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_length);
	strcpy(obj->objs[1]->name, "length");
	return obj;
}

tlo_t * tl_messageEntityBotCommand(int arg_offset, int arg_length)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageEntityBotCommand");
	int i;
	obj->id = 0x6cef8ac7;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_offset);
	strcpy(obj->objs[0]->name, "offset");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_length);
	strcpy(obj->objs[1]->name, "length");
	return obj;
}

tlo_t * tl_messageEntityUrl(int arg_offset, int arg_length)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageEntityUrl");
	int i;
	obj->id = 0x6ed02538;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_offset);
	strcpy(obj->objs[0]->name, "offset");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_length);
	strcpy(obj->objs[1]->name, "length");
	return obj;
}

tlo_t * tl_messageEntityEmail(int arg_offset, int arg_length)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageEntityEmail");
	int i;
	obj->id = 0x64e475c2;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_offset);
	strcpy(obj->objs[0]->name, "offset");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_length);
	strcpy(obj->objs[1]->name, "length");
	return obj;
}

tlo_t * tl_messageEntityBold(int arg_offset, int arg_length)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageEntityBold");
	int i;
	obj->id = 0xbd610bc9;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_offset);
	strcpy(obj->objs[0]->name, "offset");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_length);
	strcpy(obj->objs[1]->name, "length");
	return obj;
}

tlo_t * tl_messageEntityItalic(int arg_offset, int arg_length)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageEntityItalic");
	int i;
	obj->id = 0x826f8b60;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_offset);
	strcpy(obj->objs[0]->name, "offset");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_length);
	strcpy(obj->objs[1]->name, "length");
	return obj;
}

tlo_t * tl_messageEntityCode(int arg_offset, int arg_length)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageEntityCode");
	int i;
	obj->id = 0x28a20571;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_offset);
	strcpy(obj->objs[0]->name, "offset");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_length);
	strcpy(obj->objs[1]->name, "length");
	return obj;
}

tlo_t * tl_messageEntityPre(int arg_offset, int arg_length, const char * arg_language)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageEntityPre");
	int i;
	obj->id = 0x73924be0;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_offset);
	strcpy(obj->objs[0]->name, "offset");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_length);
	strcpy(obj->objs[1]->name, "length");

	//parse argument string
	if (arg_language){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_language, strlen(arg_language));
		strcpy(obj->objs[2]->name, "language");
	}

	return obj;
}

tlo_t * tl_messageEntityTextUrl(int arg_offset, int arg_length, const char * arg_url)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageEntityTextUrl");
	int i;
	obj->id = 0x76a6d327;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_offset);
	strcpy(obj->objs[0]->name, "offset");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_length);
	strcpy(obj->objs[1]->name, "length");

	//parse argument string
	if (arg_url){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[2]->name, "url");
	}

	return obj;
}

tlo_t * tl_messageEntityMentionName(int arg_offset, int arg_length, long arg_user_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageEntityMentionName");
	int i;
	obj->id = 0xdc7b1140;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_offset);
	strcpy(obj->objs[0]->name, "offset");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_length);
	strcpy(obj->objs[1]->name, "length");

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[2]->name, "user_id");
	return obj;
}

tlo_t * tl_inputMessageEntityMentionName(int arg_offset, int arg_length, InputUser arg_user_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMessageEntityMentionName");
	int i;
	obj->id = 0x208e68c9;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_offset);
	strcpy(obj->objs[0]->name, "offset");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_length);
	strcpy(obj->objs[1]->name, "length");

	//parse argument InputUser
	if (arg_user_id){
		obj->objs[2] = arg_user_id;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "user_id");
	}

	return obj;
}

tlo_t * tl_messageEntityPhone(int arg_offset, int arg_length)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageEntityPhone");
	int i;
	obj->id = 0x9b69e34b;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_offset);
	strcpy(obj->objs[0]->name, "offset");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_length);
	strcpy(obj->objs[1]->name, "length");
	return obj;
}

tlo_t * tl_messageEntityCashtag(int arg_offset, int arg_length)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageEntityCashtag");
	int i;
	obj->id = 0x4c4e743f;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_offset);
	strcpy(obj->objs[0]->name, "offset");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_length);
	strcpy(obj->objs[1]->name, "length");
	return obj;
}

tlo_t * tl_messageEntityUnderline(int arg_offset, int arg_length)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageEntityUnderline");
	int i;
	obj->id = 0x9c4e7e8b;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_offset);
	strcpy(obj->objs[0]->name, "offset");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_length);
	strcpy(obj->objs[1]->name, "length");
	return obj;
}

tlo_t * tl_messageEntityStrike(int arg_offset, int arg_length)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageEntityStrike");
	int i;
	obj->id = 0xbf0693d4;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_offset);
	strcpy(obj->objs[0]->name, "offset");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_length);
	strcpy(obj->objs[1]->name, "length");
	return obj;
}

tlo_t * tl_messageEntityBankCard(int arg_offset, int arg_length)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageEntityBankCard");
	int i;
	obj->id = 0x761e6af4;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_offset);
	strcpy(obj->objs[0]->name, "offset");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_length);
	strcpy(obj->objs[1]->name, "length");
	return obj;
}

tlo_t * tl_messageEntitySpoiler(int arg_offset, int arg_length)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageEntitySpoiler");
	int i;
	obj->id = 0x32ca960f;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_offset);
	strcpy(obj->objs[0]->name, "offset");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_length);
	strcpy(obj->objs[1]->name, "length");
	return obj;
}

tlo_t * tl_messageEntityCustomEmoji(int arg_offset, int arg_length, long arg_document_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageEntityCustomEmoji");
	int i;
	obj->id = 0xc8cf05f8;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_offset);
	strcpy(obj->objs[0]->name, "offset");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_length);
	strcpy(obj->objs[1]->name, "length");

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_document_id);
	strcpy(obj->objs[2]->name, "document_id");
	return obj;
}

tlo_t * tl_messageEntityBlockquote(bool arg_collapsed, int arg_offset, int arg_length)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageEntityBlockquote");
	int i;
	obj->id = 0xf1ccaaac;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_collapsed);
	strcpy(obj->objs[1]->name, "collapsed");
	if (arg_collapsed)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_offset);
	strcpy(obj->objs[2]->name, "offset");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_length);
	strcpy(obj->objs[3]->name, "length");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputChannelEmpty()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputChannelEmpty");
	int i;
	obj->id = 0xee8c1e86;
	return obj;
}

tlo_t * tl_inputChannel(long arg_channel_id, long arg_access_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputChannel");
	int i;
	obj->id = 0xf35aec28;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_channel_id);
	strcpy(obj->objs[0]->name, "channel_id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[1]->name, "access_hash");
	return obj;
}

tlo_t * tl_inputChannelFromMessage(InputPeer arg_peer, int arg_msg_id, long arg_channel_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputChannelFromMessage");
	int i;
	obj->id = 0x5b934f9d;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[1]->name, "msg_id");

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_channel_id);
	strcpy(obj->objs[2]->name, "channel_id");
	return obj;
}

tlo_t * tl_contacts_resolvedPeer(Peer arg_peer, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_resolvedPeer");
	int i;
	obj->id = 0x7f077ad9;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument Vector<Chat>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[1]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[2]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_messageRange(int arg_min_id, int arg_max_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageRange");
	int i;
	obj->id = 0x0ae30253;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_min_id);
	strcpy(obj->objs[0]->name, "min_id");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_max_id);
	strcpy(obj->objs[1]->name, "max_id");
	return obj;
}

tlo_t * tl_updates_channelDifferenceEmpty(bool arg_final, int arg_pts, int arg_timeout)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updates_channelDifferenceEmpty");
	int i;
	obj->id = 0x3e11affb;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_final);
	strcpy(obj->objs[1]->name, "final");
	if (arg_final)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_pts);
	strcpy(obj->objs[2]->name, "pts");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 1;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_timeout);
	strcpy(obj->objs[3]->name, "timeout");
	if (arg_timeout)
		flagsv[nflags-1] |= (1 << 1);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updates_channelDifferenceTooLong(bool arg_final, int arg_timeout, Dialog arg_dialog, Message *arg_messages, int len_arg_messages, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updates_channelDifferenceTooLong");
	int i;
	obj->id = 0xa4bcc6fe;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_final);
	strcpy(obj->objs[1]->name, "final");
	if (arg_final)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_timeout);
	strcpy(obj->objs[2]->name, "timeout");
	if (arg_timeout)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument Dialog
	if (arg_dialog){
		obj->objs[3] = arg_dialog;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "dialog");
	}


	//parse argument Vector<Message>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "messages");
	if (arg_messages){
		for(i=0; i<len_arg_messages; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_messages[i]->id);
			buf_cat(obj->objs[4]->value, arg_messages[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_VECTOR;
	strcpy(obj->objs[5]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[5]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[5]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_VECTOR;
	strcpy(obj->objs[6]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[6]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[6]->value, arg_users[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updates_channelDifference(bool arg_final, int arg_pts, int arg_timeout, Message *arg_new_messages, int len_arg_new_messages, Update *arg_other_updates, int len_arg_other_updates, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updates_channelDifference");
	int i;
	obj->id = 0x2064674e;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_final);
	strcpy(obj->objs[1]->name, "final");
	if (arg_final)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_pts);
	strcpy(obj->objs[2]->name, "pts");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 1;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_timeout);
	strcpy(obj->objs[3]->name, "timeout");
	if (arg_timeout)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument Vector<Message>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "new_messages");
	if (arg_new_messages){
		for(i=0; i<len_arg_new_messages; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_new_messages[i]->id);
			buf_cat(obj->objs[4]->value, arg_new_messages[i]->value);
		}
	}


	//parse argument Vector<Update>
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_VECTOR;
	strcpy(obj->objs[5]->name, "other_updates");
	if (arg_other_updates){
		for(i=0; i<len_arg_other_updates; ++i){
			obj->objs[5]->value = buf_add_ui32(arg_other_updates[i]->id);
			buf_cat(obj->objs[5]->value, arg_other_updates[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_VECTOR;
	strcpy(obj->objs[6]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[6]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[6]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_VECTOR;
	strcpy(obj->objs[7]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[7]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[7]->value, arg_users[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_channelMessagesFilterEmpty()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelMessagesFilterEmpty");
	int i;
	obj->id = 0x94d42ee7;
	return obj;
}

tlo_t * tl_channelMessagesFilter(bool arg_exclude_new_messages, MessageRange *arg_ranges, int len_arg_ranges)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelMessagesFilter");
	int i;
	obj->id = 0xcd77d957;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_exclude_new_messages);
	strcpy(obj->objs[1]->name, "exclude_new_messages");
	if (arg_exclude_new_messages)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument Vector<MessageRange>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "ranges");
	if (arg_ranges){
		for(i=0; i<len_arg_ranges; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_ranges[i]->id);
			buf_cat(obj->objs[2]->value, arg_ranges[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_channelParticipant(long arg_user_id, int arg_date, int arg_subscription_until_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelParticipant");
	int i;
	obj->id = 0xcb397619;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[1]->name, "user_id");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[2]->name, "date");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_subscription_until_date);
	strcpy(obj->objs[3]->name, "subscription_until_date");
	if (arg_subscription_until_date)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_channelParticipantSelf(bool arg_via_request, long arg_user_id, long arg_inviter_id, int arg_date, int arg_subscription_until_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelParticipantSelf");
	int i;
	obj->id = 0x4f607bef;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_via_request);
	strcpy(obj->objs[1]->name, "via_request");
	if (arg_via_request)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[2]->name, "user_id");

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_inviter_id);
	strcpy(obj->objs[3]->name, "inviter_id");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[4]->name, "date");

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 1;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_subscription_until_date);
	strcpy(obj->objs[5]->name, "subscription_until_date");
	if (arg_subscription_until_date)
		flagsv[nflags-1] |= (1 << 1);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_channelParticipantCreator(long arg_user_id, ChatAdminRights arg_admin_rights, const char * arg_rank)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelParticipantCreator");
	int i;
	obj->id = 0x2fe601d3;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[1]->name, "user_id");

	//parse argument ChatAdminRights
	if (arg_admin_rights){
		obj->objs[2] = arg_admin_rights;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "admin_rights");
	}


	//parse argument string
	if (arg_rank){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_rank, strlen(arg_rank));
		strcpy(obj->objs[3]->name, "rank");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_channelParticipantAdmin(bool arg_can_edit, bool arg_self, long arg_user_id, long arg_inviter_id, long arg_promoted_by, int arg_date, ChatAdminRights arg_admin_rights, const char * arg_rank)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelParticipantAdmin");
	int i;
	obj->id = 0x34c3bb53;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_can_edit);
	strcpy(obj->objs[1]->name, "can_edit");
	if (arg_can_edit)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_self);
	strcpy(obj->objs[2]->name, "self");
	if (arg_self)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[3]->name, "user_id");

	//parse argument long
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 1;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_inviter_id);
	strcpy(obj->objs[4]->name, "inviter_id");
	if (arg_inviter_id)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument long
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_LONG;
	obj->objs[5]->value = 
		buf_add_ui64(arg_promoted_by);
	strcpy(obj->objs[5]->name, "promoted_by");

	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[6]->name, "date");

	//parse argument ChatAdminRights
	if (arg_admin_rights){
		obj->objs[7] = arg_admin_rights;
		obj->objs[7]->flag_num = 0;
		obj->objs[7]->flag_bit = 0;
	strcpy(obj->objs[7]->name, "admin_rights");
	}


	//parse argument string
	if (arg_rank){
		obj->objs[8] = NEW(tlo_t, return NULL);
		obj->objs[8]->flag_num = 1;
		obj->objs[8]->flag_bit = 2;
		obj->objs[8]->type = TYPE_STRING;
		obj->objs[8]->value = 
			buf_add((ui8_t *)arg_rank, strlen(arg_rank));
		strcpy(obj->objs[8]->name, "rank");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_channelParticipantBanned(bool arg_left, Peer arg_peer, long arg_kicked_by, int arg_date, ChatBannedRights arg_banned_rights)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelParticipantBanned");
	int i;
	obj->id = 0x6df8014e;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_left);
	strcpy(obj->objs[1]->name, "left");
	if (arg_left)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument Peer
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_kicked_by);
	strcpy(obj->objs[3]->name, "kicked_by");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[4]->name, "date");

	//parse argument ChatBannedRights
	if (arg_banned_rights){
		obj->objs[5] = arg_banned_rights;
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
	strcpy(obj->objs[5]->name, "banned_rights");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_channelParticipantLeft(Peer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelParticipantLeft");
	int i;
	obj->id = 0x1b03f006;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}

	return obj;
}

tlo_t * tl_channelParticipantsRecent()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelParticipantsRecent");
	int i;
	obj->id = 0xde3f3c79;
	return obj;
}

tlo_t * tl_channelParticipantsAdmins()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelParticipantsAdmins");
	int i;
	obj->id = 0xb4608969;
	return obj;
}

tlo_t * tl_channelParticipantsKicked(const char * arg_q)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelParticipantsKicked");
	int i;
	obj->id = 0xa3b54985;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_q){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_q, strlen(arg_q));
		strcpy(obj->objs[0]->name, "q");
	}

	return obj;
}

tlo_t * tl_channelParticipantsBots()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelParticipantsBots");
	int i;
	obj->id = 0xb0d1865b;
	return obj;
}

tlo_t * tl_channelParticipantsBanned(const char * arg_q)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelParticipantsBanned");
	int i;
	obj->id = 0x1427a5e1;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_q){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_q, strlen(arg_q));
		strcpy(obj->objs[0]->name, "q");
	}

	return obj;
}

tlo_t * tl_channelParticipantsSearch(const char * arg_q)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelParticipantsSearch");
	int i;
	obj->id = 0x0656ac4b;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_q){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_q, strlen(arg_q));
		strcpy(obj->objs[0]->name, "q");
	}

	return obj;
}

tlo_t * tl_channelParticipantsContacts(const char * arg_q)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelParticipantsContacts");
	int i;
	obj->id = 0xbb6ae88d;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_q){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_q, strlen(arg_q));
		strcpy(obj->objs[0]->name, "q");
	}

	return obj;
}

tlo_t * tl_channelParticipantsMentions(const char * arg_q, int arg_top_msg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelParticipantsMentions");
	int i;
	obj->id = 0xe04b5ceb;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_q){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_q, strlen(arg_q));
		strcpy(obj->objs[1]->name, "q");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_top_msg_id);
	strcpy(obj->objs[2]->name, "top_msg_id");
	if (arg_top_msg_id)
		flagsv[nflags-1] |= (1 << 1);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_channels_channelParticipants(int arg_count, ChannelParticipant *arg_participants, int len_arg_participants, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_channelParticipants");
	int i;
	obj->id = 0x9ab0feaf;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[0]->name, "count");

	//parse argument Vector<ChannelParticipant>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "participants");
	if (arg_participants){
		for(i=0; i<len_arg_participants; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_participants[i]->id);
			buf_cat(obj->objs[1]->value, arg_participants[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[2]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[3]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_channels_channelParticipantsNotModified()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_channelParticipantsNotModified");
	int i;
	obj->id = 0xf0173fe9;
	return obj;
}

tlo_t * tl_channels_channelParticipant(ChannelParticipant arg_participant, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_channelParticipant");
	int i;
	obj->id = 0xdfb80317;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument ChannelParticipant
	if (arg_participant){
		obj->objs[0] = arg_participant;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "participant");
	}


	//parse argument Vector<Chat>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[1]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[2]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_help_termsOfService(bool arg_popup, DataJSON arg_id, const char * arg_text, MessageEntity *arg_entities, int len_arg_entities, int arg_min_age_confirm)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_termsOfService");
	int i;
	obj->id = 0x780a0310;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_popup);
	strcpy(obj->objs[1]->name, "popup");
	if (arg_popup)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument DataJSON
	if (arg_id){
		obj->objs[2] = arg_id;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "id");
	}


	//parse argument string
	if (arg_text){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[3]->name, "text");
	}


	//parse argument Vector<MessageEntity>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "entities");
	if (arg_entities){
		for(i=0; i<len_arg_entities; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_entities[i]->id);
			buf_cat(obj->objs[4]->value, arg_entities[i]->value);
		}
	}


	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 1;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_min_age_confirm);
	strcpy(obj->objs[5]->name, "min_age_confirm");
	if (arg_min_age_confirm)
		flagsv[nflags-1] |= (1 << 1);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_savedGifsNotModified()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_savedGifsNotModified");
	int i;
	obj->id = 0xe8025ca2;
	return obj;
}

tlo_t * tl_messages_savedGifs(long arg_hash, Document *arg_gifs, int len_arg_gifs)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_savedGifs");
	int i;
	obj->id = 0x84a02a0d;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");

	//parse argument Vector<Document>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "gifs");
	if (arg_gifs){
		for(i=0; i<len_arg_gifs; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_gifs[i]->id);
			buf_cat(obj->objs[1]->value, arg_gifs[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_inputBotInlineMessageMediaAuto(bool arg_invert_media, const char * arg_message, MessageEntity *arg_entities, int len_arg_entities, ReplyMarkup arg_reply_markup)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputBotInlineMessageMediaAuto");
	int i;
	obj->id = 0x3380c786;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 3;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_invert_media);
	strcpy(obj->objs[1]->name, "invert_media");
	if (arg_invert_media)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument string
	if (arg_message){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_message, strlen(arg_message));
		strcpy(obj->objs[2]->name, "message");
	}


	//parse argument Vector<MessageEntity>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 1;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "entities");
	if (arg_entities){
		for(i=0; i<len_arg_entities; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_entities[i]->id);
			buf_cat(obj->objs[3]->value, arg_entities[i]->value);
		}
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument ReplyMarkup
	if (arg_reply_markup){
		obj->objs[4] = arg_reply_markup;
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 2;
	strcpy(obj->objs[4]->name, "reply_markup");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputBotInlineMessageText(bool arg_no_webpage, bool arg_invert_media, const char * arg_message, MessageEntity *arg_entities, int len_arg_entities, ReplyMarkup arg_reply_markup)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputBotInlineMessageText");
	int i;
	obj->id = 0x3dcd7a87;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_no_webpage);
	strcpy(obj->objs[1]->name, "no_webpage");
	if (arg_no_webpage)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 3;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_invert_media);
	strcpy(obj->objs[2]->name, "invert_media");
	if (arg_invert_media)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument string
	if (arg_message){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_message, strlen(arg_message));
		strcpy(obj->objs[3]->name, "message");
	}


	//parse argument Vector<MessageEntity>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 1;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "entities");
	if (arg_entities){
		for(i=0; i<len_arg_entities; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_entities[i]->id);
			buf_cat(obj->objs[4]->value, arg_entities[i]->value);
		}
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument ReplyMarkup
	if (arg_reply_markup){
		obj->objs[5] = arg_reply_markup;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 2;
	strcpy(obj->objs[5]->name, "reply_markup");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputBotInlineMessageMediaGeo(InputGeoPoint arg_geo_point, int arg_heading, int arg_period, int arg_proximity_notification_radius, ReplyMarkup arg_reply_markup)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputBotInlineMessageMediaGeo");
	int i;
	obj->id = 0x96929a85;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputGeoPoint
	if (arg_geo_point){
		obj->objs[1] = arg_geo_point;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "geo_point");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_heading);
	strcpy(obj->objs[2]->name, "heading");
	if (arg_heading)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 1;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_period);
	strcpy(obj->objs[3]->name, "period");
	if (arg_period)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 3;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_proximity_notification_radius);
	strcpy(obj->objs[4]->name, "proximity_notification_radius");
	if (arg_proximity_notification_radius)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument ReplyMarkup
	if (arg_reply_markup){
		obj->objs[5] = arg_reply_markup;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 2;
	strcpy(obj->objs[5]->name, "reply_markup");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputBotInlineMessageMediaVenue(InputGeoPoint arg_geo_point, const char * arg_title, const char * arg_address, const char * arg_provider, const char * arg_venue_id, const char * arg_venue_type, ReplyMarkup arg_reply_markup)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputBotInlineMessageMediaVenue");
	int i;
	obj->id = 0x417bbf11;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputGeoPoint
	if (arg_geo_point){
		obj->objs[1] = arg_geo_point;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "geo_point");
	}


	//parse argument string
	if (arg_title){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[2]->name, "title");
	}


	//parse argument string
	if (arg_address){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_address, strlen(arg_address));
		strcpy(obj->objs[3]->name, "address");
	}


	//parse argument string
	if (arg_provider){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_provider, strlen(arg_provider));
		strcpy(obj->objs[4]->name, "provider");
	}


	//parse argument string
	if (arg_venue_id){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_venue_id, strlen(arg_venue_id));
		strcpy(obj->objs[5]->name, "venue_id");
	}


	//parse argument string
	if (arg_venue_type){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_venue_type, strlen(arg_venue_type));
		strcpy(obj->objs[6]->name, "venue_type");
	}


	//parse argument ReplyMarkup
	if (arg_reply_markup){
		obj->objs[7] = arg_reply_markup;
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 2;
	strcpy(obj->objs[7]->name, "reply_markup");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputBotInlineMessageMediaContact(const char * arg_phone_number, const char * arg_first_name, const char * arg_last_name, const char * arg_vcard, ReplyMarkup arg_reply_markup)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputBotInlineMessageMediaContact");
	int i;
	obj->id = 0xa6edbffd;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_phone_number){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_phone_number, strlen(arg_phone_number));
		strcpy(obj->objs[1]->name, "phone_number");
	}


	//parse argument string
	if (arg_first_name){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_first_name, strlen(arg_first_name));
		strcpy(obj->objs[2]->name, "first_name");
	}


	//parse argument string
	if (arg_last_name){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_last_name, strlen(arg_last_name));
		strcpy(obj->objs[3]->name, "last_name");
	}


	//parse argument string
	if (arg_vcard){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_vcard, strlen(arg_vcard));
		strcpy(obj->objs[4]->name, "vcard");
	}


	//parse argument ReplyMarkup
	if (arg_reply_markup){
		obj->objs[5] = arg_reply_markup;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 2;
	strcpy(obj->objs[5]->name, "reply_markup");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputBotInlineMessageGame(ReplyMarkup arg_reply_markup)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputBotInlineMessageGame");
	int i;
	obj->id = 0x4b425864;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument ReplyMarkup
	if (arg_reply_markup){
		obj->objs[1] = arg_reply_markup;
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 2;
	strcpy(obj->objs[1]->name, "reply_markup");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputBotInlineMessageMediaInvoice(const char * arg_title, const char * arg_description, InputWebDocument arg_photo, Invoice arg_invoice, unsigned char * arg_payload, int len_arg_payload, const char * arg_provider, DataJSON arg_provider_data, ReplyMarkup arg_reply_markup)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputBotInlineMessageMediaInvoice");
	int i;
	obj->id = 0xd7e78225;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_title){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[1]->name, "title");
	}


	//parse argument string
	if (arg_description){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_description, strlen(arg_description));
		strcpy(obj->objs[2]->name, "description");
	}


	//parse argument InputWebDocument
	if (arg_photo){
		obj->objs[3] = arg_photo;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "photo");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument Invoice
	if (arg_invoice){
		obj->objs[4] = arg_invoice;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "invoice");
	}


	//parse argument bytes
	if (arg_payload){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_BYTES;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_payload, len_arg_payload);
		strcpy(obj->objs[5]->name, "payload");
	}


	//parse argument string
	if (arg_provider){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_provider, strlen(arg_provider));
		strcpy(obj->objs[6]->name, "provider");
	}


	//parse argument DataJSON
	if (arg_provider_data){
		obj->objs[7] = arg_provider_data;
		obj->objs[7]->flag_num = 0;
		obj->objs[7]->flag_bit = 0;
	strcpy(obj->objs[7]->name, "provider_data");
	}


	//parse argument ReplyMarkup
	if (arg_reply_markup){
		obj->objs[8] = arg_reply_markup;
		obj->objs[8]->flag_num = 1;
		obj->objs[8]->flag_bit = 2;
	strcpy(obj->objs[8]->name, "reply_markup");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputBotInlineMessageMediaWebPage(bool arg_invert_media, bool arg_force_large_media, bool arg_force_small_media, bool arg_optional, const char * arg_message, MessageEntity *arg_entities, int len_arg_entities, const char * arg_url, ReplyMarkup arg_reply_markup)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputBotInlineMessageMediaWebPage");
	int i;
	obj->id = 0xbddcc510;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 3;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_invert_media);
	strcpy(obj->objs[1]->name, "invert_media");
	if (arg_invert_media)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 4;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_force_large_media);
	strcpy(obj->objs[2]->name, "force_large_media");
	if (arg_force_large_media)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 5;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_force_small_media);
	strcpy(obj->objs[3]->name, "force_small_media");
	if (arg_force_small_media)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 6;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_optional);
	strcpy(obj->objs[4]->name, "optional");
	if (arg_optional)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument string
	if (arg_message){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_message, strlen(arg_message));
		strcpy(obj->objs[5]->name, "message");
	}


	//parse argument Vector<MessageEntity>
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 1;
	obj->objs[6]->type = TYPE_VECTOR;
	strcpy(obj->objs[6]->name, "entities");
	if (arg_entities){
		for(i=0; i<len_arg_entities; ++i){
			obj->objs[6]->value = buf_add_ui32(arg_entities[i]->id);
			buf_cat(obj->objs[6]->value, arg_entities[i]->value);
		}
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument string
	if (arg_url){
		obj->objs[7] = NEW(tlo_t, return NULL);
		obj->objs[7]->flag_num = 0;
		obj->objs[7]->flag_bit = 0;
		obj->objs[7]->type = TYPE_STRING;
		obj->objs[7]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[7]->name, "url");
	}


	//parse argument ReplyMarkup
	if (arg_reply_markup){
		obj->objs[8] = arg_reply_markup;
		obj->objs[8]->flag_num = 1;
		obj->objs[8]->flag_bit = 2;
	strcpy(obj->objs[8]->name, "reply_markup");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputBotInlineResult(const char * arg_id, const char * arg_type, const char * arg_title, const char * arg_description, const char * arg_url, InputWebDocument arg_thumb, InputWebDocument arg_content, InputBotInlineMessage arg_send_message)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputBotInlineResult");
	int i;
	obj->id = 0x88bf9319;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_id){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_id, strlen(arg_id));
		strcpy(obj->objs[1]->name, "id");
	}


	//parse argument string
	if (arg_type){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_type, strlen(arg_type));
		strcpy(obj->objs[2]->name, "type");
	}


	//parse argument string
	if (arg_title){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 1;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[3]->name, "title");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument string
	if (arg_description){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 2;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_description, strlen(arg_description));
		strcpy(obj->objs[4]->name, "description");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument string
	if (arg_url){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 3;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[5]->name, "url");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument InputWebDocument
	if (arg_thumb){
		obj->objs[6] = arg_thumb;
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 4;
	strcpy(obj->objs[6]->name, "thumb");
		flagsv[nflags-1] |= (1 << 4);
	}


	//parse argument InputWebDocument
	if (arg_content){
		obj->objs[7] = arg_content;
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 5;
	strcpy(obj->objs[7]->name, "content");
		flagsv[nflags-1] |= (1 << 5);
	}


	//parse argument InputBotInlineMessage
	if (arg_send_message){
		obj->objs[8] = arg_send_message;
		obj->objs[8]->flag_num = 0;
		obj->objs[8]->flag_bit = 0;
	strcpy(obj->objs[8]->name, "send_message");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputBotInlineResultPhoto(const char * arg_id, const char * arg_type, InputPhoto arg_photo, InputBotInlineMessage arg_send_message)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputBotInlineResultPhoto");
	int i;
	obj->id = 0xa8d864a7;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_id){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_id, strlen(arg_id));
		strcpy(obj->objs[0]->name, "id");
	}


	//parse argument string
	if (arg_type){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_type, strlen(arg_type));
		strcpy(obj->objs[1]->name, "type");
	}


	//parse argument InputPhoto
	if (arg_photo){
		obj->objs[2] = arg_photo;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "photo");
	}


	//parse argument InputBotInlineMessage
	if (arg_send_message){
		obj->objs[3] = arg_send_message;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "send_message");
	}

	return obj;
}

tlo_t * tl_inputBotInlineResultDocument(const char * arg_id, const char * arg_type, const char * arg_title, const char * arg_description, InputDocument arg_document, InputBotInlineMessage arg_send_message)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputBotInlineResultDocument");
	int i;
	obj->id = 0xfff8fdc4;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_id){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_id, strlen(arg_id));
		strcpy(obj->objs[1]->name, "id");
	}


	//parse argument string
	if (arg_type){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_type, strlen(arg_type));
		strcpy(obj->objs[2]->name, "type");
	}


	//parse argument string
	if (arg_title){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 1;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[3]->name, "title");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument string
	if (arg_description){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 2;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_description, strlen(arg_description));
		strcpy(obj->objs[4]->name, "description");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument InputDocument
	if (arg_document){
		obj->objs[5] = arg_document;
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
	strcpy(obj->objs[5]->name, "document");
	}


	//parse argument InputBotInlineMessage
	if (arg_send_message){
		obj->objs[6] = arg_send_message;
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
	strcpy(obj->objs[6]->name, "send_message");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputBotInlineResultGame(const char * arg_id, const char * arg_short_name, InputBotInlineMessage arg_send_message)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputBotInlineResultGame");
	int i;
	obj->id = 0x4fa417f2;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_id){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_id, strlen(arg_id));
		strcpy(obj->objs[0]->name, "id");
	}


	//parse argument string
	if (arg_short_name){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_short_name, strlen(arg_short_name));
		strcpy(obj->objs[1]->name, "short_name");
	}


	//parse argument InputBotInlineMessage
	if (arg_send_message){
		obj->objs[2] = arg_send_message;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "send_message");
	}

	return obj;
}

tlo_t * tl_botInlineMessageMediaAuto(bool arg_invert_media, const char * arg_message, MessageEntity *arg_entities, int len_arg_entities, ReplyMarkup arg_reply_markup)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "botInlineMessageMediaAuto");
	int i;
	obj->id = 0x764cf810;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 3;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_invert_media);
	strcpy(obj->objs[1]->name, "invert_media");
	if (arg_invert_media)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument string
	if (arg_message){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_message, strlen(arg_message));
		strcpy(obj->objs[2]->name, "message");
	}


	//parse argument Vector<MessageEntity>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 1;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "entities");
	if (arg_entities){
		for(i=0; i<len_arg_entities; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_entities[i]->id);
			buf_cat(obj->objs[3]->value, arg_entities[i]->value);
		}
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument ReplyMarkup
	if (arg_reply_markup){
		obj->objs[4] = arg_reply_markup;
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 2;
	strcpy(obj->objs[4]->name, "reply_markup");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_botInlineMessageText(bool arg_no_webpage, bool arg_invert_media, const char * arg_message, MessageEntity *arg_entities, int len_arg_entities, ReplyMarkup arg_reply_markup)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "botInlineMessageText");
	int i;
	obj->id = 0x8c7f65e2;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_no_webpage);
	strcpy(obj->objs[1]->name, "no_webpage");
	if (arg_no_webpage)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 3;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_invert_media);
	strcpy(obj->objs[2]->name, "invert_media");
	if (arg_invert_media)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument string
	if (arg_message){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_message, strlen(arg_message));
		strcpy(obj->objs[3]->name, "message");
	}


	//parse argument Vector<MessageEntity>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 1;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "entities");
	if (arg_entities){
		for(i=0; i<len_arg_entities; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_entities[i]->id);
			buf_cat(obj->objs[4]->value, arg_entities[i]->value);
		}
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument ReplyMarkup
	if (arg_reply_markup){
		obj->objs[5] = arg_reply_markup;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 2;
	strcpy(obj->objs[5]->name, "reply_markup");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_botInlineMessageMediaGeo(GeoPoint arg_geo, int arg_heading, int arg_period, int arg_proximity_notification_radius, ReplyMarkup arg_reply_markup)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "botInlineMessageMediaGeo");
	int i;
	obj->id = 0x051846fd;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument GeoPoint
	if (arg_geo){
		obj->objs[1] = arg_geo;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "geo");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_heading);
	strcpy(obj->objs[2]->name, "heading");
	if (arg_heading)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 1;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_period);
	strcpy(obj->objs[3]->name, "period");
	if (arg_period)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 3;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_proximity_notification_radius);
	strcpy(obj->objs[4]->name, "proximity_notification_radius");
	if (arg_proximity_notification_radius)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument ReplyMarkup
	if (arg_reply_markup){
		obj->objs[5] = arg_reply_markup;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 2;
	strcpy(obj->objs[5]->name, "reply_markup");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_botInlineMessageMediaVenue(GeoPoint arg_geo, const char * arg_title, const char * arg_address, const char * arg_provider, const char * arg_venue_id, const char * arg_venue_type, ReplyMarkup arg_reply_markup)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "botInlineMessageMediaVenue");
	int i;
	obj->id = 0x8a86659c;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument GeoPoint
	if (arg_geo){
		obj->objs[1] = arg_geo;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "geo");
	}


	//parse argument string
	if (arg_title){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[2]->name, "title");
	}


	//parse argument string
	if (arg_address){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_address, strlen(arg_address));
		strcpy(obj->objs[3]->name, "address");
	}


	//parse argument string
	if (arg_provider){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_provider, strlen(arg_provider));
		strcpy(obj->objs[4]->name, "provider");
	}


	//parse argument string
	if (arg_venue_id){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_venue_id, strlen(arg_venue_id));
		strcpy(obj->objs[5]->name, "venue_id");
	}


	//parse argument string
	if (arg_venue_type){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_venue_type, strlen(arg_venue_type));
		strcpy(obj->objs[6]->name, "venue_type");
	}


	//parse argument ReplyMarkup
	if (arg_reply_markup){
		obj->objs[7] = arg_reply_markup;
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 2;
	strcpy(obj->objs[7]->name, "reply_markup");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_botInlineMessageMediaContact(const char * arg_phone_number, const char * arg_first_name, const char * arg_last_name, const char * arg_vcard, ReplyMarkup arg_reply_markup)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "botInlineMessageMediaContact");
	int i;
	obj->id = 0x18d1cdc2;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_phone_number){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_phone_number, strlen(arg_phone_number));
		strcpy(obj->objs[1]->name, "phone_number");
	}


	//parse argument string
	if (arg_first_name){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_first_name, strlen(arg_first_name));
		strcpy(obj->objs[2]->name, "first_name");
	}


	//parse argument string
	if (arg_last_name){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_last_name, strlen(arg_last_name));
		strcpy(obj->objs[3]->name, "last_name");
	}


	//parse argument string
	if (arg_vcard){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_vcard, strlen(arg_vcard));
		strcpy(obj->objs[4]->name, "vcard");
	}


	//parse argument ReplyMarkup
	if (arg_reply_markup){
		obj->objs[5] = arg_reply_markup;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 2;
	strcpy(obj->objs[5]->name, "reply_markup");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_botInlineMessageMediaInvoice(bool arg_shipping_address_requested, bool arg_test, const char * arg_title, const char * arg_description, WebDocument arg_photo, const char * arg_currency, long arg_total_amount, ReplyMarkup arg_reply_markup)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "botInlineMessageMediaInvoice");
	int i;
	obj->id = 0x354a9b09;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_shipping_address_requested);
	strcpy(obj->objs[1]->name, "shipping_address_requested");
	if (arg_shipping_address_requested)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 3;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_test);
	strcpy(obj->objs[2]->name, "test");
	if (arg_test)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument string
	if (arg_title){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[3]->name, "title");
	}


	//parse argument string
	if (arg_description){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_description, strlen(arg_description));
		strcpy(obj->objs[4]->name, "description");
	}


	//parse argument WebDocument
	if (arg_photo){
		obj->objs[5] = arg_photo;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 0;
	strcpy(obj->objs[5]->name, "photo");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_currency){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_currency, strlen(arg_currency));
		strcpy(obj->objs[6]->name, "currency");
	}


	//parse argument long
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_LONG;
	obj->objs[7]->value = 
		buf_add_ui64(arg_total_amount);
	strcpy(obj->objs[7]->name, "total_amount");

	//parse argument ReplyMarkup
	if (arg_reply_markup){
		obj->objs[8] = arg_reply_markup;
		obj->objs[8]->flag_num = 1;
		obj->objs[8]->flag_bit = 2;
	strcpy(obj->objs[8]->name, "reply_markup");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_botInlineMessageMediaWebPage(bool arg_invert_media, bool arg_force_large_media, bool arg_force_small_media, bool arg_manual, bool arg_safe, const char * arg_message, MessageEntity *arg_entities, int len_arg_entities, const char * arg_url, ReplyMarkup arg_reply_markup)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "botInlineMessageMediaWebPage");
	int i;
	obj->id = 0x809ad9a6;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 10;
	obj->objs = 
		(tlo_t **)MALLOC(10 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 3;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_invert_media);
	strcpy(obj->objs[1]->name, "invert_media");
	if (arg_invert_media)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 4;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_force_large_media);
	strcpy(obj->objs[2]->name, "force_large_media");
	if (arg_force_large_media)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 5;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_force_small_media);
	strcpy(obj->objs[3]->name, "force_small_media");
	if (arg_force_small_media)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 7;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_manual);
	strcpy(obj->objs[4]->name, "manual");
	if (arg_manual)
		flagsv[nflags-1] |= (1 << 7);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 8;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_safe);
	strcpy(obj->objs[5]->name, "safe");
	if (arg_safe)
		flagsv[nflags-1] |= (1 << 8);

	//parse argument string
	if (arg_message){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_message, strlen(arg_message));
		strcpy(obj->objs[6]->name, "message");
	}


	//parse argument Vector<MessageEntity>
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 1;
	obj->objs[7]->type = TYPE_VECTOR;
	strcpy(obj->objs[7]->name, "entities");
	if (arg_entities){
		for(i=0; i<len_arg_entities; ++i){
			obj->objs[7]->value = buf_add_ui32(arg_entities[i]->id);
			buf_cat(obj->objs[7]->value, arg_entities[i]->value);
		}
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument string
	if (arg_url){
		obj->objs[8] = NEW(tlo_t, return NULL);
		obj->objs[8]->flag_num = 0;
		obj->objs[8]->flag_bit = 0;
		obj->objs[8]->type = TYPE_STRING;
		obj->objs[8]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[8]->name, "url");
	}


	//parse argument ReplyMarkup
	if (arg_reply_markup){
		obj->objs[9] = arg_reply_markup;
		obj->objs[9]->flag_num = 1;
		obj->objs[9]->flag_bit = 2;
	strcpy(obj->objs[9]->name, "reply_markup");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_botInlineResult(const char * arg_id, const char * arg_type, const char * arg_title, const char * arg_description, const char * arg_url, WebDocument arg_thumb, WebDocument arg_content, BotInlineMessage arg_send_message)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "botInlineResult");
	int i;
	obj->id = 0x11965f3a;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_id){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_id, strlen(arg_id));
		strcpy(obj->objs[1]->name, "id");
	}


	//parse argument string
	if (arg_type){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_type, strlen(arg_type));
		strcpy(obj->objs[2]->name, "type");
	}


	//parse argument string
	if (arg_title){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 1;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[3]->name, "title");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument string
	if (arg_description){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 2;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_description, strlen(arg_description));
		strcpy(obj->objs[4]->name, "description");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument string
	if (arg_url){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 3;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[5]->name, "url");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument WebDocument
	if (arg_thumb){
		obj->objs[6] = arg_thumb;
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 4;
	strcpy(obj->objs[6]->name, "thumb");
		flagsv[nflags-1] |= (1 << 4);
	}


	//parse argument WebDocument
	if (arg_content){
		obj->objs[7] = arg_content;
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 5;
	strcpy(obj->objs[7]->name, "content");
		flagsv[nflags-1] |= (1 << 5);
	}


	//parse argument BotInlineMessage
	if (arg_send_message){
		obj->objs[8] = arg_send_message;
		obj->objs[8]->flag_num = 0;
		obj->objs[8]->flag_bit = 0;
	strcpy(obj->objs[8]->name, "send_message");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_botInlineMediaResult(const char * arg_id, const char * arg_type, Photo arg_photo, Document arg_document, const char * arg_title, const char * arg_description, BotInlineMessage arg_send_message)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "botInlineMediaResult");
	int i;
	obj->id = 0x17db940b;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_id){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_id, strlen(arg_id));
		strcpy(obj->objs[1]->name, "id");
	}


	//parse argument string
	if (arg_type){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_type, strlen(arg_type));
		strcpy(obj->objs[2]->name, "type");
	}


	//parse argument Photo
	if (arg_photo){
		obj->objs[3] = arg_photo;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "photo");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument Document
	if (arg_document){
		obj->objs[4] = arg_document;
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 1;
	strcpy(obj->objs[4]->name, "document");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument string
	if (arg_title){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 2;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[5]->name, "title");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument string
	if (arg_description){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 3;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_description, strlen(arg_description));
		strcpy(obj->objs[6]->name, "description");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument BotInlineMessage
	if (arg_send_message){
		obj->objs[7] = arg_send_message;
		obj->objs[7]->flag_num = 0;
		obj->objs[7]->flag_bit = 0;
	strcpy(obj->objs[7]->name, "send_message");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_botResults(bool arg_gallery, long arg_query_id, const char * arg_next_offset, InlineBotSwitchPM arg_switch_pm, InlineBotWebView arg_switch_webview, BotInlineResult *arg_results, int len_arg_results, int arg_cache_time, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_botResults");
	int i;
	obj->id = 0xe021f2f6;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_gallery);
	strcpy(obj->objs[1]->name, "gallery");
	if (arg_gallery)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_query_id);
	strcpy(obj->objs[2]->name, "query_id");

	//parse argument string
	if (arg_next_offset){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 1;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_next_offset, strlen(arg_next_offset));
		strcpy(obj->objs[3]->name, "next_offset");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument InlineBotSwitchPM
	if (arg_switch_pm){
		obj->objs[4] = arg_switch_pm;
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 2;
	strcpy(obj->objs[4]->name, "switch_pm");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument InlineBotWebView
	if (arg_switch_webview){
		obj->objs[5] = arg_switch_webview;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 3;
	strcpy(obj->objs[5]->name, "switch_webview");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument Vector<BotInlineResult>
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_VECTOR;
	strcpy(obj->objs[6]->name, "results");
	if (arg_results){
		for(i=0; i<len_arg_results; ++i){
			obj->objs[6]->value = buf_add_ui32(arg_results[i]->id);
			buf_cat(obj->objs[6]->value, arg_results[i]->value);
		}
	}


	//parse argument int
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_cache_time);
	strcpy(obj->objs[7]->name, "cache_time");

	//parse argument Vector<User>
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 0;
	obj->objs[8]->flag_bit = 0;
	obj->objs[8]->type = TYPE_VECTOR;
	strcpy(obj->objs[8]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[8]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[8]->value, arg_users[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_exportedMessageLink(const char * arg_link, const char * arg_html)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "exportedMessageLink");
	int i;
	obj->id = 0x5dab1af4;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_link){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_link, strlen(arg_link));
		strcpy(obj->objs[0]->name, "link");
	}


	//parse argument string
	if (arg_html){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_html, strlen(arg_html));
		strcpy(obj->objs[1]->name, "html");
	}

	return obj;
}

tlo_t * tl_messageFwdHeader(bool arg_imported, bool arg_saved_out, Peer arg_from_id, const char * arg_from_name, int arg_date, int arg_channel_post, const char * arg_post_author, Peer arg_saved_from_peer, int arg_saved_from_msg_id, Peer arg_saved_from_id, const char * arg_saved_from_name, int arg_saved_date, const char * arg_psa_type)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageFwdHeader");
	int i;
	obj->id = 0x4e4df4bb;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 14;
	obj->objs = 
		(tlo_t **)MALLOC(14 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 7;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_imported);
	strcpy(obj->objs[1]->name, "imported");
	if (arg_imported)
		flagsv[nflags-1] |= (1 << 7);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 11;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_saved_out);
	strcpy(obj->objs[2]->name, "saved_out");
	if (arg_saved_out)
		flagsv[nflags-1] |= (1 << 11);

	//parse argument Peer
	if (arg_from_id){
		obj->objs[3] = arg_from_id;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "from_id");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_from_name){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 5;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_from_name, strlen(arg_from_name));
		strcpy(obj->objs[4]->name, "from_name");
		flagsv[nflags-1] |= (1 << 5);
	}


	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[5]->name, "date");

	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 2;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_channel_post);
	strcpy(obj->objs[6]->name, "channel_post");
	if (arg_channel_post)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument string
	if (arg_post_author){
		obj->objs[7] = NEW(tlo_t, return NULL);
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 3;
		obj->objs[7]->type = TYPE_STRING;
		obj->objs[7]->value = 
			buf_add((ui8_t *)arg_post_author, strlen(arg_post_author));
		strcpy(obj->objs[7]->name, "post_author");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument Peer
	if (arg_saved_from_peer){
		obj->objs[8] = arg_saved_from_peer;
		obj->objs[8]->flag_num = 1;
		obj->objs[8]->flag_bit = 4;
	strcpy(obj->objs[8]->name, "saved_from_peer");
		flagsv[nflags-1] |= (1 << 4);
	}


	//parse argument int
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 1;
	obj->objs[9]->flag_bit = 4;
	obj->objs[9]->type = TYPE_INT;
	obj->objs[9]->value = 
		buf_add_ui32(arg_saved_from_msg_id);
	strcpy(obj->objs[9]->name, "saved_from_msg_id");
	if (arg_saved_from_msg_id)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument Peer
	if (arg_saved_from_id){
		obj->objs[10] = arg_saved_from_id;
		obj->objs[10]->flag_num = 1;
		obj->objs[10]->flag_bit = 8;
	strcpy(obj->objs[10]->name, "saved_from_id");
		flagsv[nflags-1] |= (1 << 8);
	}


	//parse argument string
	if (arg_saved_from_name){
		obj->objs[11] = NEW(tlo_t, return NULL);
		obj->objs[11]->flag_num = 1;
		obj->objs[11]->flag_bit = 9;
		obj->objs[11]->type = TYPE_STRING;
		obj->objs[11]->value = 
			buf_add((ui8_t *)arg_saved_from_name, strlen(arg_saved_from_name));
		strcpy(obj->objs[11]->name, "saved_from_name");
		flagsv[nflags-1] |= (1 << 9);
	}


	//parse argument int
	obj->objs[12] = NEW(tlo_t, return NULL);
	obj->objs[12]->flag_num = 1;
	obj->objs[12]->flag_bit = 10;
	obj->objs[12]->type = TYPE_INT;
	obj->objs[12]->value = 
		buf_add_ui32(arg_saved_date);
	strcpy(obj->objs[12]->name, "saved_date");
	if (arg_saved_date)
		flagsv[nflags-1] |= (1 << 10);

	//parse argument string
	if (arg_psa_type){
		obj->objs[13] = NEW(tlo_t, return NULL);
		obj->objs[13]->flag_num = 1;
		obj->objs[13]->flag_bit = 6;
		obj->objs[13]->type = TYPE_STRING;
		obj->objs[13]->value = 
			buf_add((ui8_t *)arg_psa_type, strlen(arg_psa_type));
		strcpy(obj->objs[13]->name, "psa_type");
		flagsv[nflags-1] |= (1 << 6);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_auth_codeTypeSms()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_codeTypeSms");
	int i;
	obj->id = 0x72a3158c;
	return obj;
}

tlo_t * tl_auth_codeTypeCall()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_codeTypeCall");
	int i;
	obj->id = 0x741cd3e3;
	return obj;
}

tlo_t * tl_auth_codeTypeFlashCall()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_codeTypeFlashCall");
	int i;
	obj->id = 0x226ccefb;
	return obj;
}

tlo_t * tl_auth_codeTypeMissedCall()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_codeTypeMissedCall");
	int i;
	obj->id = 0xd61ad6ee;
	return obj;
}

tlo_t * tl_auth_codeTypeFragmentSms()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_codeTypeFragmentSms");
	int i;
	obj->id = 0x06ed998c;
	return obj;
}

tlo_t * tl_auth_sentCodeTypeApp(int arg_length)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_sentCodeTypeApp");
	int i;
	obj->id = 0x3dbb5986;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_length);
	strcpy(obj->objs[0]->name, "length");
	return obj;
}

tlo_t * tl_auth_sentCodeTypeSms(int arg_length)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_sentCodeTypeSms");
	int i;
	obj->id = 0xc000bba2;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_length);
	strcpy(obj->objs[0]->name, "length");
	return obj;
}

tlo_t * tl_auth_sentCodeTypeCall(int arg_length)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_sentCodeTypeCall");
	int i;
	obj->id = 0x5353e5a7;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_length);
	strcpy(obj->objs[0]->name, "length");
	return obj;
}

tlo_t * tl_auth_sentCodeTypeFlashCall(const char * arg_pattern)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_sentCodeTypeFlashCall");
	int i;
	obj->id = 0xab03c6d9;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_pattern){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_pattern, strlen(arg_pattern));
		strcpy(obj->objs[0]->name, "pattern");
	}

	return obj;
}

tlo_t * tl_auth_sentCodeTypeMissedCall(const char * arg_prefix, int arg_length)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_sentCodeTypeMissedCall");
	int i;
	obj->id = 0x82006484;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_prefix){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_prefix, strlen(arg_prefix));
		strcpy(obj->objs[0]->name, "prefix");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_length);
	strcpy(obj->objs[1]->name, "length");
	return obj;
}

tlo_t * tl_auth_sentCodeTypeEmailCode(bool arg_apple_signin_allowed, bool arg_google_signin_allowed, const char * arg_email_pattern, int arg_length, int arg_reset_available_period, int arg_reset_pending_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_sentCodeTypeEmailCode");
	int i;
	obj->id = 0xf450f59b;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_apple_signin_allowed);
	strcpy(obj->objs[1]->name, "apple_signin_allowed");
	if (arg_apple_signin_allowed)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_google_signin_allowed);
	strcpy(obj->objs[2]->name, "google_signin_allowed");
	if (arg_google_signin_allowed)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument string
	if (arg_email_pattern){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_email_pattern, strlen(arg_email_pattern));
		strcpy(obj->objs[3]->name, "email_pattern");
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_length);
	strcpy(obj->objs[4]->name, "length");

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 3;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_reset_available_period);
	strcpy(obj->objs[5]->name, "reset_available_period");
	if (arg_reset_available_period)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 4;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_reset_pending_date);
	strcpy(obj->objs[6]->name, "reset_pending_date");
	if (arg_reset_pending_date)
		flagsv[nflags-1] |= (1 << 4);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_auth_sentCodeTypeSetUpEmailRequired(bool arg_apple_signin_allowed, bool arg_google_signin_allowed)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_sentCodeTypeSetUpEmailRequired");
	int i;
	obj->id = 0xa5491dea;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_apple_signin_allowed);
	strcpy(obj->objs[1]->name, "apple_signin_allowed");
	if (arg_apple_signin_allowed)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_google_signin_allowed);
	strcpy(obj->objs[2]->name, "google_signin_allowed");
	if (arg_google_signin_allowed)
		flagsv[nflags-1] |= (1 << 1);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_auth_sentCodeTypeFragmentSms(const char * arg_url, int arg_length)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_sentCodeTypeFragmentSms");
	int i;
	obj->id = 0xd9565c39;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_url){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[0]->name, "url");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_length);
	strcpy(obj->objs[1]->name, "length");
	return obj;
}

tlo_t * tl_auth_sentCodeTypeFirebaseSms(unsigned char * arg_nonce, int len_arg_nonce, long arg_play_integrity_project_id, unsigned char * arg_play_integrity_nonce, int len_arg_play_integrity_nonce, const char * arg_receipt, int arg_push_timeout, int arg_length)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_sentCodeTypeFirebaseSms");
	int i;
	obj->id = 0x009fd736;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument bytes
	if (arg_nonce){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_nonce, len_arg_nonce);
		strcpy(obj->objs[1]->name, "nonce");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 2;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_play_integrity_project_id);
	strcpy(obj->objs[2]->name, "play_integrity_project_id");
	if (arg_play_integrity_project_id)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument bytes
	if (arg_play_integrity_nonce){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 2;
		obj->objs[3]->type = TYPE_BYTES;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_play_integrity_nonce, len_arg_play_integrity_nonce);
		strcpy(obj->objs[3]->name, "play_integrity_nonce");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument string
	if (arg_receipt){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 1;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_receipt, strlen(arg_receipt));
		strcpy(obj->objs[4]->name, "receipt");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 1;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_push_timeout);
	strcpy(obj->objs[5]->name, "push_timeout");
	if (arg_push_timeout)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_length);
	strcpy(obj->objs[6]->name, "length");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_auth_sentCodeTypeSmsWord(const char * arg_beginning)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_sentCodeTypeSmsWord");
	int i;
	obj->id = 0xa416ac81;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_beginning){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_beginning, strlen(arg_beginning));
		strcpy(obj->objs[1]->name, "beginning");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_auth_sentCodeTypeSmsPhrase(const char * arg_beginning)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_sentCodeTypeSmsPhrase");
	int i;
	obj->id = 0xb37794af;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_beginning){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_beginning, strlen(arg_beginning));
		strcpy(obj->objs[1]->name, "beginning");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_botCallbackAnswer(bool arg_alert, bool arg_has_url, bool arg_native_ui, const char * arg_message, const char * arg_url, int arg_cache_time)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_botCallbackAnswer");
	int i;
	obj->id = 0x36585ea4;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_alert);
	strcpy(obj->objs[1]->name, "alert");
	if (arg_alert)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 3;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_has_url);
	strcpy(obj->objs[2]->name, "has_url");
	if (arg_has_url)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 4;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_native_ui);
	strcpy(obj->objs[3]->name, "native_ui");
	if (arg_native_ui)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument string
	if (arg_message){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_message, strlen(arg_message));
		strcpy(obj->objs[4]->name, "message");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_url){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 2;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[5]->name, "url");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_cache_time);
	strcpy(obj->objs[6]->name, "cache_time");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_messageEditData(bool arg_caption)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_messageEditData");
	int i;
	obj->id = 0x26b5dde6;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_caption);
	strcpy(obj->objs[1]->name, "caption");
	if (arg_caption)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputBotInlineMessageID(int arg_dc_id, long arg_id, long arg_access_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputBotInlineMessageID");
	int i;
	obj->id = 0x890c3d89;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_dc_id);
	strcpy(obj->objs[0]->name, "dc_id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[1]->name, "id");

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[2]->name, "access_hash");
	return obj;
}

tlo_t * tl_inputBotInlineMessageID64(int arg_dc_id, long arg_owner_id, int arg_id, long arg_access_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputBotInlineMessageID64");
	int i;
	obj->id = 0xb6d915d7;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_dc_id);
	strcpy(obj->objs[0]->name, "dc_id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_owner_id);
	strcpy(obj->objs[1]->name, "owner_id");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[2]->name, "id");

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[3]->name, "access_hash");
	return obj;
}

tlo_t * tl_inlineBotSwitchPM(const char * arg_text, const char * arg_start_param)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inlineBotSwitchPM");
	int i;
	obj->id = 0x3c20629f;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_text){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[0]->name, "text");
	}


	//parse argument string
	if (arg_start_param){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_start_param, strlen(arg_start_param));
		strcpy(obj->objs[1]->name, "start_param");
	}

	return obj;
}

tlo_t * tl_messages_peerDialogs(Dialog *arg_dialogs, int len_arg_dialogs, Message *arg_messages, int len_arg_messages, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users, updates_State arg_state)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_peerDialogs");
	int i;
	obj->id = 0x3371c354;
	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<Dialog>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "dialogs");
	if (arg_dialogs){
		for(i=0; i<len_arg_dialogs; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_dialogs[i]->id);
			buf_cat(obj->objs[0]->value, arg_dialogs[i]->value);
		}
	}


	//parse argument Vector<Message>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "messages");
	if (arg_messages){
		for(i=0; i<len_arg_messages; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_messages[i]->id);
			buf_cat(obj->objs[1]->value, arg_messages[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[2]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[3]->value, arg_users[i]->value);
		}
	}


	//parse argument updates_State
	if (arg_state){
		obj->objs[4] = arg_state;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "state");
	}

	return obj;
}

tlo_t * tl_topPeer(Peer arg_peer, double arg_rating)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "topPeer");
	int i;
	obj->id = 0xedcdc05b;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument double
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_rating);
	strcpy(obj->objs[1]->name, "rating");
	return obj;
}

tlo_t * tl_topPeerCategoryBotsPM()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "topPeerCategoryBotsPM");
	int i;
	obj->id = 0xab661b5b;
	return obj;
}

tlo_t * tl_topPeerCategoryBotsInline()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "topPeerCategoryBotsInline");
	int i;
	obj->id = 0x148677e2;
	return obj;
}

tlo_t * tl_topPeerCategoryCorrespondents()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "topPeerCategoryCorrespondents");
	int i;
	obj->id = 0x0637b7ed;
	return obj;
}

tlo_t * tl_topPeerCategoryGroups()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "topPeerCategoryGroups");
	int i;
	obj->id = 0xbd17a14a;
	return obj;
}

tlo_t * tl_topPeerCategoryChannels()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "topPeerCategoryChannels");
	int i;
	obj->id = 0x161d9628;
	return obj;
}

tlo_t * tl_topPeerCategoryPhoneCalls()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "topPeerCategoryPhoneCalls");
	int i;
	obj->id = 0x1e76a78c;
	return obj;
}

tlo_t * tl_topPeerCategoryForwardUsers()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "topPeerCategoryForwardUsers");
	int i;
	obj->id = 0xa8406ca9;
	return obj;
}

tlo_t * tl_topPeerCategoryForwardChats()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "topPeerCategoryForwardChats");
	int i;
	obj->id = 0xfbeec0f0;
	return obj;
}

tlo_t * tl_topPeerCategoryBotsApp()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "topPeerCategoryBotsApp");
	int i;
	obj->id = 0xfd9e7bec;
	return obj;
}

tlo_t * tl_topPeerCategoryPeers(TopPeerCategory arg_category, int arg_count, TopPeer *arg_peers, int len_arg_peers)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "topPeerCategoryPeers");
	int i;
	obj->id = 0xfb834291;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument TopPeerCategory
	if (arg_category){
		obj->objs[0] = arg_category;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "category");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[1]->name, "count");

	//parse argument Vector<TopPeer>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "peers");
	if (arg_peers){
		for(i=0; i<len_arg_peers; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_peers[i]->id);
			buf_cat(obj->objs[2]->value, arg_peers[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_contacts_topPeersNotModified()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_topPeersNotModified");
	int i;
	obj->id = 0xde266ef5;
	return obj;
}

tlo_t * tl_contacts_topPeers(TopPeerCategoryPeers *arg_categories, int len_arg_categories, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_topPeers");
	int i;
	obj->id = 0x70b772a8;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<TopPeerCategoryPeers>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "categories");
	if (arg_categories){
		for(i=0; i<len_arg_categories; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_categories[i]->id);
			buf_cat(obj->objs[0]->value, arg_categories[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[1]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[2]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_contacts_topPeersDisabled()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_topPeersDisabled");
	int i;
	obj->id = 0xb52c939d;
	return obj;
}

tlo_t * tl_draftMessageEmpty(int arg_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "draftMessageEmpty");
	int i;
	obj->id = 0x1b0c841a;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[1]->name, "date");
	if (arg_date)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_draftMessage(bool arg_no_webpage, bool arg_invert_media, InputReplyTo arg_reply_to, const char * arg_message, MessageEntity *arg_entities, int len_arg_entities, InputMedia arg_media, int arg_date, long arg_effect)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "draftMessage");
	int i;
	obj->id = 0x2d65321f;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_no_webpage);
	strcpy(obj->objs[1]->name, "no_webpage");
	if (arg_no_webpage)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 6;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_invert_media);
	strcpy(obj->objs[2]->name, "invert_media");
	if (arg_invert_media)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument InputReplyTo
	if (arg_reply_to){
		obj->objs[3] = arg_reply_to;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 4;
	strcpy(obj->objs[3]->name, "reply_to");
		flagsv[nflags-1] |= (1 << 4);
	}


	//parse argument string
	if (arg_message){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_message, strlen(arg_message));
		strcpy(obj->objs[4]->name, "message");
	}


	//parse argument Vector<MessageEntity>
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 3;
	obj->objs[5]->type = TYPE_VECTOR;
	strcpy(obj->objs[5]->name, "entities");
	if (arg_entities){
		for(i=0; i<len_arg_entities; ++i){
			obj->objs[5]->value = buf_add_ui32(arg_entities[i]->id);
			buf_cat(obj->objs[5]->value, arg_entities[i]->value);
		}
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument InputMedia
	if (arg_media){
		obj->objs[6] = arg_media;
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 5;
	strcpy(obj->objs[6]->name, "media");
		flagsv[nflags-1] |= (1 << 5);
	}


	//parse argument int
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[7]->name, "date");

	//parse argument long
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 7;
	obj->objs[8]->type = TYPE_LONG;
	obj->objs[8]->value = 
		buf_add_ui64(arg_effect);
	strcpy(obj->objs[8]->name, "effect");
	if (arg_effect)
		flagsv[nflags-1] |= (1 << 7);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_featuredStickersNotModified(int arg_count)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_featuredStickersNotModified");
	int i;
	obj->id = 0xc6dc0c66;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[0]->name, "count");
	return obj;
}

tlo_t * tl_messages_featuredStickers(bool arg_premium, long arg_hash, int arg_count, StickerSetCovered *arg_sets, int len_arg_sets, long *arg_unread, int len_arg_unread)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_featuredStickers");
	int i;
	obj->id = 0xbe382906;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_premium);
	strcpy(obj->objs[1]->name, "premium");
	if (arg_premium)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[2]->name, "hash");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[3]->name, "count");

	//parse argument Vector<StickerSetCovered>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "sets");
	if (arg_sets){
		for(i=0; i<len_arg_sets; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_sets[i]->id);
			buf_cat(obj->objs[4]->value, arg_sets[i]->value);
		}
	}


	//parse argument Vector<long>
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_VECTOR;
	strcpy(obj->objs[5]->name, "unread");
	if (arg_unread){
		for(i=0; i<len_arg_unread; ++i){
			buf_t b = buf_add_ui64(arg_unread[i]);
			buf_cat(obj->objs[5]->value, b);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_recentStickersNotModified()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_recentStickersNotModified");
	int i;
	obj->id = 0x0b17f890;
	return obj;
}

tlo_t * tl_messages_recentStickers(long arg_hash, StickerPack *arg_packs, int len_arg_packs, Document *arg_stickers, int len_arg_stickers, int *arg_dates, int len_arg_dates)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_recentStickers");
	int i;
	obj->id = 0x88d37c56;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");

	//parse argument Vector<StickerPack>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "packs");
	if (arg_packs){
		for(i=0; i<len_arg_packs; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_packs[i]->id);
			buf_cat(obj->objs[1]->value, arg_packs[i]->value);
		}
	}


	//parse argument Vector<Document>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "stickers");
	if (arg_stickers){
		for(i=0; i<len_arg_stickers; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_stickers[i]->id);
			buf_cat(obj->objs[2]->value, arg_stickers[i]->value);
		}
	}


	//parse argument Vector<int>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "dates");
	if (arg_dates){
		for(i=0; i<len_arg_dates; ++i){
			buf_t b = buf_add_ui32(arg_dates[i]);
			buf_cat(obj->objs[3]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_messages_archivedStickers(int arg_count, StickerSetCovered *arg_sets, int len_arg_sets)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_archivedStickers");
	int i;
	obj->id = 0x4fcba9c8;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[0]->name, "count");

	//parse argument Vector<StickerSetCovered>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "sets");
	if (arg_sets){
		for(i=0; i<len_arg_sets; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_sets[i]->id);
			buf_cat(obj->objs[1]->value, arg_sets[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_messages_stickerSetInstallResultSuccess()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_stickerSetInstallResultSuccess");
	int i;
	obj->id = 0x38641628;
	return obj;
}

tlo_t * tl_messages_stickerSetInstallResultArchive(StickerSetCovered *arg_sets, int len_arg_sets)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_stickerSetInstallResultArchive");
	int i;
	obj->id = 0x35e410a8;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<StickerSetCovered>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "sets");
	if (arg_sets){
		for(i=0; i<len_arg_sets; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_sets[i]->id);
			buf_cat(obj->objs[0]->value, arg_sets[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_stickerSetCovered(StickerSet arg_set, Document arg_cover)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stickerSetCovered");
	int i;
	obj->id = 0x6410a5d2;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument StickerSet
	if (arg_set){
		obj->objs[0] = arg_set;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "set");
	}


	//parse argument Document
	if (arg_cover){
		obj->objs[1] = arg_cover;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "cover");
	}

	return obj;
}

tlo_t * tl_stickerSetMultiCovered(StickerSet arg_set, Document *arg_covers, int len_arg_covers)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stickerSetMultiCovered");
	int i;
	obj->id = 0x3407e51b;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument StickerSet
	if (arg_set){
		obj->objs[0] = arg_set;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "set");
	}


	//parse argument Vector<Document>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "covers");
	if (arg_covers){
		for(i=0; i<len_arg_covers; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_covers[i]->id);
			buf_cat(obj->objs[1]->value, arg_covers[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_stickerSetFullCovered(StickerSet arg_set, StickerPack *arg_packs, int len_arg_packs, StickerKeyword *arg_keywords, int len_arg_keywords, Document *arg_documents, int len_arg_documents)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stickerSetFullCovered");
	int i;
	obj->id = 0x40d13c0e;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument StickerSet
	if (arg_set){
		obj->objs[0] = arg_set;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "set");
	}


	//parse argument Vector<StickerPack>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "packs");
	if (arg_packs){
		for(i=0; i<len_arg_packs; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_packs[i]->id);
			buf_cat(obj->objs[1]->value, arg_packs[i]->value);
		}
	}


	//parse argument Vector<StickerKeyword>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "keywords");
	if (arg_keywords){
		for(i=0; i<len_arg_keywords; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_keywords[i]->id);
			buf_cat(obj->objs[2]->value, arg_keywords[i]->value);
		}
	}


	//parse argument Vector<Document>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "documents");
	if (arg_documents){
		for(i=0; i<len_arg_documents; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_documents[i]->id);
			buf_cat(obj->objs[3]->value, arg_documents[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_stickerSetNoCovered(StickerSet arg_set)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stickerSetNoCovered");
	int i;
	obj->id = 0x77b15d1c;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument StickerSet
	if (arg_set){
		obj->objs[0] = arg_set;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "set");
	}

	return obj;
}

tlo_t * tl_maskCoords(int arg_n, double arg_x, double arg_y, double arg_zoom)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "maskCoords");
	int i;
	obj->id = 0xaed6dbb2;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_n);
	strcpy(obj->objs[0]->name, "n");

	//parse argument double
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_x);
	strcpy(obj->objs[1]->name, "x");

	//parse argument double
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_y);
	strcpy(obj->objs[2]->name, "y");

	//parse argument double
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_zoom);
	strcpy(obj->objs[3]->name, "zoom");
	return obj;
}

tlo_t * tl_inputStickeredMediaPhoto(InputPhoto arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputStickeredMediaPhoto");
	int i;
	obj->id = 0x4a992157;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputPhoto
	if (arg_id){
		obj->objs[0] = arg_id;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "id");
	}

	return obj;
}

tlo_t * tl_inputStickeredMediaDocument(InputDocument arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputStickeredMediaDocument");
	int i;
	obj->id = 0x0438865b;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputDocument
	if (arg_id){
		obj->objs[0] = arg_id;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "id");
	}

	return obj;
}

tlo_t * tl_game(long arg_id, long arg_access_hash, const char * arg_short_name, const char * arg_title, const char * arg_description, Photo arg_photo, Document arg_document)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "game");
	int i;
	obj->id = 0xbdf9653b;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[1]->name, "id");

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[2]->name, "access_hash");

	//parse argument string
	if (arg_short_name){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_short_name, strlen(arg_short_name));
		strcpy(obj->objs[3]->name, "short_name");
	}


	//parse argument string
	if (arg_title){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[4]->name, "title");
	}


	//parse argument string
	if (arg_description){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_description, strlen(arg_description));
		strcpy(obj->objs[5]->name, "description");
	}


	//parse argument Photo
	if (arg_photo){
		obj->objs[6] = arg_photo;
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
	strcpy(obj->objs[6]->name, "photo");
	}


	//parse argument Document
	if (arg_document){
		obj->objs[7] = arg_document;
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 0;
	strcpy(obj->objs[7]->name, "document");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputGameID(long arg_id, long arg_access_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputGameID");
	int i;
	obj->id = 0x032c3e77;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[1]->name, "access_hash");
	return obj;
}

tlo_t * tl_inputGameShortName(InputUser arg_bot_id, const char * arg_short_name)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputGameShortName");
	int i;
	obj->id = 0xc331e80a;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputUser
	if (arg_bot_id){
		obj->objs[0] = arg_bot_id;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "bot_id");
	}


	//parse argument string
	if (arg_short_name){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_short_name, strlen(arg_short_name));
		strcpy(obj->objs[1]->name, "short_name");
	}

	return obj;
}

tlo_t * tl_highScore(int arg_pos, long arg_user_id, int arg_score)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "highScore");
	int i;
	obj->id = 0x73a379eb;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_pos);
	strcpy(obj->objs[0]->name, "pos");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[1]->name, "user_id");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_score);
	strcpy(obj->objs[2]->name, "score");
	return obj;
}

tlo_t * tl_messages_highScores(HighScore *arg_scores, int len_arg_scores, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_highScores");
	int i;
	obj->id = 0x9a3bfd99;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<HighScore>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "scores");
	if (arg_scores){
		for(i=0; i<len_arg_scores; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_scores[i]->id);
			buf_cat(obj->objs[0]->value, arg_scores[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[1]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_textEmpty()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "textEmpty");
	int i;
	obj->id = 0xdc3d824f;
	return obj;
}

tlo_t * tl_textPlain(const char * arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "textPlain");
	int i;
	obj->id = 0x744694e0;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_text){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[0]->name, "text");
	}

	return obj;
}

tlo_t * tl_textBold(RichText arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "textBold");
	int i;
	obj->id = 0x6724abc4;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument RichText
	if (arg_text){
		obj->objs[0] = arg_text;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "text");
	}

	return obj;
}

tlo_t * tl_textItalic(RichText arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "textItalic");
	int i;
	obj->id = 0xd912a59c;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument RichText
	if (arg_text){
		obj->objs[0] = arg_text;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "text");
	}

	return obj;
}

tlo_t * tl_textUnderline(RichText arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "textUnderline");
	int i;
	obj->id = 0xc12622c4;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument RichText
	if (arg_text){
		obj->objs[0] = arg_text;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "text");
	}

	return obj;
}

tlo_t * tl_textStrike(RichText arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "textStrike");
	int i;
	obj->id = 0x9bf8bb95;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument RichText
	if (arg_text){
		obj->objs[0] = arg_text;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "text");
	}

	return obj;
}

tlo_t * tl_textFixed(RichText arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "textFixed");
	int i;
	obj->id = 0x6c3f19b9;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument RichText
	if (arg_text){
		obj->objs[0] = arg_text;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "text");
	}

	return obj;
}

tlo_t * tl_textUrl(RichText arg_text, const char * arg_url, long arg_webpage_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "textUrl");
	int i;
	obj->id = 0x3c2884c1;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument RichText
	if (arg_text){
		obj->objs[0] = arg_text;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "text");
	}


	//parse argument string
	if (arg_url){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[1]->name, "url");
	}


	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_webpage_id);
	strcpy(obj->objs[2]->name, "webpage_id");
	return obj;
}

tlo_t * tl_textEmail(RichText arg_text, const char * arg_email)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "textEmail");
	int i;
	obj->id = 0xde5a0dd6;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument RichText
	if (arg_text){
		obj->objs[0] = arg_text;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "text");
	}


	//parse argument string
	if (arg_email){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_email, strlen(arg_email));
		strcpy(obj->objs[1]->name, "email");
	}

	return obj;
}

tlo_t * tl_textConcat(RichText *arg_texts, int len_arg_texts)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "textConcat");
	int i;
	obj->id = 0x7e6260d7;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<RichText>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "texts");
	if (arg_texts){
		for(i=0; i<len_arg_texts; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_texts[i]->id);
			buf_cat(obj->objs[0]->value, arg_texts[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_textSubscript(RichText arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "textSubscript");
	int i;
	obj->id = 0xed6a8504;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument RichText
	if (arg_text){
		obj->objs[0] = arg_text;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "text");
	}

	return obj;
}

tlo_t * tl_textSuperscript(RichText arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "textSuperscript");
	int i;
	obj->id = 0xc7fb5e01;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument RichText
	if (arg_text){
		obj->objs[0] = arg_text;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "text");
	}

	return obj;
}

tlo_t * tl_textMarked(RichText arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "textMarked");
	int i;
	obj->id = 0x034b8621;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument RichText
	if (arg_text){
		obj->objs[0] = arg_text;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "text");
	}

	return obj;
}

tlo_t * tl_textPhone(RichText arg_text, const char * arg_phone)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "textPhone");
	int i;
	obj->id = 0x1ccb966a;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument RichText
	if (arg_text){
		obj->objs[0] = arg_text;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "text");
	}


	//parse argument string
	if (arg_phone){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_phone, strlen(arg_phone));
		strcpy(obj->objs[1]->name, "phone");
	}

	return obj;
}

tlo_t * tl_textImage(long arg_document_id, int arg_w, int arg_h)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "textImage");
	int i;
	obj->id = 0x081ccf4f;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_document_id);
	strcpy(obj->objs[0]->name, "document_id");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_w);
	strcpy(obj->objs[1]->name, "w");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_h);
	strcpy(obj->objs[2]->name, "h");
	return obj;
}

tlo_t * tl_textAnchor(RichText arg_text, const char * arg_name)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "textAnchor");
	int i;
	obj->id = 0x35553762;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument RichText
	if (arg_text){
		obj->objs[0] = arg_text;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "text");
	}


	//parse argument string
	if (arg_name){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_name, strlen(arg_name));
		strcpy(obj->objs[1]->name, "name");
	}

	return obj;
}

tlo_t * tl_pageBlockUnsupported()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageBlockUnsupported");
	int i;
	obj->id = 0x13567e8a;
	return obj;
}

tlo_t * tl_pageBlockTitle(RichText arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageBlockTitle");
	int i;
	obj->id = 0x70abc3fd;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument RichText
	if (arg_text){
		obj->objs[0] = arg_text;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "text");
	}

	return obj;
}

tlo_t * tl_pageBlockSubtitle(RichText arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageBlockSubtitle");
	int i;
	obj->id = 0x8ffa9a1f;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument RichText
	if (arg_text){
		obj->objs[0] = arg_text;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "text");
	}

	return obj;
}

tlo_t * tl_pageBlockAuthorDate(RichText arg_author, int arg_published_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageBlockAuthorDate");
	int i;
	obj->id = 0xbaafe5e0;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument RichText
	if (arg_author){
		obj->objs[0] = arg_author;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "author");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_published_date);
	strcpy(obj->objs[1]->name, "published_date");
	return obj;
}

tlo_t * tl_pageBlockHeader(RichText arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageBlockHeader");
	int i;
	obj->id = 0xbfd064ec;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument RichText
	if (arg_text){
		obj->objs[0] = arg_text;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "text");
	}

	return obj;
}

tlo_t * tl_pageBlockSubheader(RichText arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageBlockSubheader");
	int i;
	obj->id = 0xf12bb6e1;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument RichText
	if (arg_text){
		obj->objs[0] = arg_text;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "text");
	}

	return obj;
}

tlo_t * tl_pageBlockParagraph(RichText arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageBlockParagraph");
	int i;
	obj->id = 0x467a0766;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument RichText
	if (arg_text){
		obj->objs[0] = arg_text;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "text");
	}

	return obj;
}

tlo_t * tl_pageBlockPreformatted(RichText arg_text, const char * arg_language)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageBlockPreformatted");
	int i;
	obj->id = 0xc070d93e;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument RichText
	if (arg_text){
		obj->objs[0] = arg_text;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "text");
	}


	//parse argument string
	if (arg_language){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_language, strlen(arg_language));
		strcpy(obj->objs[1]->name, "language");
	}

	return obj;
}

tlo_t * tl_pageBlockFooter(RichText arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageBlockFooter");
	int i;
	obj->id = 0x48870999;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument RichText
	if (arg_text){
		obj->objs[0] = arg_text;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "text");
	}

	return obj;
}

tlo_t * tl_pageBlockDivider()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageBlockDivider");
	int i;
	obj->id = 0xdb20b188;
	return obj;
}

tlo_t * tl_pageBlockAnchor(const char * arg_name)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageBlockAnchor");
	int i;
	obj->id = 0xce0d37b0;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_name){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_name, strlen(arg_name));
		strcpy(obj->objs[0]->name, "name");
	}

	return obj;
}

tlo_t * tl_pageBlockList(PageListItem *arg_items, int len_arg_items)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageBlockList");
	int i;
	obj->id = 0xe4e88011;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<PageListItem>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "items");
	if (arg_items){
		for(i=0; i<len_arg_items; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_items[i]->id);
			buf_cat(obj->objs[0]->value, arg_items[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_pageBlockBlockquote(RichText arg_text, RichText arg_caption)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageBlockBlockquote");
	int i;
	obj->id = 0x263d7c26;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument RichText
	if (arg_text){
		obj->objs[0] = arg_text;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "text");
	}


	//parse argument RichText
	if (arg_caption){
		obj->objs[1] = arg_caption;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "caption");
	}

	return obj;
}

tlo_t * tl_pageBlockPullquote(RichText arg_text, RichText arg_caption)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageBlockPullquote");
	int i;
	obj->id = 0x4f4456d3;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument RichText
	if (arg_text){
		obj->objs[0] = arg_text;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "text");
	}


	//parse argument RichText
	if (arg_caption){
		obj->objs[1] = arg_caption;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "caption");
	}

	return obj;
}

tlo_t * tl_pageBlockPhoto(long arg_photo_id, PageCaption arg_caption, const char * arg_url, long arg_webpage_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageBlockPhoto");
	int i;
	obj->id = 0x1759c560;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_photo_id);
	strcpy(obj->objs[1]->name, "photo_id");

	//parse argument PageCaption
	if (arg_caption){
		obj->objs[2] = arg_caption;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "caption");
	}


	//parse argument string
	if (arg_url){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[3]->name, "url");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument long
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_webpage_id);
	strcpy(obj->objs[4]->name, "webpage_id");
	if (arg_webpage_id)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_pageBlockVideo(bool arg_autoplay, bool arg_loop, long arg_video_id, PageCaption arg_caption)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageBlockVideo");
	int i;
	obj->id = 0x7c8fe7b6;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_autoplay);
	strcpy(obj->objs[1]->name, "autoplay");
	if (arg_autoplay)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_loop);
	strcpy(obj->objs[2]->name, "loop");
	if (arg_loop)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_video_id);
	strcpy(obj->objs[3]->name, "video_id");

	//parse argument PageCaption
	if (arg_caption){
		obj->objs[4] = arg_caption;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "caption");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_pageBlockCover(PageBlock arg_cover)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageBlockCover");
	int i;
	obj->id = 0x39f23300;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument PageBlock
	if (arg_cover){
		obj->objs[0] = arg_cover;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "cover");
	}

	return obj;
}

tlo_t * tl_pageBlockEmbed(bool arg_full_width, bool arg_allow_scrolling, const char * arg_url, const char * arg_html, long arg_poster_photo_id, int arg_w, int arg_h, PageCaption arg_caption)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageBlockEmbed");
	int i;
	obj->id = 0xa8718dc5;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_full_width);
	strcpy(obj->objs[1]->name, "full_width");
	if (arg_full_width)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 3;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_allow_scrolling);
	strcpy(obj->objs[2]->name, "allow_scrolling");
	if (arg_allow_scrolling)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument string
	if (arg_url){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 1;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[3]->name, "url");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument string
	if (arg_html){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 2;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_html, strlen(arg_html));
		strcpy(obj->objs[4]->name, "html");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument long
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 4;
	obj->objs[5]->type = TYPE_LONG;
	obj->objs[5]->value = 
		buf_add_ui64(arg_poster_photo_id);
	strcpy(obj->objs[5]->name, "poster_photo_id");
	if (arg_poster_photo_id)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 5;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_w);
	strcpy(obj->objs[6]->name, "w");
	if (arg_w)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument int
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 5;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_h);
	strcpy(obj->objs[7]->name, "h");
	if (arg_h)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument PageCaption
	if (arg_caption){
		obj->objs[8] = arg_caption;
		obj->objs[8]->flag_num = 0;
		obj->objs[8]->flag_bit = 0;
	strcpy(obj->objs[8]->name, "caption");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_pageBlockEmbedPost(const char * arg_url, long arg_webpage_id, long arg_author_photo_id, const char * arg_author, int arg_date, PageBlock *arg_blocks, int len_arg_blocks, PageCaption arg_caption)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageBlockEmbedPost");
	int i;
	obj->id = 0xf259a80b;
	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_url){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[0]->name, "url");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_webpage_id);
	strcpy(obj->objs[1]->name, "webpage_id");

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_author_photo_id);
	strcpy(obj->objs[2]->name, "author_photo_id");

	//parse argument string
	if (arg_author){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_author, strlen(arg_author));
		strcpy(obj->objs[3]->name, "author");
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[4]->name, "date");

	//parse argument Vector<PageBlock>
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_VECTOR;
	strcpy(obj->objs[5]->name, "blocks");
	if (arg_blocks){
		for(i=0; i<len_arg_blocks; ++i){
			obj->objs[5]->value = buf_add_ui32(arg_blocks[i]->id);
			buf_cat(obj->objs[5]->value, arg_blocks[i]->value);
		}
	}


	//parse argument PageCaption
	if (arg_caption){
		obj->objs[6] = arg_caption;
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
	strcpy(obj->objs[6]->name, "caption");
	}

	return obj;
}

tlo_t * tl_pageBlockCollage(PageBlock *arg_items, int len_arg_items, PageCaption arg_caption)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageBlockCollage");
	int i;
	obj->id = 0x65a0fa4d;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<PageBlock>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "items");
	if (arg_items){
		for(i=0; i<len_arg_items; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_items[i]->id);
			buf_cat(obj->objs[0]->value, arg_items[i]->value);
		}
	}


	//parse argument PageCaption
	if (arg_caption){
		obj->objs[1] = arg_caption;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "caption");
	}

	return obj;
}

tlo_t * tl_pageBlockSlideshow(PageBlock *arg_items, int len_arg_items, PageCaption arg_caption)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageBlockSlideshow");
	int i;
	obj->id = 0x031f9590;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<PageBlock>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "items");
	if (arg_items){
		for(i=0; i<len_arg_items; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_items[i]->id);
			buf_cat(obj->objs[0]->value, arg_items[i]->value);
		}
	}


	//parse argument PageCaption
	if (arg_caption){
		obj->objs[1] = arg_caption;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "caption");
	}

	return obj;
}

tlo_t * tl_pageBlockChannel(Chat arg_channel)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageBlockChannel");
	int i;
	obj->id = 0xef1751b5;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Chat
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}

	return obj;
}

tlo_t * tl_pageBlockAudio(long arg_audio_id, PageCaption arg_caption)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageBlockAudio");
	int i;
	obj->id = 0x804361ea;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_audio_id);
	strcpy(obj->objs[0]->name, "audio_id");

	//parse argument PageCaption
	if (arg_caption){
		obj->objs[1] = arg_caption;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "caption");
	}

	return obj;
}

tlo_t * tl_pageBlockKicker(RichText arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageBlockKicker");
	int i;
	obj->id = 0x1e148390;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument RichText
	if (arg_text){
		obj->objs[0] = arg_text;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "text");
	}

	return obj;
}

tlo_t * tl_pageBlockTable(bool arg_bordered, bool arg_striped, RichText arg_title, PageTableRow *arg_rows, int len_arg_rows)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageBlockTable");
	int i;
	obj->id = 0xbf4dea82;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_bordered);
	strcpy(obj->objs[1]->name, "bordered");
	if (arg_bordered)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_striped);
	strcpy(obj->objs[2]->name, "striped");
	if (arg_striped)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument RichText
	if (arg_title){
		obj->objs[3] = arg_title;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "title");
	}


	//parse argument Vector<PageTableRow>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "rows");
	if (arg_rows){
		for(i=0; i<len_arg_rows; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_rows[i]->id);
			buf_cat(obj->objs[4]->value, arg_rows[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_pageBlockOrderedList(PageListOrderedItem *arg_items, int len_arg_items)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageBlockOrderedList");
	int i;
	obj->id = 0x9a8ae1e1;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<PageListOrderedItem>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "items");
	if (arg_items){
		for(i=0; i<len_arg_items; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_items[i]->id);
			buf_cat(obj->objs[0]->value, arg_items[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_pageBlockDetails(bool arg_open, PageBlock *arg_blocks, int len_arg_blocks, RichText arg_title)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageBlockDetails");
	int i;
	obj->id = 0x76768bed;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_open);
	strcpy(obj->objs[1]->name, "open");
	if (arg_open)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument Vector<PageBlock>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "blocks");
	if (arg_blocks){
		for(i=0; i<len_arg_blocks; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_blocks[i]->id);
			buf_cat(obj->objs[2]->value, arg_blocks[i]->value);
		}
	}


	//parse argument RichText
	if (arg_title){
		obj->objs[3] = arg_title;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "title");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_pageBlockRelatedArticles(RichText arg_title, PageRelatedArticle *arg_articles, int len_arg_articles)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageBlockRelatedArticles");
	int i;
	obj->id = 0x16115a96;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument RichText
	if (arg_title){
		obj->objs[0] = arg_title;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "title");
	}


	//parse argument Vector<PageRelatedArticle>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "articles");
	if (arg_articles){
		for(i=0; i<len_arg_articles; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_articles[i]->id);
			buf_cat(obj->objs[1]->value, arg_articles[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_pageBlockMap(GeoPoint arg_geo, int arg_zoom, int arg_w, int arg_h, PageCaption arg_caption)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageBlockMap");
	int i;
	obj->id = 0xa44f3ef6;
	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument GeoPoint
	if (arg_geo){
		obj->objs[0] = arg_geo;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "geo");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_zoom);
	strcpy(obj->objs[1]->name, "zoom");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_w);
	strcpy(obj->objs[2]->name, "w");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_h);
	strcpy(obj->objs[3]->name, "h");

	//parse argument PageCaption
	if (arg_caption){
		obj->objs[4] = arg_caption;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "caption");
	}

	return obj;
}

tlo_t * tl_phoneCallDiscardReasonMissed()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phoneCallDiscardReasonMissed");
	int i;
	obj->id = 0x85e42301;
	return obj;
}

tlo_t * tl_phoneCallDiscardReasonDisconnect()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phoneCallDiscardReasonDisconnect");
	int i;
	obj->id = 0xe095c1a0;
	return obj;
}

tlo_t * tl_phoneCallDiscardReasonHangup()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phoneCallDiscardReasonHangup");
	int i;
	obj->id = 0x57adc690;
	return obj;
}

tlo_t * tl_phoneCallDiscardReasonBusy()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phoneCallDiscardReasonBusy");
	int i;
	obj->id = 0xfaf7e8c9;
	return obj;
}

tlo_t * tl_dataJSON(const char * arg_data)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "dataJSON");
	int i;
	obj->id = 0x7d748d04;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_data){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_data, strlen(arg_data));
		strcpy(obj->objs[0]->name, "data");
	}

	return obj;
}

tlo_t * tl_labeledPrice(const char * arg_label, long arg_amount)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "labeledPrice");
	int i;
	obj->id = 0xcb296bf8;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_label){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_label, strlen(arg_label));
		strcpy(obj->objs[0]->name, "label");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_amount);
	strcpy(obj->objs[1]->name, "amount");
	return obj;
}

tlo_t * tl_invoice(bool arg_test, bool arg_name_requested, bool arg_phone_requested, bool arg_email_requested, bool arg_shipping_address_requested, bool arg_flexible, bool arg_phone_to_provider, bool arg_email_to_provider, bool arg_recurring, const char * arg_currency, LabeledPrice *arg_prices, int len_arg_prices, long arg_max_tip_amount, long *arg_suggested_tip_amounts, int len_arg_suggested_tip_amounts, const char * arg_terms_url)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "invoice");
	int i;
	obj->id = 0x5db95a15;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 15;
	obj->objs = 
		(tlo_t **)MALLOC(15 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_test);
	strcpy(obj->objs[1]->name, "test");
	if (arg_test)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_name_requested);
	strcpy(obj->objs[2]->name, "name_requested");
	if (arg_name_requested)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_phone_requested);
	strcpy(obj->objs[3]->name, "phone_requested");
	if (arg_phone_requested)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 3;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_email_requested);
	strcpy(obj->objs[4]->name, "email_requested");
	if (arg_email_requested)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 4;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_shipping_address_requested);
	strcpy(obj->objs[5]->name, "shipping_address_requested");
	if (arg_shipping_address_requested)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument true
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 5;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_flexible);
	strcpy(obj->objs[6]->name, "flexible");
	if (arg_flexible)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument true
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 6;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_phone_to_provider);
	strcpy(obj->objs[7]->name, "phone_to_provider");
	if (arg_phone_to_provider)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument true
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 7;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_email_to_provider);
	strcpy(obj->objs[8]->name, "email_to_provider");
	if (arg_email_to_provider)
		flagsv[nflags-1] |= (1 << 7);

	//parse argument true
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 1;
	obj->objs[9]->flag_bit = 9;
	obj->objs[9]->type = TYPE_INT;
	obj->objs[9]->value = 
		buf_add_ui32(arg_recurring);
	strcpy(obj->objs[9]->name, "recurring");
	if (arg_recurring)
		flagsv[nflags-1] |= (1 << 9);

	//parse argument string
	if (arg_currency){
		obj->objs[10] = NEW(tlo_t, return NULL);
		obj->objs[10]->flag_num = 0;
		obj->objs[10]->flag_bit = 0;
		obj->objs[10]->type = TYPE_STRING;
		obj->objs[10]->value = 
			buf_add((ui8_t *)arg_currency, strlen(arg_currency));
		strcpy(obj->objs[10]->name, "currency");
	}


	//parse argument Vector<LabeledPrice>
	obj->objs[11] = NEW(tlo_t, return NULL);
	obj->objs[11]->flag_num = 0;
	obj->objs[11]->flag_bit = 0;
	obj->objs[11]->type = TYPE_VECTOR;
	strcpy(obj->objs[11]->name, "prices");
	if (arg_prices){
		for(i=0; i<len_arg_prices; ++i){
			obj->objs[11]->value = buf_add_ui32(arg_prices[i]->id);
			buf_cat(obj->objs[11]->value, arg_prices[i]->value);
		}
	}


	//parse argument long
	obj->objs[12] = NEW(tlo_t, return NULL);
	obj->objs[12]->flag_num = 1;
	obj->objs[12]->flag_bit = 8;
	obj->objs[12]->type = TYPE_LONG;
	obj->objs[12]->value = 
		buf_add_ui64(arg_max_tip_amount);
	strcpy(obj->objs[12]->name, "max_tip_amount");
	if (arg_max_tip_amount)
		flagsv[nflags-1] |= (1 << 8);

	//parse argument Vector<long>
	obj->objs[13] = NEW(tlo_t, return NULL);
	obj->objs[13]->flag_num = 1;
	obj->objs[13]->flag_bit = 8;
	obj->objs[13]->type = TYPE_VECTOR;
	strcpy(obj->objs[13]->name, "suggested_tip_amounts");
	if (arg_suggested_tip_amounts){
		for(i=0; i<len_arg_suggested_tip_amounts; ++i){
			buf_t b = buf_add_ui64(arg_suggested_tip_amounts[i]);
			buf_cat(obj->objs[13]->value, b);
		}
		flagsv[nflags-1] |= (1 << 8);
	}


	//parse argument string
	if (arg_terms_url){
		obj->objs[14] = NEW(tlo_t, return NULL);
		obj->objs[14]->flag_num = 1;
		obj->objs[14]->flag_bit = 10;
		obj->objs[14]->type = TYPE_STRING;
		obj->objs[14]->value = 
			buf_add((ui8_t *)arg_terms_url, strlen(arg_terms_url));
		strcpy(obj->objs[14]->name, "terms_url");
		flagsv[nflags-1] |= (1 << 10);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_paymentCharge(const char * arg_id, const char * arg_provider_charge_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "paymentCharge");
	int i;
	obj->id = 0xea02c27e;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_id){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_id, strlen(arg_id));
		strcpy(obj->objs[0]->name, "id");
	}


	//parse argument string
	if (arg_provider_charge_id){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_provider_charge_id, strlen(arg_provider_charge_id));
		strcpy(obj->objs[1]->name, "provider_charge_id");
	}

	return obj;
}

tlo_t * tl_postAddress(const char * arg_street_line1, const char * arg_street_line2, const char * arg_city, const char * arg_state, const char * arg_country_iso2, const char * arg_post_code)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "postAddress");
	int i;
	obj->id = 0x1e8caaeb;
	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_street_line1){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_street_line1, strlen(arg_street_line1));
		strcpy(obj->objs[0]->name, "street_line1");
	}


	//parse argument string
	if (arg_street_line2){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_street_line2, strlen(arg_street_line2));
		strcpy(obj->objs[1]->name, "street_line2");
	}


	//parse argument string
	if (arg_city){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_city, strlen(arg_city));
		strcpy(obj->objs[2]->name, "city");
	}


	//parse argument string
	if (arg_state){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_state, strlen(arg_state));
		strcpy(obj->objs[3]->name, "state");
	}


	//parse argument string
	if (arg_country_iso2){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_country_iso2, strlen(arg_country_iso2));
		strcpy(obj->objs[4]->name, "country_iso2");
	}


	//parse argument string
	if (arg_post_code){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_post_code, strlen(arg_post_code));
		strcpy(obj->objs[5]->name, "post_code");
	}

	return obj;
}

tlo_t * tl_paymentRequestedInfo(const char * arg_name, const char * arg_phone, const char * arg_email, PostAddress arg_shipping_address)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "paymentRequestedInfo");
	int i;
	obj->id = 0x909c3f94;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_name){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_name, strlen(arg_name));
		strcpy(obj->objs[1]->name, "name");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_phone){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 1;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_phone, strlen(arg_phone));
		strcpy(obj->objs[2]->name, "phone");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument string
	if (arg_email){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 2;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_email, strlen(arg_email));
		strcpy(obj->objs[3]->name, "email");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument PostAddress
	if (arg_shipping_address){
		obj->objs[4] = arg_shipping_address;
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 3;
	strcpy(obj->objs[4]->name, "shipping_address");
		flagsv[nflags-1] |= (1 << 3);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_paymentSavedCredentialsCard(const char * arg_id, const char * arg_title)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "paymentSavedCredentialsCard");
	int i;
	obj->id = 0xcdc27a1f;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_id){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_id, strlen(arg_id));
		strcpy(obj->objs[0]->name, "id");
	}


	//parse argument string
	if (arg_title){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[1]->name, "title");
	}

	return obj;
}

tlo_t * tl_webDocument(const char * arg_url, long arg_access_hash, int arg_size, const char * arg_mime_type, DocumentAttribute *arg_attributes, int len_arg_attributes)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "webDocument");
	int i;
	obj->id = 0x1c570ed1;
	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_url){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[0]->name, "url");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[1]->name, "access_hash");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_size);
	strcpy(obj->objs[2]->name, "size");

	//parse argument string
	if (arg_mime_type){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_mime_type, strlen(arg_mime_type));
		strcpy(obj->objs[3]->name, "mime_type");
	}


	//parse argument Vector<DocumentAttribute>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "attributes");
	if (arg_attributes){
		for(i=0; i<len_arg_attributes; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_attributes[i]->id);
			buf_cat(obj->objs[4]->value, arg_attributes[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_webDocumentNoProxy(const char * arg_url, int arg_size, const char * arg_mime_type, DocumentAttribute *arg_attributes, int len_arg_attributes)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "webDocumentNoProxy");
	int i;
	obj->id = 0xf9c8bcc6;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_url){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[0]->name, "url");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_size);
	strcpy(obj->objs[1]->name, "size");

	//parse argument string
	if (arg_mime_type){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_mime_type, strlen(arg_mime_type));
		strcpy(obj->objs[2]->name, "mime_type");
	}


	//parse argument Vector<DocumentAttribute>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "attributes");
	if (arg_attributes){
		for(i=0; i<len_arg_attributes; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_attributes[i]->id);
			buf_cat(obj->objs[3]->value, arg_attributes[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_inputWebDocument(const char * arg_url, int arg_size, const char * arg_mime_type, DocumentAttribute *arg_attributes, int len_arg_attributes)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputWebDocument");
	int i;
	obj->id = 0x9bed434d;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_url){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[0]->name, "url");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_size);
	strcpy(obj->objs[1]->name, "size");

	//parse argument string
	if (arg_mime_type){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_mime_type, strlen(arg_mime_type));
		strcpy(obj->objs[2]->name, "mime_type");
	}


	//parse argument Vector<DocumentAttribute>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "attributes");
	if (arg_attributes){
		for(i=0; i<len_arg_attributes; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_attributes[i]->id);
			buf_cat(obj->objs[3]->value, arg_attributes[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_inputWebFileLocation(const char * arg_url, long arg_access_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputWebFileLocation");
	int i;
	obj->id = 0xc239d686;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_url){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[0]->name, "url");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[1]->name, "access_hash");
	return obj;
}

tlo_t * tl_inputWebFileGeoPointLocation(InputGeoPoint arg_geo_point, long arg_access_hash, int arg_w, int arg_h, int arg_zoom, int arg_scale)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputWebFileGeoPointLocation");
	int i;
	obj->id = 0x9f2221c9;
	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument InputGeoPoint
	if (arg_geo_point){
		obj->objs[0] = arg_geo_point;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "geo_point");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[1]->name, "access_hash");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_w);
	strcpy(obj->objs[2]->name, "w");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_h);
	strcpy(obj->objs[3]->name, "h");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_zoom);
	strcpy(obj->objs[4]->name, "zoom");

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_scale);
	strcpy(obj->objs[5]->name, "scale");
	return obj;
}

tlo_t * tl_inputWebFileAudioAlbumThumbLocation(bool arg_small, InputDocument arg_document, const char * arg_title, const char * arg_performer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputWebFileAudioAlbumThumbLocation");
	int i;
	obj->id = 0xf46fe924;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 2;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_small);
	strcpy(obj->objs[1]->name, "small");
	if (arg_small)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument InputDocument
	if (arg_document){
		obj->objs[2] = arg_document;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "document");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_title){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 1;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[3]->name, "title");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument string
	if (arg_performer){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 1;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_performer, strlen(arg_performer));
		strcpy(obj->objs[4]->name, "performer");
		flagsv[nflags-1] |= (1 << 1);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_upload_webFile(int arg_size, const char * arg_mime_type, storage_FileType arg_file_type, int arg_mtime, unsigned char * arg_bytes, int len_arg_bytes)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "upload_webFile");
	int i;
	obj->id = 0x21e753bc;
	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_size);
	strcpy(obj->objs[0]->name, "size");

	//parse argument string
	if (arg_mime_type){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_mime_type, strlen(arg_mime_type));
		strcpy(obj->objs[1]->name, "mime_type");
	}


	//parse argument storage_FileType
	if (arg_file_type){
		obj->objs[2] = arg_file_type;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "file_type");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_mtime);
	strcpy(obj->objs[3]->name, "mtime");

	//parse argument bytes
	if (arg_bytes){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_BYTES;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_bytes, len_arg_bytes);
		strcpy(obj->objs[4]->name, "bytes");
	}

	return obj;
}

tlo_t * tl_payments_paymentForm(bool arg_can_save_credentials, bool arg_password_missing, long arg_form_id, long arg_bot_id, const char * arg_title, const char * arg_description, WebDocument arg_photo, Invoice arg_invoice, long arg_provider_id, const char * arg_url, const char * arg_native_provider, DataJSON arg_native_params, PaymentFormMethod *arg_additional_methods, int len_arg_additional_methods, PaymentRequestedInfo arg_saved_info, PaymentSavedCredentials *arg_saved_credentials, int len_arg_saved_credentials, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_paymentForm");
	int i;
	obj->id = 0xa0058751;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 17;
	obj->objs = 
		(tlo_t **)MALLOC(17 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 2;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_can_save_credentials);
	strcpy(obj->objs[1]->name, "can_save_credentials");
	if (arg_can_save_credentials)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 3;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_password_missing);
	strcpy(obj->objs[2]->name, "password_missing");
	if (arg_password_missing)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_form_id);
	strcpy(obj->objs[3]->name, "form_id");

	//parse argument long
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_bot_id);
	strcpy(obj->objs[4]->name, "bot_id");

	//parse argument string
	if (arg_title){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[5]->name, "title");
	}


	//parse argument string
	if (arg_description){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_description, strlen(arg_description));
		strcpy(obj->objs[6]->name, "description");
	}


	//parse argument WebDocument
	if (arg_photo){
		obj->objs[7] = arg_photo;
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 5;
	strcpy(obj->objs[7]->name, "photo");
		flagsv[nflags-1] |= (1 << 5);
	}


	//parse argument Invoice
	if (arg_invoice){
		obj->objs[8] = arg_invoice;
		obj->objs[8]->flag_num = 0;
		obj->objs[8]->flag_bit = 0;
	strcpy(obj->objs[8]->name, "invoice");
	}


	//parse argument long
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 0;
	obj->objs[9]->flag_bit = 0;
	obj->objs[9]->type = TYPE_LONG;
	obj->objs[9]->value = 
		buf_add_ui64(arg_provider_id);
	strcpy(obj->objs[9]->name, "provider_id");

	//parse argument string
	if (arg_url){
		obj->objs[10] = NEW(tlo_t, return NULL);
		obj->objs[10]->flag_num = 0;
		obj->objs[10]->flag_bit = 0;
		obj->objs[10]->type = TYPE_STRING;
		obj->objs[10]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[10]->name, "url");
	}


	//parse argument string
	if (arg_native_provider){
		obj->objs[11] = NEW(tlo_t, return NULL);
		obj->objs[11]->flag_num = 1;
		obj->objs[11]->flag_bit = 4;
		obj->objs[11]->type = TYPE_STRING;
		obj->objs[11]->value = 
			buf_add((ui8_t *)arg_native_provider, strlen(arg_native_provider));
		strcpy(obj->objs[11]->name, "native_provider");
		flagsv[nflags-1] |= (1 << 4);
	}


	//parse argument DataJSON
	if (arg_native_params){
		obj->objs[12] = arg_native_params;
		obj->objs[12]->flag_num = 1;
		obj->objs[12]->flag_bit = 4;
	strcpy(obj->objs[12]->name, "native_params");
		flagsv[nflags-1] |= (1 << 4);
	}


	//parse argument Vector<PaymentFormMethod>
	obj->objs[13] = NEW(tlo_t, return NULL);
	obj->objs[13]->flag_num = 1;
	obj->objs[13]->flag_bit = 6;
	obj->objs[13]->type = TYPE_VECTOR;
	strcpy(obj->objs[13]->name, "additional_methods");
	if (arg_additional_methods){
		for(i=0; i<len_arg_additional_methods; ++i){
			obj->objs[13]->value = buf_add_ui32(arg_additional_methods[i]->id);
			buf_cat(obj->objs[13]->value, arg_additional_methods[i]->value);
		}
		flagsv[nflags-1] |= (1 << 6);
	}


	//parse argument PaymentRequestedInfo
	if (arg_saved_info){
		obj->objs[14] = arg_saved_info;
		obj->objs[14]->flag_num = 1;
		obj->objs[14]->flag_bit = 0;
	strcpy(obj->objs[14]->name, "saved_info");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument Vector<PaymentSavedCredentials>
	obj->objs[15] = NEW(tlo_t, return NULL);
	obj->objs[15]->flag_num = 1;
	obj->objs[15]->flag_bit = 1;
	obj->objs[15]->type = TYPE_VECTOR;
	strcpy(obj->objs[15]->name, "saved_credentials");
	if (arg_saved_credentials){
		for(i=0; i<len_arg_saved_credentials; ++i){
			obj->objs[15]->value = buf_add_ui32(arg_saved_credentials[i]->id);
			buf_cat(obj->objs[15]->value, arg_saved_credentials[i]->value);
		}
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument Vector<User>
	obj->objs[16] = NEW(tlo_t, return NULL);
	obj->objs[16]->flag_num = 0;
	obj->objs[16]->flag_bit = 0;
	obj->objs[16]->type = TYPE_VECTOR;
	strcpy(obj->objs[16]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[16]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[16]->value, arg_users[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_payments_paymentFormStars(long arg_form_id, long arg_bot_id, const char * arg_title, const char * arg_description, WebDocument arg_photo, Invoice arg_invoice, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_paymentFormStars");
	int i;
	obj->id = 0x7bf6b15c;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_form_id);
	strcpy(obj->objs[1]->name, "form_id");

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_bot_id);
	strcpy(obj->objs[2]->name, "bot_id");

	//parse argument string
	if (arg_title){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[3]->name, "title");
	}


	//parse argument string
	if (arg_description){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_description, strlen(arg_description));
		strcpy(obj->objs[4]->name, "description");
	}


	//parse argument WebDocument
	if (arg_photo){
		obj->objs[5] = arg_photo;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 5;
	strcpy(obj->objs[5]->name, "photo");
		flagsv[nflags-1] |= (1 << 5);
	}


	//parse argument Invoice
	if (arg_invoice){
		obj->objs[6] = arg_invoice;
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
	strcpy(obj->objs[6]->name, "invoice");
	}


	//parse argument Vector<User>
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_VECTOR;
	strcpy(obj->objs[7]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[7]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[7]->value, arg_users[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_payments_paymentFormStarGift(long arg_form_id, Invoice arg_invoice)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_paymentFormStarGift");
	int i;
	obj->id = 0xb425cfe1;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_form_id);
	strcpy(obj->objs[0]->name, "form_id");

	//parse argument Invoice
	if (arg_invoice){
		obj->objs[1] = arg_invoice;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "invoice");
	}

	return obj;
}

tlo_t * tl_payments_validatedRequestedInfo(const char * arg_id, ShippingOption *arg_shipping_options, int len_arg_shipping_options)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_validatedRequestedInfo");
	int i;
	obj->id = 0xd1451883;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_id){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_id, strlen(arg_id));
		strcpy(obj->objs[1]->name, "id");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument Vector<ShippingOption>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "shipping_options");
	if (arg_shipping_options){
		for(i=0; i<len_arg_shipping_options; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_shipping_options[i]->id);
			buf_cat(obj->objs[2]->value, arg_shipping_options[i]->value);
		}
		flagsv[nflags-1] |= (1 << 1);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_payments_paymentResult(Updates arg_updates)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_paymentResult");
	int i;
	obj->id = 0x4e5f810d;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Updates
	if (arg_updates){
		obj->objs[0] = arg_updates;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "updates");
	}

	return obj;
}

tlo_t * tl_payments_paymentVerificationNeeded(const char * arg_url)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_paymentVerificationNeeded");
	int i;
	obj->id = 0xd8411139;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_url){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[0]->name, "url");
	}

	return obj;
}

tlo_t * tl_payments_paymentReceipt(int arg_date, long arg_bot_id, long arg_provider_id, const char * arg_title, const char * arg_description, WebDocument arg_photo, Invoice arg_invoice, PaymentRequestedInfo arg_info, ShippingOption arg_shipping, long arg_tip_amount, const char * arg_currency, long arg_total_amount, const char * arg_credentials_title, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_paymentReceipt");
	int i;
	obj->id = 0x70c4fe03;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 15;
	obj->objs = 
		(tlo_t **)MALLOC(15 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[1]->name, "date");

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_bot_id);
	strcpy(obj->objs[2]->name, "bot_id");

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_provider_id);
	strcpy(obj->objs[3]->name, "provider_id");

	//parse argument string
	if (arg_title){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[4]->name, "title");
	}


	//parse argument string
	if (arg_description){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_description, strlen(arg_description));
		strcpy(obj->objs[5]->name, "description");
	}


	//parse argument WebDocument
	if (arg_photo){
		obj->objs[6] = arg_photo;
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 2;
	strcpy(obj->objs[6]->name, "photo");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument Invoice
	if (arg_invoice){
		obj->objs[7] = arg_invoice;
		obj->objs[7]->flag_num = 0;
		obj->objs[7]->flag_bit = 0;
	strcpy(obj->objs[7]->name, "invoice");
	}


	//parse argument PaymentRequestedInfo
	if (arg_info){
		obj->objs[8] = arg_info;
		obj->objs[8]->flag_num = 1;
		obj->objs[8]->flag_bit = 0;
	strcpy(obj->objs[8]->name, "info");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument ShippingOption
	if (arg_shipping){
		obj->objs[9] = arg_shipping;
		obj->objs[9]->flag_num = 1;
		obj->objs[9]->flag_bit = 1;
	strcpy(obj->objs[9]->name, "shipping");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument long
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 1;
	obj->objs[10]->flag_bit = 3;
	obj->objs[10]->type = TYPE_LONG;
	obj->objs[10]->value = 
		buf_add_ui64(arg_tip_amount);
	strcpy(obj->objs[10]->name, "tip_amount");
	if (arg_tip_amount)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument string
	if (arg_currency){
		obj->objs[11] = NEW(tlo_t, return NULL);
		obj->objs[11]->flag_num = 0;
		obj->objs[11]->flag_bit = 0;
		obj->objs[11]->type = TYPE_STRING;
		obj->objs[11]->value = 
			buf_add((ui8_t *)arg_currency, strlen(arg_currency));
		strcpy(obj->objs[11]->name, "currency");
	}


	//parse argument long
	obj->objs[12] = NEW(tlo_t, return NULL);
	obj->objs[12]->flag_num = 0;
	obj->objs[12]->flag_bit = 0;
	obj->objs[12]->type = TYPE_LONG;
	obj->objs[12]->value = 
		buf_add_ui64(arg_total_amount);
	strcpy(obj->objs[12]->name, "total_amount");

	//parse argument string
	if (arg_credentials_title){
		obj->objs[13] = NEW(tlo_t, return NULL);
		obj->objs[13]->flag_num = 0;
		obj->objs[13]->flag_bit = 0;
		obj->objs[13]->type = TYPE_STRING;
		obj->objs[13]->value = 
			buf_add((ui8_t *)arg_credentials_title, strlen(arg_credentials_title));
		strcpy(obj->objs[13]->name, "credentials_title");
	}


	//parse argument Vector<User>
	obj->objs[14] = NEW(tlo_t, return NULL);
	obj->objs[14]->flag_num = 0;
	obj->objs[14]->flag_bit = 0;
	obj->objs[14]->type = TYPE_VECTOR;
	strcpy(obj->objs[14]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[14]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[14]->value, arg_users[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_payments_paymentReceiptStars(int arg_date, long arg_bot_id, const char * arg_title, const char * arg_description, WebDocument arg_photo, Invoice arg_invoice, const char * arg_currency, long arg_total_amount, const char * arg_transaction_id, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_paymentReceiptStars");
	int i;
	obj->id = 0xdabbf83a;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 11;
	obj->objs = 
		(tlo_t **)MALLOC(11 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[1]->name, "date");

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_bot_id);
	strcpy(obj->objs[2]->name, "bot_id");

	//parse argument string
	if (arg_title){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[3]->name, "title");
	}


	//parse argument string
	if (arg_description){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_description, strlen(arg_description));
		strcpy(obj->objs[4]->name, "description");
	}


	//parse argument WebDocument
	if (arg_photo){
		obj->objs[5] = arg_photo;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 2;
	strcpy(obj->objs[5]->name, "photo");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument Invoice
	if (arg_invoice){
		obj->objs[6] = arg_invoice;
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
	strcpy(obj->objs[6]->name, "invoice");
	}


	//parse argument string
	if (arg_currency){
		obj->objs[7] = NEW(tlo_t, return NULL);
		obj->objs[7]->flag_num = 0;
		obj->objs[7]->flag_bit = 0;
		obj->objs[7]->type = TYPE_STRING;
		obj->objs[7]->value = 
			buf_add((ui8_t *)arg_currency, strlen(arg_currency));
		strcpy(obj->objs[7]->name, "currency");
	}


	//parse argument long
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 0;
	obj->objs[8]->flag_bit = 0;
	obj->objs[8]->type = TYPE_LONG;
	obj->objs[8]->value = 
		buf_add_ui64(arg_total_amount);
	strcpy(obj->objs[8]->name, "total_amount");

	//parse argument string
	if (arg_transaction_id){
		obj->objs[9] = NEW(tlo_t, return NULL);
		obj->objs[9]->flag_num = 0;
		obj->objs[9]->flag_bit = 0;
		obj->objs[9]->type = TYPE_STRING;
		obj->objs[9]->value = 
			buf_add((ui8_t *)arg_transaction_id, strlen(arg_transaction_id));
		strcpy(obj->objs[9]->name, "transaction_id");
	}


	//parse argument Vector<User>
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 0;
	obj->objs[10]->flag_bit = 0;
	obj->objs[10]->type = TYPE_VECTOR;
	strcpy(obj->objs[10]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[10]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[10]->value, arg_users[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_payments_savedInfo(bool arg_has_saved_credentials, PaymentRequestedInfo arg_saved_info)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_savedInfo");
	int i;
	obj->id = 0xfb8fe43c;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_has_saved_credentials);
	strcpy(obj->objs[1]->name, "has_saved_credentials");
	if (arg_has_saved_credentials)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument PaymentRequestedInfo
	if (arg_saved_info){
		obj->objs[2] = arg_saved_info;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "saved_info");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputPaymentCredentialsSaved(const char * arg_id, unsigned char * arg_tmp_password, int len_arg_tmp_password)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPaymentCredentialsSaved");
	int i;
	obj->id = 0xc10eb2cf;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_id){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_id, strlen(arg_id));
		strcpy(obj->objs[0]->name, "id");
	}


	//parse argument bytes
	if (arg_tmp_password){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_tmp_password, len_arg_tmp_password);
		strcpy(obj->objs[1]->name, "tmp_password");
	}

	return obj;
}

tlo_t * tl_inputPaymentCredentials(bool arg_save, DataJSON arg_data)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPaymentCredentials");
	int i;
	obj->id = 0x3417d728;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_save);
	strcpy(obj->objs[1]->name, "save");
	if (arg_save)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument DataJSON
	if (arg_data){
		obj->objs[2] = arg_data;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "data");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputPaymentCredentialsApplePay(DataJSON arg_payment_data)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPaymentCredentialsApplePay");
	int i;
	obj->id = 0x0aa1c39f;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument DataJSON
	if (arg_payment_data){
		obj->objs[0] = arg_payment_data;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "payment_data");
	}

	return obj;
}

tlo_t * tl_inputPaymentCredentialsGooglePay(DataJSON arg_payment_token)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPaymentCredentialsGooglePay");
	int i;
	obj->id = 0x8ac32801;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument DataJSON
	if (arg_payment_token){
		obj->objs[0] = arg_payment_token;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "payment_token");
	}

	return obj;
}

tlo_t * tl_account_tmpPassword(unsigned char * arg_tmp_password, int len_arg_tmp_password, int arg_valid_until)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_tmpPassword");
	int i;
	obj->id = 0xdb64fd34;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument bytes
	if (arg_tmp_password){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_BYTES;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_tmp_password, len_arg_tmp_password);
		strcpy(obj->objs[0]->name, "tmp_password");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_valid_until);
	strcpy(obj->objs[1]->name, "valid_until");
	return obj;
}

tlo_t * tl_shippingOption(const char * arg_id, const char * arg_title, LabeledPrice *arg_prices, int len_arg_prices)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "shippingOption");
	int i;
	obj->id = 0xb6213cdf;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_id){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_id, strlen(arg_id));
		strcpy(obj->objs[0]->name, "id");
	}


	//parse argument string
	if (arg_title){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[1]->name, "title");
	}


	//parse argument Vector<LabeledPrice>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "prices");
	if (arg_prices){
		for(i=0; i<len_arg_prices; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_prices[i]->id);
			buf_cat(obj->objs[2]->value, arg_prices[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_inputStickerSetItem(InputDocument arg_document, const char * arg_emoji, MaskCoords arg_mask_coords, const char * arg_keywords)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputStickerSetItem");
	int i;
	obj->id = 0x32da9e9c;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputDocument
	if (arg_document){
		obj->objs[1] = arg_document;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "document");
	}


	//parse argument string
	if (arg_emoji){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_emoji, strlen(arg_emoji));
		strcpy(obj->objs[2]->name, "emoji");
	}


	//parse argument MaskCoords
	if (arg_mask_coords){
		obj->objs[3] = arg_mask_coords;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "mask_coords");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_keywords){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 1;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_keywords, strlen(arg_keywords));
		strcpy(obj->objs[4]->name, "keywords");
		flagsv[nflags-1] |= (1 << 1);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputPhoneCall(long arg_id, long arg_access_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputPhoneCall");
	int i;
	obj->id = 0x1e36fded;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[1]->name, "access_hash");
	return obj;
}

tlo_t * tl_phoneCallEmpty(long arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phoneCallEmpty");
	int i;
	obj->id = 0x5366c915;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");
	return obj;
}

tlo_t * tl_phoneCallWaiting(bool arg_video, long arg_id, long arg_access_hash, int arg_date, long arg_admin_id, long arg_participant_id, PhoneCallProtocol arg_protocol, int arg_receive_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phoneCallWaiting");
	int i;
	obj->id = 0xc5226f17;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 6;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_video);
	strcpy(obj->objs[1]->name, "video");
	if (arg_video)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[2]->name, "id");

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[3]->name, "access_hash");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[4]->name, "date");

	//parse argument long
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_LONG;
	obj->objs[5]->value = 
		buf_add_ui64(arg_admin_id);
	strcpy(obj->objs[5]->name, "admin_id");

	//parse argument long
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_LONG;
	obj->objs[6]->value = 
		buf_add_ui64(arg_participant_id);
	strcpy(obj->objs[6]->name, "participant_id");

	//parse argument PhoneCallProtocol
	if (arg_protocol){
		obj->objs[7] = arg_protocol;
		obj->objs[7]->flag_num = 0;
		obj->objs[7]->flag_bit = 0;
	strcpy(obj->objs[7]->name, "protocol");
	}


	//parse argument int
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 0;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_receive_date);
	strcpy(obj->objs[8]->name, "receive_date");
	if (arg_receive_date)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_phoneCallRequested(bool arg_video, long arg_id, long arg_access_hash, int arg_date, long arg_admin_id, long arg_participant_id, unsigned char * arg_g_a_hash, int len_arg_g_a_hash, PhoneCallProtocol arg_protocol)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phoneCallRequested");
	int i;
	obj->id = 0x14b0ed0c;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 6;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_video);
	strcpy(obj->objs[1]->name, "video");
	if (arg_video)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[2]->name, "id");

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[3]->name, "access_hash");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[4]->name, "date");

	//parse argument long
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_LONG;
	obj->objs[5]->value = 
		buf_add_ui64(arg_admin_id);
	strcpy(obj->objs[5]->name, "admin_id");

	//parse argument long
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_LONG;
	obj->objs[6]->value = 
		buf_add_ui64(arg_participant_id);
	strcpy(obj->objs[6]->name, "participant_id");

	//parse argument bytes
	if (arg_g_a_hash){
		obj->objs[7] = NEW(tlo_t, return NULL);
		obj->objs[7]->flag_num = 0;
		obj->objs[7]->flag_bit = 0;
		obj->objs[7]->type = TYPE_BYTES;
		obj->objs[7]->value = 
			buf_add((ui8_t *)arg_g_a_hash, len_arg_g_a_hash);
		strcpy(obj->objs[7]->name, "g_a_hash");
	}


	//parse argument PhoneCallProtocol
	if (arg_protocol){
		obj->objs[8] = arg_protocol;
		obj->objs[8]->flag_num = 0;
		obj->objs[8]->flag_bit = 0;
	strcpy(obj->objs[8]->name, "protocol");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_phoneCallAccepted(bool arg_video, long arg_id, long arg_access_hash, int arg_date, long arg_admin_id, long arg_participant_id, unsigned char * arg_g_b, int len_arg_g_b, PhoneCallProtocol arg_protocol)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phoneCallAccepted");
	int i;
	obj->id = 0x3660c311;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 6;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_video);
	strcpy(obj->objs[1]->name, "video");
	if (arg_video)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[2]->name, "id");

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[3]->name, "access_hash");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[4]->name, "date");

	//parse argument long
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_LONG;
	obj->objs[5]->value = 
		buf_add_ui64(arg_admin_id);
	strcpy(obj->objs[5]->name, "admin_id");

	//parse argument long
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_LONG;
	obj->objs[6]->value = 
		buf_add_ui64(arg_participant_id);
	strcpy(obj->objs[6]->name, "participant_id");

	//parse argument bytes
	if (arg_g_b){
		obj->objs[7] = NEW(tlo_t, return NULL);
		obj->objs[7]->flag_num = 0;
		obj->objs[7]->flag_bit = 0;
		obj->objs[7]->type = TYPE_BYTES;
		obj->objs[7]->value = 
			buf_add((ui8_t *)arg_g_b, len_arg_g_b);
		strcpy(obj->objs[7]->name, "g_b");
	}


	//parse argument PhoneCallProtocol
	if (arg_protocol){
		obj->objs[8] = arg_protocol;
		obj->objs[8]->flag_num = 0;
		obj->objs[8]->flag_bit = 0;
	strcpy(obj->objs[8]->name, "protocol");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_phoneCall(bool arg_p2p_allowed, bool arg_video, long arg_id, long arg_access_hash, int arg_date, long arg_admin_id, long arg_participant_id, unsigned char * arg_g_a_or_b, int len_arg_g_a_or_b, long arg_key_fingerprint, PhoneCallProtocol arg_protocol, PhoneConnection *arg_connections, int len_arg_connections, int arg_start_date, DataJSON arg_custom_parameters)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phoneCall");
	int i;
	obj->id = 0x30535af5;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 14;
	obj->objs = 
		(tlo_t **)MALLOC(14 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 5;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_p2p_allowed);
	strcpy(obj->objs[1]->name, "p2p_allowed");
	if (arg_p2p_allowed)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 6;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_video);
	strcpy(obj->objs[2]->name, "video");
	if (arg_video)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[3]->name, "id");

	//parse argument long
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[4]->name, "access_hash");

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[5]->name, "date");

	//parse argument long
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_LONG;
	obj->objs[6]->value = 
		buf_add_ui64(arg_admin_id);
	strcpy(obj->objs[6]->name, "admin_id");

	//parse argument long
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_LONG;
	obj->objs[7]->value = 
		buf_add_ui64(arg_participant_id);
	strcpy(obj->objs[7]->name, "participant_id");

	//parse argument bytes
	if (arg_g_a_or_b){
		obj->objs[8] = NEW(tlo_t, return NULL);
		obj->objs[8]->flag_num = 0;
		obj->objs[8]->flag_bit = 0;
		obj->objs[8]->type = TYPE_BYTES;
		obj->objs[8]->value = 
			buf_add((ui8_t *)arg_g_a_or_b, len_arg_g_a_or_b);
		strcpy(obj->objs[8]->name, "g_a_or_b");
	}


	//parse argument long
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 0;
	obj->objs[9]->flag_bit = 0;
	obj->objs[9]->type = TYPE_LONG;
	obj->objs[9]->value = 
		buf_add_ui64(arg_key_fingerprint);
	strcpy(obj->objs[9]->name, "key_fingerprint");

	//parse argument PhoneCallProtocol
	if (arg_protocol){
		obj->objs[10] = arg_protocol;
		obj->objs[10]->flag_num = 0;
		obj->objs[10]->flag_bit = 0;
	strcpy(obj->objs[10]->name, "protocol");
	}


	//parse argument Vector<PhoneConnection>
	obj->objs[11] = NEW(tlo_t, return NULL);
	obj->objs[11]->flag_num = 0;
	obj->objs[11]->flag_bit = 0;
	obj->objs[11]->type = TYPE_VECTOR;
	strcpy(obj->objs[11]->name, "connections");
	if (arg_connections){
		for(i=0; i<len_arg_connections; ++i){
			obj->objs[11]->value = buf_add_ui32(arg_connections[i]->id);
			buf_cat(obj->objs[11]->value, arg_connections[i]->value);
		}
	}


	//parse argument int
	obj->objs[12] = NEW(tlo_t, return NULL);
	obj->objs[12]->flag_num = 0;
	obj->objs[12]->flag_bit = 0;
	obj->objs[12]->type = TYPE_INT;
	obj->objs[12]->value = 
		buf_add_ui32(arg_start_date);
	strcpy(obj->objs[12]->name, "start_date");

	//parse argument DataJSON
	if (arg_custom_parameters){
		obj->objs[13] = arg_custom_parameters;
		obj->objs[13]->flag_num = 1;
		obj->objs[13]->flag_bit = 7;
	strcpy(obj->objs[13]->name, "custom_parameters");
		flagsv[nflags-1] |= (1 << 7);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_phoneCallDiscarded(bool arg_need_rating, bool arg_need_debug, bool arg_video, long arg_id, PhoneCallDiscardReason arg_reason, int arg_duration)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phoneCallDiscarded");
	int i;
	obj->id = 0x50ca4de1;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 2;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_need_rating);
	strcpy(obj->objs[1]->name, "need_rating");
	if (arg_need_rating)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 3;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_need_debug);
	strcpy(obj->objs[2]->name, "need_debug");
	if (arg_need_debug)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 6;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_video);
	strcpy(obj->objs[3]->name, "video");
	if (arg_video)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument long
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[4]->name, "id");

	//parse argument PhoneCallDiscardReason
	if (arg_reason){
		obj->objs[5] = arg_reason;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 0;
	strcpy(obj->objs[5]->name, "reason");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 1;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_duration);
	strcpy(obj->objs[6]->name, "duration");
	if (arg_duration)
		flagsv[nflags-1] |= (1 << 1);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_phoneConnection(bool arg_tcp, long arg_id, const char * arg_ip, const char * arg_ipv6, int arg_port, unsigned char * arg_peer_tag, int len_arg_peer_tag)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phoneConnection");
	int i;
	obj->id = 0x9cc123c7;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_tcp);
	strcpy(obj->objs[1]->name, "tcp");
	if (arg_tcp)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[2]->name, "id");

	//parse argument string
	if (arg_ip){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_ip, strlen(arg_ip));
		strcpy(obj->objs[3]->name, "ip");
	}


	//parse argument string
	if (arg_ipv6){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_ipv6, strlen(arg_ipv6));
		strcpy(obj->objs[4]->name, "ipv6");
	}


	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_port);
	strcpy(obj->objs[5]->name, "port");

	//parse argument bytes
	if (arg_peer_tag){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
		obj->objs[6]->type = TYPE_BYTES;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_peer_tag, len_arg_peer_tag);
		strcpy(obj->objs[6]->name, "peer_tag");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_phoneConnectionWebrtc(bool arg_turn, bool arg_stun, long arg_id, const char * arg_ip, const char * arg_ipv6, int arg_port, const char * arg_username, const char * arg_password)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phoneConnectionWebrtc");
	int i;
	obj->id = 0x635fe375;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_turn);
	strcpy(obj->objs[1]->name, "turn");
	if (arg_turn)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_stun);
	strcpy(obj->objs[2]->name, "stun");
	if (arg_stun)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[3]->name, "id");

	//parse argument string
	if (arg_ip){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_ip, strlen(arg_ip));
		strcpy(obj->objs[4]->name, "ip");
	}


	//parse argument string
	if (arg_ipv6){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_ipv6, strlen(arg_ipv6));
		strcpy(obj->objs[5]->name, "ipv6");
	}


	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_port);
	strcpy(obj->objs[6]->name, "port");

	//parse argument string
	if (arg_username){
		obj->objs[7] = NEW(tlo_t, return NULL);
		obj->objs[7]->flag_num = 0;
		obj->objs[7]->flag_bit = 0;
		obj->objs[7]->type = TYPE_STRING;
		obj->objs[7]->value = 
			buf_add((ui8_t *)arg_username, strlen(arg_username));
		strcpy(obj->objs[7]->name, "username");
	}


	//parse argument string
	if (arg_password){
		obj->objs[8] = NEW(tlo_t, return NULL);
		obj->objs[8]->flag_num = 0;
		obj->objs[8]->flag_bit = 0;
		obj->objs[8]->type = TYPE_STRING;
		obj->objs[8]->value = 
			buf_add((ui8_t *)arg_password, strlen(arg_password));
		strcpy(obj->objs[8]->name, "password");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_phoneCallProtocol(bool arg_udp_p2p, bool arg_udp_reflector, int arg_min_layer, int arg_max_layer, const char * *arg_library_versions, int len_arg_library_versions)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phoneCallProtocol");
	int i;
	obj->id = 0xfc878fc8;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_udp_p2p);
	strcpy(obj->objs[1]->name, "udp_p2p");
	if (arg_udp_p2p)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_udp_reflector);
	strcpy(obj->objs[2]->name, "udp_reflector");
	if (arg_udp_reflector)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_min_layer);
	strcpy(obj->objs[3]->name, "min_layer");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_max_layer);
	strcpy(obj->objs[4]->name, "max_layer");

	//parse argument Vector<string>
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_VECTOR;
	strcpy(obj->objs[5]->name, "library_versions");
	if (arg_library_versions){
		for(i=0; i<len_arg_library_versions; ++i){
			int len = strlen(arg_library_versions[i]);
			buf_t b = buf_add((ui8_t *)arg_library_versions[i], len);
			buf_cat(obj->objs[5]->value, b);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_phone_phoneCall(PhoneCall arg_phone_call, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_phoneCall");
	int i;
	obj->id = 0xec82e140;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument PhoneCall
	if (arg_phone_call){
		obj->objs[0] = arg_phone_call;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "phone_call");
	}


	//parse argument Vector<User>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[1]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_upload_cdnFileReuploadNeeded(unsigned char * arg_request_token, int len_arg_request_token)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "upload_cdnFileReuploadNeeded");
	int i;
	obj->id = 0xeea8e46e;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument bytes
	if (arg_request_token){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_BYTES;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_request_token, len_arg_request_token);
		strcpy(obj->objs[0]->name, "request_token");
	}

	return obj;
}

tlo_t * tl_upload_cdnFile(unsigned char * arg_bytes, int len_arg_bytes)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "upload_cdnFile");
	int i;
	obj->id = 0xa99fca4f;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument bytes
	if (arg_bytes){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_BYTES;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_bytes, len_arg_bytes);
		strcpy(obj->objs[0]->name, "bytes");
	}

	return obj;
}

tlo_t * tl_cdnPublicKey(int arg_dc_id, const char * arg_public_key)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "cdnPublicKey");
	int i;
	obj->id = 0xc982eaba;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_dc_id);
	strcpy(obj->objs[0]->name, "dc_id");

	//parse argument string
	if (arg_public_key){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_public_key, strlen(arg_public_key));
		strcpy(obj->objs[1]->name, "public_key");
	}

	return obj;
}

tlo_t * tl_cdnConfig(CdnPublicKey *arg_public_keys, int len_arg_public_keys)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "cdnConfig");
	int i;
	obj->id = 0x5725e40a;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<CdnPublicKey>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "public_keys");
	if (arg_public_keys){
		for(i=0; i<len_arg_public_keys; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_public_keys[i]->id);
			buf_cat(obj->objs[0]->value, arg_public_keys[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_langPackString(const char * arg_key, const char * arg_value)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "langPackString");
	int i;
	obj->id = 0xcad181f6;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_key){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_key, strlen(arg_key));
		strcpy(obj->objs[0]->name, "key");
	}


	//parse argument string
	if (arg_value){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_value, strlen(arg_value));
		strcpy(obj->objs[1]->name, "value");
	}

	return obj;
}

tlo_t * tl_langPackStringPluralized(const char * arg_key, const char * arg_zero_value, const char * arg_one_value, const char * arg_two_value, const char * arg_few_value, const char * arg_many_value, const char * arg_other_value)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "langPackStringPluralized");
	int i;
	obj->id = 0x6c47ac9f;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_key){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_key, strlen(arg_key));
		strcpy(obj->objs[1]->name, "key");
	}


	//parse argument string
	if (arg_zero_value){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_zero_value, strlen(arg_zero_value));
		strcpy(obj->objs[2]->name, "zero_value");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_one_value){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 1;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_one_value, strlen(arg_one_value));
		strcpy(obj->objs[3]->name, "one_value");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument string
	if (arg_two_value){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 2;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_two_value, strlen(arg_two_value));
		strcpy(obj->objs[4]->name, "two_value");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument string
	if (arg_few_value){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 3;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_few_value, strlen(arg_few_value));
		strcpy(obj->objs[5]->name, "few_value");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument string
	if (arg_many_value){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 4;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_many_value, strlen(arg_many_value));
		strcpy(obj->objs[6]->name, "many_value");
		flagsv[nflags-1] |= (1 << 4);
	}


	//parse argument string
	if (arg_other_value){
		obj->objs[7] = NEW(tlo_t, return NULL);
		obj->objs[7]->flag_num = 0;
		obj->objs[7]->flag_bit = 0;
		obj->objs[7]->type = TYPE_STRING;
		obj->objs[7]->value = 
			buf_add((ui8_t *)arg_other_value, strlen(arg_other_value));
		strcpy(obj->objs[7]->name, "other_value");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_langPackStringDeleted(const char * arg_key)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "langPackStringDeleted");
	int i;
	obj->id = 0x2979eeb2;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_key){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_key, strlen(arg_key));
		strcpy(obj->objs[0]->name, "key");
	}

	return obj;
}

tlo_t * tl_langPackDifference(const char * arg_lang_code, int arg_from_version, int arg_version, LangPackString *arg_strings, int len_arg_strings)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "langPackDifference");
	int i;
	obj->id = 0xf385c1f6;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_lang_code){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_lang_code, strlen(arg_lang_code));
		strcpy(obj->objs[0]->name, "lang_code");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_from_version);
	strcpy(obj->objs[1]->name, "from_version");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_version);
	strcpy(obj->objs[2]->name, "version");

	//parse argument Vector<LangPackString>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "strings");
	if (arg_strings){
		for(i=0; i<len_arg_strings; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_strings[i]->id);
			buf_cat(obj->objs[3]->value, arg_strings[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_langPackLanguage(bool arg_official, bool arg_rtl, bool arg_beta, const char * arg_name, const char * arg_native_name, const char * arg_lang_code, const char * arg_base_lang_code, const char * arg_plural_code, int arg_strings_count, int arg_translated_count, const char * arg_translations_url)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "langPackLanguage");
	int i;
	obj->id = 0xeeca5ce3;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 12;
	obj->objs = 
		(tlo_t **)MALLOC(12 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_official);
	strcpy(obj->objs[1]->name, "official");
	if (arg_official)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 2;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_rtl);
	strcpy(obj->objs[2]->name, "rtl");
	if (arg_rtl)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 3;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_beta);
	strcpy(obj->objs[3]->name, "beta");
	if (arg_beta)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument string
	if (arg_name){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_name, strlen(arg_name));
		strcpy(obj->objs[4]->name, "name");
	}


	//parse argument string
	if (arg_native_name){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_native_name, strlen(arg_native_name));
		strcpy(obj->objs[5]->name, "native_name");
	}


	//parse argument string
	if (arg_lang_code){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_lang_code, strlen(arg_lang_code));
		strcpy(obj->objs[6]->name, "lang_code");
	}


	//parse argument string
	if (arg_base_lang_code){
		obj->objs[7] = NEW(tlo_t, return NULL);
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 1;
		obj->objs[7]->type = TYPE_STRING;
		obj->objs[7]->value = 
			buf_add((ui8_t *)arg_base_lang_code, strlen(arg_base_lang_code));
		strcpy(obj->objs[7]->name, "base_lang_code");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument string
	if (arg_plural_code){
		obj->objs[8] = NEW(tlo_t, return NULL);
		obj->objs[8]->flag_num = 0;
		obj->objs[8]->flag_bit = 0;
		obj->objs[8]->type = TYPE_STRING;
		obj->objs[8]->value = 
			buf_add((ui8_t *)arg_plural_code, strlen(arg_plural_code));
		strcpy(obj->objs[8]->name, "plural_code");
	}


	//parse argument int
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 0;
	obj->objs[9]->flag_bit = 0;
	obj->objs[9]->type = TYPE_INT;
	obj->objs[9]->value = 
		buf_add_ui32(arg_strings_count);
	strcpy(obj->objs[9]->name, "strings_count");

	//parse argument int
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 0;
	obj->objs[10]->flag_bit = 0;
	obj->objs[10]->type = TYPE_INT;
	obj->objs[10]->value = 
		buf_add_ui32(arg_translated_count);
	strcpy(obj->objs[10]->name, "translated_count");

	//parse argument string
	if (arg_translations_url){
		obj->objs[11] = NEW(tlo_t, return NULL);
		obj->objs[11]->flag_num = 0;
		obj->objs[11]->flag_bit = 0;
		obj->objs[11]->type = TYPE_STRING;
		obj->objs[11]->value = 
			buf_add((ui8_t *)arg_translations_url, strlen(arg_translations_url));
		strcpy(obj->objs[11]->name, "translations_url");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_channelAdminLogEventActionChangeTitle(const char * arg_prev_value, const char * arg_new_value)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionChangeTitle");
	int i;
	obj->id = 0xe6dfb825;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_prev_value){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_prev_value, strlen(arg_prev_value));
		strcpy(obj->objs[0]->name, "prev_value");
	}


	//parse argument string
	if (arg_new_value){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_new_value, strlen(arg_new_value));
		strcpy(obj->objs[1]->name, "new_value");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionChangeAbout(const char * arg_prev_value, const char * arg_new_value)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionChangeAbout");
	int i;
	obj->id = 0x55188a2e;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_prev_value){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_prev_value, strlen(arg_prev_value));
		strcpy(obj->objs[0]->name, "prev_value");
	}


	//parse argument string
	if (arg_new_value){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_new_value, strlen(arg_new_value));
		strcpy(obj->objs[1]->name, "new_value");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionChangeUsername(const char * arg_prev_value, const char * arg_new_value)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionChangeUsername");
	int i;
	obj->id = 0x6a4afc38;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_prev_value){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_prev_value, strlen(arg_prev_value));
		strcpy(obj->objs[0]->name, "prev_value");
	}


	//parse argument string
	if (arg_new_value){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_new_value, strlen(arg_new_value));
		strcpy(obj->objs[1]->name, "new_value");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionChangePhoto(Photo arg_prev_photo, Photo arg_new_photo)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionChangePhoto");
	int i;
	obj->id = 0x434bd2af;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Photo
	if (arg_prev_photo){
		obj->objs[0] = arg_prev_photo;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "prev_photo");
	}


	//parse argument Photo
	if (arg_new_photo){
		obj->objs[1] = arg_new_photo;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "new_photo");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionToggleInvites(Bool arg_new_value)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionToggleInvites");
	int i;
	obj->id = 0x1b7907ae;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Bool
	if (arg_new_value){
		obj->objs[0] = arg_new_value;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "new_value");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionToggleSignatures(Bool arg_new_value)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionToggleSignatures");
	int i;
	obj->id = 0x26ae0971;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Bool
	if (arg_new_value){
		obj->objs[0] = arg_new_value;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "new_value");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionUpdatePinned(Message arg_message)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionUpdatePinned");
	int i;
	obj->id = 0xe9e82c18;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Message
	if (arg_message){
		obj->objs[0] = arg_message;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "message");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionEditMessage(Message arg_prev_message, Message arg_new_message)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionEditMessage");
	int i;
	obj->id = 0x709b2405;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Message
	if (arg_prev_message){
		obj->objs[0] = arg_prev_message;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "prev_message");
	}


	//parse argument Message
	if (arg_new_message){
		obj->objs[1] = arg_new_message;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "new_message");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionDeleteMessage(Message arg_message)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionDeleteMessage");
	int i;
	obj->id = 0x42e047bb;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Message
	if (arg_message){
		obj->objs[0] = arg_message;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "message");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionParticipantJoin()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionParticipantJoin");
	int i;
	obj->id = 0x183040d3;
	return obj;
}

tlo_t * tl_channelAdminLogEventActionParticipantLeave()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionParticipantLeave");
	int i;
	obj->id = 0xf89777f2;
	return obj;
}

tlo_t * tl_channelAdminLogEventActionParticipantInvite(ChannelParticipant arg_participant)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionParticipantInvite");
	int i;
	obj->id = 0xe31c34d8;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument ChannelParticipant
	if (arg_participant){
		obj->objs[0] = arg_participant;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "participant");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionParticipantToggleBan(ChannelParticipant arg_prev_participant, ChannelParticipant arg_new_participant)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionParticipantToggleBan");
	int i;
	obj->id = 0xe6d83d7e;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument ChannelParticipant
	if (arg_prev_participant){
		obj->objs[0] = arg_prev_participant;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "prev_participant");
	}


	//parse argument ChannelParticipant
	if (arg_new_participant){
		obj->objs[1] = arg_new_participant;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "new_participant");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionParticipantToggleAdmin(ChannelParticipant arg_prev_participant, ChannelParticipant arg_new_participant)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionParticipantToggleAdmin");
	int i;
	obj->id = 0xd5676710;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument ChannelParticipant
	if (arg_prev_participant){
		obj->objs[0] = arg_prev_participant;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "prev_participant");
	}


	//parse argument ChannelParticipant
	if (arg_new_participant){
		obj->objs[1] = arg_new_participant;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "new_participant");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionChangeStickerSet(InputStickerSet arg_prev_stickerset, InputStickerSet arg_new_stickerset)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionChangeStickerSet");
	int i;
	obj->id = 0xb1c3caa7;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputStickerSet
	if (arg_prev_stickerset){
		obj->objs[0] = arg_prev_stickerset;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "prev_stickerset");
	}


	//parse argument InputStickerSet
	if (arg_new_stickerset){
		obj->objs[1] = arg_new_stickerset;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "new_stickerset");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionTogglePreHistoryHidden(Bool arg_new_value)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionTogglePreHistoryHidden");
	int i;
	obj->id = 0x5f5c95f1;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Bool
	if (arg_new_value){
		obj->objs[0] = arg_new_value;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "new_value");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionDefaultBannedRights(ChatBannedRights arg_prev_banned_rights, ChatBannedRights arg_new_banned_rights)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionDefaultBannedRights");
	int i;
	obj->id = 0x2df5fc0a;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument ChatBannedRights
	if (arg_prev_banned_rights){
		obj->objs[0] = arg_prev_banned_rights;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "prev_banned_rights");
	}


	//parse argument ChatBannedRights
	if (arg_new_banned_rights){
		obj->objs[1] = arg_new_banned_rights;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "new_banned_rights");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionStopPoll(Message arg_message)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionStopPoll");
	int i;
	obj->id = 0x8f079643;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Message
	if (arg_message){
		obj->objs[0] = arg_message;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "message");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionChangeLinkedChat(long arg_prev_value, long arg_new_value)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionChangeLinkedChat");
	int i;
	obj->id = 0x050c7ac8;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_prev_value);
	strcpy(obj->objs[0]->name, "prev_value");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_new_value);
	strcpy(obj->objs[1]->name, "new_value");
	return obj;
}

tlo_t * tl_channelAdminLogEventActionChangeLocation(ChannelLocation arg_prev_value, ChannelLocation arg_new_value)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionChangeLocation");
	int i;
	obj->id = 0x0e6b76ae;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument ChannelLocation
	if (arg_prev_value){
		obj->objs[0] = arg_prev_value;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "prev_value");
	}


	//parse argument ChannelLocation
	if (arg_new_value){
		obj->objs[1] = arg_new_value;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "new_value");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionToggleSlowMode(int arg_prev_value, int arg_new_value)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionToggleSlowMode");
	int i;
	obj->id = 0x53909779;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_prev_value);
	strcpy(obj->objs[0]->name, "prev_value");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_new_value);
	strcpy(obj->objs[1]->name, "new_value");
	return obj;
}

tlo_t * tl_channelAdminLogEventActionStartGroupCall(InputGroupCall arg_call)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionStartGroupCall");
	int i;
	obj->id = 0x23209745;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputGroupCall
	if (arg_call){
		obj->objs[0] = arg_call;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "call");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionDiscardGroupCall(InputGroupCall arg_call)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionDiscardGroupCall");
	int i;
	obj->id = 0xdb9f9140;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputGroupCall
	if (arg_call){
		obj->objs[0] = arg_call;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "call");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionParticipantMute(GroupCallParticipant arg_participant)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionParticipantMute");
	int i;
	obj->id = 0xf92424d2;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument GroupCallParticipant
	if (arg_participant){
		obj->objs[0] = arg_participant;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "participant");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionParticipantUnmute(GroupCallParticipant arg_participant)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionParticipantUnmute");
	int i;
	obj->id = 0xe64429c0;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument GroupCallParticipant
	if (arg_participant){
		obj->objs[0] = arg_participant;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "participant");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionToggleGroupCallSetting(Bool arg_join_muted)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionToggleGroupCallSetting");
	int i;
	obj->id = 0x56d6a247;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Bool
	if (arg_join_muted){
		obj->objs[0] = arg_join_muted;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "join_muted");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionParticipantJoinByInvite(bool arg_via_chatlist, ExportedChatInvite arg_invite)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionParticipantJoinByInvite");
	int i;
	obj->id = 0xfe9fc158;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_via_chatlist);
	strcpy(obj->objs[1]->name, "via_chatlist");
	if (arg_via_chatlist)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument ExportedChatInvite
	if (arg_invite){
		obj->objs[2] = arg_invite;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "invite");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_channelAdminLogEventActionExportedInviteDelete(ExportedChatInvite arg_invite)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionExportedInviteDelete");
	int i;
	obj->id = 0x5a50fca4;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument ExportedChatInvite
	if (arg_invite){
		obj->objs[0] = arg_invite;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "invite");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionExportedInviteRevoke(ExportedChatInvite arg_invite)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionExportedInviteRevoke");
	int i;
	obj->id = 0x410a134e;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument ExportedChatInvite
	if (arg_invite){
		obj->objs[0] = arg_invite;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "invite");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionExportedInviteEdit(ExportedChatInvite arg_prev_invite, ExportedChatInvite arg_new_invite)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionExportedInviteEdit");
	int i;
	obj->id = 0xe90ebb59;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument ExportedChatInvite
	if (arg_prev_invite){
		obj->objs[0] = arg_prev_invite;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "prev_invite");
	}


	//parse argument ExportedChatInvite
	if (arg_new_invite){
		obj->objs[1] = arg_new_invite;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "new_invite");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionParticipantVolume(GroupCallParticipant arg_participant)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionParticipantVolume");
	int i;
	obj->id = 0x3e7f6847;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument GroupCallParticipant
	if (arg_participant){
		obj->objs[0] = arg_participant;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "participant");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionChangeHistoryTTL(int arg_prev_value, int arg_new_value)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionChangeHistoryTTL");
	int i;
	obj->id = 0x6e941a38;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_prev_value);
	strcpy(obj->objs[0]->name, "prev_value");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_new_value);
	strcpy(obj->objs[1]->name, "new_value");
	return obj;
}

tlo_t * tl_channelAdminLogEventActionParticipantJoinByRequest(ExportedChatInvite arg_invite, long arg_approved_by)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionParticipantJoinByRequest");
	int i;
	obj->id = 0xafb6144a;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument ExportedChatInvite
	if (arg_invite){
		obj->objs[0] = arg_invite;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "invite");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_approved_by);
	strcpy(obj->objs[1]->name, "approved_by");
	return obj;
}

tlo_t * tl_channelAdminLogEventActionToggleNoForwards(Bool arg_new_value)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionToggleNoForwards");
	int i;
	obj->id = 0xcb2ac766;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Bool
	if (arg_new_value){
		obj->objs[0] = arg_new_value;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "new_value");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionSendMessage(Message arg_message)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionSendMessage");
	int i;
	obj->id = 0x278f2868;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Message
	if (arg_message){
		obj->objs[0] = arg_message;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "message");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionChangeAvailableReactions(ChatReactions arg_prev_value, ChatReactions arg_new_value)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionChangeAvailableReactions");
	int i;
	obj->id = 0xbe4e0ef8;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument ChatReactions
	if (arg_prev_value){
		obj->objs[0] = arg_prev_value;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "prev_value");
	}


	//parse argument ChatReactions
	if (arg_new_value){
		obj->objs[1] = arg_new_value;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "new_value");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionChangeUsernames(const char * *arg_prev_value, int len_arg_prev_value, const char * *arg_new_value, int len_arg_new_value)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionChangeUsernames");
	int i;
	obj->id = 0xf04fb3a9;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<string>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "prev_value");
	if (arg_prev_value){
		for(i=0; i<len_arg_prev_value; ++i){
			int len = strlen(arg_prev_value[i]);
			buf_t b = buf_add((ui8_t *)arg_prev_value[i], len);
			buf_cat(obj->objs[0]->value, b);
		}
	}


	//parse argument Vector<string>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "new_value");
	if (arg_new_value){
		for(i=0; i<len_arg_new_value; ++i){
			int len = strlen(arg_new_value[i]);
			buf_t b = buf_add((ui8_t *)arg_new_value[i], len);
			buf_cat(obj->objs[1]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionToggleForum(Bool arg_new_value)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionToggleForum");
	int i;
	obj->id = 0x02cc6383;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Bool
	if (arg_new_value){
		obj->objs[0] = arg_new_value;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "new_value");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionCreateTopic(ForumTopic arg_topic)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionCreateTopic");
	int i;
	obj->id = 0x58707d28;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument ForumTopic
	if (arg_topic){
		obj->objs[0] = arg_topic;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "topic");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionEditTopic(ForumTopic arg_prev_topic, ForumTopic arg_new_topic)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionEditTopic");
	int i;
	obj->id = 0xf06fe208;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument ForumTopic
	if (arg_prev_topic){
		obj->objs[0] = arg_prev_topic;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "prev_topic");
	}


	//parse argument ForumTopic
	if (arg_new_topic){
		obj->objs[1] = arg_new_topic;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "new_topic");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionDeleteTopic(ForumTopic arg_topic)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionDeleteTopic");
	int i;
	obj->id = 0xae168909;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument ForumTopic
	if (arg_topic){
		obj->objs[0] = arg_topic;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "topic");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionPinTopic(ForumTopic arg_prev_topic, ForumTopic arg_new_topic)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionPinTopic");
	int i;
	obj->id = 0x5d8d353b;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument ForumTopic
	if (arg_prev_topic){
		obj->objs[1] = arg_prev_topic;
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "prev_topic");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument ForumTopic
	if (arg_new_topic){
		obj->objs[2] = arg_new_topic;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 1;
	strcpy(obj->objs[2]->name, "new_topic");
		flagsv[nflags-1] |= (1 << 1);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_channelAdminLogEventActionToggleAntiSpam(Bool arg_new_value)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionToggleAntiSpam");
	int i;
	obj->id = 0x64f36dfc;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Bool
	if (arg_new_value){
		obj->objs[0] = arg_new_value;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "new_value");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionChangePeerColor(PeerColor arg_prev_value, PeerColor arg_new_value)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionChangePeerColor");
	int i;
	obj->id = 0x5796e780;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument PeerColor
	if (arg_prev_value){
		obj->objs[0] = arg_prev_value;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "prev_value");
	}


	//parse argument PeerColor
	if (arg_new_value){
		obj->objs[1] = arg_new_value;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "new_value");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionChangeProfilePeerColor(PeerColor arg_prev_value, PeerColor arg_new_value)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionChangeProfilePeerColor");
	int i;
	obj->id = 0x5e477b25;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument PeerColor
	if (arg_prev_value){
		obj->objs[0] = arg_prev_value;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "prev_value");
	}


	//parse argument PeerColor
	if (arg_new_value){
		obj->objs[1] = arg_new_value;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "new_value");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionChangeWallpaper(WallPaper arg_prev_value, WallPaper arg_new_value)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionChangeWallpaper");
	int i;
	obj->id = 0x31bb5d52;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument WallPaper
	if (arg_prev_value){
		obj->objs[0] = arg_prev_value;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "prev_value");
	}


	//parse argument WallPaper
	if (arg_new_value){
		obj->objs[1] = arg_new_value;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "new_value");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionChangeEmojiStatus(EmojiStatus arg_prev_value, EmojiStatus arg_new_value)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionChangeEmojiStatus");
	int i;
	obj->id = 0x3ea9feb1;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument EmojiStatus
	if (arg_prev_value){
		obj->objs[0] = arg_prev_value;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "prev_value");
	}


	//parse argument EmojiStatus
	if (arg_new_value){
		obj->objs[1] = arg_new_value;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "new_value");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionChangeEmojiStickerSet(InputStickerSet arg_prev_stickerset, InputStickerSet arg_new_stickerset)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionChangeEmojiStickerSet");
	int i;
	obj->id = 0x46d840ab;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputStickerSet
	if (arg_prev_stickerset){
		obj->objs[0] = arg_prev_stickerset;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "prev_stickerset");
	}


	//parse argument InputStickerSet
	if (arg_new_stickerset){
		obj->objs[1] = arg_new_stickerset;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "new_stickerset");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionToggleSignatureProfiles(Bool arg_new_value)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionToggleSignatureProfiles");
	int i;
	obj->id = 0x60a79c79;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Bool
	if (arg_new_value){
		obj->objs[0] = arg_new_value;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "new_value");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventActionParticipantSubExtend(ChannelParticipant arg_prev_participant, ChannelParticipant arg_new_participant)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventActionParticipantSubExtend");
	int i;
	obj->id = 0x64642db3;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument ChannelParticipant
	if (arg_prev_participant){
		obj->objs[0] = arg_prev_participant;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "prev_participant");
	}


	//parse argument ChannelParticipant
	if (arg_new_participant){
		obj->objs[1] = arg_new_participant;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "new_participant");
	}

	return obj;
}

tlo_t * tl_channelAdminLogEvent(long arg_id, int arg_date, long arg_user_id, ChannelAdminLogEventAction arg_action)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEvent");
	int i;
	obj->id = 0x1fad68cd;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[1]->name, "date");

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[2]->name, "user_id");

	//parse argument ChannelAdminLogEventAction
	if (arg_action){
		obj->objs[3] = arg_action;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "action");
	}

	return obj;
}

tlo_t * tl_channels_adminLogResults(ChannelAdminLogEvent *arg_events, int len_arg_events, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_adminLogResults");
	int i;
	obj->id = 0xed8af74d;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<ChannelAdminLogEvent>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "events");
	if (arg_events){
		for(i=0; i<len_arg_events; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_events[i]->id);
			buf_cat(obj->objs[0]->value, arg_events[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[1]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[2]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_channelAdminLogEventsFilter(bool arg_join, bool arg_leave, bool arg_invite, bool arg_ban, bool arg_unban, bool arg_kick, bool arg_unkick, bool arg_promote, bool arg_demote, bool arg_info, bool arg_settings, bool arg_pinned, bool arg_edit, bool arg_delete, bool arg_group_call, bool arg_invites, bool arg_send, bool arg_forums, bool arg_sub_extend)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelAdminLogEventsFilter");
	int i;
	obj->id = 0xea107ae4;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 20;
	obj->objs = 
		(tlo_t **)MALLOC(20 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_join);
	strcpy(obj->objs[1]->name, "join");
	if (arg_join)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_leave);
	strcpy(obj->objs[2]->name, "leave");
	if (arg_leave)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_invite);
	strcpy(obj->objs[3]->name, "invite");
	if (arg_invite)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 3;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_ban);
	strcpy(obj->objs[4]->name, "ban");
	if (arg_ban)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 4;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_unban);
	strcpy(obj->objs[5]->name, "unban");
	if (arg_unban)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument true
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 5;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_kick);
	strcpy(obj->objs[6]->name, "kick");
	if (arg_kick)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument true
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 6;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_unkick);
	strcpy(obj->objs[7]->name, "unkick");
	if (arg_unkick)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument true
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 7;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_promote);
	strcpy(obj->objs[8]->name, "promote");
	if (arg_promote)
		flagsv[nflags-1] |= (1 << 7);

	//parse argument true
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 1;
	obj->objs[9]->flag_bit = 8;
	obj->objs[9]->type = TYPE_INT;
	obj->objs[9]->value = 
		buf_add_ui32(arg_demote);
	strcpy(obj->objs[9]->name, "demote");
	if (arg_demote)
		flagsv[nflags-1] |= (1 << 8);

	//parse argument true
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 1;
	obj->objs[10]->flag_bit = 9;
	obj->objs[10]->type = TYPE_INT;
	obj->objs[10]->value = 
		buf_add_ui32(arg_info);
	strcpy(obj->objs[10]->name, "info");
	if (arg_info)
		flagsv[nflags-1] |= (1 << 9);

	//parse argument true
	obj->objs[11] = NEW(tlo_t, return NULL);
	obj->objs[11]->flag_num = 1;
	obj->objs[11]->flag_bit = 10;
	obj->objs[11]->type = TYPE_INT;
	obj->objs[11]->value = 
		buf_add_ui32(arg_settings);
	strcpy(obj->objs[11]->name, "settings");
	if (arg_settings)
		flagsv[nflags-1] |= (1 << 10);

	//parse argument true
	obj->objs[12] = NEW(tlo_t, return NULL);
	obj->objs[12]->flag_num = 1;
	obj->objs[12]->flag_bit = 11;
	obj->objs[12]->type = TYPE_INT;
	obj->objs[12]->value = 
		buf_add_ui32(arg_pinned);
	strcpy(obj->objs[12]->name, "pinned");
	if (arg_pinned)
		flagsv[nflags-1] |= (1 << 11);

	//parse argument true
	obj->objs[13] = NEW(tlo_t, return NULL);
	obj->objs[13]->flag_num = 1;
	obj->objs[13]->flag_bit = 12;
	obj->objs[13]->type = TYPE_INT;
	obj->objs[13]->value = 
		buf_add_ui32(arg_edit);
	strcpy(obj->objs[13]->name, "edit");
	if (arg_edit)
		flagsv[nflags-1] |= (1 << 12);

	//parse argument true
	obj->objs[14] = NEW(tlo_t, return NULL);
	obj->objs[14]->flag_num = 1;
	obj->objs[14]->flag_bit = 13;
	obj->objs[14]->type = TYPE_INT;
	obj->objs[14]->value = 
		buf_add_ui32(arg_delete);
	strcpy(obj->objs[14]->name, "delete");
	if (arg_delete)
		flagsv[nflags-1] |= (1 << 13);

	//parse argument true
	obj->objs[15] = NEW(tlo_t, return NULL);
	obj->objs[15]->flag_num = 1;
	obj->objs[15]->flag_bit = 14;
	obj->objs[15]->type = TYPE_INT;
	obj->objs[15]->value = 
		buf_add_ui32(arg_group_call);
	strcpy(obj->objs[15]->name, "group_call");
	if (arg_group_call)
		flagsv[nflags-1] |= (1 << 14);

	//parse argument true
	obj->objs[16] = NEW(tlo_t, return NULL);
	obj->objs[16]->flag_num = 1;
	obj->objs[16]->flag_bit = 15;
	obj->objs[16]->type = TYPE_INT;
	obj->objs[16]->value = 
		buf_add_ui32(arg_invites);
	strcpy(obj->objs[16]->name, "invites");
	if (arg_invites)
		flagsv[nflags-1] |= (1 << 15);

	//parse argument true
	obj->objs[17] = NEW(tlo_t, return NULL);
	obj->objs[17]->flag_num = 1;
	obj->objs[17]->flag_bit = 16;
	obj->objs[17]->type = TYPE_INT;
	obj->objs[17]->value = 
		buf_add_ui32(arg_send);
	strcpy(obj->objs[17]->name, "send");
	if (arg_send)
		flagsv[nflags-1] |= (1 << 16);

	//parse argument true
	obj->objs[18] = NEW(tlo_t, return NULL);
	obj->objs[18]->flag_num = 1;
	obj->objs[18]->flag_bit = 17;
	obj->objs[18]->type = TYPE_INT;
	obj->objs[18]->value = 
		buf_add_ui32(arg_forums);
	strcpy(obj->objs[18]->name, "forums");
	if (arg_forums)
		flagsv[nflags-1] |= (1 << 17);

	//parse argument true
	obj->objs[19] = NEW(tlo_t, return NULL);
	obj->objs[19]->flag_num = 1;
	obj->objs[19]->flag_bit = 18;
	obj->objs[19]->type = TYPE_INT;
	obj->objs[19]->value = 
		buf_add_ui32(arg_sub_extend);
	strcpy(obj->objs[19]->name, "sub_extend");
	if (arg_sub_extend)
		flagsv[nflags-1] |= (1 << 18);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_popularContact(long arg_client_id, int arg_importers)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "popularContact");
	int i;
	obj->id = 0x5ce14175;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_client_id);
	strcpy(obj->objs[0]->name, "client_id");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_importers);
	strcpy(obj->objs[1]->name, "importers");
	return obj;
}

tlo_t * tl_messages_favedStickersNotModified()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_favedStickersNotModified");
	int i;
	obj->id = 0x9e8fa6d3;
	return obj;
}

tlo_t * tl_messages_favedStickers(long arg_hash, StickerPack *arg_packs, int len_arg_packs, Document *arg_stickers, int len_arg_stickers)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_favedStickers");
	int i;
	obj->id = 0x2cb51097;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");

	//parse argument Vector<StickerPack>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "packs");
	if (arg_packs){
		for(i=0; i<len_arg_packs; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_packs[i]->id);
			buf_cat(obj->objs[1]->value, arg_packs[i]->value);
		}
	}


	//parse argument Vector<Document>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "stickers");
	if (arg_stickers){
		for(i=0; i<len_arg_stickers; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_stickers[i]->id);
			buf_cat(obj->objs[2]->value, arg_stickers[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_recentMeUrlUnknown(const char * arg_url)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "recentMeUrlUnknown");
	int i;
	obj->id = 0x46e1d13d;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_url){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[0]->name, "url");
	}

	return obj;
}

tlo_t * tl_recentMeUrlUser(const char * arg_url, long arg_user_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "recentMeUrlUser");
	int i;
	obj->id = 0xb92c09e2;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_url){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[0]->name, "url");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[1]->name, "user_id");
	return obj;
}

tlo_t * tl_recentMeUrlChat(const char * arg_url, long arg_chat_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "recentMeUrlChat");
	int i;
	obj->id = 0xb2da71d2;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_url){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[0]->name, "url");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_chat_id);
	strcpy(obj->objs[1]->name, "chat_id");
	return obj;
}

tlo_t * tl_recentMeUrlChatInvite(const char * arg_url, ChatInvite arg_chat_invite)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "recentMeUrlChatInvite");
	int i;
	obj->id = 0xeb49081d;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_url){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[0]->name, "url");
	}


	//parse argument ChatInvite
	if (arg_chat_invite){
		obj->objs[1] = arg_chat_invite;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "chat_invite");
	}

	return obj;
}

tlo_t * tl_recentMeUrlStickerSet(const char * arg_url, StickerSetCovered arg_set)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "recentMeUrlStickerSet");
	int i;
	obj->id = 0xbc0a57dc;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_url){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[0]->name, "url");
	}


	//parse argument StickerSetCovered
	if (arg_set){
		obj->objs[1] = arg_set;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "set");
	}

	return obj;
}

tlo_t * tl_help_recentMeUrls(RecentMeUrl *arg_urls, int len_arg_urls, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_recentMeUrls");
	int i;
	obj->id = 0x0e0310d7;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<RecentMeUrl>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "urls");
	if (arg_urls){
		for(i=0; i<len_arg_urls; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_urls[i]->id);
			buf_cat(obj->objs[0]->value, arg_urls[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[1]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[2]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_inputSingleMedia(InputMedia arg_media, long arg_random_id, const char * arg_message, MessageEntity *arg_entities, int len_arg_entities)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputSingleMedia");
	int i;
	obj->id = 0x1cc6e91f;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputMedia
	if (arg_media){
		obj->objs[1] = arg_media;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "media");
	}


	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_random_id);
	strcpy(obj->objs[2]->name, "random_id");

	//parse argument string
	if (arg_message){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_message, strlen(arg_message));
		strcpy(obj->objs[3]->name, "message");
	}


	//parse argument Vector<MessageEntity>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "entities");
	if (arg_entities){
		for(i=0; i<len_arg_entities; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_entities[i]->id);
			buf_cat(obj->objs[4]->value, arg_entities[i]->value);
		}
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_webAuthorization(long arg_hash, long arg_bot_id, const char * arg_domain, const char * arg_browser, const char * arg_platform, int arg_date_created, int arg_date_active, const char * arg_ip, const char * arg_region)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "webAuthorization");
	int i;
	obj->id = 0xa6f8f452;
	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_bot_id);
	strcpy(obj->objs[1]->name, "bot_id");

	//parse argument string
	if (arg_domain){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_domain, strlen(arg_domain));
		strcpy(obj->objs[2]->name, "domain");
	}


	//parse argument string
	if (arg_browser){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_browser, strlen(arg_browser));
		strcpy(obj->objs[3]->name, "browser");
	}


	//parse argument string
	if (arg_platform){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_platform, strlen(arg_platform));
		strcpy(obj->objs[4]->name, "platform");
	}


	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_date_created);
	strcpy(obj->objs[5]->name, "date_created");

	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_date_active);
	strcpy(obj->objs[6]->name, "date_active");

	//parse argument string
	if (arg_ip){
		obj->objs[7] = NEW(tlo_t, return NULL);
		obj->objs[7]->flag_num = 0;
		obj->objs[7]->flag_bit = 0;
		obj->objs[7]->type = TYPE_STRING;
		obj->objs[7]->value = 
			buf_add((ui8_t *)arg_ip, strlen(arg_ip));
		strcpy(obj->objs[7]->name, "ip");
	}


	//parse argument string
	if (arg_region){
		obj->objs[8] = NEW(tlo_t, return NULL);
		obj->objs[8]->flag_num = 0;
		obj->objs[8]->flag_bit = 0;
		obj->objs[8]->type = TYPE_STRING;
		obj->objs[8]->value = 
			buf_add((ui8_t *)arg_region, strlen(arg_region));
		strcpy(obj->objs[8]->name, "region");
	}

	return obj;
}

tlo_t * tl_account_webAuthorizations(WebAuthorization *arg_authorizations, int len_arg_authorizations, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_webAuthorizations");
	int i;
	obj->id = 0xed56c9fc;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<WebAuthorization>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "authorizations");
	if (arg_authorizations){
		for(i=0; i<len_arg_authorizations; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_authorizations[i]->id);
			buf_cat(obj->objs[0]->value, arg_authorizations[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[1]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_inputMessageID(int arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMessageID");
	int i;
	obj->id = 0xa676a322;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[0]->name, "id");
	return obj;
}

tlo_t * tl_inputMessageReplyTo(int arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMessageReplyTo");
	int i;
	obj->id = 0xbad88395;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[0]->name, "id");
	return obj;
}

tlo_t * tl_inputMessagePinned()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMessagePinned");
	int i;
	obj->id = 0x86872538;
	return obj;
}

tlo_t * tl_inputMessageCallbackQuery(int arg_id, long arg_query_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMessageCallbackQuery");
	int i;
	obj->id = 0xacfa1a7e;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_query_id);
	strcpy(obj->objs[1]->name, "query_id");
	return obj;
}

tlo_t * tl_inputDialogPeer(InputPeer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputDialogPeer");
	int i;
	obj->id = 0xfcaafeb7;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}

	return obj;
}

tlo_t * tl_inputDialogPeerFolder(int arg_folder_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputDialogPeerFolder");
	int i;
	obj->id = 0x64600527;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_folder_id);
	strcpy(obj->objs[0]->name, "folder_id");
	return obj;
}

tlo_t * tl_dialogPeer(Peer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "dialogPeer");
	int i;
	obj->id = 0xe56dbf05;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}

	return obj;
}

tlo_t * tl_dialogPeerFolder(int arg_folder_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "dialogPeerFolder");
	int i;
	obj->id = 0x514519e2;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_folder_id);
	strcpy(obj->objs[0]->name, "folder_id");
	return obj;
}

tlo_t * tl_messages_foundStickerSetsNotModified()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_foundStickerSetsNotModified");
	int i;
	obj->id = 0x0d54b65d;
	return obj;
}

tlo_t * tl_messages_foundStickerSets(long arg_hash, StickerSetCovered *arg_sets, int len_arg_sets)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_foundStickerSets");
	int i;
	obj->id = 0x8af09dd2;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");

	//parse argument Vector<StickerSetCovered>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "sets");
	if (arg_sets){
		for(i=0; i<len_arg_sets; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_sets[i]->id);
			buf_cat(obj->objs[1]->value, arg_sets[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_fileHash(long arg_offset, int arg_limit, unsigned char * arg_hash, int len_arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "fileHash");
	int i;
	obj->id = 0xf39b035c;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_offset);
	strcpy(obj->objs[0]->name, "offset");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[1]->name, "limit");

	//parse argument bytes
	if (arg_hash){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_BYTES;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_hash, len_arg_hash);
		strcpy(obj->objs[2]->name, "hash");
	}

	return obj;
}

tlo_t * tl_inputClientProxy(const char * arg_address, int arg_port)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputClientProxy");
	int i;
	obj->id = 0x75588b3f;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_address){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_address, strlen(arg_address));
		strcpy(obj->objs[0]->name, "address");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_port);
	strcpy(obj->objs[1]->name, "port");
	return obj;
}

tlo_t * tl_help_termsOfServiceUpdateEmpty(int arg_expires)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_termsOfServiceUpdateEmpty");
	int i;
	obj->id = 0xe3309f7f;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_expires);
	strcpy(obj->objs[0]->name, "expires");
	return obj;
}

tlo_t * tl_help_termsOfServiceUpdate(int arg_expires, help_TermsOfService arg_terms_of_service)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_termsOfServiceUpdate");
	int i;
	obj->id = 0x28ecf961;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_expires);
	strcpy(obj->objs[0]->name, "expires");

	//parse argument help_TermsOfService
	if (arg_terms_of_service){
		obj->objs[1] = arg_terms_of_service;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "terms_of_service");
	}

	return obj;
}

tlo_t * tl_inputSecureFileUploaded(long arg_id, int arg_parts, const char * arg_md5_checksum, unsigned char * arg_file_hash, int len_arg_file_hash, unsigned char * arg_secret, int len_arg_secret)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputSecureFileUploaded");
	int i;
	obj->id = 0x3334b0f0;
	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_parts);
	strcpy(obj->objs[1]->name, "parts");

	//parse argument string
	if (arg_md5_checksum){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_md5_checksum, strlen(arg_md5_checksum));
		strcpy(obj->objs[2]->name, "md5_checksum");
	}


	//parse argument bytes
	if (arg_file_hash){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_BYTES;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_file_hash, len_arg_file_hash);
		strcpy(obj->objs[3]->name, "file_hash");
	}


	//parse argument bytes
	if (arg_secret){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_BYTES;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_secret, len_arg_secret);
		strcpy(obj->objs[4]->name, "secret");
	}

	return obj;
}

tlo_t * tl_inputSecureFile(long arg_id, long arg_access_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputSecureFile");
	int i;
	obj->id = 0x5367e5be;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[1]->name, "access_hash");
	return obj;
}

tlo_t * tl_secureFileEmpty()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "secureFileEmpty");
	int i;
	obj->id = 0x64199744;
	return obj;
}

tlo_t * tl_secureFile(long arg_id, long arg_access_hash, long arg_size, int arg_dc_id, int arg_date, unsigned char * arg_file_hash, int len_arg_file_hash, unsigned char * arg_secret, int len_arg_secret)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "secureFile");
	int i;
	obj->id = 0x7d09c27e;
	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[1]->name, "access_hash");

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_size);
	strcpy(obj->objs[2]->name, "size");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_dc_id);
	strcpy(obj->objs[3]->name, "dc_id");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[4]->name, "date");

	//parse argument bytes
	if (arg_file_hash){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_BYTES;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_file_hash, len_arg_file_hash);
		strcpy(obj->objs[5]->name, "file_hash");
	}


	//parse argument bytes
	if (arg_secret){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
		obj->objs[6]->type = TYPE_BYTES;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_secret, len_arg_secret);
		strcpy(obj->objs[6]->name, "secret");
	}

	return obj;
}

tlo_t * tl_secureData(unsigned char * arg_data, int len_arg_data, unsigned char * arg_data_hash, int len_arg_data_hash, unsigned char * arg_secret, int len_arg_secret)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "secureData");
	int i;
	obj->id = 0x8aeabec3;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument bytes
	if (arg_data){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_BYTES;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_data, len_arg_data);
		strcpy(obj->objs[0]->name, "data");
	}


	//parse argument bytes
	if (arg_data_hash){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_data_hash, len_arg_data_hash);
		strcpy(obj->objs[1]->name, "data_hash");
	}


	//parse argument bytes
	if (arg_secret){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_BYTES;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_secret, len_arg_secret);
		strcpy(obj->objs[2]->name, "secret");
	}

	return obj;
}

tlo_t * tl_securePlainPhone(const char * arg_phone)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "securePlainPhone");
	int i;
	obj->id = 0x7d6099dd;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_phone){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_phone, strlen(arg_phone));
		strcpy(obj->objs[0]->name, "phone");
	}

	return obj;
}

tlo_t * tl_securePlainEmail(const char * arg_email)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "securePlainEmail");
	int i;
	obj->id = 0x21ec5a5f;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_email){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_email, strlen(arg_email));
		strcpy(obj->objs[0]->name, "email");
	}

	return obj;
}

tlo_t * tl_secureValueTypePersonalDetails()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "secureValueTypePersonalDetails");
	int i;
	obj->id = 0x9d2a81e3;
	return obj;
}

tlo_t * tl_secureValueTypePassport()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "secureValueTypePassport");
	int i;
	obj->id = 0x3dac6a00;
	return obj;
}

tlo_t * tl_secureValueTypeDriverLicense()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "secureValueTypeDriverLicense");
	int i;
	obj->id = 0x06e425c4;
	return obj;
}

tlo_t * tl_secureValueTypeIdentityCard()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "secureValueTypeIdentityCard");
	int i;
	obj->id = 0xa0d0744b;
	return obj;
}

tlo_t * tl_secureValueTypeInternalPassport()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "secureValueTypeInternalPassport");
	int i;
	obj->id = 0x99a48f23;
	return obj;
}

tlo_t * tl_secureValueTypeAddress()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "secureValueTypeAddress");
	int i;
	obj->id = 0xcbe31e26;
	return obj;
}

tlo_t * tl_secureValueTypeUtilityBill()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "secureValueTypeUtilityBill");
	int i;
	obj->id = 0xfc36954e;
	return obj;
}

tlo_t * tl_secureValueTypeBankStatement()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "secureValueTypeBankStatement");
	int i;
	obj->id = 0x89137c0d;
	return obj;
}

tlo_t * tl_secureValueTypeRentalAgreement()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "secureValueTypeRentalAgreement");
	int i;
	obj->id = 0x8b883488;
	return obj;
}

tlo_t * tl_secureValueTypePassportRegistration()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "secureValueTypePassportRegistration");
	int i;
	obj->id = 0x99e3806a;
	return obj;
}

tlo_t * tl_secureValueTypeTemporaryRegistration()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "secureValueTypeTemporaryRegistration");
	int i;
	obj->id = 0xea02ec33;
	return obj;
}

tlo_t * tl_secureValueTypePhone()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "secureValueTypePhone");
	int i;
	obj->id = 0xb320aadb;
	return obj;
}

tlo_t * tl_secureValueTypeEmail()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "secureValueTypeEmail");
	int i;
	obj->id = 0x8e3ca7ee;
	return obj;
}

tlo_t * tl_secureValue(SecureValueType arg_type, SecureData arg_data, SecureFile arg_front_side, SecureFile arg_reverse_side, SecureFile arg_selfie, SecureFile *arg_translation, int len_arg_translation, SecureFile *arg_files, int len_arg_files, SecurePlainData arg_plain_data, unsigned char * arg_hash, int len_arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "secureValue");
	int i;
	obj->id = 0x187fa0ca;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 10;
	obj->objs = 
		(tlo_t **)MALLOC(10 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument SecureValueType
	if (arg_type){
		obj->objs[1] = arg_type;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "type");
	}


	//parse argument SecureData
	if (arg_data){
		obj->objs[2] = arg_data;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "data");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument SecureFile
	if (arg_front_side){
		obj->objs[3] = arg_front_side;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 1;
	strcpy(obj->objs[3]->name, "front_side");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument SecureFile
	if (arg_reverse_side){
		obj->objs[4] = arg_reverse_side;
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 2;
	strcpy(obj->objs[4]->name, "reverse_side");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument SecureFile
	if (arg_selfie){
		obj->objs[5] = arg_selfie;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 3;
	strcpy(obj->objs[5]->name, "selfie");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument Vector<SecureFile>
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 6;
	obj->objs[6]->type = TYPE_VECTOR;
	strcpy(obj->objs[6]->name, "translation");
	if (arg_translation){
		for(i=0; i<len_arg_translation; ++i){
			obj->objs[6]->value = buf_add_ui32(arg_translation[i]->id);
			buf_cat(obj->objs[6]->value, arg_translation[i]->value);
		}
		flagsv[nflags-1] |= (1 << 6);
	}


	//parse argument Vector<SecureFile>
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 4;
	obj->objs[7]->type = TYPE_VECTOR;
	strcpy(obj->objs[7]->name, "files");
	if (arg_files){
		for(i=0; i<len_arg_files; ++i){
			obj->objs[7]->value = buf_add_ui32(arg_files[i]->id);
			buf_cat(obj->objs[7]->value, arg_files[i]->value);
		}
		flagsv[nflags-1] |= (1 << 4);
	}


	//parse argument SecurePlainData
	if (arg_plain_data){
		obj->objs[8] = arg_plain_data;
		obj->objs[8]->flag_num = 1;
		obj->objs[8]->flag_bit = 5;
	strcpy(obj->objs[8]->name, "plain_data");
		flagsv[nflags-1] |= (1 << 5);
	}


	//parse argument bytes
	if (arg_hash){
		obj->objs[9] = NEW(tlo_t, return NULL);
		obj->objs[9]->flag_num = 0;
		obj->objs[9]->flag_bit = 0;
		obj->objs[9]->type = TYPE_BYTES;
		obj->objs[9]->value = 
			buf_add((ui8_t *)arg_hash, len_arg_hash);
		strcpy(obj->objs[9]->name, "hash");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputSecureValue(SecureValueType arg_type, SecureData arg_data, InputSecureFile arg_front_side, InputSecureFile arg_reverse_side, InputSecureFile arg_selfie, InputSecureFile *arg_translation, int len_arg_translation, InputSecureFile *arg_files, int len_arg_files, SecurePlainData arg_plain_data)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputSecureValue");
	int i;
	obj->id = 0xdb21d0a7;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument SecureValueType
	if (arg_type){
		obj->objs[1] = arg_type;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "type");
	}


	//parse argument SecureData
	if (arg_data){
		obj->objs[2] = arg_data;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "data");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument InputSecureFile
	if (arg_front_side){
		obj->objs[3] = arg_front_side;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 1;
	strcpy(obj->objs[3]->name, "front_side");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument InputSecureFile
	if (arg_reverse_side){
		obj->objs[4] = arg_reverse_side;
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 2;
	strcpy(obj->objs[4]->name, "reverse_side");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument InputSecureFile
	if (arg_selfie){
		obj->objs[5] = arg_selfie;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 3;
	strcpy(obj->objs[5]->name, "selfie");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument Vector<InputSecureFile>
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 6;
	obj->objs[6]->type = TYPE_VECTOR;
	strcpy(obj->objs[6]->name, "translation");
	if (arg_translation){
		for(i=0; i<len_arg_translation; ++i){
			obj->objs[6]->value = buf_add_ui32(arg_translation[i]->id);
			buf_cat(obj->objs[6]->value, arg_translation[i]->value);
		}
		flagsv[nflags-1] |= (1 << 6);
	}


	//parse argument Vector<InputSecureFile>
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 4;
	obj->objs[7]->type = TYPE_VECTOR;
	strcpy(obj->objs[7]->name, "files");
	if (arg_files){
		for(i=0; i<len_arg_files; ++i){
			obj->objs[7]->value = buf_add_ui32(arg_files[i]->id);
			buf_cat(obj->objs[7]->value, arg_files[i]->value);
		}
		flagsv[nflags-1] |= (1 << 4);
	}


	//parse argument SecurePlainData
	if (arg_plain_data){
		obj->objs[8] = arg_plain_data;
		obj->objs[8]->flag_num = 1;
		obj->objs[8]->flag_bit = 5;
	strcpy(obj->objs[8]->name, "plain_data");
		flagsv[nflags-1] |= (1 << 5);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_secureValueHash(SecureValueType arg_type, unsigned char * arg_hash, int len_arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "secureValueHash");
	int i;
	obj->id = 0xed1ecdb0;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument SecureValueType
	if (arg_type){
		obj->objs[0] = arg_type;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "type");
	}


	//parse argument bytes
	if (arg_hash){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_hash, len_arg_hash);
		strcpy(obj->objs[1]->name, "hash");
	}

	return obj;
}

tlo_t * tl_secureValueErrorData(SecureValueType arg_type, unsigned char * arg_data_hash, int len_arg_data_hash, const char * arg_field, const char * arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "secureValueErrorData");
	int i;
	obj->id = 0xe8a40bd9;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument SecureValueType
	if (arg_type){
		obj->objs[0] = arg_type;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "type");
	}


	//parse argument bytes
	if (arg_data_hash){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_data_hash, len_arg_data_hash);
		strcpy(obj->objs[1]->name, "data_hash");
	}


	//parse argument string
	if (arg_field){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_field, strlen(arg_field));
		strcpy(obj->objs[2]->name, "field");
	}


	//parse argument string
	if (arg_text){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[3]->name, "text");
	}

	return obj;
}

tlo_t * tl_secureValueErrorFrontSide(SecureValueType arg_type, unsigned char * arg_file_hash, int len_arg_file_hash, const char * arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "secureValueErrorFrontSide");
	int i;
	obj->id = 0x00be3dfa;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument SecureValueType
	if (arg_type){
		obj->objs[0] = arg_type;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "type");
	}


	//parse argument bytes
	if (arg_file_hash){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_file_hash, len_arg_file_hash);
		strcpy(obj->objs[1]->name, "file_hash");
	}


	//parse argument string
	if (arg_text){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[2]->name, "text");
	}

	return obj;
}

tlo_t * tl_secureValueErrorReverseSide(SecureValueType arg_type, unsigned char * arg_file_hash, int len_arg_file_hash, const char * arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "secureValueErrorReverseSide");
	int i;
	obj->id = 0x868a2aa5;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument SecureValueType
	if (arg_type){
		obj->objs[0] = arg_type;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "type");
	}


	//parse argument bytes
	if (arg_file_hash){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_file_hash, len_arg_file_hash);
		strcpy(obj->objs[1]->name, "file_hash");
	}


	//parse argument string
	if (arg_text){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[2]->name, "text");
	}

	return obj;
}

tlo_t * tl_secureValueErrorSelfie(SecureValueType arg_type, unsigned char * arg_file_hash, int len_arg_file_hash, const char * arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "secureValueErrorSelfie");
	int i;
	obj->id = 0xe537ced6;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument SecureValueType
	if (arg_type){
		obj->objs[0] = arg_type;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "type");
	}


	//parse argument bytes
	if (arg_file_hash){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_file_hash, len_arg_file_hash);
		strcpy(obj->objs[1]->name, "file_hash");
	}


	//parse argument string
	if (arg_text){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[2]->name, "text");
	}

	return obj;
}

tlo_t * tl_secureValueErrorFile(SecureValueType arg_type, unsigned char * arg_file_hash, int len_arg_file_hash, const char * arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "secureValueErrorFile");
	int i;
	obj->id = 0x7a700873;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument SecureValueType
	if (arg_type){
		obj->objs[0] = arg_type;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "type");
	}


	//parse argument bytes
	if (arg_file_hash){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_file_hash, len_arg_file_hash);
		strcpy(obj->objs[1]->name, "file_hash");
	}


	//parse argument string
	if (arg_text){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[2]->name, "text");
	}

	return obj;
}

tlo_t * tl_secureValueErrorFiles(SecureValueType arg_type, unsigned char * *arg_file_hash, int len_arg_file_hash, const char * arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "secureValueErrorFiles");
	int i;
	obj->id = 0x666220e9;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument SecureValueType
	if (arg_type){
		obj->objs[0] = arg_type;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "type");
	}


	//parse argument Vector<bytes>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "file_hash");
	if (arg_file_hash){
		for(i=0; i<len_arg_file_hash; ++i){
			int len = *(int *)(arg_file_hash[i]);
			ui8_t *p = &(arg_file_hash[i][4]);
			buf_t b = buf_add(p, len);
			buf_cat(obj->objs[1]->value, b);
		}
	}


	//parse argument string
	if (arg_text){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[2]->name, "text");
	}

	return obj;
}

tlo_t * tl_secureValueError(SecureValueType arg_type, unsigned char * arg_hash, int len_arg_hash, const char * arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "secureValueError");
	int i;
	obj->id = 0x869d758f;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument SecureValueType
	if (arg_type){
		obj->objs[0] = arg_type;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "type");
	}


	//parse argument bytes
	if (arg_hash){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_hash, len_arg_hash);
		strcpy(obj->objs[1]->name, "hash");
	}


	//parse argument string
	if (arg_text){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[2]->name, "text");
	}

	return obj;
}

tlo_t * tl_secureValueErrorTranslationFile(SecureValueType arg_type, unsigned char * arg_file_hash, int len_arg_file_hash, const char * arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "secureValueErrorTranslationFile");
	int i;
	obj->id = 0xa1144770;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument SecureValueType
	if (arg_type){
		obj->objs[0] = arg_type;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "type");
	}


	//parse argument bytes
	if (arg_file_hash){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_file_hash, len_arg_file_hash);
		strcpy(obj->objs[1]->name, "file_hash");
	}


	//parse argument string
	if (arg_text){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[2]->name, "text");
	}

	return obj;
}

tlo_t * tl_secureValueErrorTranslationFiles(SecureValueType arg_type, unsigned char * *arg_file_hash, int len_arg_file_hash, const char * arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "secureValueErrorTranslationFiles");
	int i;
	obj->id = 0x34636dd8;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument SecureValueType
	if (arg_type){
		obj->objs[0] = arg_type;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "type");
	}


	//parse argument Vector<bytes>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "file_hash");
	if (arg_file_hash){
		for(i=0; i<len_arg_file_hash; ++i){
			int len = *(int *)(arg_file_hash[i]);
			ui8_t *p = &(arg_file_hash[i][4]);
			buf_t b = buf_add(p, len);
			buf_cat(obj->objs[1]->value, b);
		}
	}


	//parse argument string
	if (arg_text){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[2]->name, "text");
	}

	return obj;
}

tlo_t * tl_secureCredentialsEncrypted(unsigned char * arg_data, int len_arg_data, unsigned char * arg_hash, int len_arg_hash, unsigned char * arg_secret, int len_arg_secret)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "secureCredentialsEncrypted");
	int i;
	obj->id = 0x33f0ea47;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument bytes
	if (arg_data){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_BYTES;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_data, len_arg_data);
		strcpy(obj->objs[0]->name, "data");
	}


	//parse argument bytes
	if (arg_hash){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_hash, len_arg_hash);
		strcpy(obj->objs[1]->name, "hash");
	}


	//parse argument bytes
	if (arg_secret){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_BYTES;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_secret, len_arg_secret);
		strcpy(obj->objs[2]->name, "secret");
	}

	return obj;
}

tlo_t * tl_account_authorizationForm(SecureRequiredType *arg_required_types, int len_arg_required_types, SecureValue *arg_values, int len_arg_values, SecureValueError *arg_errors, int len_arg_errors, User *arg_users, int len_arg_users, const char * arg_privacy_policy_url)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_authorizationForm");
	int i;
	obj->id = 0xad2e1cd8;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument Vector<SecureRequiredType>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "required_types");
	if (arg_required_types){
		for(i=0; i<len_arg_required_types; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_required_types[i]->id);
			buf_cat(obj->objs[1]->value, arg_required_types[i]->value);
		}
	}


	//parse argument Vector<SecureValue>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "values");
	if (arg_values){
		for(i=0; i<len_arg_values; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_values[i]->id);
			buf_cat(obj->objs[2]->value, arg_values[i]->value);
		}
	}


	//parse argument Vector<SecureValueError>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "errors");
	if (arg_errors){
		for(i=0; i<len_arg_errors; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_errors[i]->id);
			buf_cat(obj->objs[3]->value, arg_errors[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[4]->value, arg_users[i]->value);
		}
	}


	//parse argument string
	if (arg_privacy_policy_url){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_privacy_policy_url, strlen(arg_privacy_policy_url));
		strcpy(obj->objs[5]->name, "privacy_policy_url");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_account_sentEmailCode(const char * arg_email_pattern, int arg_length)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_sentEmailCode");
	int i;
	obj->id = 0x811f854f;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_email_pattern){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_email_pattern, strlen(arg_email_pattern));
		strcpy(obj->objs[0]->name, "email_pattern");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_length);
	strcpy(obj->objs[1]->name, "length");
	return obj;
}

tlo_t * tl_help_deepLinkInfoEmpty()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_deepLinkInfoEmpty");
	int i;
	obj->id = 0x66afa166;
	return obj;
}

tlo_t * tl_help_deepLinkInfo(bool arg_update_app, const char * arg_message, MessageEntity *arg_entities, int len_arg_entities)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_deepLinkInfo");
	int i;
	obj->id = 0x6a4ee832;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_update_app);
	strcpy(obj->objs[1]->name, "update_app");
	if (arg_update_app)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument string
	if (arg_message){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_message, strlen(arg_message));
		strcpy(obj->objs[2]->name, "message");
	}


	//parse argument Vector<MessageEntity>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 1;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "entities");
	if (arg_entities){
		for(i=0; i<len_arg_entities; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_entities[i]->id);
			buf_cat(obj->objs[3]->value, arg_entities[i]->value);
		}
		flagsv[nflags-1] |= (1 << 1);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_savedPhoneContact(const char * arg_phone, const char * arg_first_name, const char * arg_last_name, int arg_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "savedPhoneContact");
	int i;
	obj->id = 0x1142bd56;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_phone){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_phone, strlen(arg_phone));
		strcpy(obj->objs[0]->name, "phone");
	}


	//parse argument string
	if (arg_first_name){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_first_name, strlen(arg_first_name));
		strcpy(obj->objs[1]->name, "first_name");
	}


	//parse argument string
	if (arg_last_name){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_last_name, strlen(arg_last_name));
		strcpy(obj->objs[2]->name, "last_name");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[3]->name, "date");
	return obj;
}

tlo_t * tl_account_takeout(long arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_takeout");
	int i;
	obj->id = 0x4dba4501;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");
	return obj;
}

tlo_t * tl_passwordKdfAlgoUnknown()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "passwordKdfAlgoUnknown");
	int i;
	obj->id = 0xd45ab096;
	return obj;
}

tlo_t * tl_passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow(unsigned char * arg_salt1, int len_arg_salt1, unsigned char * arg_salt2, int len_arg_salt2, int arg_g, unsigned char * arg_p, int len_arg_p)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow");
	int i;
	obj->id = 0x3a912d4a;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument bytes
	if (arg_salt1){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_BYTES;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_salt1, len_arg_salt1);
		strcpy(obj->objs[0]->name, "salt1");
	}


	//parse argument bytes
	if (arg_salt2){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_salt2, len_arg_salt2);
		strcpy(obj->objs[1]->name, "salt2");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_g);
	strcpy(obj->objs[2]->name, "g");

	//parse argument bytes
	if (arg_p){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_BYTES;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_p, len_arg_p);
		strcpy(obj->objs[3]->name, "p");
	}

	return obj;
}

tlo_t * tl_securePasswordKdfAlgoUnknown()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "securePasswordKdfAlgoUnknown");
	int i;
	obj->id = 0x004a8537;
	return obj;
}

tlo_t * tl_securePasswordKdfAlgoPBKDF2HMACSHA512iter100000(unsigned char * arg_salt, int len_arg_salt)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "securePasswordKdfAlgoPBKDF2HMACSHA512iter100000");
	int i;
	obj->id = 0xbbf2dda0;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument bytes
	if (arg_salt){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_BYTES;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_salt, len_arg_salt);
		strcpy(obj->objs[0]->name, "salt");
	}

	return obj;
}

tlo_t * tl_securePasswordKdfAlgoSHA512(unsigned char * arg_salt, int len_arg_salt)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "securePasswordKdfAlgoSHA512");
	int i;
	obj->id = 0x86471d92;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument bytes
	if (arg_salt){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_BYTES;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_salt, len_arg_salt);
		strcpy(obj->objs[0]->name, "salt");
	}

	return obj;
}

tlo_t * tl_secureSecretSettings(SecurePasswordKdfAlgo arg_secure_algo, unsigned char * arg_secure_secret, int len_arg_secure_secret, long arg_secure_secret_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "secureSecretSettings");
	int i;
	obj->id = 0x1527bcac;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument SecurePasswordKdfAlgo
	if (arg_secure_algo){
		obj->objs[0] = arg_secure_algo;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "secure_algo");
	}


	//parse argument bytes
	if (arg_secure_secret){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_secure_secret, len_arg_secure_secret);
		strcpy(obj->objs[1]->name, "secure_secret");
	}


	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_secure_secret_id);
	strcpy(obj->objs[2]->name, "secure_secret_id");
	return obj;
}

tlo_t * tl_inputCheckPasswordEmpty()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputCheckPasswordEmpty");
	int i;
	obj->id = 0x9880f658;
	return obj;
}

tlo_t * tl_inputCheckPasswordSRP(long arg_srp_id, unsigned char * arg_A, int len_arg_A, unsigned char * arg_M1, int len_arg_M1)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputCheckPasswordSRP");
	int i;
	obj->id = 0xd27ff082;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_srp_id);
	strcpy(obj->objs[0]->name, "srp_id");

	//parse argument bytes
	if (arg_A){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_A, len_arg_A);
		strcpy(obj->objs[1]->name, "A");
	}


	//parse argument bytes
	if (arg_M1){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_BYTES;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_M1, len_arg_M1);
		strcpy(obj->objs[2]->name, "M1");
	}

	return obj;
}

tlo_t * tl_secureRequiredType(bool arg_native_names, bool arg_selfie_required, bool arg_translation_required, SecureValueType arg_type)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "secureRequiredType");
	int i;
	obj->id = 0x829d99da;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_native_names);
	strcpy(obj->objs[1]->name, "native_names");
	if (arg_native_names)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_selfie_required);
	strcpy(obj->objs[2]->name, "selfie_required");
	if (arg_selfie_required)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_translation_required);
	strcpy(obj->objs[3]->name, "translation_required");
	if (arg_translation_required)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument SecureValueType
	if (arg_type){
		obj->objs[4] = arg_type;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "type");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_secureRequiredTypeOneOf(SecureRequiredType *arg_types, int len_arg_types)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "secureRequiredTypeOneOf");
	int i;
	obj->id = 0x027477b4;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<SecureRequiredType>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "types");
	if (arg_types){
		for(i=0; i<len_arg_types; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_types[i]->id);
			buf_cat(obj->objs[0]->value, arg_types[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_help_passportConfigNotModified()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_passportConfigNotModified");
	int i;
	obj->id = 0xbfb9f457;
	return obj;
}

tlo_t * tl_help_passportConfig(int arg_hash, DataJSON arg_countries_langs)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_passportConfig");
	int i;
	obj->id = 0xa098d6af;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_hash);
	strcpy(obj->objs[0]->name, "hash");

	//parse argument DataJSON
	if (arg_countries_langs){
		obj->objs[1] = arg_countries_langs;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "countries_langs");
	}

	return obj;
}

tlo_t * tl_inputAppEvent(double arg_time, const char * arg_type, long arg_peer, JSONValue arg_data)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputAppEvent");
	int i;
	obj->id = 0x1d1b1245;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument double
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_time);
	strcpy(obj->objs[0]->name, "time");

	//parse argument string
	if (arg_type){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_type, strlen(arg_type));
		strcpy(obj->objs[1]->name, "type");
	}


	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_peer);
	strcpy(obj->objs[2]->name, "peer");

	//parse argument JSONValue
	if (arg_data){
		obj->objs[3] = arg_data;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "data");
	}

	return obj;
}

tlo_t * tl_jsonObjectValue(const char * arg_key, JSONValue arg_value)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "jsonObjectValue");
	int i;
	obj->id = 0xc0de1bd9;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_key){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_key, strlen(arg_key));
		strcpy(obj->objs[0]->name, "key");
	}


	//parse argument JSONValue
	if (arg_value){
		obj->objs[1] = arg_value;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "value");
	}

	return obj;
}

tlo_t * tl_jsonNull()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "jsonNull");
	int i;
	obj->id = 0x3f6d7b68;
	return obj;
}

tlo_t * tl_jsonBool(Bool arg_value)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "jsonBool");
	int i;
	obj->id = 0xc7345e6a;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Bool
	if (arg_value){
		obj->objs[0] = arg_value;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "value");
	}

	return obj;
}

tlo_t * tl_jsonNumber(double arg_value)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "jsonNumber");
	int i;
	obj->id = 0x2be0dfa4;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument double
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_value);
	strcpy(obj->objs[0]->name, "value");
	return obj;
}

tlo_t * tl_jsonString(const char * arg_value)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "jsonString");
	int i;
	obj->id = 0xb71e767a;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_value){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_value, strlen(arg_value));
		strcpy(obj->objs[0]->name, "value");
	}

	return obj;
}

tlo_t * tl_jsonArray(JSONValue *arg_value, int len_arg_value)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "jsonArray");
	int i;
	obj->id = 0xf7444763;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<JSONValue>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "value");
	if (arg_value){
		for(i=0; i<len_arg_value; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_value[i]->id);
			buf_cat(obj->objs[0]->value, arg_value[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_jsonObject(JSONObjectValue *arg_value, int len_arg_value)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "jsonObject");
	int i;
	obj->id = 0x99c1d49d;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<JSONObjectValue>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "value");
	if (arg_value){
		for(i=0; i<len_arg_value; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_value[i]->id);
			buf_cat(obj->objs[0]->value, arg_value[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_pageTableCell(bool arg_header, bool arg_align_center, bool arg_align_right, bool arg_valign_middle, bool arg_valign_bottom, RichText arg_text, int arg_colspan, int arg_rowspan)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageTableCell");
	int i;
	obj->id = 0x34566b6a;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_header);
	strcpy(obj->objs[1]->name, "header");
	if (arg_header)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 3;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_align_center);
	strcpy(obj->objs[2]->name, "align_center");
	if (arg_align_center)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 4;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_align_right);
	strcpy(obj->objs[3]->name, "align_right");
	if (arg_align_right)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 5;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_valign_middle);
	strcpy(obj->objs[4]->name, "valign_middle");
	if (arg_valign_middle)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 6;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_valign_bottom);
	strcpy(obj->objs[5]->name, "valign_bottom");
	if (arg_valign_bottom)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument RichText
	if (arg_text){
		obj->objs[6] = arg_text;
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 7;
	strcpy(obj->objs[6]->name, "text");
		flagsv[nflags-1] |= (1 << 7);
	}


	//parse argument int
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 1;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_colspan);
	strcpy(obj->objs[7]->name, "colspan");
	if (arg_colspan)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument int
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 2;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_rowspan);
	strcpy(obj->objs[8]->name, "rowspan");
	if (arg_rowspan)
		flagsv[nflags-1] |= (1 << 2);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_pageTableRow(PageTableCell *arg_cells, int len_arg_cells)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageTableRow");
	int i;
	obj->id = 0xe0c0c5e5;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<PageTableCell>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "cells");
	if (arg_cells){
		for(i=0; i<len_arg_cells; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_cells[i]->id);
			buf_cat(obj->objs[0]->value, arg_cells[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_pageCaption(RichText arg_text, RichText arg_credit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageCaption");
	int i;
	obj->id = 0x6f747657;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument RichText
	if (arg_text){
		obj->objs[0] = arg_text;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "text");
	}


	//parse argument RichText
	if (arg_credit){
		obj->objs[1] = arg_credit;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "credit");
	}

	return obj;
}

tlo_t * tl_pageListItemText(RichText arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageListItemText");
	int i;
	obj->id = 0xb92fb6cd;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument RichText
	if (arg_text){
		obj->objs[0] = arg_text;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "text");
	}

	return obj;
}

tlo_t * tl_pageListItemBlocks(PageBlock *arg_blocks, int len_arg_blocks)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageListItemBlocks");
	int i;
	obj->id = 0x25e073fc;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<PageBlock>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "blocks");
	if (arg_blocks){
		for(i=0; i<len_arg_blocks; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_blocks[i]->id);
			buf_cat(obj->objs[0]->value, arg_blocks[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_pageListOrderedItemText(const char * arg_num, RichText arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageListOrderedItemText");
	int i;
	obj->id = 0x5e068047;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_num){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_num, strlen(arg_num));
		strcpy(obj->objs[0]->name, "num");
	}


	//parse argument RichText
	if (arg_text){
		obj->objs[1] = arg_text;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "text");
	}

	return obj;
}

tlo_t * tl_pageListOrderedItemBlocks(const char * arg_num, PageBlock *arg_blocks, int len_arg_blocks)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageListOrderedItemBlocks");
	int i;
	obj->id = 0x98dd8936;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_num){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_num, strlen(arg_num));
		strcpy(obj->objs[0]->name, "num");
	}


	//parse argument Vector<PageBlock>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "blocks");
	if (arg_blocks){
		for(i=0; i<len_arg_blocks; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_blocks[i]->id);
			buf_cat(obj->objs[1]->value, arg_blocks[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_pageRelatedArticle(const char * arg_url, long arg_webpage_id, const char * arg_title, const char * arg_description, long arg_photo_id, const char * arg_author, int arg_published_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pageRelatedArticle");
	int i;
	obj->id = 0xb390dc08;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_url){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[1]->name, "url");
	}


	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_webpage_id);
	strcpy(obj->objs[2]->name, "webpage_id");

	//parse argument string
	if (arg_title){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[3]->name, "title");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_description){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 1;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_description, strlen(arg_description));
		strcpy(obj->objs[4]->name, "description");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument long
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 2;
	obj->objs[5]->type = TYPE_LONG;
	obj->objs[5]->value = 
		buf_add_ui64(arg_photo_id);
	strcpy(obj->objs[5]->name, "photo_id");
	if (arg_photo_id)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument string
	if (arg_author){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 3;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_author, strlen(arg_author));
		strcpy(obj->objs[6]->name, "author");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument int
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 4;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_published_date);
	strcpy(obj->objs[7]->name, "published_date");
	if (arg_published_date)
		flagsv[nflags-1] |= (1 << 4);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_page(bool arg_part, bool arg_rtl, bool arg_v2, const char * arg_url, PageBlock *arg_blocks, int len_arg_blocks, Photo *arg_photos, int len_arg_photos, Document *arg_documents, int len_arg_documents, int arg_views)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "page");
	int i;
	obj->id = 0x98657f0d;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_part);
	strcpy(obj->objs[1]->name, "part");
	if (arg_part)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_rtl);
	strcpy(obj->objs[2]->name, "rtl");
	if (arg_rtl)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_v2);
	strcpy(obj->objs[3]->name, "v2");
	if (arg_v2)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument string
	if (arg_url){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[4]->name, "url");
	}


	//parse argument Vector<PageBlock>
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_VECTOR;
	strcpy(obj->objs[5]->name, "blocks");
	if (arg_blocks){
		for(i=0; i<len_arg_blocks; ++i){
			obj->objs[5]->value = buf_add_ui32(arg_blocks[i]->id);
			buf_cat(obj->objs[5]->value, arg_blocks[i]->value);
		}
	}


	//parse argument Vector<Photo>
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_VECTOR;
	strcpy(obj->objs[6]->name, "photos");
	if (arg_photos){
		for(i=0; i<len_arg_photos; ++i){
			obj->objs[6]->value = buf_add_ui32(arg_photos[i]->id);
			buf_cat(obj->objs[6]->value, arg_photos[i]->value);
		}
	}


	//parse argument Vector<Document>
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_VECTOR;
	strcpy(obj->objs[7]->name, "documents");
	if (arg_documents){
		for(i=0; i<len_arg_documents; ++i){
			obj->objs[7]->value = buf_add_ui32(arg_documents[i]->id);
			buf_cat(obj->objs[7]->value, arg_documents[i]->value);
		}
	}


	//parse argument int
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 3;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_views);
	strcpy(obj->objs[8]->name, "views");
	if (arg_views)
		flagsv[nflags-1] |= (1 << 3);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_help_supportName(const char * arg_name)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_supportName");
	int i;
	obj->id = 0x8c05f1c9;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_name){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_name, strlen(arg_name));
		strcpy(obj->objs[0]->name, "name");
	}

	return obj;
}

tlo_t * tl_help_userInfoEmpty()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_userInfoEmpty");
	int i;
	obj->id = 0xf3ae2eed;
	return obj;
}

tlo_t * tl_help_userInfo(const char * arg_message, MessageEntity *arg_entities, int len_arg_entities, const char * arg_author, int arg_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_userInfo");
	int i;
	obj->id = 0x01eb3758;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_message){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_message, strlen(arg_message));
		strcpy(obj->objs[0]->name, "message");
	}


	//parse argument Vector<MessageEntity>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "entities");
	if (arg_entities){
		for(i=0; i<len_arg_entities; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_entities[i]->id);
			buf_cat(obj->objs[1]->value, arg_entities[i]->value);
		}
	}


	//parse argument string
	if (arg_author){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_author, strlen(arg_author));
		strcpy(obj->objs[2]->name, "author");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[3]->name, "date");
	return obj;
}

tlo_t * tl_pollAnswer(TextWithEntities arg_text, unsigned char * arg_option, int len_arg_option)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pollAnswer");
	int i;
	obj->id = 0xff16e2ca;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument TextWithEntities
	if (arg_text){
		obj->objs[0] = arg_text;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "text");
	}


	//parse argument bytes
	if (arg_option){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_option, len_arg_option);
		strcpy(obj->objs[1]->name, "option");
	}

	return obj;
}

tlo_t * tl_poll(long arg_id, bool arg_closed, bool arg_public_voters, bool arg_multiple_choice, bool arg_quiz, TextWithEntities arg_question, PollAnswer *arg_answers, int len_arg_answers, int arg_close_period, int arg_close_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "poll");
	int i;
	obj->id = 0x58747131;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 10;
	obj->objs = 
		(tlo_t **)MALLOC(10 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument (null)
	obj->objs[1] = NEW(tlo_t, return NULL);
	flags[nflags++] = 1;
	obj->objs[1]->type = TYPE_FLAG;
	strcpy(obj->objs[1]->name, "flags");

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_closed);
	strcpy(obj->objs[2]->name, "closed");
	if (arg_closed)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 1;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_public_voters);
	strcpy(obj->objs[3]->name, "public_voters");
	if (arg_public_voters)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 2;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_multiple_choice);
	strcpy(obj->objs[4]->name, "multiple_choice");
	if (arg_multiple_choice)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 3;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_quiz);
	strcpy(obj->objs[5]->name, "quiz");
	if (arg_quiz)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument TextWithEntities
	if (arg_question){
		obj->objs[6] = arg_question;
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
	strcpy(obj->objs[6]->name, "question");
	}


	//parse argument Vector<PollAnswer>
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_VECTOR;
	strcpy(obj->objs[7]->name, "answers");
	if (arg_answers){
		for(i=0; i<len_arg_answers; ++i){
			obj->objs[7]->value = buf_add_ui32(arg_answers[i]->id);
			buf_cat(obj->objs[7]->value, arg_answers[i]->value);
		}
	}


	//parse argument int
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 4;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_close_period);
	strcpy(obj->objs[8]->name, "close_period");
	if (arg_close_period)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument int
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 1;
	obj->objs[9]->flag_bit = 5;
	obj->objs[9]->type = TYPE_INT;
	obj->objs[9]->value = 
		buf_add_ui32(arg_close_date);
	strcpy(obj->objs[9]->name, "close_date");
	if (arg_close_date)
		flagsv[nflags-1] |= (1 << 5);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_pollAnswerVoters(bool arg_chosen, bool arg_correct, unsigned char * arg_option, int len_arg_option, int arg_voters)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pollAnswerVoters");
	int i;
	obj->id = 0x3b6ddad2;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_chosen);
	strcpy(obj->objs[1]->name, "chosen");
	if (arg_chosen)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_correct);
	strcpy(obj->objs[2]->name, "correct");
	if (arg_correct)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument bytes
	if (arg_option){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_BYTES;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_option, len_arg_option);
		strcpy(obj->objs[3]->name, "option");
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_voters);
	strcpy(obj->objs[4]->name, "voters");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_pollResults(bool arg_min, PollAnswerVoters *arg_results, int len_arg_results, int arg_total_voters, Peer *arg_recent_voters, int len_arg_recent_voters, const char * arg_solution, MessageEntity *arg_solution_entities, int len_arg_solution_entities)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "pollResults");
	int i;
	obj->id = 0x7adf2420;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_min);
	strcpy(obj->objs[1]->name, "min");
	if (arg_min)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument Vector<PollAnswerVoters>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "results");
	if (arg_results){
		for(i=0; i<len_arg_results; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_results[i]->id);
			buf_cat(obj->objs[2]->value, arg_results[i]->value);
		}
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_total_voters);
	strcpy(obj->objs[3]->name, "total_voters");
	if (arg_total_voters)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument Vector<Peer>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 3;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "recent_voters");
	if (arg_recent_voters){
		for(i=0; i<len_arg_recent_voters; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_recent_voters[i]->id);
			buf_cat(obj->objs[4]->value, arg_recent_voters[i]->value);
		}
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument string
	if (arg_solution){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 4;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_solution, strlen(arg_solution));
		strcpy(obj->objs[5]->name, "solution");
		flagsv[nflags-1] |= (1 << 4);
	}


	//parse argument Vector<MessageEntity>
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 4;
	obj->objs[6]->type = TYPE_VECTOR;
	strcpy(obj->objs[6]->name, "solution_entities");
	if (arg_solution_entities){
		for(i=0; i<len_arg_solution_entities; ++i){
			obj->objs[6]->value = buf_add_ui32(arg_solution_entities[i]->id);
			buf_cat(obj->objs[6]->value, arg_solution_entities[i]->value);
		}
		flagsv[nflags-1] |= (1 << 4);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_chatOnlines(int arg_onlines)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatOnlines");
	int i;
	obj->id = 0xf041e250;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_onlines);
	strcpy(obj->objs[0]->name, "onlines");
	return obj;
}

tlo_t * tl_statsURL(const char * arg_url)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "statsURL");
	int i;
	obj->id = 0x47a971e0;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_url){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[0]->name, "url");
	}

	return obj;
}

tlo_t * tl_chatAdminRights(bool arg_change_info, bool arg_post_messages, bool arg_edit_messages, bool arg_delete_messages, bool arg_ban_users, bool arg_invite_users, bool arg_pin_messages, bool arg_add_admins, bool arg_anonymous, bool arg_manage_call, bool arg_other, bool arg_manage_topics, bool arg_post_stories, bool arg_edit_stories, bool arg_delete_stories)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatAdminRights");
	int i;
	obj->id = 0x5fb224d5;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 16;
	obj->objs = 
		(tlo_t **)MALLOC(16 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_change_info);
	strcpy(obj->objs[1]->name, "change_info");
	if (arg_change_info)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_post_messages);
	strcpy(obj->objs[2]->name, "post_messages");
	if (arg_post_messages)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_edit_messages);
	strcpy(obj->objs[3]->name, "edit_messages");
	if (arg_edit_messages)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 3;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_delete_messages);
	strcpy(obj->objs[4]->name, "delete_messages");
	if (arg_delete_messages)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 4;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_ban_users);
	strcpy(obj->objs[5]->name, "ban_users");
	if (arg_ban_users)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument true
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 5;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_invite_users);
	strcpy(obj->objs[6]->name, "invite_users");
	if (arg_invite_users)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument true
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 7;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_pin_messages);
	strcpy(obj->objs[7]->name, "pin_messages");
	if (arg_pin_messages)
		flagsv[nflags-1] |= (1 << 7);

	//parse argument true
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 9;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_add_admins);
	strcpy(obj->objs[8]->name, "add_admins");
	if (arg_add_admins)
		flagsv[nflags-1] |= (1 << 9);

	//parse argument true
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 1;
	obj->objs[9]->flag_bit = 10;
	obj->objs[9]->type = TYPE_INT;
	obj->objs[9]->value = 
		buf_add_ui32(arg_anonymous);
	strcpy(obj->objs[9]->name, "anonymous");
	if (arg_anonymous)
		flagsv[nflags-1] |= (1 << 10);

	//parse argument true
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 1;
	obj->objs[10]->flag_bit = 11;
	obj->objs[10]->type = TYPE_INT;
	obj->objs[10]->value = 
		buf_add_ui32(arg_manage_call);
	strcpy(obj->objs[10]->name, "manage_call");
	if (arg_manage_call)
		flagsv[nflags-1] |= (1 << 11);

	//parse argument true
	obj->objs[11] = NEW(tlo_t, return NULL);
	obj->objs[11]->flag_num = 1;
	obj->objs[11]->flag_bit = 12;
	obj->objs[11]->type = TYPE_INT;
	obj->objs[11]->value = 
		buf_add_ui32(arg_other);
	strcpy(obj->objs[11]->name, "other");
	if (arg_other)
		flagsv[nflags-1] |= (1 << 12);

	//parse argument true
	obj->objs[12] = NEW(tlo_t, return NULL);
	obj->objs[12]->flag_num = 1;
	obj->objs[12]->flag_bit = 13;
	obj->objs[12]->type = TYPE_INT;
	obj->objs[12]->value = 
		buf_add_ui32(arg_manage_topics);
	strcpy(obj->objs[12]->name, "manage_topics");
	if (arg_manage_topics)
		flagsv[nflags-1] |= (1 << 13);

	//parse argument true
	obj->objs[13] = NEW(tlo_t, return NULL);
	obj->objs[13]->flag_num = 1;
	obj->objs[13]->flag_bit = 14;
	obj->objs[13]->type = TYPE_INT;
	obj->objs[13]->value = 
		buf_add_ui32(arg_post_stories);
	strcpy(obj->objs[13]->name, "post_stories");
	if (arg_post_stories)
		flagsv[nflags-1] |= (1 << 14);

	//parse argument true
	obj->objs[14] = NEW(tlo_t, return NULL);
	obj->objs[14]->flag_num = 1;
	obj->objs[14]->flag_bit = 15;
	obj->objs[14]->type = TYPE_INT;
	obj->objs[14]->value = 
		buf_add_ui32(arg_edit_stories);
	strcpy(obj->objs[14]->name, "edit_stories");
	if (arg_edit_stories)
		flagsv[nflags-1] |= (1 << 15);

	//parse argument true
	obj->objs[15] = NEW(tlo_t, return NULL);
	obj->objs[15]->flag_num = 1;
	obj->objs[15]->flag_bit = 16;
	obj->objs[15]->type = TYPE_INT;
	obj->objs[15]->value = 
		buf_add_ui32(arg_delete_stories);
	strcpy(obj->objs[15]->name, "delete_stories");
	if (arg_delete_stories)
		flagsv[nflags-1] |= (1 << 16);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_chatBannedRights(bool arg_view_messages, bool arg_send_messages, bool arg_send_media, bool arg_send_stickers, bool arg_send_gifs, bool arg_send_games, bool arg_send_inline, bool arg_embed_links, bool arg_send_polls, bool arg_change_info, bool arg_invite_users, bool arg_pin_messages, bool arg_manage_topics, bool arg_send_photos, bool arg_send_videos, bool arg_send_roundvideos, bool arg_send_audios, bool arg_send_voices, bool arg_send_docs, bool arg_send_plain, int arg_until_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatBannedRights");
	int i;
	obj->id = 0x9f120418;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 22;
	obj->objs = 
		(tlo_t **)MALLOC(22 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_view_messages);
	strcpy(obj->objs[1]->name, "view_messages");
	if (arg_view_messages)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_send_messages);
	strcpy(obj->objs[2]->name, "send_messages");
	if (arg_send_messages)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_send_media);
	strcpy(obj->objs[3]->name, "send_media");
	if (arg_send_media)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 3;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_send_stickers);
	strcpy(obj->objs[4]->name, "send_stickers");
	if (arg_send_stickers)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 4;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_send_gifs);
	strcpy(obj->objs[5]->name, "send_gifs");
	if (arg_send_gifs)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument true
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 5;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_send_games);
	strcpy(obj->objs[6]->name, "send_games");
	if (arg_send_games)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument true
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 6;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_send_inline);
	strcpy(obj->objs[7]->name, "send_inline");
	if (arg_send_inline)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument true
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 7;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_embed_links);
	strcpy(obj->objs[8]->name, "embed_links");
	if (arg_embed_links)
		flagsv[nflags-1] |= (1 << 7);

	//parse argument true
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 1;
	obj->objs[9]->flag_bit = 8;
	obj->objs[9]->type = TYPE_INT;
	obj->objs[9]->value = 
		buf_add_ui32(arg_send_polls);
	strcpy(obj->objs[9]->name, "send_polls");
	if (arg_send_polls)
		flagsv[nflags-1] |= (1 << 8);

	//parse argument true
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 1;
	obj->objs[10]->flag_bit = 10;
	obj->objs[10]->type = TYPE_INT;
	obj->objs[10]->value = 
		buf_add_ui32(arg_change_info);
	strcpy(obj->objs[10]->name, "change_info");
	if (arg_change_info)
		flagsv[nflags-1] |= (1 << 10);

	//parse argument true
	obj->objs[11] = NEW(tlo_t, return NULL);
	obj->objs[11]->flag_num = 1;
	obj->objs[11]->flag_bit = 15;
	obj->objs[11]->type = TYPE_INT;
	obj->objs[11]->value = 
		buf_add_ui32(arg_invite_users);
	strcpy(obj->objs[11]->name, "invite_users");
	if (arg_invite_users)
		flagsv[nflags-1] |= (1 << 15);

	//parse argument true
	obj->objs[12] = NEW(tlo_t, return NULL);
	obj->objs[12]->flag_num = 1;
	obj->objs[12]->flag_bit = 17;
	obj->objs[12]->type = TYPE_INT;
	obj->objs[12]->value = 
		buf_add_ui32(arg_pin_messages);
	strcpy(obj->objs[12]->name, "pin_messages");
	if (arg_pin_messages)
		flagsv[nflags-1] |= (1 << 17);

	//parse argument true
	obj->objs[13] = NEW(tlo_t, return NULL);
	obj->objs[13]->flag_num = 1;
	obj->objs[13]->flag_bit = 18;
	obj->objs[13]->type = TYPE_INT;
	obj->objs[13]->value = 
		buf_add_ui32(arg_manage_topics);
	strcpy(obj->objs[13]->name, "manage_topics");
	if (arg_manage_topics)
		flagsv[nflags-1] |= (1 << 18);

	//parse argument true
	obj->objs[14] = NEW(tlo_t, return NULL);
	obj->objs[14]->flag_num = 1;
	obj->objs[14]->flag_bit = 19;
	obj->objs[14]->type = TYPE_INT;
	obj->objs[14]->value = 
		buf_add_ui32(arg_send_photos);
	strcpy(obj->objs[14]->name, "send_photos");
	if (arg_send_photos)
		flagsv[nflags-1] |= (1 << 19);

	//parse argument true
	obj->objs[15] = NEW(tlo_t, return NULL);
	obj->objs[15]->flag_num = 1;
	obj->objs[15]->flag_bit = 20;
	obj->objs[15]->type = TYPE_INT;
	obj->objs[15]->value = 
		buf_add_ui32(arg_send_videos);
	strcpy(obj->objs[15]->name, "send_videos");
	if (arg_send_videos)
		flagsv[nflags-1] |= (1 << 20);

	//parse argument true
	obj->objs[16] = NEW(tlo_t, return NULL);
	obj->objs[16]->flag_num = 1;
	obj->objs[16]->flag_bit = 21;
	obj->objs[16]->type = TYPE_INT;
	obj->objs[16]->value = 
		buf_add_ui32(arg_send_roundvideos);
	strcpy(obj->objs[16]->name, "send_roundvideos");
	if (arg_send_roundvideos)
		flagsv[nflags-1] |= (1 << 21);

	//parse argument true
	obj->objs[17] = NEW(tlo_t, return NULL);
	obj->objs[17]->flag_num = 1;
	obj->objs[17]->flag_bit = 22;
	obj->objs[17]->type = TYPE_INT;
	obj->objs[17]->value = 
		buf_add_ui32(arg_send_audios);
	strcpy(obj->objs[17]->name, "send_audios");
	if (arg_send_audios)
		flagsv[nflags-1] |= (1 << 22);

	//parse argument true
	obj->objs[18] = NEW(tlo_t, return NULL);
	obj->objs[18]->flag_num = 1;
	obj->objs[18]->flag_bit = 23;
	obj->objs[18]->type = TYPE_INT;
	obj->objs[18]->value = 
		buf_add_ui32(arg_send_voices);
	strcpy(obj->objs[18]->name, "send_voices");
	if (arg_send_voices)
		flagsv[nflags-1] |= (1 << 23);

	//parse argument true
	obj->objs[19] = NEW(tlo_t, return NULL);
	obj->objs[19]->flag_num = 1;
	obj->objs[19]->flag_bit = 24;
	obj->objs[19]->type = TYPE_INT;
	obj->objs[19]->value = 
		buf_add_ui32(arg_send_docs);
	strcpy(obj->objs[19]->name, "send_docs");
	if (arg_send_docs)
		flagsv[nflags-1] |= (1 << 24);

	//parse argument true
	obj->objs[20] = NEW(tlo_t, return NULL);
	obj->objs[20]->flag_num = 1;
	obj->objs[20]->flag_bit = 25;
	obj->objs[20]->type = TYPE_INT;
	obj->objs[20]->value = 
		buf_add_ui32(arg_send_plain);
	strcpy(obj->objs[20]->name, "send_plain");
	if (arg_send_plain)
		flagsv[nflags-1] |= (1 << 25);

	//parse argument int
	obj->objs[21] = NEW(tlo_t, return NULL);
	obj->objs[21]->flag_num = 0;
	obj->objs[21]->flag_bit = 0;
	obj->objs[21]->type = TYPE_INT;
	obj->objs[21]->value = 
		buf_add_ui32(arg_until_date);
	strcpy(obj->objs[21]->name, "until_date");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputWallPaper(long arg_id, long arg_access_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputWallPaper");
	int i;
	obj->id = 0xe630b979;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[1]->name, "access_hash");
	return obj;
}

tlo_t * tl_inputWallPaperSlug(const char * arg_slug)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputWallPaperSlug");
	int i;
	obj->id = 0x72091c80;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_slug){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_slug, strlen(arg_slug));
		strcpy(obj->objs[0]->name, "slug");
	}

	return obj;
}

tlo_t * tl_inputWallPaperNoFile(long arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputWallPaperNoFile");
	int i;
	obj->id = 0x967a462e;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");
	return obj;
}

tlo_t * tl_account_wallPapersNotModified()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_wallPapersNotModified");
	int i;
	obj->id = 0x1c199183;
	return obj;
}

tlo_t * tl_account_wallPapers(long arg_hash, WallPaper *arg_wallpapers, int len_arg_wallpapers)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_wallPapers");
	int i;
	obj->id = 0xcdc3858c;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");

	//parse argument Vector<WallPaper>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "wallpapers");
	if (arg_wallpapers){
		for(i=0; i<len_arg_wallpapers; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_wallpapers[i]->id);
			buf_cat(obj->objs[1]->value, arg_wallpapers[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_codeSettings(bool arg_allow_flashcall, bool arg_current_number, bool arg_allow_app_hash, bool arg_allow_missed_call, bool arg_allow_firebase, bool arg_unknown_number, unsigned char * *arg_logout_tokens, int len_arg_logout_tokens, const char * arg_token, Bool arg_app_sandbox)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "codeSettings");
	int i;
	obj->id = 0xad253d78;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 10;
	obj->objs = 
		(tlo_t **)MALLOC(10 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_allow_flashcall);
	strcpy(obj->objs[1]->name, "allow_flashcall");
	if (arg_allow_flashcall)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_current_number);
	strcpy(obj->objs[2]->name, "current_number");
	if (arg_current_number)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 4;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_allow_app_hash);
	strcpy(obj->objs[3]->name, "allow_app_hash");
	if (arg_allow_app_hash)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 5;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_allow_missed_call);
	strcpy(obj->objs[4]->name, "allow_missed_call");
	if (arg_allow_missed_call)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 7;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_allow_firebase);
	strcpy(obj->objs[5]->name, "allow_firebase");
	if (arg_allow_firebase)
		flagsv[nflags-1] |= (1 << 7);

	//parse argument true
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 9;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_unknown_number);
	strcpy(obj->objs[6]->name, "unknown_number");
	if (arg_unknown_number)
		flagsv[nflags-1] |= (1 << 9);

	//parse argument Vector<bytes>
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 6;
	obj->objs[7]->type = TYPE_VECTOR;
	strcpy(obj->objs[7]->name, "logout_tokens");
	if (arg_logout_tokens){
		for(i=0; i<len_arg_logout_tokens; ++i){
			int len = *(int *)(arg_logout_tokens[i]);
			ui8_t *p = &(arg_logout_tokens[i][4]);
			buf_t b = buf_add(p, len);
			buf_cat(obj->objs[7]->value, b);
		}
		flagsv[nflags-1] |= (1 << 6);
	}


	//parse argument string
	if (arg_token){
		obj->objs[8] = NEW(tlo_t, return NULL);
		obj->objs[8]->flag_num = 1;
		obj->objs[8]->flag_bit = 8;
		obj->objs[8]->type = TYPE_STRING;
		obj->objs[8]->value = 
			buf_add((ui8_t *)arg_token, strlen(arg_token));
		strcpy(obj->objs[8]->name, "token");
		flagsv[nflags-1] |= (1 << 8);
	}


	//parse argument Bool
	if (arg_app_sandbox){
		obj->objs[9] = arg_app_sandbox;
		obj->objs[9]->flag_num = 1;
		obj->objs[9]->flag_bit = 8;
	strcpy(obj->objs[9]->name, "app_sandbox");
		flagsv[nflags-1] |= (1 << 8);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_wallPaperSettings(bool arg_blur, bool arg_motion, int arg_background_color, int arg_second_background_color, int arg_third_background_color, int arg_fourth_background_color, int arg_intensity, int arg_rotation, const char * arg_emoticon)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "wallPaperSettings");
	int i;
	obj->id = 0x372efcd0;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 10;
	obj->objs = 
		(tlo_t **)MALLOC(10 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_blur);
	strcpy(obj->objs[1]->name, "blur");
	if (arg_blur)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 2;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_motion);
	strcpy(obj->objs[2]->name, "motion");
	if (arg_motion)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_background_color);
	strcpy(obj->objs[3]->name, "background_color");
	if (arg_background_color)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 4;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_second_background_color);
	strcpy(obj->objs[4]->name, "second_background_color");
	if (arg_second_background_color)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 5;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_third_background_color);
	strcpy(obj->objs[5]->name, "third_background_color");
	if (arg_third_background_color)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 6;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_fourth_background_color);
	strcpy(obj->objs[6]->name, "fourth_background_color");
	if (arg_fourth_background_color)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument int
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 3;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_intensity);
	strcpy(obj->objs[7]->name, "intensity");
	if (arg_intensity)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument int
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 4;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_rotation);
	strcpy(obj->objs[8]->name, "rotation");
	if (arg_rotation)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument string
	if (arg_emoticon){
		obj->objs[9] = NEW(tlo_t, return NULL);
		obj->objs[9]->flag_num = 1;
		obj->objs[9]->flag_bit = 7;
		obj->objs[9]->type = TYPE_STRING;
		obj->objs[9]->value = 
			buf_add((ui8_t *)arg_emoticon, strlen(arg_emoticon));
		strcpy(obj->objs[9]->name, "emoticon");
		flagsv[nflags-1] |= (1 << 7);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_autoDownloadSettings(bool arg_disabled, bool arg_video_preload_large, bool arg_audio_preload_next, bool arg_phonecalls_less_data, bool arg_stories_preload, int arg_photo_size_max, long arg_video_size_max, long arg_file_size_max, int arg_video_upload_maxbitrate, int arg_small_queue_active_operations_max, int arg_large_queue_active_operations_max)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "autoDownloadSettings");
	int i;
	obj->id = 0xbaa57628;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 12;
	obj->objs = 
		(tlo_t **)MALLOC(12 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_disabled);
	strcpy(obj->objs[1]->name, "disabled");
	if (arg_disabled)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_video_preload_large);
	strcpy(obj->objs[2]->name, "video_preload_large");
	if (arg_video_preload_large)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_audio_preload_next);
	strcpy(obj->objs[3]->name, "audio_preload_next");
	if (arg_audio_preload_next)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 3;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_phonecalls_less_data);
	strcpy(obj->objs[4]->name, "phonecalls_less_data");
	if (arg_phonecalls_less_data)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 4;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_stories_preload);
	strcpy(obj->objs[5]->name, "stories_preload");
	if (arg_stories_preload)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_photo_size_max);
	strcpy(obj->objs[6]->name, "photo_size_max");

	//parse argument long
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_LONG;
	obj->objs[7]->value = 
		buf_add_ui64(arg_video_size_max);
	strcpy(obj->objs[7]->name, "video_size_max");

	//parse argument long
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 0;
	obj->objs[8]->flag_bit = 0;
	obj->objs[8]->type = TYPE_LONG;
	obj->objs[8]->value = 
		buf_add_ui64(arg_file_size_max);
	strcpy(obj->objs[8]->name, "file_size_max");

	//parse argument int
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 0;
	obj->objs[9]->flag_bit = 0;
	obj->objs[9]->type = TYPE_INT;
	obj->objs[9]->value = 
		buf_add_ui32(arg_video_upload_maxbitrate);
	strcpy(obj->objs[9]->name, "video_upload_maxbitrate");

	//parse argument int
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 0;
	obj->objs[10]->flag_bit = 0;
	obj->objs[10]->type = TYPE_INT;
	obj->objs[10]->value = 
		buf_add_ui32(arg_small_queue_active_operations_max);
	strcpy(obj->objs[10]->name, "small_queue_active_operations_max");

	//parse argument int
	obj->objs[11] = NEW(tlo_t, return NULL);
	obj->objs[11]->flag_num = 0;
	obj->objs[11]->flag_bit = 0;
	obj->objs[11]->type = TYPE_INT;
	obj->objs[11]->value = 
		buf_add_ui32(arg_large_queue_active_operations_max);
	strcpy(obj->objs[11]->name, "large_queue_active_operations_max");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_account_autoDownloadSettings(AutoDownloadSettings arg_low, AutoDownloadSettings arg_medium, AutoDownloadSettings arg_high)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_autoDownloadSettings");
	int i;
	obj->id = 0x63cacf26;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument AutoDownloadSettings
	if (arg_low){
		obj->objs[0] = arg_low;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "low");
	}


	//parse argument AutoDownloadSettings
	if (arg_medium){
		obj->objs[1] = arg_medium;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "medium");
	}


	//parse argument AutoDownloadSettings
	if (arg_high){
		obj->objs[2] = arg_high;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "high");
	}

	return obj;
}

tlo_t * tl_emojiKeyword(const char * arg_keyword, const char * *arg_emoticons, int len_arg_emoticons)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "emojiKeyword");
	int i;
	obj->id = 0xd5b3b9f9;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_keyword){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_keyword, strlen(arg_keyword));
		strcpy(obj->objs[0]->name, "keyword");
	}


	//parse argument Vector<string>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "emoticons");
	if (arg_emoticons){
		for(i=0; i<len_arg_emoticons; ++i){
			int len = strlen(arg_emoticons[i]);
			buf_t b = buf_add((ui8_t *)arg_emoticons[i], len);
			buf_cat(obj->objs[1]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_emojiKeywordDeleted(const char * arg_keyword, const char * *arg_emoticons, int len_arg_emoticons)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "emojiKeywordDeleted");
	int i;
	obj->id = 0x236df622;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_keyword){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_keyword, strlen(arg_keyword));
		strcpy(obj->objs[0]->name, "keyword");
	}


	//parse argument Vector<string>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "emoticons");
	if (arg_emoticons){
		for(i=0; i<len_arg_emoticons; ++i){
			int len = strlen(arg_emoticons[i]);
			buf_t b = buf_add((ui8_t *)arg_emoticons[i], len);
			buf_cat(obj->objs[1]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_emojiKeywordsDifference(const char * arg_lang_code, int arg_from_version, int arg_version, EmojiKeyword *arg_keywords, int len_arg_keywords)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "emojiKeywordsDifference");
	int i;
	obj->id = 0x5cc761bd;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_lang_code){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_lang_code, strlen(arg_lang_code));
		strcpy(obj->objs[0]->name, "lang_code");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_from_version);
	strcpy(obj->objs[1]->name, "from_version");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_version);
	strcpy(obj->objs[2]->name, "version");

	//parse argument Vector<EmojiKeyword>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "keywords");
	if (arg_keywords){
		for(i=0; i<len_arg_keywords; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_keywords[i]->id);
			buf_cat(obj->objs[3]->value, arg_keywords[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_emojiURL(const char * arg_url)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "emojiURL");
	int i;
	obj->id = 0xa575739d;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_url){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[0]->name, "url");
	}

	return obj;
}

tlo_t * tl_emojiLanguage(const char * arg_lang_code)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "emojiLanguage");
	int i;
	obj->id = 0xb3fb5361;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_lang_code){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_lang_code, strlen(arg_lang_code));
		strcpy(obj->objs[0]->name, "lang_code");
	}

	return obj;
}

tlo_t * tl_folder(bool arg_autofill_new_broadcasts, bool arg_autofill_public_groups, bool arg_autofill_new_correspondents, int arg_id, const char * arg_title, ChatPhoto arg_photo)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "folder");
	int i;
	obj->id = 0xff544e65;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_autofill_new_broadcasts);
	strcpy(obj->objs[1]->name, "autofill_new_broadcasts");
	if (arg_autofill_new_broadcasts)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_autofill_public_groups);
	strcpy(obj->objs[2]->name, "autofill_public_groups");
	if (arg_autofill_public_groups)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_autofill_new_correspondents);
	strcpy(obj->objs[3]->name, "autofill_new_correspondents");
	if (arg_autofill_new_correspondents)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[4]->name, "id");

	//parse argument string
	if (arg_title){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[5]->name, "title");
	}


	//parse argument ChatPhoto
	if (arg_photo){
		obj->objs[6] = arg_photo;
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 3;
	strcpy(obj->objs[6]->name, "photo");
		flagsv[nflags-1] |= (1 << 3);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputFolderPeer(InputPeer arg_peer, int arg_folder_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputFolderPeer");
	int i;
	obj->id = 0xfbd2c296;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_folder_id);
	strcpy(obj->objs[1]->name, "folder_id");
	return obj;
}

tlo_t * tl_folderPeer(Peer arg_peer, int arg_folder_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "folderPeer");
	int i;
	obj->id = 0xe9baa668;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_folder_id);
	strcpy(obj->objs[1]->name, "folder_id");
	return obj;
}

tlo_t * tl_messages_searchCounter(bool arg_inexact, MessagesFilter arg_filter, int arg_count)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_searchCounter");
	int i;
	obj->id = 0xe844ebff;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_inexact);
	strcpy(obj->objs[1]->name, "inexact");
	if (arg_inexact)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument MessagesFilter
	if (arg_filter){
		obj->objs[2] = arg_filter;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "filter");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[3]->name, "count");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_urlAuthResultRequest(bool arg_request_write_access, User arg_bot, const char * arg_domain)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "urlAuthResultRequest");
	int i;
	obj->id = 0x92d33a0e;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_request_write_access);
	strcpy(obj->objs[1]->name, "request_write_access");
	if (arg_request_write_access)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument User
	if (arg_bot){
		obj->objs[2] = arg_bot;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "bot");
	}


	//parse argument string
	if (arg_domain){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_domain, strlen(arg_domain));
		strcpy(obj->objs[3]->name, "domain");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_urlAuthResultAccepted(const char * arg_url)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "urlAuthResultAccepted");
	int i;
	obj->id = 0x8f8c0e4e;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_url){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[0]->name, "url");
	}

	return obj;
}

tlo_t * tl_urlAuthResultDefault()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "urlAuthResultDefault");
	int i;
	obj->id = 0xa9d6db1f;
	return obj;
}

tlo_t * tl_channelLocationEmpty()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelLocationEmpty");
	int i;
	obj->id = 0xbfb5ad8b;
	return obj;
}

tlo_t * tl_channelLocation(GeoPoint arg_geo_point, const char * arg_address)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channelLocation");
	int i;
	obj->id = 0x209b82db;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument GeoPoint
	if (arg_geo_point){
		obj->objs[0] = arg_geo_point;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "geo_point");
	}


	//parse argument string
	if (arg_address){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_address, strlen(arg_address));
		strcpy(obj->objs[1]->name, "address");
	}

	return obj;
}

tlo_t * tl_peerLocated(Peer arg_peer, int arg_expires, int arg_distance)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "peerLocated");
	int i;
	obj->id = 0xca461b5d;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_expires);
	strcpy(obj->objs[1]->name, "expires");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_distance);
	strcpy(obj->objs[2]->name, "distance");
	return obj;
}

tlo_t * tl_peerSelfLocated(int arg_expires)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "peerSelfLocated");
	int i;
	obj->id = 0xf8ec284b;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_expires);
	strcpy(obj->objs[0]->name, "expires");
	return obj;
}

tlo_t * tl_restrictionReason(const char * arg_platform, const char * arg_reason, const char * arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "restrictionReason");
	int i;
	obj->id = 0xd072acb4;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_platform){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_platform, strlen(arg_platform));
		strcpy(obj->objs[0]->name, "platform");
	}


	//parse argument string
	if (arg_reason){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_reason, strlen(arg_reason));
		strcpy(obj->objs[1]->name, "reason");
	}


	//parse argument string
	if (arg_text){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[2]->name, "text");
	}

	return obj;
}

tlo_t * tl_inputTheme(long arg_id, long arg_access_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputTheme");
	int i;
	obj->id = 0x3c5693e9;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[1]->name, "access_hash");
	return obj;
}

tlo_t * tl_inputThemeSlug(const char * arg_slug)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputThemeSlug");
	int i;
	obj->id = 0xf5890df1;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_slug){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_slug, strlen(arg_slug));
		strcpy(obj->objs[0]->name, "slug");
	}

	return obj;
}

tlo_t * tl_theme(bool arg_creator, bool arg_default, bool arg_for_chat, long arg_id, long arg_access_hash, const char * arg_slug, const char * arg_title, Document arg_document, ThemeSettings *arg_settings, int len_arg_settings, const char * arg_emoticon, int arg_installs_count)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "theme");
	int i;
	obj->id = 0xa00e67d6;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 12;
	obj->objs = 
		(tlo_t **)MALLOC(12 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_creator);
	strcpy(obj->objs[1]->name, "creator");
	if (arg_creator)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_default);
	strcpy(obj->objs[2]->name, "default");
	if (arg_default)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 5;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_for_chat);
	strcpy(obj->objs[3]->name, "for_chat");
	if (arg_for_chat)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument long
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[4]->name, "id");

	//parse argument long
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_LONG;
	obj->objs[5]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[5]->name, "access_hash");

	//parse argument string
	if (arg_slug){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_slug, strlen(arg_slug));
		strcpy(obj->objs[6]->name, "slug");
	}


	//parse argument string
	if (arg_title){
		obj->objs[7] = NEW(tlo_t, return NULL);
		obj->objs[7]->flag_num = 0;
		obj->objs[7]->flag_bit = 0;
		obj->objs[7]->type = TYPE_STRING;
		obj->objs[7]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[7]->name, "title");
	}


	//parse argument Document
	if (arg_document){
		obj->objs[8] = arg_document;
		obj->objs[8]->flag_num = 1;
		obj->objs[8]->flag_bit = 2;
	strcpy(obj->objs[8]->name, "document");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument Vector<ThemeSettings>
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 1;
	obj->objs[9]->flag_bit = 3;
	obj->objs[9]->type = TYPE_VECTOR;
	strcpy(obj->objs[9]->name, "settings");
	if (arg_settings){
		for(i=0; i<len_arg_settings; ++i){
			obj->objs[9]->value = buf_add_ui32(arg_settings[i]->id);
			buf_cat(obj->objs[9]->value, arg_settings[i]->value);
		}
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument string
	if (arg_emoticon){
		obj->objs[10] = NEW(tlo_t, return NULL);
		obj->objs[10]->flag_num = 1;
		obj->objs[10]->flag_bit = 6;
		obj->objs[10]->type = TYPE_STRING;
		obj->objs[10]->value = 
			buf_add((ui8_t *)arg_emoticon, strlen(arg_emoticon));
		strcpy(obj->objs[10]->name, "emoticon");
		flagsv[nflags-1] |= (1 << 6);
	}


	//parse argument int
	obj->objs[11] = NEW(tlo_t, return NULL);
	obj->objs[11]->flag_num = 1;
	obj->objs[11]->flag_bit = 4;
	obj->objs[11]->type = TYPE_INT;
	obj->objs[11]->value = 
		buf_add_ui32(arg_installs_count);
	strcpy(obj->objs[11]->name, "installs_count");
	if (arg_installs_count)
		flagsv[nflags-1] |= (1 << 4);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_account_themesNotModified()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_themesNotModified");
	int i;
	obj->id = 0xf41eb622;
	return obj;
}

tlo_t * tl_account_themes(long arg_hash, Theme *arg_themes, int len_arg_themes)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_themes");
	int i;
	obj->id = 0x9a3d8c6d;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");

	//parse argument Vector<Theme>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "themes");
	if (arg_themes){
		for(i=0; i<len_arg_themes; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_themes[i]->id);
			buf_cat(obj->objs[1]->value, arg_themes[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_auth_loginToken(int arg_expires, unsigned char * arg_token, int len_arg_token)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_loginToken");
	int i;
	obj->id = 0x629f1980;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_expires);
	strcpy(obj->objs[0]->name, "expires");

	//parse argument bytes
	if (arg_token){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_token, len_arg_token);
		strcpy(obj->objs[1]->name, "token");
	}

	return obj;
}

tlo_t * tl_auth_loginTokenMigrateTo(int arg_dc_id, unsigned char * arg_token, int len_arg_token)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_loginTokenMigrateTo");
	int i;
	obj->id = 0x068e9916;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_dc_id);
	strcpy(obj->objs[0]->name, "dc_id");

	//parse argument bytes
	if (arg_token){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_token, len_arg_token);
		strcpy(obj->objs[1]->name, "token");
	}

	return obj;
}

tlo_t * tl_auth_loginTokenSuccess(auth_Authorization arg_authorization)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_loginTokenSuccess");
	int i;
	obj->id = 0x390d5c5e;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument auth_Authorization
	if (arg_authorization){
		obj->objs[0] = arg_authorization;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "authorization");
	}

	return obj;
}

tlo_t * tl_account_contentSettings(bool arg_sensitive_enabled, bool arg_sensitive_can_change)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_contentSettings");
	int i;
	obj->id = 0x57e28221;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_sensitive_enabled);
	strcpy(obj->objs[1]->name, "sensitive_enabled");
	if (arg_sensitive_enabled)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_sensitive_can_change);
	strcpy(obj->objs[2]->name, "sensitive_can_change");
	if (arg_sensitive_can_change)
		flagsv[nflags-1] |= (1 << 1);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_inactiveChats(int *arg_dates, int len_arg_dates, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_inactiveChats");
	int i;
	obj->id = 0xa927fec5;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<int>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "dates");
	if (arg_dates){
		for(i=0; i<len_arg_dates; ++i){
			buf_t b = buf_add_ui32(arg_dates[i]);
			buf_cat(obj->objs[0]->value, b);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[1]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[2]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_baseThemeClassic()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "baseThemeClassic");
	int i;
	obj->id = 0xc3a12462;
	return obj;
}

tlo_t * tl_baseThemeDay()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "baseThemeDay");
	int i;
	obj->id = 0xfbd81688;
	return obj;
}

tlo_t * tl_baseThemeNight()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "baseThemeNight");
	int i;
	obj->id = 0xb7b31ea8;
	return obj;
}

tlo_t * tl_baseThemeTinted()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "baseThemeTinted");
	int i;
	obj->id = 0x6d5f77ee;
	return obj;
}

tlo_t * tl_baseThemeArctic()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "baseThemeArctic");
	int i;
	obj->id = 0x5b11125a;
	return obj;
}

tlo_t * tl_inputThemeSettings(bool arg_message_colors_animated, BaseTheme arg_base_theme, int arg_accent_color, int arg_outbox_accent_color, int *arg_message_colors, int len_arg_message_colors, InputWallPaper arg_wallpaper, WallPaperSettings arg_wallpaper_settings)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputThemeSettings");
	int i;
	obj->id = 0x8fde504f;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 2;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_message_colors_animated);
	strcpy(obj->objs[1]->name, "message_colors_animated");
	if (arg_message_colors_animated)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument BaseTheme
	if (arg_base_theme){
		obj->objs[2] = arg_base_theme;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "base_theme");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_accent_color);
	strcpy(obj->objs[3]->name, "accent_color");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 3;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_outbox_accent_color);
	strcpy(obj->objs[4]->name, "outbox_accent_color");
	if (arg_outbox_accent_color)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument Vector<int>
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_VECTOR;
	strcpy(obj->objs[5]->name, "message_colors");
	if (arg_message_colors){
		for(i=0; i<len_arg_message_colors; ++i){
			buf_t b = buf_add_ui32(arg_message_colors[i]);
			buf_cat(obj->objs[5]->value, b);
		}
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument InputWallPaper
	if (arg_wallpaper){
		obj->objs[6] = arg_wallpaper;
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 1;
	strcpy(obj->objs[6]->name, "wallpaper");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument WallPaperSettings
	if (arg_wallpaper_settings){
		obj->objs[7] = arg_wallpaper_settings;
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 1;
	strcpy(obj->objs[7]->name, "wallpaper_settings");
		flagsv[nflags-1] |= (1 << 1);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_themeSettings(bool arg_message_colors_animated, BaseTheme arg_base_theme, int arg_accent_color, int arg_outbox_accent_color, int *arg_message_colors, int len_arg_message_colors, WallPaper arg_wallpaper)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "themeSettings");
	int i;
	obj->id = 0xfa58b6d4;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 2;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_message_colors_animated);
	strcpy(obj->objs[1]->name, "message_colors_animated");
	if (arg_message_colors_animated)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument BaseTheme
	if (arg_base_theme){
		obj->objs[2] = arg_base_theme;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "base_theme");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_accent_color);
	strcpy(obj->objs[3]->name, "accent_color");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 3;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_outbox_accent_color);
	strcpy(obj->objs[4]->name, "outbox_accent_color");
	if (arg_outbox_accent_color)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument Vector<int>
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_VECTOR;
	strcpy(obj->objs[5]->name, "message_colors");
	if (arg_message_colors){
		for(i=0; i<len_arg_message_colors; ++i){
			buf_t b = buf_add_ui32(arg_message_colors[i]);
			buf_cat(obj->objs[5]->value, b);
		}
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument WallPaper
	if (arg_wallpaper){
		obj->objs[6] = arg_wallpaper;
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 1;
	strcpy(obj->objs[6]->name, "wallpaper");
		flagsv[nflags-1] |= (1 << 1);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_webPageAttributeTheme(Document *arg_documents, int len_arg_documents, ThemeSettings arg_settings)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "webPageAttributeTheme");
	int i;
	obj->id = 0x54b56617;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument Vector<Document>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "documents");
	if (arg_documents){
		for(i=0; i<len_arg_documents; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_documents[i]->id);
			buf_cat(obj->objs[1]->value, arg_documents[i]->value);
		}
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument ThemeSettings
	if (arg_settings){
		obj->objs[2] = arg_settings;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 1;
	strcpy(obj->objs[2]->name, "settings");
		flagsv[nflags-1] |= (1 << 1);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_webPageAttributeStory(Peer arg_peer, int arg_id, StoryItem arg_story)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "webPageAttributeStory");
	int i;
	obj->id = 0x2e94c3e7;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument Peer
	if (arg_peer){
		obj->objs[1] = arg_peer;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "peer");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[2]->name, "id");

	//parse argument StoryItem
	if (arg_story){
		obj->objs[3] = arg_story;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "story");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_webPageAttributeStickerSet(bool arg_emojis, bool arg_text_color, Document *arg_stickers, int len_arg_stickers)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "webPageAttributeStickerSet");
	int i;
	obj->id = 0x50cc03d3;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_emojis);
	strcpy(obj->objs[1]->name, "emojis");
	if (arg_emojis)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_text_color);
	strcpy(obj->objs[2]->name, "text_color");
	if (arg_text_color)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument Vector<Document>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "stickers");
	if (arg_stickers){
		for(i=0; i<len_arg_stickers; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_stickers[i]->id);
			buf_cat(obj->objs[3]->value, arg_stickers[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_votesList(int arg_count, MessagePeerVote *arg_votes, int len_arg_votes, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users, const char * arg_next_offset)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_votesList");
	int i;
	obj->id = 0x4899484e;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[1]->name, "count");

	//parse argument Vector<MessagePeerVote>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "votes");
	if (arg_votes){
		for(i=0; i<len_arg_votes; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_votes[i]->id);
			buf_cat(obj->objs[2]->value, arg_votes[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[3]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[4]->value, arg_users[i]->value);
		}
	}


	//parse argument string
	if (arg_next_offset){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_next_offset, strlen(arg_next_offset));
		strcpy(obj->objs[5]->name, "next_offset");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_bankCardOpenUrl(const char * arg_url, const char * arg_name)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "bankCardOpenUrl");
	int i;
	obj->id = 0xf568028a;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_url){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[0]->name, "url");
	}


	//parse argument string
	if (arg_name){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_name, strlen(arg_name));
		strcpy(obj->objs[1]->name, "name");
	}

	return obj;
}

tlo_t * tl_payments_bankCardData(const char * arg_title, BankCardOpenUrl *arg_open_urls, int len_arg_open_urls)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_bankCardData");
	int i;
	obj->id = 0x3e24e573;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_title){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[0]->name, "title");
	}


	//parse argument Vector<BankCardOpenUrl>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "open_urls");
	if (arg_open_urls){
		for(i=0; i<len_arg_open_urls; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_open_urls[i]->id);
			buf_cat(obj->objs[1]->value, arg_open_urls[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_dialogFilter(bool arg_contacts, bool arg_non_contacts, bool arg_groups, bool arg_broadcasts, bool arg_bots, bool arg_exclude_muted, bool arg_exclude_read, bool arg_exclude_archived, int arg_id, const char * arg_title, const char * arg_emoticon, int arg_color, InputPeer *arg_pinned_peers, int len_arg_pinned_peers, InputPeer *arg_include_peers, int len_arg_include_peers, InputPeer *arg_exclude_peers, int len_arg_exclude_peers)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "dialogFilter");
	int i;
	obj->id = 0x5fb5523b;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 16;
	obj->objs = 
		(tlo_t **)MALLOC(16 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_contacts);
	strcpy(obj->objs[1]->name, "contacts");
	if (arg_contacts)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_non_contacts);
	strcpy(obj->objs[2]->name, "non_contacts");
	if (arg_non_contacts)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_groups);
	strcpy(obj->objs[3]->name, "groups");
	if (arg_groups)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 3;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_broadcasts);
	strcpy(obj->objs[4]->name, "broadcasts");
	if (arg_broadcasts)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 4;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_bots);
	strcpy(obj->objs[5]->name, "bots");
	if (arg_bots)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument true
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 11;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_exclude_muted);
	strcpy(obj->objs[6]->name, "exclude_muted");
	if (arg_exclude_muted)
		flagsv[nflags-1] |= (1 << 11);

	//parse argument true
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 12;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_exclude_read);
	strcpy(obj->objs[7]->name, "exclude_read");
	if (arg_exclude_read)
		flagsv[nflags-1] |= (1 << 12);

	//parse argument true
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 13;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_exclude_archived);
	strcpy(obj->objs[8]->name, "exclude_archived");
	if (arg_exclude_archived)
		flagsv[nflags-1] |= (1 << 13);

	//parse argument int
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 0;
	obj->objs[9]->flag_bit = 0;
	obj->objs[9]->type = TYPE_INT;
	obj->objs[9]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[9]->name, "id");

	//parse argument string
	if (arg_title){
		obj->objs[10] = NEW(tlo_t, return NULL);
		obj->objs[10]->flag_num = 0;
		obj->objs[10]->flag_bit = 0;
		obj->objs[10]->type = TYPE_STRING;
		obj->objs[10]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[10]->name, "title");
	}


	//parse argument string
	if (arg_emoticon){
		obj->objs[11] = NEW(tlo_t, return NULL);
		obj->objs[11]->flag_num = 1;
		obj->objs[11]->flag_bit = 25;
		obj->objs[11]->type = TYPE_STRING;
		obj->objs[11]->value = 
			buf_add((ui8_t *)arg_emoticon, strlen(arg_emoticon));
		strcpy(obj->objs[11]->name, "emoticon");
		flagsv[nflags-1] |= (1 << 25);
	}


	//parse argument int
	obj->objs[12] = NEW(tlo_t, return NULL);
	obj->objs[12]->flag_num = 1;
	obj->objs[12]->flag_bit = 27;
	obj->objs[12]->type = TYPE_INT;
	obj->objs[12]->value = 
		buf_add_ui32(arg_color);
	strcpy(obj->objs[12]->name, "color");
	if (arg_color)
		flagsv[nflags-1] |= (1 << 27);

	//parse argument Vector<InputPeer>
	obj->objs[13] = NEW(tlo_t, return NULL);
	obj->objs[13]->flag_num = 0;
	obj->objs[13]->flag_bit = 0;
	obj->objs[13]->type = TYPE_VECTOR;
	strcpy(obj->objs[13]->name, "pinned_peers");
	if (arg_pinned_peers){
		for(i=0; i<len_arg_pinned_peers; ++i){
			obj->objs[13]->value = buf_add_ui32(arg_pinned_peers[i]->id);
			buf_cat(obj->objs[13]->value, arg_pinned_peers[i]->value);
		}
	}


	//parse argument Vector<InputPeer>
	obj->objs[14] = NEW(tlo_t, return NULL);
	obj->objs[14]->flag_num = 0;
	obj->objs[14]->flag_bit = 0;
	obj->objs[14]->type = TYPE_VECTOR;
	strcpy(obj->objs[14]->name, "include_peers");
	if (arg_include_peers){
		for(i=0; i<len_arg_include_peers; ++i){
			obj->objs[14]->value = buf_add_ui32(arg_include_peers[i]->id);
			buf_cat(obj->objs[14]->value, arg_include_peers[i]->value);
		}
	}


	//parse argument Vector<InputPeer>
	obj->objs[15] = NEW(tlo_t, return NULL);
	obj->objs[15]->flag_num = 0;
	obj->objs[15]->flag_bit = 0;
	obj->objs[15]->type = TYPE_VECTOR;
	strcpy(obj->objs[15]->name, "exclude_peers");
	if (arg_exclude_peers){
		for(i=0; i<len_arg_exclude_peers; ++i){
			obj->objs[15]->value = buf_add_ui32(arg_exclude_peers[i]->id);
			buf_cat(obj->objs[15]->value, arg_exclude_peers[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_dialogFilterDefault()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "dialogFilterDefault");
	int i;
	obj->id = 0x363293ae;
	return obj;
}

tlo_t * tl_dialogFilterChatlist(bool arg_has_my_invites, int arg_id, const char * arg_title, const char * arg_emoticon, int arg_color, InputPeer *arg_pinned_peers, int len_arg_pinned_peers, InputPeer *arg_include_peers, int len_arg_include_peers)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "dialogFilterChatlist");
	int i;
	obj->id = 0x9fe28ea4;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 26;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_has_my_invites);
	strcpy(obj->objs[1]->name, "has_my_invites");
	if (arg_has_my_invites)
		flagsv[nflags-1] |= (1 << 26);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[2]->name, "id");

	//parse argument string
	if (arg_title){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[3]->name, "title");
	}


	//parse argument string
	if (arg_emoticon){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 25;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_emoticon, strlen(arg_emoticon));
		strcpy(obj->objs[4]->name, "emoticon");
		flagsv[nflags-1] |= (1 << 25);
	}


	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 27;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_color);
	strcpy(obj->objs[5]->name, "color");
	if (arg_color)
		flagsv[nflags-1] |= (1 << 27);

	//parse argument Vector<InputPeer>
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_VECTOR;
	strcpy(obj->objs[6]->name, "pinned_peers");
	if (arg_pinned_peers){
		for(i=0; i<len_arg_pinned_peers; ++i){
			obj->objs[6]->value = buf_add_ui32(arg_pinned_peers[i]->id);
			buf_cat(obj->objs[6]->value, arg_pinned_peers[i]->value);
		}
	}


	//parse argument Vector<InputPeer>
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_VECTOR;
	strcpy(obj->objs[7]->name, "include_peers");
	if (arg_include_peers){
		for(i=0; i<len_arg_include_peers; ++i){
			obj->objs[7]->value = buf_add_ui32(arg_include_peers[i]->id);
			buf_cat(obj->objs[7]->value, arg_include_peers[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_dialogFilterSuggested(DialogFilter arg_filter, const char * arg_description)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "dialogFilterSuggested");
	int i;
	obj->id = 0x77744d4a;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument DialogFilter
	if (arg_filter){
		obj->objs[0] = arg_filter;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "filter");
	}


	//parse argument string
	if (arg_description){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_description, strlen(arg_description));
		strcpy(obj->objs[1]->name, "description");
	}

	return obj;
}

tlo_t * tl_statsDateRangeDays(int arg_min_date, int arg_max_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "statsDateRangeDays");
	int i;
	obj->id = 0xb637edaf;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_min_date);
	strcpy(obj->objs[0]->name, "min_date");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_max_date);
	strcpy(obj->objs[1]->name, "max_date");
	return obj;
}

tlo_t * tl_statsAbsValueAndPrev(double arg_current, double arg_previous)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "statsAbsValueAndPrev");
	int i;
	obj->id = 0xcb43acde;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument double
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_current);
	strcpy(obj->objs[0]->name, "current");

	//parse argument double
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_previous);
	strcpy(obj->objs[1]->name, "previous");
	return obj;
}

tlo_t * tl_statsPercentValue(double arg_part, double arg_total)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "statsPercentValue");
	int i;
	obj->id = 0xcbce2fe0;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument double
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_part);
	strcpy(obj->objs[0]->name, "part");

	//parse argument double
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_total);
	strcpy(obj->objs[1]->name, "total");
	return obj;
}

tlo_t * tl_statsGraphAsync(const char * arg_token)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "statsGraphAsync");
	int i;
	obj->id = 0x4a27eb2d;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_token){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_token, strlen(arg_token));
		strcpy(obj->objs[0]->name, "token");
	}

	return obj;
}

tlo_t * tl_statsGraphError(const char * arg_error)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "statsGraphError");
	int i;
	obj->id = 0xbedc9822;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_error){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_error, strlen(arg_error));
		strcpy(obj->objs[0]->name, "error");
	}

	return obj;
}

tlo_t * tl_statsGraph(DataJSON arg_json, const char * arg_zoom_token)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "statsGraph");
	int i;
	obj->id = 0x8ea464b6;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument DataJSON
	if (arg_json){
		obj->objs[1] = arg_json;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "json");
	}


	//parse argument string
	if (arg_zoom_token){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_zoom_token, strlen(arg_zoom_token));
		strcpy(obj->objs[2]->name, "zoom_token");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_stats_broadcastStats(StatsDateRangeDays arg_period, StatsAbsValueAndPrev arg_followers, StatsAbsValueAndPrev arg_views_per_post, StatsAbsValueAndPrev arg_shares_per_post, StatsAbsValueAndPrev arg_reactions_per_post, StatsAbsValueAndPrev arg_views_per_story, StatsAbsValueAndPrev arg_shares_per_story, StatsAbsValueAndPrev arg_reactions_per_story, StatsPercentValue arg_enabled_notifications, StatsGraph arg_growth_graph, StatsGraph arg_followers_graph, StatsGraph arg_mute_graph, StatsGraph arg_top_hours_graph, StatsGraph arg_interactions_graph, StatsGraph arg_iv_interactions_graph, StatsGraph arg_views_by_source_graph, StatsGraph arg_new_followers_by_source_graph, StatsGraph arg_languages_graph, StatsGraph arg_reactions_by_emotion_graph, StatsGraph arg_story_interactions_graph, StatsGraph arg_story_reactions_by_emotion_graph, PostInteractionCounters *arg_recent_posts_interactions, int len_arg_recent_posts_interactions)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stats_broadcastStats");
	int i;
	obj->id = 0x396ca5fc;
	obj->nobjs = 22;
	obj->objs = 
		(tlo_t **)MALLOC(22 * sizeof(tlo_t*), return NULL);

	//parse argument StatsDateRangeDays
	if (arg_period){
		obj->objs[0] = arg_period;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "period");
	}


	//parse argument StatsAbsValueAndPrev
	if (arg_followers){
		obj->objs[1] = arg_followers;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "followers");
	}


	//parse argument StatsAbsValueAndPrev
	if (arg_views_per_post){
		obj->objs[2] = arg_views_per_post;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "views_per_post");
	}


	//parse argument StatsAbsValueAndPrev
	if (arg_shares_per_post){
		obj->objs[3] = arg_shares_per_post;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "shares_per_post");
	}


	//parse argument StatsAbsValueAndPrev
	if (arg_reactions_per_post){
		obj->objs[4] = arg_reactions_per_post;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "reactions_per_post");
	}


	//parse argument StatsAbsValueAndPrev
	if (arg_views_per_story){
		obj->objs[5] = arg_views_per_story;
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
	strcpy(obj->objs[5]->name, "views_per_story");
	}


	//parse argument StatsAbsValueAndPrev
	if (arg_shares_per_story){
		obj->objs[6] = arg_shares_per_story;
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
	strcpy(obj->objs[6]->name, "shares_per_story");
	}


	//parse argument StatsAbsValueAndPrev
	if (arg_reactions_per_story){
		obj->objs[7] = arg_reactions_per_story;
		obj->objs[7]->flag_num = 0;
		obj->objs[7]->flag_bit = 0;
	strcpy(obj->objs[7]->name, "reactions_per_story");
	}


	//parse argument StatsPercentValue
	if (arg_enabled_notifications){
		obj->objs[8] = arg_enabled_notifications;
		obj->objs[8]->flag_num = 0;
		obj->objs[8]->flag_bit = 0;
	strcpy(obj->objs[8]->name, "enabled_notifications");
	}


	//parse argument StatsGraph
	if (arg_growth_graph){
		obj->objs[9] = arg_growth_graph;
		obj->objs[9]->flag_num = 0;
		obj->objs[9]->flag_bit = 0;
	strcpy(obj->objs[9]->name, "growth_graph");
	}


	//parse argument StatsGraph
	if (arg_followers_graph){
		obj->objs[10] = arg_followers_graph;
		obj->objs[10]->flag_num = 0;
		obj->objs[10]->flag_bit = 0;
	strcpy(obj->objs[10]->name, "followers_graph");
	}


	//parse argument StatsGraph
	if (arg_mute_graph){
		obj->objs[11] = arg_mute_graph;
		obj->objs[11]->flag_num = 0;
		obj->objs[11]->flag_bit = 0;
	strcpy(obj->objs[11]->name, "mute_graph");
	}


	//parse argument StatsGraph
	if (arg_top_hours_graph){
		obj->objs[12] = arg_top_hours_graph;
		obj->objs[12]->flag_num = 0;
		obj->objs[12]->flag_bit = 0;
	strcpy(obj->objs[12]->name, "top_hours_graph");
	}


	//parse argument StatsGraph
	if (arg_interactions_graph){
		obj->objs[13] = arg_interactions_graph;
		obj->objs[13]->flag_num = 0;
		obj->objs[13]->flag_bit = 0;
	strcpy(obj->objs[13]->name, "interactions_graph");
	}


	//parse argument StatsGraph
	if (arg_iv_interactions_graph){
		obj->objs[14] = arg_iv_interactions_graph;
		obj->objs[14]->flag_num = 0;
		obj->objs[14]->flag_bit = 0;
	strcpy(obj->objs[14]->name, "iv_interactions_graph");
	}


	//parse argument StatsGraph
	if (arg_views_by_source_graph){
		obj->objs[15] = arg_views_by_source_graph;
		obj->objs[15]->flag_num = 0;
		obj->objs[15]->flag_bit = 0;
	strcpy(obj->objs[15]->name, "views_by_source_graph");
	}


	//parse argument StatsGraph
	if (arg_new_followers_by_source_graph){
		obj->objs[16] = arg_new_followers_by_source_graph;
		obj->objs[16]->flag_num = 0;
		obj->objs[16]->flag_bit = 0;
	strcpy(obj->objs[16]->name, "new_followers_by_source_graph");
	}


	//parse argument StatsGraph
	if (arg_languages_graph){
		obj->objs[17] = arg_languages_graph;
		obj->objs[17]->flag_num = 0;
		obj->objs[17]->flag_bit = 0;
	strcpy(obj->objs[17]->name, "languages_graph");
	}


	//parse argument StatsGraph
	if (arg_reactions_by_emotion_graph){
		obj->objs[18] = arg_reactions_by_emotion_graph;
		obj->objs[18]->flag_num = 0;
		obj->objs[18]->flag_bit = 0;
	strcpy(obj->objs[18]->name, "reactions_by_emotion_graph");
	}


	//parse argument StatsGraph
	if (arg_story_interactions_graph){
		obj->objs[19] = arg_story_interactions_graph;
		obj->objs[19]->flag_num = 0;
		obj->objs[19]->flag_bit = 0;
	strcpy(obj->objs[19]->name, "story_interactions_graph");
	}


	//parse argument StatsGraph
	if (arg_story_reactions_by_emotion_graph){
		obj->objs[20] = arg_story_reactions_by_emotion_graph;
		obj->objs[20]->flag_num = 0;
		obj->objs[20]->flag_bit = 0;
	strcpy(obj->objs[20]->name, "story_reactions_by_emotion_graph");
	}


	//parse argument Vector<PostInteractionCounters>
	obj->objs[21] = NEW(tlo_t, return NULL);
	obj->objs[21]->flag_num = 0;
	obj->objs[21]->flag_bit = 0;
	obj->objs[21]->type = TYPE_VECTOR;
	strcpy(obj->objs[21]->name, "recent_posts_interactions");
	if (arg_recent_posts_interactions){
		for(i=0; i<len_arg_recent_posts_interactions; ++i){
			obj->objs[21]->value = buf_add_ui32(arg_recent_posts_interactions[i]->id);
			buf_cat(obj->objs[21]->value, arg_recent_posts_interactions[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_help_promoDataEmpty(int arg_expires)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_promoDataEmpty");
	int i;
	obj->id = 0x98f6ac75;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_expires);
	strcpy(obj->objs[0]->name, "expires");
	return obj;
}

tlo_t * tl_help_promoData(bool arg_proxy, int arg_expires, Peer arg_peer, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users, const char * arg_psa_type, const char * arg_psa_message)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_promoData");
	int i;
	obj->id = 0x8c39793f;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_proxy);
	strcpy(obj->objs[1]->name, "proxy");
	if (arg_proxy)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_expires);
	strcpy(obj->objs[2]->name, "expires");

	//parse argument Peer
	if (arg_peer){
		obj->objs[3] = arg_peer;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "peer");
	}


	//parse argument Vector<Chat>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[4]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_VECTOR;
	strcpy(obj->objs[5]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[5]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[5]->value, arg_users[i]->value);
		}
	}


	//parse argument string
	if (arg_psa_type){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 1;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_psa_type, strlen(arg_psa_type));
		strcpy(obj->objs[6]->name, "psa_type");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument string
	if (arg_psa_message){
		obj->objs[7] = NEW(tlo_t, return NULL);
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 2;
		obj->objs[7]->type = TYPE_STRING;
		obj->objs[7]->value = 
			buf_add((ui8_t *)arg_psa_message, strlen(arg_psa_message));
		strcpy(obj->objs[7]->name, "psa_message");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_videoSize(const char * arg_type, int arg_w, int arg_h, int arg_size, double arg_video_start_ts)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "videoSize");
	int i;
	obj->id = 0xde33b094;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_type){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_type, strlen(arg_type));
		strcpy(obj->objs[1]->name, "type");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_w);
	strcpy(obj->objs[2]->name, "w");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_h);
	strcpy(obj->objs[3]->name, "h");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_size);
	strcpy(obj->objs[4]->name, "size");

	//parse argument double
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_LONG;
	obj->objs[5]->value = 
		buf_add_ui64(arg_video_start_ts);
	strcpy(obj->objs[5]->name, "video_start_ts");
	if (arg_video_start_ts)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_videoSizeEmojiMarkup(long arg_emoji_id, int *arg_background_colors, int len_arg_background_colors)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "videoSizeEmojiMarkup");
	int i;
	obj->id = 0xf85c413c;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_emoji_id);
	strcpy(obj->objs[0]->name, "emoji_id");

	//parse argument Vector<int>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "background_colors");
	if (arg_background_colors){
		for(i=0; i<len_arg_background_colors; ++i){
			buf_t b = buf_add_ui32(arg_background_colors[i]);
			buf_cat(obj->objs[1]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_videoSizeStickerMarkup(InputStickerSet arg_stickerset, long arg_sticker_id, int *arg_background_colors, int len_arg_background_colors)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "videoSizeStickerMarkup");
	int i;
	obj->id = 0x0da082fe;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputStickerSet
	if (arg_stickerset){
		obj->objs[0] = arg_stickerset;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "stickerset");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_sticker_id);
	strcpy(obj->objs[1]->name, "sticker_id");

	//parse argument Vector<int>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "background_colors");
	if (arg_background_colors){
		for(i=0; i<len_arg_background_colors; ++i){
			buf_t b = buf_add_ui32(arg_background_colors[i]);
			buf_cat(obj->objs[2]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_statsGroupTopPoster(long arg_user_id, int arg_messages, int arg_avg_chars)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "statsGroupTopPoster");
	int i;
	obj->id = 0x9d04af9b;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[0]->name, "user_id");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_messages);
	strcpy(obj->objs[1]->name, "messages");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_avg_chars);
	strcpy(obj->objs[2]->name, "avg_chars");
	return obj;
}

tlo_t * tl_statsGroupTopAdmin(long arg_user_id, int arg_deleted, int arg_kicked, int arg_banned)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "statsGroupTopAdmin");
	int i;
	obj->id = 0xd7584c87;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[0]->name, "user_id");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_deleted);
	strcpy(obj->objs[1]->name, "deleted");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_kicked);
	strcpy(obj->objs[2]->name, "kicked");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_banned);
	strcpy(obj->objs[3]->name, "banned");
	return obj;
}

tlo_t * tl_statsGroupTopInviter(long arg_user_id, int arg_invitations)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "statsGroupTopInviter");
	int i;
	obj->id = 0x535f779d;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[0]->name, "user_id");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_invitations);
	strcpy(obj->objs[1]->name, "invitations");
	return obj;
}

tlo_t * tl_stats_megagroupStats(StatsDateRangeDays arg_period, StatsAbsValueAndPrev arg_members, StatsAbsValueAndPrev arg_messages, StatsAbsValueAndPrev arg_viewers, StatsAbsValueAndPrev arg_posters, StatsGraph arg_growth_graph, StatsGraph arg_members_graph, StatsGraph arg_new_members_by_source_graph, StatsGraph arg_languages_graph, StatsGraph arg_messages_graph, StatsGraph arg_actions_graph, StatsGraph arg_top_hours_graph, StatsGraph arg_weekdays_graph, StatsGroupTopPoster *arg_top_posters, int len_arg_top_posters, StatsGroupTopAdmin *arg_top_admins, int len_arg_top_admins, StatsGroupTopInviter *arg_top_inviters, int len_arg_top_inviters, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stats_megagroupStats");
	int i;
	obj->id = 0xef7ff916;
	obj->nobjs = 17;
	obj->objs = 
		(tlo_t **)MALLOC(17 * sizeof(tlo_t*), return NULL);

	//parse argument StatsDateRangeDays
	if (arg_period){
		obj->objs[0] = arg_period;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "period");
	}


	//parse argument StatsAbsValueAndPrev
	if (arg_members){
		obj->objs[1] = arg_members;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "members");
	}


	//parse argument StatsAbsValueAndPrev
	if (arg_messages){
		obj->objs[2] = arg_messages;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "messages");
	}


	//parse argument StatsAbsValueAndPrev
	if (arg_viewers){
		obj->objs[3] = arg_viewers;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "viewers");
	}


	//parse argument StatsAbsValueAndPrev
	if (arg_posters){
		obj->objs[4] = arg_posters;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "posters");
	}


	//parse argument StatsGraph
	if (arg_growth_graph){
		obj->objs[5] = arg_growth_graph;
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
	strcpy(obj->objs[5]->name, "growth_graph");
	}


	//parse argument StatsGraph
	if (arg_members_graph){
		obj->objs[6] = arg_members_graph;
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
	strcpy(obj->objs[6]->name, "members_graph");
	}


	//parse argument StatsGraph
	if (arg_new_members_by_source_graph){
		obj->objs[7] = arg_new_members_by_source_graph;
		obj->objs[7]->flag_num = 0;
		obj->objs[7]->flag_bit = 0;
	strcpy(obj->objs[7]->name, "new_members_by_source_graph");
	}


	//parse argument StatsGraph
	if (arg_languages_graph){
		obj->objs[8] = arg_languages_graph;
		obj->objs[8]->flag_num = 0;
		obj->objs[8]->flag_bit = 0;
	strcpy(obj->objs[8]->name, "languages_graph");
	}


	//parse argument StatsGraph
	if (arg_messages_graph){
		obj->objs[9] = arg_messages_graph;
		obj->objs[9]->flag_num = 0;
		obj->objs[9]->flag_bit = 0;
	strcpy(obj->objs[9]->name, "messages_graph");
	}


	//parse argument StatsGraph
	if (arg_actions_graph){
		obj->objs[10] = arg_actions_graph;
		obj->objs[10]->flag_num = 0;
		obj->objs[10]->flag_bit = 0;
	strcpy(obj->objs[10]->name, "actions_graph");
	}


	//parse argument StatsGraph
	if (arg_top_hours_graph){
		obj->objs[11] = arg_top_hours_graph;
		obj->objs[11]->flag_num = 0;
		obj->objs[11]->flag_bit = 0;
	strcpy(obj->objs[11]->name, "top_hours_graph");
	}


	//parse argument StatsGraph
	if (arg_weekdays_graph){
		obj->objs[12] = arg_weekdays_graph;
		obj->objs[12]->flag_num = 0;
		obj->objs[12]->flag_bit = 0;
	strcpy(obj->objs[12]->name, "weekdays_graph");
	}


	//parse argument Vector<StatsGroupTopPoster>
	obj->objs[13] = NEW(tlo_t, return NULL);
	obj->objs[13]->flag_num = 0;
	obj->objs[13]->flag_bit = 0;
	obj->objs[13]->type = TYPE_VECTOR;
	strcpy(obj->objs[13]->name, "top_posters");
	if (arg_top_posters){
		for(i=0; i<len_arg_top_posters; ++i){
			obj->objs[13]->value = buf_add_ui32(arg_top_posters[i]->id);
			buf_cat(obj->objs[13]->value, arg_top_posters[i]->value);
		}
	}


	//parse argument Vector<StatsGroupTopAdmin>
	obj->objs[14] = NEW(tlo_t, return NULL);
	obj->objs[14]->flag_num = 0;
	obj->objs[14]->flag_bit = 0;
	obj->objs[14]->type = TYPE_VECTOR;
	strcpy(obj->objs[14]->name, "top_admins");
	if (arg_top_admins){
		for(i=0; i<len_arg_top_admins; ++i){
			obj->objs[14]->value = buf_add_ui32(arg_top_admins[i]->id);
			buf_cat(obj->objs[14]->value, arg_top_admins[i]->value);
		}
	}


	//parse argument Vector<StatsGroupTopInviter>
	obj->objs[15] = NEW(tlo_t, return NULL);
	obj->objs[15]->flag_num = 0;
	obj->objs[15]->flag_bit = 0;
	obj->objs[15]->type = TYPE_VECTOR;
	strcpy(obj->objs[15]->name, "top_inviters");
	if (arg_top_inviters){
		for(i=0; i<len_arg_top_inviters; ++i){
			obj->objs[15]->value = buf_add_ui32(arg_top_inviters[i]->id);
			buf_cat(obj->objs[15]->value, arg_top_inviters[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[16] = NEW(tlo_t, return NULL);
	obj->objs[16]->flag_num = 0;
	obj->objs[16]->flag_bit = 0;
	obj->objs[16]->type = TYPE_VECTOR;
	strcpy(obj->objs[16]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[16]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[16]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_globalPrivacySettings(bool arg_archive_and_mute_new_noncontact_peers, bool arg_keep_archived_unmuted, bool arg_keep_archived_folders, bool arg_hide_read_marks, bool arg_new_noncontact_peers_require_premium)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "globalPrivacySettings");
	int i;
	obj->id = 0x734c4ccb;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_archive_and_mute_new_noncontact_peers);
	strcpy(obj->objs[1]->name, "archive_and_mute_new_noncontact_peers");
	if (arg_archive_and_mute_new_noncontact_peers)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_keep_archived_unmuted);
	strcpy(obj->objs[2]->name, "keep_archived_unmuted");
	if (arg_keep_archived_unmuted)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_keep_archived_folders);
	strcpy(obj->objs[3]->name, "keep_archived_folders");
	if (arg_keep_archived_folders)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 3;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_hide_read_marks);
	strcpy(obj->objs[4]->name, "hide_read_marks");
	if (arg_hide_read_marks)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 4;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_new_noncontact_peers_require_premium);
	strcpy(obj->objs[5]->name, "new_noncontact_peers_require_premium");
	if (arg_new_noncontact_peers_require_premium)
		flagsv[nflags-1] |= (1 << 4);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_help_countryCode(const char * arg_country_code, const char * *arg_prefixes, int len_arg_prefixes, const char * *arg_patterns, int len_arg_patterns)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_countryCode");
	int i;
	obj->id = 0x4203c5ef;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_country_code){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_country_code, strlen(arg_country_code));
		strcpy(obj->objs[1]->name, "country_code");
	}


	//parse argument Vector<string>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "prefixes");
	if (arg_prefixes){
		for(i=0; i<len_arg_prefixes; ++i){
			int len = strlen(arg_prefixes[i]);
			buf_t b = buf_add((ui8_t *)arg_prefixes[i], len);
			buf_cat(obj->objs[2]->value, b);
		}
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument Vector<string>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 1;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "patterns");
	if (arg_patterns){
		for(i=0; i<len_arg_patterns; ++i){
			int len = strlen(arg_patterns[i]);
			buf_t b = buf_add((ui8_t *)arg_patterns[i], len);
			buf_cat(obj->objs[3]->value, b);
		}
		flagsv[nflags-1] |= (1 << 1);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_help_country(bool arg_hidden, const char * arg_iso2, const char * arg_default_name, const char * arg_name, help_CountryCode *arg_country_codes, int len_arg_country_codes)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_country");
	int i;
	obj->id = 0xc3878e23;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_hidden);
	strcpy(obj->objs[1]->name, "hidden");
	if (arg_hidden)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument string
	if (arg_iso2){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_iso2, strlen(arg_iso2));
		strcpy(obj->objs[2]->name, "iso2");
	}


	//parse argument string
	if (arg_default_name){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_default_name, strlen(arg_default_name));
		strcpy(obj->objs[3]->name, "default_name");
	}


	//parse argument string
	if (arg_name){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 1;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_name, strlen(arg_name));
		strcpy(obj->objs[4]->name, "name");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument Vector<help_CountryCode>
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_VECTOR;
	strcpy(obj->objs[5]->name, "country_codes");
	if (arg_country_codes){
		for(i=0; i<len_arg_country_codes; ++i){
			obj->objs[5]->value = buf_add_ui32(arg_country_codes[i]->id);
			buf_cat(obj->objs[5]->value, arg_country_codes[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_help_countriesListNotModified()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_countriesListNotModified");
	int i;
	obj->id = 0x93cc1f32;
	return obj;
}

tlo_t * tl_help_countriesList(help_Country *arg_countries, int len_arg_countries, int arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_countriesList");
	int i;
	obj->id = 0x87d0759e;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<help_Country>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "countries");
	if (arg_countries){
		for(i=0; i<len_arg_countries; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_countries[i]->id);
			buf_cat(obj->objs[0]->value, arg_countries[i]->value);
		}
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_hash);
	strcpy(obj->objs[1]->name, "hash");
	return obj;
}

tlo_t * tl_messageViews(int arg_views, int arg_forwards, MessageReplies arg_replies)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageViews");
	int i;
	obj->id = 0x455b853d;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_views);
	strcpy(obj->objs[1]->name, "views");
	if (arg_views)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_forwards);
	strcpy(obj->objs[2]->name, "forwards");
	if (arg_forwards)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument MessageReplies
	if (arg_replies){
		obj->objs[3] = arg_replies;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 2;
	strcpy(obj->objs[3]->name, "replies");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_messageViews(MessageViews *arg_views, int len_arg_views, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_messageViews");
	int i;
	obj->id = 0xb6c4f543;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<MessageViews>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "views");
	if (arg_views){
		for(i=0; i<len_arg_views; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_views[i]->id);
			buf_cat(obj->objs[0]->value, arg_views[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[1]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[2]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_messages_discussionMessage(Message *arg_messages, int len_arg_messages, int arg_max_id, int arg_read_inbox_max_id, int arg_read_outbox_max_id, int arg_unread_count, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_discussionMessage");
	int i;
	obj->id = 0xa6341782;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument Vector<Message>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "messages");
	if (arg_messages){
		for(i=0; i<len_arg_messages; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_messages[i]->id);
			buf_cat(obj->objs[1]->value, arg_messages[i]->value);
		}
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_max_id);
	strcpy(obj->objs[2]->name, "max_id");
	if (arg_max_id)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 1;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_read_inbox_max_id);
	strcpy(obj->objs[3]->name, "read_inbox_max_id");
	if (arg_read_inbox_max_id)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 2;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_read_outbox_max_id);
	strcpy(obj->objs[4]->name, "read_outbox_max_id");
	if (arg_read_outbox_max_id)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_unread_count);
	strcpy(obj->objs[5]->name, "unread_count");

	//parse argument Vector<Chat>
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_VECTOR;
	strcpy(obj->objs[6]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[6]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[6]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_VECTOR;
	strcpy(obj->objs[7]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[7]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[7]->value, arg_users[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messageReplyHeader(bool arg_reply_to_scheduled, bool arg_forum_topic, bool arg_quote, int arg_reply_to_msg_id, Peer arg_reply_to_peer_id, MessageFwdHeader arg_reply_from, MessageMedia arg_reply_media, int arg_reply_to_top_id, const char * arg_quote_text, MessageEntity *arg_quote_entities, int len_arg_quote_entities, int arg_quote_offset)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageReplyHeader");
	int i;
	obj->id = 0xafbc09db;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 12;
	obj->objs = 
		(tlo_t **)MALLOC(12 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 2;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_reply_to_scheduled);
	strcpy(obj->objs[1]->name, "reply_to_scheduled");
	if (arg_reply_to_scheduled)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 3;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_forum_topic);
	strcpy(obj->objs[2]->name, "forum_topic");
	if (arg_forum_topic)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 9;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_quote);
	strcpy(obj->objs[3]->name, "quote");
	if (arg_quote)
		flagsv[nflags-1] |= (1 << 9);

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 4;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_reply_to_msg_id);
	strcpy(obj->objs[4]->name, "reply_to_msg_id");
	if (arg_reply_to_msg_id)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument Peer
	if (arg_reply_to_peer_id){
		obj->objs[5] = arg_reply_to_peer_id;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 0;
	strcpy(obj->objs[5]->name, "reply_to_peer_id");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument MessageFwdHeader
	if (arg_reply_from){
		obj->objs[6] = arg_reply_from;
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 5;
	strcpy(obj->objs[6]->name, "reply_from");
		flagsv[nflags-1] |= (1 << 5);
	}


	//parse argument MessageMedia
	if (arg_reply_media){
		obj->objs[7] = arg_reply_media;
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 8;
	strcpy(obj->objs[7]->name, "reply_media");
		flagsv[nflags-1] |= (1 << 8);
	}


	//parse argument int
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 1;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_reply_to_top_id);
	strcpy(obj->objs[8]->name, "reply_to_top_id");
	if (arg_reply_to_top_id)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument string
	if (arg_quote_text){
		obj->objs[9] = NEW(tlo_t, return NULL);
		obj->objs[9]->flag_num = 1;
		obj->objs[9]->flag_bit = 6;
		obj->objs[9]->type = TYPE_STRING;
		obj->objs[9]->value = 
			buf_add((ui8_t *)arg_quote_text, strlen(arg_quote_text));
		strcpy(obj->objs[9]->name, "quote_text");
		flagsv[nflags-1] |= (1 << 6);
	}


	//parse argument Vector<MessageEntity>
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 1;
	obj->objs[10]->flag_bit = 7;
	obj->objs[10]->type = TYPE_VECTOR;
	strcpy(obj->objs[10]->name, "quote_entities");
	if (arg_quote_entities){
		for(i=0; i<len_arg_quote_entities; ++i){
			obj->objs[10]->value = buf_add_ui32(arg_quote_entities[i]->id);
			buf_cat(obj->objs[10]->value, arg_quote_entities[i]->value);
		}
		flagsv[nflags-1] |= (1 << 7);
	}


	//parse argument int
	obj->objs[11] = NEW(tlo_t, return NULL);
	obj->objs[11]->flag_num = 1;
	obj->objs[11]->flag_bit = 10;
	obj->objs[11]->type = TYPE_INT;
	obj->objs[11]->value = 
		buf_add_ui32(arg_quote_offset);
	strcpy(obj->objs[11]->name, "quote_offset");
	if (arg_quote_offset)
		flagsv[nflags-1] |= (1 << 10);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messageReplyStoryHeader(Peer arg_peer, int arg_story_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageReplyStoryHeader");
	int i;
	obj->id = 0x0e5af939;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_story_id);
	strcpy(obj->objs[1]->name, "story_id");
	return obj;
}

tlo_t * tl_messageReplies(bool arg_comments, int arg_replies, int arg_replies_pts, Peer *arg_recent_repliers, int len_arg_recent_repliers, long arg_channel_id, int arg_max_id, int arg_read_max_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageReplies");
	int i;
	obj->id = 0x83d60fc2;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_comments);
	strcpy(obj->objs[1]->name, "comments");
	if (arg_comments)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_replies);
	strcpy(obj->objs[2]->name, "replies");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_replies_pts);
	strcpy(obj->objs[3]->name, "replies_pts");

	//parse argument Vector<Peer>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 1;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "recent_repliers");
	if (arg_recent_repliers){
		for(i=0; i<len_arg_recent_repliers; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_recent_repliers[i]->id);
			buf_cat(obj->objs[4]->value, arg_recent_repliers[i]->value);
		}
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument long
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_LONG;
	obj->objs[5]->value = 
		buf_add_ui64(arg_channel_id);
	strcpy(obj->objs[5]->name, "channel_id");
	if (arg_channel_id)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 2;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_max_id);
	strcpy(obj->objs[6]->name, "max_id");
	if (arg_max_id)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument int
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 3;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_read_max_id);
	strcpy(obj->objs[7]->name, "read_max_id");
	if (arg_read_max_id)
		flagsv[nflags-1] |= (1 << 3);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_peerBlocked(Peer arg_peer_id, int arg_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "peerBlocked");
	int i;
	obj->id = 0xe8fd8014;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer_id){
		obj->objs[0] = arg_peer_id;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer_id");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[1]->name, "date");
	return obj;
}

tlo_t * tl_stats_messageStats(StatsGraph arg_views_graph, StatsGraph arg_reactions_by_emotion_graph)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stats_messageStats");
	int i;
	obj->id = 0x7fe91c14;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument StatsGraph
	if (arg_views_graph){
		obj->objs[0] = arg_views_graph;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "views_graph");
	}


	//parse argument StatsGraph
	if (arg_reactions_by_emotion_graph){
		obj->objs[1] = arg_reactions_by_emotion_graph;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "reactions_by_emotion_graph");
	}

	return obj;
}

tlo_t * tl_groupCallDiscarded(long arg_id, long arg_access_hash, int arg_duration)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "groupCallDiscarded");
	int i;
	obj->id = 0x7780bcb4;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[1]->name, "access_hash");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_duration);
	strcpy(obj->objs[2]->name, "duration");
	return obj;
}

tlo_t * tl_groupCall(bool arg_join_muted, bool arg_can_change_join_muted, bool arg_join_date_asc, bool arg_schedule_start_subscribed, bool arg_can_start_video, bool arg_record_video_active, bool arg_rtmp_stream, bool arg_listeners_hidden, long arg_id, long arg_access_hash, int arg_participants_count, const char * arg_title, int arg_stream_dc_id, int arg_record_start_date, int arg_schedule_date, int arg_unmuted_video_count, int arg_unmuted_video_limit, int arg_version)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "groupCall");
	int i;
	obj->id = 0xd597650c;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 19;
	obj->objs = 
		(tlo_t **)MALLOC(19 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_join_muted);
	strcpy(obj->objs[1]->name, "join_muted");
	if (arg_join_muted)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 2;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_can_change_join_muted);
	strcpy(obj->objs[2]->name, "can_change_join_muted");
	if (arg_can_change_join_muted)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 6;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_join_date_asc);
	strcpy(obj->objs[3]->name, "join_date_asc");
	if (arg_join_date_asc)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 8;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_schedule_start_subscribed);
	strcpy(obj->objs[4]->name, "schedule_start_subscribed");
	if (arg_schedule_start_subscribed)
		flagsv[nflags-1] |= (1 << 8);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 9;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_can_start_video);
	strcpy(obj->objs[5]->name, "can_start_video");
	if (arg_can_start_video)
		flagsv[nflags-1] |= (1 << 9);

	//parse argument true
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 11;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_record_video_active);
	strcpy(obj->objs[6]->name, "record_video_active");
	if (arg_record_video_active)
		flagsv[nflags-1] |= (1 << 11);

	//parse argument true
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 12;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_rtmp_stream);
	strcpy(obj->objs[7]->name, "rtmp_stream");
	if (arg_rtmp_stream)
		flagsv[nflags-1] |= (1 << 12);

	//parse argument true
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 13;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_listeners_hidden);
	strcpy(obj->objs[8]->name, "listeners_hidden");
	if (arg_listeners_hidden)
		flagsv[nflags-1] |= (1 << 13);

	//parse argument long
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 0;
	obj->objs[9]->flag_bit = 0;
	obj->objs[9]->type = TYPE_LONG;
	obj->objs[9]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[9]->name, "id");

	//parse argument long
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 0;
	obj->objs[10]->flag_bit = 0;
	obj->objs[10]->type = TYPE_LONG;
	obj->objs[10]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[10]->name, "access_hash");

	//parse argument int
	obj->objs[11] = NEW(tlo_t, return NULL);
	obj->objs[11]->flag_num = 0;
	obj->objs[11]->flag_bit = 0;
	obj->objs[11]->type = TYPE_INT;
	obj->objs[11]->value = 
		buf_add_ui32(arg_participants_count);
	strcpy(obj->objs[11]->name, "participants_count");

	//parse argument string
	if (arg_title){
		obj->objs[12] = NEW(tlo_t, return NULL);
		obj->objs[12]->flag_num = 1;
		obj->objs[12]->flag_bit = 3;
		obj->objs[12]->type = TYPE_STRING;
		obj->objs[12]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[12]->name, "title");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument int
	obj->objs[13] = NEW(tlo_t, return NULL);
	obj->objs[13]->flag_num = 1;
	obj->objs[13]->flag_bit = 4;
	obj->objs[13]->type = TYPE_INT;
	obj->objs[13]->value = 
		buf_add_ui32(arg_stream_dc_id);
	strcpy(obj->objs[13]->name, "stream_dc_id");
	if (arg_stream_dc_id)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument int
	obj->objs[14] = NEW(tlo_t, return NULL);
	obj->objs[14]->flag_num = 1;
	obj->objs[14]->flag_bit = 5;
	obj->objs[14]->type = TYPE_INT;
	obj->objs[14]->value = 
		buf_add_ui32(arg_record_start_date);
	strcpy(obj->objs[14]->name, "record_start_date");
	if (arg_record_start_date)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument int
	obj->objs[15] = NEW(tlo_t, return NULL);
	obj->objs[15]->flag_num = 1;
	obj->objs[15]->flag_bit = 7;
	obj->objs[15]->type = TYPE_INT;
	obj->objs[15]->value = 
		buf_add_ui32(arg_schedule_date);
	strcpy(obj->objs[15]->name, "schedule_date");
	if (arg_schedule_date)
		flagsv[nflags-1] |= (1 << 7);

	//parse argument int
	obj->objs[16] = NEW(tlo_t, return NULL);
	obj->objs[16]->flag_num = 1;
	obj->objs[16]->flag_bit = 10;
	obj->objs[16]->type = TYPE_INT;
	obj->objs[16]->value = 
		buf_add_ui32(arg_unmuted_video_count);
	strcpy(obj->objs[16]->name, "unmuted_video_count");
	if (arg_unmuted_video_count)
		flagsv[nflags-1] |= (1 << 10);

	//parse argument int
	obj->objs[17] = NEW(tlo_t, return NULL);
	obj->objs[17]->flag_num = 0;
	obj->objs[17]->flag_bit = 0;
	obj->objs[17]->type = TYPE_INT;
	obj->objs[17]->value = 
		buf_add_ui32(arg_unmuted_video_limit);
	strcpy(obj->objs[17]->name, "unmuted_video_limit");

	//parse argument int
	obj->objs[18] = NEW(tlo_t, return NULL);
	obj->objs[18]->flag_num = 0;
	obj->objs[18]->flag_bit = 0;
	obj->objs[18]->type = TYPE_INT;
	obj->objs[18]->value = 
		buf_add_ui32(arg_version);
	strcpy(obj->objs[18]->name, "version");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputGroupCall(long arg_id, long arg_access_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputGroupCall");
	int i;
	obj->id = 0xd8aa840f;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[1]->name, "access_hash");
	return obj;
}

tlo_t * tl_groupCallParticipant(bool arg_muted, bool arg_left, bool arg_can_self_unmute, bool arg_just_joined, bool arg_versioned, bool arg_min, bool arg_muted_by_you, bool arg_volume_by_admin, bool arg_self, bool arg_video_joined, Peer arg_peer, int arg_date, int arg_active_date, int arg_source, int arg_volume, const char * arg_about, long arg_raise_hand_rating, GroupCallParticipantVideo arg_video, GroupCallParticipantVideo arg_presentation)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "groupCallParticipant");
	int i;
	obj->id = 0xeba636fe;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 20;
	obj->objs = 
		(tlo_t **)MALLOC(20 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_muted);
	strcpy(obj->objs[1]->name, "muted");
	if (arg_muted)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_left);
	strcpy(obj->objs[2]->name, "left");
	if (arg_left)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_can_self_unmute);
	strcpy(obj->objs[3]->name, "can_self_unmute");
	if (arg_can_self_unmute)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 4;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_just_joined);
	strcpy(obj->objs[4]->name, "just_joined");
	if (arg_just_joined)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 5;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_versioned);
	strcpy(obj->objs[5]->name, "versioned");
	if (arg_versioned)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument true
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 8;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_min);
	strcpy(obj->objs[6]->name, "min");
	if (arg_min)
		flagsv[nflags-1] |= (1 << 8);

	//parse argument true
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 9;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_muted_by_you);
	strcpy(obj->objs[7]->name, "muted_by_you");
	if (arg_muted_by_you)
		flagsv[nflags-1] |= (1 << 9);

	//parse argument true
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 10;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_volume_by_admin);
	strcpy(obj->objs[8]->name, "volume_by_admin");
	if (arg_volume_by_admin)
		flagsv[nflags-1] |= (1 << 10);

	//parse argument true
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 1;
	obj->objs[9]->flag_bit = 12;
	obj->objs[9]->type = TYPE_INT;
	obj->objs[9]->value = 
		buf_add_ui32(arg_self);
	strcpy(obj->objs[9]->name, "self");
	if (arg_self)
		flagsv[nflags-1] |= (1 << 12);

	//parse argument true
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 1;
	obj->objs[10]->flag_bit = 15;
	obj->objs[10]->type = TYPE_INT;
	obj->objs[10]->value = 
		buf_add_ui32(arg_video_joined);
	strcpy(obj->objs[10]->name, "video_joined");
	if (arg_video_joined)
		flagsv[nflags-1] |= (1 << 15);

	//parse argument Peer
	if (arg_peer){
		obj->objs[11] = arg_peer;
		obj->objs[11]->flag_num = 0;
		obj->objs[11]->flag_bit = 0;
	strcpy(obj->objs[11]->name, "peer");
	}


	//parse argument int
	obj->objs[12] = NEW(tlo_t, return NULL);
	obj->objs[12]->flag_num = 0;
	obj->objs[12]->flag_bit = 0;
	obj->objs[12]->type = TYPE_INT;
	obj->objs[12]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[12]->name, "date");

	//parse argument int
	obj->objs[13] = NEW(tlo_t, return NULL);
	obj->objs[13]->flag_num = 1;
	obj->objs[13]->flag_bit = 3;
	obj->objs[13]->type = TYPE_INT;
	obj->objs[13]->value = 
		buf_add_ui32(arg_active_date);
	strcpy(obj->objs[13]->name, "active_date");
	if (arg_active_date)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument int
	obj->objs[14] = NEW(tlo_t, return NULL);
	obj->objs[14]->flag_num = 0;
	obj->objs[14]->flag_bit = 0;
	obj->objs[14]->type = TYPE_INT;
	obj->objs[14]->value = 
		buf_add_ui32(arg_source);
	strcpy(obj->objs[14]->name, "source");

	//parse argument int
	obj->objs[15] = NEW(tlo_t, return NULL);
	obj->objs[15]->flag_num = 1;
	obj->objs[15]->flag_bit = 7;
	obj->objs[15]->type = TYPE_INT;
	obj->objs[15]->value = 
		buf_add_ui32(arg_volume);
	strcpy(obj->objs[15]->name, "volume");
	if (arg_volume)
		flagsv[nflags-1] |= (1 << 7);

	//parse argument string
	if (arg_about){
		obj->objs[16] = NEW(tlo_t, return NULL);
		obj->objs[16]->flag_num = 1;
		obj->objs[16]->flag_bit = 11;
		obj->objs[16]->type = TYPE_STRING;
		obj->objs[16]->value = 
			buf_add((ui8_t *)arg_about, strlen(arg_about));
		strcpy(obj->objs[16]->name, "about");
		flagsv[nflags-1] |= (1 << 11);
	}


	//parse argument long
	obj->objs[17] = NEW(tlo_t, return NULL);
	obj->objs[17]->flag_num = 1;
	obj->objs[17]->flag_bit = 13;
	obj->objs[17]->type = TYPE_LONG;
	obj->objs[17]->value = 
		buf_add_ui64(arg_raise_hand_rating);
	strcpy(obj->objs[17]->name, "raise_hand_rating");
	if (arg_raise_hand_rating)
		flagsv[nflags-1] |= (1 << 13);

	//parse argument GroupCallParticipantVideo
	if (arg_video){
		obj->objs[18] = arg_video;
		obj->objs[18]->flag_num = 1;
		obj->objs[18]->flag_bit = 6;
	strcpy(obj->objs[18]->name, "video");
		flagsv[nflags-1] |= (1 << 6);
	}


	//parse argument GroupCallParticipantVideo
	if (arg_presentation){
		obj->objs[19] = arg_presentation;
		obj->objs[19]->flag_num = 1;
		obj->objs[19]->flag_bit = 14;
	strcpy(obj->objs[19]->name, "presentation");
		flagsv[nflags-1] |= (1 << 14);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_phone_groupCall(GroupCall arg_call, GroupCallParticipant *arg_participants, int len_arg_participants, const char * arg_participants_next_offset, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_groupCall");
	int i;
	obj->id = 0x9e727aad;
	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument GroupCall
	if (arg_call){
		obj->objs[0] = arg_call;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "call");
	}


	//parse argument Vector<GroupCallParticipant>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "participants");
	if (arg_participants){
		for(i=0; i<len_arg_participants; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_participants[i]->id);
			buf_cat(obj->objs[1]->value, arg_participants[i]->value);
		}
	}


	//parse argument string
	if (arg_participants_next_offset){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_participants_next_offset, strlen(arg_participants_next_offset));
		strcpy(obj->objs[2]->name, "participants_next_offset");
	}


	//parse argument Vector<Chat>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[3]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[4]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_phone_groupParticipants(int arg_count, GroupCallParticipant *arg_participants, int len_arg_participants, const char * arg_next_offset, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users, int arg_version)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_groupParticipants");
	int i;
	obj->id = 0xf47751b6;
	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[0]->name, "count");

	//parse argument Vector<GroupCallParticipant>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "participants");
	if (arg_participants){
		for(i=0; i<len_arg_participants; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_participants[i]->id);
			buf_cat(obj->objs[1]->value, arg_participants[i]->value);
		}
	}


	//parse argument string
	if (arg_next_offset){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_next_offset, strlen(arg_next_offset));
		strcpy(obj->objs[2]->name, "next_offset");
	}


	//parse argument Vector<Chat>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[3]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[4]->value, arg_users[i]->value);
		}
	}


	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_version);
	strcpy(obj->objs[5]->name, "version");
	return obj;
}

tlo_t * tl_inlineQueryPeerTypeSameBotPM()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inlineQueryPeerTypeSameBotPM");
	int i;
	obj->id = 0x3081ed9d;
	return obj;
}

tlo_t * tl_inlineQueryPeerTypePM()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inlineQueryPeerTypePM");
	int i;
	obj->id = 0x833c0fac;
	return obj;
}

tlo_t * tl_inlineQueryPeerTypeChat()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inlineQueryPeerTypeChat");
	int i;
	obj->id = 0xd766c50a;
	return obj;
}

tlo_t * tl_inlineQueryPeerTypeMegagroup()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inlineQueryPeerTypeMegagroup");
	int i;
	obj->id = 0x5ec4be43;
	return obj;
}

tlo_t * tl_inlineQueryPeerTypeBroadcast()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inlineQueryPeerTypeBroadcast");
	int i;
	obj->id = 0x6334ee9a;
	return obj;
}

tlo_t * tl_inlineQueryPeerTypeBotPM()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inlineQueryPeerTypeBotPM");
	int i;
	obj->id = 0x0e3b2d0c;
	return obj;
}

tlo_t * tl_messages_historyImport(long arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_historyImport");
	int i;
	obj->id = 0x1662af0b;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");
	return obj;
}

tlo_t * tl_messages_historyImportParsed(bool arg_pm, bool arg_group, const char * arg_title)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_historyImportParsed");
	int i;
	obj->id = 0x5e0fb7b9;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_pm);
	strcpy(obj->objs[1]->name, "pm");
	if (arg_pm)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_group);
	strcpy(obj->objs[2]->name, "group");
	if (arg_group)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument string
	if (arg_title){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 2;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[3]->name, "title");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_affectedFoundMessages(int arg_pts, int arg_pts_count, int arg_offset, int *arg_messages, int len_arg_messages)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_affectedFoundMessages");
	int i;
	obj->id = 0xef8d3e6c;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_pts);
	strcpy(obj->objs[0]->name, "pts");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_pts_count);
	strcpy(obj->objs[1]->name, "pts_count");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_offset);
	strcpy(obj->objs[2]->name, "offset");

	//parse argument Vector<int>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "messages");
	if (arg_messages){
		for(i=0; i<len_arg_messages; ++i){
			buf_t b = buf_add_ui32(arg_messages[i]);
			buf_cat(obj->objs[3]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_chatInviteImporter(bool arg_requested, bool arg_via_chatlist, long arg_user_id, int arg_date, const char * arg_about, long arg_approved_by)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatInviteImporter");
	int i;
	obj->id = 0x8c5adfd9;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_requested);
	strcpy(obj->objs[1]->name, "requested");
	if (arg_requested)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 3;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_via_chatlist);
	strcpy(obj->objs[2]->name, "via_chatlist");
	if (arg_via_chatlist)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[3]->name, "user_id");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[4]->name, "date");

	//parse argument string
	if (arg_about){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 2;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_about, strlen(arg_about));
		strcpy(obj->objs[5]->name, "about");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument long
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 1;
	obj->objs[6]->type = TYPE_LONG;
	obj->objs[6]->value = 
		buf_add_ui64(arg_approved_by);
	strcpy(obj->objs[6]->name, "approved_by");
	if (arg_approved_by)
		flagsv[nflags-1] |= (1 << 1);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_exportedChatInvites(int arg_count, ExportedChatInvite *arg_invites, int len_arg_invites, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_exportedChatInvites");
	int i;
	obj->id = 0xbdc62dcc;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[0]->name, "count");

	//parse argument Vector<ExportedChatInvite>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "invites");
	if (arg_invites){
		for(i=0; i<len_arg_invites; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_invites[i]->id);
			buf_cat(obj->objs[1]->value, arg_invites[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[2]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_messages_exportedChatInvite(ExportedChatInvite arg_invite, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_exportedChatInvite");
	int i;
	obj->id = 0x1871be50;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument ExportedChatInvite
	if (arg_invite){
		obj->objs[0] = arg_invite;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "invite");
	}


	//parse argument Vector<User>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[1]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_messages_exportedChatInviteReplaced(ExportedChatInvite arg_invite, ExportedChatInvite arg_new_invite, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_exportedChatInviteReplaced");
	int i;
	obj->id = 0x222600ef;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument ExportedChatInvite
	if (arg_invite){
		obj->objs[0] = arg_invite;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "invite");
	}


	//parse argument ExportedChatInvite
	if (arg_new_invite){
		obj->objs[1] = arg_new_invite;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "new_invite");
	}


	//parse argument Vector<User>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[2]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_messages_chatInviteImporters(int arg_count, ChatInviteImporter *arg_importers, int len_arg_importers, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_chatInviteImporters");
	int i;
	obj->id = 0x81b6b00a;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[0]->name, "count");

	//parse argument Vector<ChatInviteImporter>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "importers");
	if (arg_importers){
		for(i=0; i<len_arg_importers; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_importers[i]->id);
			buf_cat(obj->objs[1]->value, arg_importers[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[2]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_chatAdminWithInvites(long arg_admin_id, int arg_invites_count, int arg_revoked_invites_count)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatAdminWithInvites");
	int i;
	obj->id = 0xf2ecef23;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_admin_id);
	strcpy(obj->objs[0]->name, "admin_id");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_invites_count);
	strcpy(obj->objs[1]->name, "invites_count");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_revoked_invites_count);
	strcpy(obj->objs[2]->name, "revoked_invites_count");
	return obj;
}

tlo_t * tl_messages_chatAdminsWithInvites(ChatAdminWithInvites *arg_admins, int len_arg_admins, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_chatAdminsWithInvites");
	int i;
	obj->id = 0xb69b72d7;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<ChatAdminWithInvites>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "admins");
	if (arg_admins){
		for(i=0; i<len_arg_admins; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_admins[i]->id);
			buf_cat(obj->objs[0]->value, arg_admins[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[1]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_messages_checkedHistoryImportPeer(const char * arg_confirm_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_checkedHistoryImportPeer");
	int i;
	obj->id = 0xa24de717;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_confirm_text){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_confirm_text, strlen(arg_confirm_text));
		strcpy(obj->objs[0]->name, "confirm_text");
	}

	return obj;
}

tlo_t * tl_phone_joinAsPeers(Peer *arg_peers, int len_arg_peers, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_joinAsPeers");
	int i;
	obj->id = 0xafe5623f;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<Peer>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "peers");
	if (arg_peers){
		for(i=0; i<len_arg_peers; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_peers[i]->id);
			buf_cat(obj->objs[0]->value, arg_peers[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[1]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[2]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_phone_exportedGroupCallInvite(const char * arg_link)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_exportedGroupCallInvite");
	int i;
	obj->id = 0x204bd158;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_link){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_link, strlen(arg_link));
		strcpy(obj->objs[0]->name, "link");
	}

	return obj;
}

tlo_t * tl_groupCallParticipantVideoSourceGroup(const char * arg_semantics, int *arg_sources, int len_arg_sources)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "groupCallParticipantVideoSourceGroup");
	int i;
	obj->id = 0xdcb118b7;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_semantics){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_semantics, strlen(arg_semantics));
		strcpy(obj->objs[0]->name, "semantics");
	}


	//parse argument Vector<int>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "sources");
	if (arg_sources){
		for(i=0; i<len_arg_sources; ++i){
			buf_t b = buf_add_ui32(arg_sources[i]);
			buf_cat(obj->objs[1]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_groupCallParticipantVideo(bool arg_paused, const char * arg_endpoint, GroupCallParticipantVideoSourceGroup *arg_source_groups, int len_arg_source_groups, int arg_audio_source)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "groupCallParticipantVideo");
	int i;
	obj->id = 0x67753ac8;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_paused);
	strcpy(obj->objs[1]->name, "paused");
	if (arg_paused)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument string
	if (arg_endpoint){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_endpoint, strlen(arg_endpoint));
		strcpy(obj->objs[2]->name, "endpoint");
	}


	//parse argument Vector<GroupCallParticipantVideoSourceGroup>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "source_groups");
	if (arg_source_groups){
		for(i=0; i<len_arg_source_groups; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_source_groups[i]->id);
			buf_cat(obj->objs[3]->value, arg_source_groups[i]->value);
		}
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 1;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_audio_source);
	strcpy(obj->objs[4]->name, "audio_source");
	if (arg_audio_source)
		flagsv[nflags-1] |= (1 << 1);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_stickers_suggestedShortName(const char * arg_short_name)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stickers_suggestedShortName");
	int i;
	obj->id = 0x85fea03f;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_short_name){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_short_name, strlen(arg_short_name));
		strcpy(obj->objs[0]->name, "short_name");
	}

	return obj;
}

tlo_t * tl_botCommandScopeDefault()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "botCommandScopeDefault");
	int i;
	obj->id = 0x2f6cb2ab;
	return obj;
}

tlo_t * tl_botCommandScopeUsers()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "botCommandScopeUsers");
	int i;
	obj->id = 0x3c4f04d8;
	return obj;
}

tlo_t * tl_botCommandScopeChats()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "botCommandScopeChats");
	int i;
	obj->id = 0x6fe1a881;
	return obj;
}

tlo_t * tl_botCommandScopeChatAdmins()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "botCommandScopeChatAdmins");
	int i;
	obj->id = 0xb9aa606a;
	return obj;
}

tlo_t * tl_botCommandScopePeer(InputPeer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "botCommandScopePeer");
	int i;
	obj->id = 0xdb9d897d;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}

	return obj;
}

tlo_t * tl_botCommandScopePeerAdmins(InputPeer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "botCommandScopePeerAdmins");
	int i;
	obj->id = 0x3fd863d1;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}

	return obj;
}

tlo_t * tl_botCommandScopePeerUser(InputPeer arg_peer, InputUser arg_user_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "botCommandScopePeerUser");
	int i;
	obj->id = 0x0a1321f3;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument InputUser
	if (arg_user_id){
		obj->objs[1] = arg_user_id;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "user_id");
	}

	return obj;
}

tlo_t * tl_account_resetPasswordFailedWait(int arg_retry_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_resetPasswordFailedWait");
	int i;
	obj->id = 0xe3779861;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_retry_date);
	strcpy(obj->objs[0]->name, "retry_date");
	return obj;
}

tlo_t * tl_account_resetPasswordRequestedWait(int arg_until_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_resetPasswordRequestedWait");
	int i;
	obj->id = 0xe9effc7d;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_until_date);
	strcpy(obj->objs[0]->name, "until_date");
	return obj;
}

tlo_t * tl_account_resetPasswordOk()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_resetPasswordOk");
	int i;
	obj->id = 0xe926d63e;
	return obj;
}

tlo_t * tl_sponsoredMessage(bool arg_recommended, bool arg_can_report, unsigned char * arg_random_id, int len_arg_random_id, const char * arg_url, const char * arg_title, const char * arg_message, MessageEntity *arg_entities, int len_arg_entities, Photo arg_photo, MessageMedia arg_media, PeerColor arg_color, const char * arg_button_text, const char * arg_sponsor_info, const char * arg_additional_info)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "sponsoredMessage");
	int i;
	obj->id = 0x4d93a990;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 14;
	obj->objs = 
		(tlo_t **)MALLOC(14 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 5;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_recommended);
	strcpy(obj->objs[1]->name, "recommended");
	if (arg_recommended)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 12;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_can_report);
	strcpy(obj->objs[2]->name, "can_report");
	if (arg_can_report)
		flagsv[nflags-1] |= (1 << 12);

	//parse argument bytes
	if (arg_random_id){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_BYTES;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_random_id, len_arg_random_id);
		strcpy(obj->objs[3]->name, "random_id");
	}


	//parse argument string
	if (arg_url){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[4]->name, "url");
	}


	//parse argument string
	if (arg_title){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[5]->name, "title");
	}


	//parse argument string
	if (arg_message){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_message, strlen(arg_message));
		strcpy(obj->objs[6]->name, "message");
	}


	//parse argument Vector<MessageEntity>
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 1;
	obj->objs[7]->type = TYPE_VECTOR;
	strcpy(obj->objs[7]->name, "entities");
	if (arg_entities){
		for(i=0; i<len_arg_entities; ++i){
			obj->objs[7]->value = buf_add_ui32(arg_entities[i]->id);
			buf_cat(obj->objs[7]->value, arg_entities[i]->value);
		}
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument Photo
	if (arg_photo){
		obj->objs[8] = arg_photo;
		obj->objs[8]->flag_num = 1;
		obj->objs[8]->flag_bit = 6;
	strcpy(obj->objs[8]->name, "photo");
		flagsv[nflags-1] |= (1 << 6);
	}


	//parse argument MessageMedia
	if (arg_media){
		obj->objs[9] = arg_media;
		obj->objs[9]->flag_num = 1;
		obj->objs[9]->flag_bit = 14;
	strcpy(obj->objs[9]->name, "media");
		flagsv[nflags-1] |= (1 << 14);
	}


	//parse argument PeerColor
	if (arg_color){
		obj->objs[10] = arg_color;
		obj->objs[10]->flag_num = 1;
		obj->objs[10]->flag_bit = 13;
	strcpy(obj->objs[10]->name, "color");
		flagsv[nflags-1] |= (1 << 13);
	}


	//parse argument string
	if (arg_button_text){
		obj->objs[11] = NEW(tlo_t, return NULL);
		obj->objs[11]->flag_num = 0;
		obj->objs[11]->flag_bit = 0;
		obj->objs[11]->type = TYPE_STRING;
		obj->objs[11]->value = 
			buf_add((ui8_t *)arg_button_text, strlen(arg_button_text));
		strcpy(obj->objs[11]->name, "button_text");
	}


	//parse argument string
	if (arg_sponsor_info){
		obj->objs[12] = NEW(tlo_t, return NULL);
		obj->objs[12]->flag_num = 1;
		obj->objs[12]->flag_bit = 7;
		obj->objs[12]->type = TYPE_STRING;
		obj->objs[12]->value = 
			buf_add((ui8_t *)arg_sponsor_info, strlen(arg_sponsor_info));
		strcpy(obj->objs[12]->name, "sponsor_info");
		flagsv[nflags-1] |= (1 << 7);
	}


	//parse argument string
	if (arg_additional_info){
		obj->objs[13] = NEW(tlo_t, return NULL);
		obj->objs[13]->flag_num = 1;
		obj->objs[13]->flag_bit = 8;
		obj->objs[13]->type = TYPE_STRING;
		obj->objs[13]->value = 
			buf_add((ui8_t *)arg_additional_info, strlen(arg_additional_info));
		strcpy(obj->objs[13]->name, "additional_info");
		flagsv[nflags-1] |= (1 << 8);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_sponsoredMessages(int arg_posts_between, SponsoredMessage *arg_messages, int len_arg_messages, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_sponsoredMessages");
	int i;
	obj->id = 0xc9ee1d87;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_posts_between);
	strcpy(obj->objs[1]->name, "posts_between");
	if (arg_posts_between)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument Vector<SponsoredMessage>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "messages");
	if (arg_messages){
		for(i=0; i<len_arg_messages; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_messages[i]->id);
			buf_cat(obj->objs[2]->value, arg_messages[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[3]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[4]->value, arg_users[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_sponsoredMessagesEmpty()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_sponsoredMessagesEmpty");
	int i;
	obj->id = 0x1839490f;
	return obj;
}

tlo_t * tl_searchResultsCalendarPeriod(int arg_date, int arg_min_msg_id, int arg_max_msg_id, int arg_count)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "searchResultsCalendarPeriod");
	int i;
	obj->id = 0xc9b0539f;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[0]->name, "date");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_min_msg_id);
	strcpy(obj->objs[1]->name, "min_msg_id");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_max_msg_id);
	strcpy(obj->objs[2]->name, "max_msg_id");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[3]->name, "count");
	return obj;
}

tlo_t * tl_messages_searchResultsCalendar(bool arg_inexact, int arg_count, int arg_min_date, int arg_min_msg_id, int arg_offset_id_offset, SearchResultsCalendarPeriod *arg_periods, int len_arg_periods, Message *arg_messages, int len_arg_messages, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_searchResultsCalendar");
	int i;
	obj->id = 0x147ee23c;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 10;
	obj->objs = 
		(tlo_t **)MALLOC(10 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_inexact);
	strcpy(obj->objs[1]->name, "inexact");
	if (arg_inexact)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[2]->name, "count");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_min_date);
	strcpy(obj->objs[3]->name, "min_date");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_min_msg_id);
	strcpy(obj->objs[4]->name, "min_msg_id");

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 1;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_offset_id_offset);
	strcpy(obj->objs[5]->name, "offset_id_offset");
	if (arg_offset_id_offset)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument Vector<SearchResultsCalendarPeriod>
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_VECTOR;
	strcpy(obj->objs[6]->name, "periods");
	if (arg_periods){
		for(i=0; i<len_arg_periods; ++i){
			obj->objs[6]->value = buf_add_ui32(arg_periods[i]->id);
			buf_cat(obj->objs[6]->value, arg_periods[i]->value);
		}
	}


	//parse argument Vector<Message>
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_VECTOR;
	strcpy(obj->objs[7]->name, "messages");
	if (arg_messages){
		for(i=0; i<len_arg_messages; ++i){
			obj->objs[7]->value = buf_add_ui32(arg_messages[i]->id);
			buf_cat(obj->objs[7]->value, arg_messages[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 0;
	obj->objs[8]->flag_bit = 0;
	obj->objs[8]->type = TYPE_VECTOR;
	strcpy(obj->objs[8]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[8]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[8]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 0;
	obj->objs[9]->flag_bit = 0;
	obj->objs[9]->type = TYPE_VECTOR;
	strcpy(obj->objs[9]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[9]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[9]->value, arg_users[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_searchResultPosition(int arg_msg_id, int arg_date, int arg_offset)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "searchResultPosition");
	int i;
	obj->id = 0x7f648b67;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[0]->name, "msg_id");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[1]->name, "date");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_offset);
	strcpy(obj->objs[2]->name, "offset");
	return obj;
}

tlo_t * tl_messages_searchResultsPositions(int arg_count, SearchResultsPosition *arg_positions, int len_arg_positions)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_searchResultsPositions");
	int i;
	obj->id = 0x53b22baf;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[0]->name, "count");

	//parse argument Vector<SearchResultsPosition>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "positions");
	if (arg_positions){
		for(i=0; i<len_arg_positions; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_positions[i]->id);
			buf_cat(obj->objs[1]->value, arg_positions[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_channels_sendAsPeers(SendAsPeer *arg_peers, int len_arg_peers, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_sendAsPeers");
	int i;
	obj->id = 0xf496b0c6;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<SendAsPeer>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "peers");
	if (arg_peers){
		for(i=0; i<len_arg_peers; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_peers[i]->id);
			buf_cat(obj->objs[0]->value, arg_peers[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[1]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[2]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_users_userFull(UserFull arg_full_user, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "users_userFull");
	int i;
	obj->id = 0x3b6d152e;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument UserFull
	if (arg_full_user){
		obj->objs[0] = arg_full_user;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "full_user");
	}


	//parse argument Vector<Chat>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[1]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[2]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_messages_peerSettings(PeerSettings arg_settings, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_peerSettings");
	int i;
	obj->id = 0x6880b94d;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument PeerSettings
	if (arg_settings){
		obj->objs[0] = arg_settings;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "settings");
	}


	//parse argument Vector<Chat>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[1]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[2]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_auth_loggedOut(unsigned char * arg_future_auth_token, int len_arg_future_auth_token)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_loggedOut");
	int i;
	obj->id = 0xc3a2835f;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument bytes
	if (arg_future_auth_token){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_future_auth_token, len_arg_future_auth_token);
		strcpy(obj->objs[1]->name, "future_auth_token");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_reactionCount(int arg_chosen_order, Reaction arg_reaction, int arg_count)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "reactionCount");
	int i;
	obj->id = 0xa3d1cb80;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_chosen_order);
	strcpy(obj->objs[1]->name, "chosen_order");
	if (arg_chosen_order)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument Reaction
	if (arg_reaction){
		obj->objs[2] = arg_reaction;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "reaction");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[3]->name, "count");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messageReactions(bool arg_min, bool arg_can_see_list, bool arg_reactions_as_tags, ReactionCount *arg_results, int len_arg_results, MessagePeerReaction *arg_recent_reactions, int len_arg_recent_reactions, MessageReactor *arg_top_reactors, int len_arg_top_reactors)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageReactions");
	int i;
	obj->id = 0x0a339f0b;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_min);
	strcpy(obj->objs[1]->name, "min");
	if (arg_min)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 2;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_can_see_list);
	strcpy(obj->objs[2]->name, "can_see_list");
	if (arg_can_see_list)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 3;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_reactions_as_tags);
	strcpy(obj->objs[3]->name, "reactions_as_tags");
	if (arg_reactions_as_tags)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument Vector<ReactionCount>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "results");
	if (arg_results){
		for(i=0; i<len_arg_results; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_results[i]->id);
			buf_cat(obj->objs[4]->value, arg_results[i]->value);
		}
	}


	//parse argument Vector<MessagePeerReaction>
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 1;
	obj->objs[5]->type = TYPE_VECTOR;
	strcpy(obj->objs[5]->name, "recent_reactions");
	if (arg_recent_reactions){
		for(i=0; i<len_arg_recent_reactions; ++i){
			obj->objs[5]->value = buf_add_ui32(arg_recent_reactions[i]->id);
			buf_cat(obj->objs[5]->value, arg_recent_reactions[i]->value);
		}
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument Vector<MessageReactor>
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 4;
	obj->objs[6]->type = TYPE_VECTOR;
	strcpy(obj->objs[6]->name, "top_reactors");
	if (arg_top_reactors){
		for(i=0; i<len_arg_top_reactors; ++i){
			obj->objs[6]->value = buf_add_ui32(arg_top_reactors[i]->id);
			buf_cat(obj->objs[6]->value, arg_top_reactors[i]->value);
		}
		flagsv[nflags-1] |= (1 << 4);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_messageReactionsList(int arg_count, MessagePeerReaction *arg_reactions, int len_arg_reactions, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users, const char * arg_next_offset)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_messageReactionsList");
	int i;
	obj->id = 0x31bd492d;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[1]->name, "count");

	//parse argument Vector<MessagePeerReaction>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "reactions");
	if (arg_reactions){
		for(i=0; i<len_arg_reactions; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_reactions[i]->id);
			buf_cat(obj->objs[2]->value, arg_reactions[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[3]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[4]->value, arg_users[i]->value);
		}
	}


	//parse argument string
	if (arg_next_offset){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_next_offset, strlen(arg_next_offset));
		strcpy(obj->objs[5]->name, "next_offset");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_availableReaction(bool arg_inactive, bool arg_premium, const char * arg_reaction, const char * arg_title, Document arg_static_icon, Document arg_appear_animation, Document arg_select_animation, Document arg_activate_animation, Document arg_effect_animation, Document arg_around_animation, Document arg_center_icon)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "availableReaction");
	int i;
	obj->id = 0xc077ec01;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 12;
	obj->objs = 
		(tlo_t **)MALLOC(12 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_inactive);
	strcpy(obj->objs[1]->name, "inactive");
	if (arg_inactive)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 2;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_premium);
	strcpy(obj->objs[2]->name, "premium");
	if (arg_premium)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument string
	if (arg_reaction){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_reaction, strlen(arg_reaction));
		strcpy(obj->objs[3]->name, "reaction");
	}


	//parse argument string
	if (arg_title){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[4]->name, "title");
	}


	//parse argument Document
	if (arg_static_icon){
		obj->objs[5] = arg_static_icon;
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
	strcpy(obj->objs[5]->name, "static_icon");
	}


	//parse argument Document
	if (arg_appear_animation){
		obj->objs[6] = arg_appear_animation;
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
	strcpy(obj->objs[6]->name, "appear_animation");
	}


	//parse argument Document
	if (arg_select_animation){
		obj->objs[7] = arg_select_animation;
		obj->objs[7]->flag_num = 0;
		obj->objs[7]->flag_bit = 0;
	strcpy(obj->objs[7]->name, "select_animation");
	}


	//parse argument Document
	if (arg_activate_animation){
		obj->objs[8] = arg_activate_animation;
		obj->objs[8]->flag_num = 0;
		obj->objs[8]->flag_bit = 0;
	strcpy(obj->objs[8]->name, "activate_animation");
	}


	//parse argument Document
	if (arg_effect_animation){
		obj->objs[9] = arg_effect_animation;
		obj->objs[9]->flag_num = 0;
		obj->objs[9]->flag_bit = 0;
	strcpy(obj->objs[9]->name, "effect_animation");
	}


	//parse argument Document
	if (arg_around_animation){
		obj->objs[10] = arg_around_animation;
		obj->objs[10]->flag_num = 1;
		obj->objs[10]->flag_bit = 1;
	strcpy(obj->objs[10]->name, "around_animation");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument Document
	if (arg_center_icon){
		obj->objs[11] = arg_center_icon;
		obj->objs[11]->flag_num = 1;
		obj->objs[11]->flag_bit = 1;
	strcpy(obj->objs[11]->name, "center_icon");
		flagsv[nflags-1] |= (1 << 1);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_availableReactionsNotModified()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_availableReactionsNotModified");
	int i;
	obj->id = 0x9f071957;
	return obj;
}

tlo_t * tl_messages_availableReactions(int arg_hash, AvailableReaction *arg_reactions, int len_arg_reactions)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_availableReactions");
	int i;
	obj->id = 0x768e3aad;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_hash);
	strcpy(obj->objs[0]->name, "hash");

	//parse argument Vector<AvailableReaction>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "reactions");
	if (arg_reactions){
		for(i=0; i<len_arg_reactions; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_reactions[i]->id);
			buf_cat(obj->objs[1]->value, arg_reactions[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_messagePeerReaction(bool arg_big, bool arg_unread, bool arg_my, Peer arg_peer_id, int arg_date, Reaction arg_reaction)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messagePeerReaction");
	int i;
	obj->id = 0x8c79b63c;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_big);
	strcpy(obj->objs[1]->name, "big");
	if (arg_big)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_unread);
	strcpy(obj->objs[2]->name, "unread");
	if (arg_unread)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_my);
	strcpy(obj->objs[3]->name, "my");
	if (arg_my)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument Peer
	if (arg_peer_id){
		obj->objs[4] = arg_peer_id;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "peer_id");
	}


	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[5]->name, "date");

	//parse argument Reaction
	if (arg_reaction){
		obj->objs[6] = arg_reaction;
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
	strcpy(obj->objs[6]->name, "reaction");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_groupCallStreamChannel(int arg_channel, int arg_scale, long arg_last_timestamp_ms)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "groupCallStreamChannel");
	int i;
	obj->id = 0x80eb48af;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_channel);
	strcpy(obj->objs[0]->name, "channel");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_scale);
	strcpy(obj->objs[1]->name, "scale");

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_last_timestamp_ms);
	strcpy(obj->objs[2]->name, "last_timestamp_ms");
	return obj;
}

tlo_t * tl_phone_groupCallStreamChannels(GroupCallStreamChannel *arg_channels, int len_arg_channels)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_groupCallStreamChannels");
	int i;
	obj->id = 0xd0e482b2;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<GroupCallStreamChannel>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "channels");
	if (arg_channels){
		for(i=0; i<len_arg_channels; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_channels[i]->id);
			buf_cat(obj->objs[0]->value, arg_channels[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_phone_groupCallStreamRtmpUrl(const char * arg_url, const char * arg_key)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_groupCallStreamRtmpUrl");
	int i;
	obj->id = 0x2dbf3432;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_url){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[0]->name, "url");
	}


	//parse argument string
	if (arg_key){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_key, strlen(arg_key));
		strcpy(obj->objs[1]->name, "key");
	}

	return obj;
}

tlo_t * tl_attachMenuBotIconColor(const char * arg_name, int arg_color)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "attachMenuBotIconColor");
	int i;
	obj->id = 0x4576f3f0;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_name){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_name, strlen(arg_name));
		strcpy(obj->objs[0]->name, "name");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_color);
	strcpy(obj->objs[1]->name, "color");
	return obj;
}

tlo_t * tl_attachMenuBotIcon(const char * arg_name, Document arg_icon, AttachMenuBotIconColor *arg_colors, int len_arg_colors)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "attachMenuBotIcon");
	int i;
	obj->id = 0xb2a7386b;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_name){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_name, strlen(arg_name));
		strcpy(obj->objs[1]->name, "name");
	}


	//parse argument Document
	if (arg_icon){
		obj->objs[2] = arg_icon;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "icon");
	}


	//parse argument Vector<AttachMenuBotIconColor>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "colors");
	if (arg_colors){
		for(i=0; i<len_arg_colors; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_colors[i]->id);
			buf_cat(obj->objs[3]->value, arg_colors[i]->value);
		}
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_attachMenuBot(bool arg_inactive, bool arg_has_settings, bool arg_request_write_access, bool arg_show_in_attach_menu, bool arg_show_in_side_menu, bool arg_side_menu_disclaimer_needed, long arg_bot_id, const char * arg_short_name, AttachMenuPeerType *arg_peer_types, int len_arg_peer_types, AttachMenuBotIcon *arg_icons, int len_arg_icons)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "attachMenuBot");
	int i;
	obj->id = 0xd90d8dfe;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 11;
	obj->objs = 
		(tlo_t **)MALLOC(11 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_inactive);
	strcpy(obj->objs[1]->name, "inactive");
	if (arg_inactive)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_has_settings);
	strcpy(obj->objs[2]->name, "has_settings");
	if (arg_has_settings)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_request_write_access);
	strcpy(obj->objs[3]->name, "request_write_access");
	if (arg_request_write_access)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 3;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_show_in_attach_menu);
	strcpy(obj->objs[4]->name, "show_in_attach_menu");
	if (arg_show_in_attach_menu)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 4;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_show_in_side_menu);
	strcpy(obj->objs[5]->name, "show_in_side_menu");
	if (arg_show_in_side_menu)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument true
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 5;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_side_menu_disclaimer_needed);
	strcpy(obj->objs[6]->name, "side_menu_disclaimer_needed");
	if (arg_side_menu_disclaimer_needed)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument long
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_LONG;
	obj->objs[7]->value = 
		buf_add_ui64(arg_bot_id);
	strcpy(obj->objs[7]->name, "bot_id");

	//parse argument string
	if (arg_short_name){
		obj->objs[8] = NEW(tlo_t, return NULL);
		obj->objs[8]->flag_num = 0;
		obj->objs[8]->flag_bit = 0;
		obj->objs[8]->type = TYPE_STRING;
		obj->objs[8]->value = 
			buf_add((ui8_t *)arg_short_name, strlen(arg_short_name));
		strcpy(obj->objs[8]->name, "short_name");
	}


	//parse argument Vector<AttachMenuPeerType>
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 1;
	obj->objs[9]->flag_bit = 3;
	obj->objs[9]->type = TYPE_VECTOR;
	strcpy(obj->objs[9]->name, "peer_types");
	if (arg_peer_types){
		for(i=0; i<len_arg_peer_types; ++i){
			obj->objs[9]->value = buf_add_ui32(arg_peer_types[i]->id);
			buf_cat(obj->objs[9]->value, arg_peer_types[i]->value);
		}
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument Vector<AttachMenuBotIcon>
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 0;
	obj->objs[10]->flag_bit = 0;
	obj->objs[10]->type = TYPE_VECTOR;
	strcpy(obj->objs[10]->name, "icons");
	if (arg_icons){
		for(i=0; i<len_arg_icons; ++i){
			obj->objs[10]->value = buf_add_ui32(arg_icons[i]->id);
			buf_cat(obj->objs[10]->value, arg_icons[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_attachMenuBotsNotModified()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "attachMenuBotsNotModified");
	int i;
	obj->id = 0xf1d88a5c;
	return obj;
}

tlo_t * tl_attachMenuBots(long arg_hash, AttachMenuBot *arg_bots, int len_arg_bots, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "attachMenuBots");
	int i;
	obj->id = 0x3c4301c0;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");

	//parse argument Vector<AttachMenuBot>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "bots");
	if (arg_bots){
		for(i=0; i<len_arg_bots; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_bots[i]->id);
			buf_cat(obj->objs[1]->value, arg_bots[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[2]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_attachMenuBotsBot(AttachMenuBot arg_bot, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "attachMenuBotsBot");
	int i;
	obj->id = 0x93bf667f;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument AttachMenuBot
	if (arg_bot){
		obj->objs[0] = arg_bot;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "bot");
	}


	//parse argument Vector<User>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[1]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_webViewResultUrl(bool arg_fullsize, long arg_query_id, const char * arg_url)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "webViewResultUrl");
	int i;
	obj->id = 0x4d22ff98;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_fullsize);
	strcpy(obj->objs[1]->name, "fullsize");
	if (arg_fullsize)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_query_id);
	strcpy(obj->objs[2]->name, "query_id");
	if (arg_query_id)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument string
	if (arg_url){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[3]->name, "url");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_webViewMessageSent(InputBotInlineMessageID arg_msg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "webViewMessageSent");
	int i;
	obj->id = 0x0c94511c;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputBotInlineMessageID
	if (arg_msg_id){
		obj->objs[1] = arg_msg_id;
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "msg_id");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_botMenuButtonDefault()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "botMenuButtonDefault");
	int i;
	obj->id = 0x7533a588;
	return obj;
}

tlo_t * tl_botMenuButtonCommands()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "botMenuButtonCommands");
	int i;
	obj->id = 0x4258c205;
	return obj;
}

tlo_t * tl_botMenuButton(const char * arg_text, const char * arg_url)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "botMenuButton");
	int i;
	obj->id = 0xc7b57ce6;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_text){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[0]->name, "text");
	}


	//parse argument string
	if (arg_url){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[1]->name, "url");
	}

	return obj;
}

tlo_t * tl_account_savedRingtonesNotModified()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_savedRingtonesNotModified");
	int i;
	obj->id = 0xfbf6e8b1;
	return obj;
}

tlo_t * tl_account_savedRingtones(long arg_hash, Document *arg_ringtones, int len_arg_ringtones)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_savedRingtones");
	int i;
	obj->id = 0xc1e92cc5;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");

	//parse argument Vector<Document>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "ringtones");
	if (arg_ringtones){
		for(i=0; i<len_arg_ringtones; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_ringtones[i]->id);
			buf_cat(obj->objs[1]->value, arg_ringtones[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_notificationSoundDefault()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "notificationSoundDefault");
	int i;
	obj->id = 0x97e8bebe;
	return obj;
}

tlo_t * tl_notificationSoundNone()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "notificationSoundNone");
	int i;
	obj->id = 0x6f0c34df;
	return obj;
}

tlo_t * tl_notificationSoundLocal(const char * arg_title, const char * arg_data)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "notificationSoundLocal");
	int i;
	obj->id = 0x830b9ae4;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_title){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[0]->name, "title");
	}


	//parse argument string
	if (arg_data){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_data, strlen(arg_data));
		strcpy(obj->objs[1]->name, "data");
	}

	return obj;
}

tlo_t * tl_notificationSoundRingtone(long arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "notificationSoundRingtone");
	int i;
	obj->id = 0xff6c8049;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");
	return obj;
}

tlo_t * tl_account_savedRingtone()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_savedRingtone");
	int i;
	obj->id = 0xb7263f6d;
	return obj;
}

tlo_t * tl_account_savedRingtoneConverted(Document arg_document)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_savedRingtoneConverted");
	int i;
	obj->id = 0x1f307eb7;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Document
	if (arg_document){
		obj->objs[0] = arg_document;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "document");
	}

	return obj;
}

tlo_t * tl_attachMenuPeerTypeSameBotPM()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "attachMenuPeerTypeSameBotPM");
	int i;
	obj->id = 0x7d6be90e;
	return obj;
}

tlo_t * tl_attachMenuPeerTypeBotPM()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "attachMenuPeerTypeBotPM");
	int i;
	obj->id = 0xc32bfa1a;
	return obj;
}

tlo_t * tl_attachMenuPeerTypePM()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "attachMenuPeerTypePM");
	int i;
	obj->id = 0xf146d31f;
	return obj;
}

tlo_t * tl_attachMenuPeerTypeChat()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "attachMenuPeerTypeChat");
	int i;
	obj->id = 0x0509113f;
	return obj;
}

tlo_t * tl_attachMenuPeerTypeBroadcast()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "attachMenuPeerTypeBroadcast");
	int i;
	obj->id = 0x7bfbdefc;
	return obj;
}

tlo_t * tl_inputInvoiceMessage(InputPeer arg_peer, int arg_msg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputInvoiceMessage");
	int i;
	obj->id = 0xc5b56859;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[1]->name, "msg_id");
	return obj;
}

tlo_t * tl_inputInvoiceSlug(const char * arg_slug)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputInvoiceSlug");
	int i;
	obj->id = 0xc326caef;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_slug){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_slug, strlen(arg_slug));
		strcpy(obj->objs[0]->name, "slug");
	}

	return obj;
}

tlo_t * tl_inputInvoicePremiumGiftCode(InputStorePaymentPurpose arg_purpose, PremiumGiftCodeOption arg_option)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputInvoicePremiumGiftCode");
	int i;
	obj->id = 0x98986c0d;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputStorePaymentPurpose
	if (arg_purpose){
		obj->objs[0] = arg_purpose;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "purpose");
	}


	//parse argument PremiumGiftCodeOption
	if (arg_option){
		obj->objs[1] = arg_option;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "option");
	}

	return obj;
}

tlo_t * tl_inputInvoiceStars(InputStorePaymentPurpose arg_purpose)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputInvoiceStars");
	int i;
	obj->id = 0x65f00ce3;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputStorePaymentPurpose
	if (arg_purpose){
		obj->objs[0] = arg_purpose;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "purpose");
	}

	return obj;
}

tlo_t * tl_inputInvoiceChatInviteSubscription(const char * arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputInvoiceChatInviteSubscription");
	int i;
	obj->id = 0x34e793f1;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_hash){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_hash, strlen(arg_hash));
		strcpy(obj->objs[0]->name, "hash");
	}

	return obj;
}

tlo_t * tl_inputInvoiceStarGift(bool arg_hide_name, InputUser arg_user_id, long arg_gift_id, TextWithEntities arg_message)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputInvoiceStarGift");
	int i;
	obj->id = 0x25d8c1d8;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_hide_name);
	strcpy(obj->objs[1]->name, "hide_name");
	if (arg_hide_name)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputUser
	if (arg_user_id){
		obj->objs[2] = arg_user_id;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "user_id");
	}


	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_gift_id);
	strcpy(obj->objs[3]->name, "gift_id");

	//parse argument TextWithEntities
	if (arg_message){
		obj->objs[4] = arg_message;
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 1;
	strcpy(obj->objs[4]->name, "message");
		flagsv[nflags-1] |= (1 << 1);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_payments_exportedInvoice(const char * arg_url)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_exportedInvoice");
	int i;
	obj->id = 0xaed0cbd9;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_url){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[0]->name, "url");
	}

	return obj;
}

tlo_t * tl_messages_transcribedAudio(bool arg_pending, long arg_transcription_id, const char * arg_text, int arg_trial_remains_num, int arg_trial_remains_until_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_transcribedAudio");
	int i;
	obj->id = 0xcfb9d957;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_pending);
	strcpy(obj->objs[1]->name, "pending");
	if (arg_pending)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_transcription_id);
	strcpy(obj->objs[2]->name, "transcription_id");

	//parse argument string
	if (arg_text){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[3]->name, "text");
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 1;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_trial_remains_num);
	strcpy(obj->objs[4]->name, "trial_remains_num");
	if (arg_trial_remains_num)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 1;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_trial_remains_until_date);
	strcpy(obj->objs[5]->name, "trial_remains_until_date");
	if (arg_trial_remains_until_date)
		flagsv[nflags-1] |= (1 << 1);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_help_premiumPromo(const char * arg_status_text, MessageEntity *arg_status_entities, int len_arg_status_entities, const char * *arg_video_sections, int len_arg_video_sections, Document *arg_videos, int len_arg_videos, PremiumSubscriptionOption *arg_period_options, int len_arg_period_options, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_premiumPromo");
	int i;
	obj->id = 0x5334759c;
	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_status_text){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_status_text, strlen(arg_status_text));
		strcpy(obj->objs[0]->name, "status_text");
	}


	//parse argument Vector<MessageEntity>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "status_entities");
	if (arg_status_entities){
		for(i=0; i<len_arg_status_entities; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_status_entities[i]->id);
			buf_cat(obj->objs[1]->value, arg_status_entities[i]->value);
		}
	}


	//parse argument Vector<string>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "video_sections");
	if (arg_video_sections){
		for(i=0; i<len_arg_video_sections; ++i){
			int len = strlen(arg_video_sections[i]);
			buf_t b = buf_add((ui8_t *)arg_video_sections[i], len);
			buf_cat(obj->objs[2]->value, b);
		}
	}


	//parse argument Vector<Document>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "videos");
	if (arg_videos){
		for(i=0; i<len_arg_videos; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_videos[i]->id);
			buf_cat(obj->objs[3]->value, arg_videos[i]->value);
		}
	}


	//parse argument Vector<PremiumSubscriptionOption>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "period_options");
	if (arg_period_options){
		for(i=0; i<len_arg_period_options; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_period_options[i]->id);
			buf_cat(obj->objs[4]->value, arg_period_options[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_VECTOR;
	strcpy(obj->objs[5]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[5]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[5]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_inputStorePaymentPremiumSubscription(bool arg_restore, bool arg_upgrade)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputStorePaymentPremiumSubscription");
	int i;
	obj->id = 0xa6751e66;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_restore);
	strcpy(obj->objs[1]->name, "restore");
	if (arg_restore)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_upgrade);
	strcpy(obj->objs[2]->name, "upgrade");
	if (arg_upgrade)
		flagsv[nflags-1] |= (1 << 1);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputStorePaymentGiftPremium(InputUser arg_user_id, const char * arg_currency, long arg_amount)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputStorePaymentGiftPremium");
	int i;
	obj->id = 0x616f7fe8;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputUser
	if (arg_user_id){
		obj->objs[0] = arg_user_id;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "user_id");
	}


	//parse argument string
	if (arg_currency){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_currency, strlen(arg_currency));
		strcpy(obj->objs[1]->name, "currency");
	}


	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_amount);
	strcpy(obj->objs[2]->name, "amount");
	return obj;
}

tlo_t * tl_inputStorePaymentPremiumGiftCode(InputUser *arg_users, int len_arg_users, InputPeer arg_boost_peer, const char * arg_currency, long arg_amount)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputStorePaymentPremiumGiftCode");
	int i;
	obj->id = 0xa3805f3f;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument Vector<InputUser>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[1]->value, arg_users[i]->value);
		}
	}


	//parse argument InputPeer
	if (arg_boost_peer){
		obj->objs[2] = arg_boost_peer;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "boost_peer");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_currency){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_currency, strlen(arg_currency));
		strcpy(obj->objs[3]->name, "currency");
	}


	//parse argument long
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_amount);
	strcpy(obj->objs[4]->name, "amount");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputStorePaymentPremiumGiveaway(bool arg_only_new_subscribers, bool arg_winners_are_visible, InputPeer arg_boost_peer, InputPeer *arg_additional_peers, int len_arg_additional_peers, const char * *arg_countries_iso2, int len_arg_countries_iso2, const char * arg_prize_description, long arg_random_id, int arg_until_date, const char * arg_currency, long arg_amount)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputStorePaymentPremiumGiveaway");
	int i;
	obj->id = 0x160544ca;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 11;
	obj->objs = 
		(tlo_t **)MALLOC(11 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_only_new_subscribers);
	strcpy(obj->objs[1]->name, "only_new_subscribers");
	if (arg_only_new_subscribers)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 3;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_winners_are_visible);
	strcpy(obj->objs[2]->name, "winners_are_visible");
	if (arg_winners_are_visible)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument InputPeer
	if (arg_boost_peer){
		obj->objs[3] = arg_boost_peer;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "boost_peer");
	}


	//parse argument Vector<InputPeer>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 1;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "additional_peers");
	if (arg_additional_peers){
		for(i=0; i<len_arg_additional_peers; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_additional_peers[i]->id);
			buf_cat(obj->objs[4]->value, arg_additional_peers[i]->value);
		}
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument Vector<string>
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 2;
	obj->objs[5]->type = TYPE_VECTOR;
	strcpy(obj->objs[5]->name, "countries_iso2");
	if (arg_countries_iso2){
		for(i=0; i<len_arg_countries_iso2; ++i){
			int len = strlen(arg_countries_iso2[i]);
			buf_t b = buf_add((ui8_t *)arg_countries_iso2[i], len);
			buf_cat(obj->objs[5]->value, b);
		}
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument string
	if (arg_prize_description){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 4;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_prize_description, strlen(arg_prize_description));
		strcpy(obj->objs[6]->name, "prize_description");
		flagsv[nflags-1] |= (1 << 4);
	}


	//parse argument long
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_LONG;
	obj->objs[7]->value = 
		buf_add_ui64(arg_random_id);
	strcpy(obj->objs[7]->name, "random_id");

	//parse argument int
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 0;
	obj->objs[8]->flag_bit = 0;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_until_date);
	strcpy(obj->objs[8]->name, "until_date");

	//parse argument string
	if (arg_currency){
		obj->objs[9] = NEW(tlo_t, return NULL);
		obj->objs[9]->flag_num = 0;
		obj->objs[9]->flag_bit = 0;
		obj->objs[9]->type = TYPE_STRING;
		obj->objs[9]->value = 
			buf_add((ui8_t *)arg_currency, strlen(arg_currency));
		strcpy(obj->objs[9]->name, "currency");
	}


	//parse argument long
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 0;
	obj->objs[10]->flag_bit = 0;
	obj->objs[10]->type = TYPE_LONG;
	obj->objs[10]->value = 
		buf_add_ui64(arg_amount);
	strcpy(obj->objs[10]->name, "amount");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputStorePaymentStarsTopup(long arg_stars, const char * arg_currency, long arg_amount)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputStorePaymentStarsTopup");
	int i;
	obj->id = 0xdddd0f56;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_stars);
	strcpy(obj->objs[0]->name, "stars");

	//parse argument string
	if (arg_currency){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_currency, strlen(arg_currency));
		strcpy(obj->objs[1]->name, "currency");
	}


	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_amount);
	strcpy(obj->objs[2]->name, "amount");
	return obj;
}

tlo_t * tl_inputStorePaymentStarsGift(InputUser arg_user_id, long arg_stars, const char * arg_currency, long arg_amount)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputStorePaymentStarsGift");
	int i;
	obj->id = 0x1d741ef7;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument InputUser
	if (arg_user_id){
		obj->objs[0] = arg_user_id;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "user_id");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_stars);
	strcpy(obj->objs[1]->name, "stars");

	//parse argument string
	if (arg_currency){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_currency, strlen(arg_currency));
		strcpy(obj->objs[2]->name, "currency");
	}


	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_amount);
	strcpy(obj->objs[3]->name, "amount");
	return obj;
}

tlo_t * tl_inputStorePaymentStarsGiveaway(bool arg_only_new_subscribers, bool arg_winners_are_visible, long arg_stars, InputPeer arg_boost_peer, InputPeer *arg_additional_peers, int len_arg_additional_peers, const char * *arg_countries_iso2, int len_arg_countries_iso2, const char * arg_prize_description, long arg_random_id, int arg_until_date, const char * arg_currency, long arg_amount, int arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputStorePaymentStarsGiveaway");
	int i;
	obj->id = 0x751f08fa;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 13;
	obj->objs = 
		(tlo_t **)MALLOC(13 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_only_new_subscribers);
	strcpy(obj->objs[1]->name, "only_new_subscribers");
	if (arg_only_new_subscribers)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 3;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_winners_are_visible);
	strcpy(obj->objs[2]->name, "winners_are_visible");
	if (arg_winners_are_visible)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_stars);
	strcpy(obj->objs[3]->name, "stars");

	//parse argument InputPeer
	if (arg_boost_peer){
		obj->objs[4] = arg_boost_peer;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "boost_peer");
	}


	//parse argument Vector<InputPeer>
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 1;
	obj->objs[5]->type = TYPE_VECTOR;
	strcpy(obj->objs[5]->name, "additional_peers");
	if (arg_additional_peers){
		for(i=0; i<len_arg_additional_peers; ++i){
			obj->objs[5]->value = buf_add_ui32(arg_additional_peers[i]->id);
			buf_cat(obj->objs[5]->value, arg_additional_peers[i]->value);
		}
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument Vector<string>
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 2;
	obj->objs[6]->type = TYPE_VECTOR;
	strcpy(obj->objs[6]->name, "countries_iso2");
	if (arg_countries_iso2){
		for(i=0; i<len_arg_countries_iso2; ++i){
			int len = strlen(arg_countries_iso2[i]);
			buf_t b = buf_add((ui8_t *)arg_countries_iso2[i], len);
			buf_cat(obj->objs[6]->value, b);
		}
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument string
	if (arg_prize_description){
		obj->objs[7] = NEW(tlo_t, return NULL);
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 4;
		obj->objs[7]->type = TYPE_STRING;
		obj->objs[7]->value = 
			buf_add((ui8_t *)arg_prize_description, strlen(arg_prize_description));
		strcpy(obj->objs[7]->name, "prize_description");
		flagsv[nflags-1] |= (1 << 4);
	}


	//parse argument long
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 0;
	obj->objs[8]->flag_bit = 0;
	obj->objs[8]->type = TYPE_LONG;
	obj->objs[8]->value = 
		buf_add_ui64(arg_random_id);
	strcpy(obj->objs[8]->name, "random_id");

	//parse argument int
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 0;
	obj->objs[9]->flag_bit = 0;
	obj->objs[9]->type = TYPE_INT;
	obj->objs[9]->value = 
		buf_add_ui32(arg_until_date);
	strcpy(obj->objs[9]->name, "until_date");

	//parse argument string
	if (arg_currency){
		obj->objs[10] = NEW(tlo_t, return NULL);
		obj->objs[10]->flag_num = 0;
		obj->objs[10]->flag_bit = 0;
		obj->objs[10]->type = TYPE_STRING;
		obj->objs[10]->value = 
			buf_add((ui8_t *)arg_currency, strlen(arg_currency));
		strcpy(obj->objs[10]->name, "currency");
	}


	//parse argument long
	obj->objs[11] = NEW(tlo_t, return NULL);
	obj->objs[11]->flag_num = 0;
	obj->objs[11]->flag_bit = 0;
	obj->objs[11]->type = TYPE_LONG;
	obj->objs[11]->value = 
		buf_add_ui64(arg_amount);
	strcpy(obj->objs[11]->name, "amount");

	//parse argument int
	obj->objs[12] = NEW(tlo_t, return NULL);
	obj->objs[12]->flag_num = 0;
	obj->objs[12]->flag_bit = 0;
	obj->objs[12]->type = TYPE_INT;
	obj->objs[12]->value = 
		buf_add_ui32(arg_users);
	strcpy(obj->objs[12]->name, "users");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_premiumGiftOption(int arg_months, const char * arg_currency, long arg_amount, const char * arg_bot_url, const char * arg_store_product)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "premiumGiftOption");
	int i;
	obj->id = 0x74c34319;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_months);
	strcpy(obj->objs[1]->name, "months");

	//parse argument string
	if (arg_currency){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_currency, strlen(arg_currency));
		strcpy(obj->objs[2]->name, "currency");
	}


	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_amount);
	strcpy(obj->objs[3]->name, "amount");

	//parse argument string
	if (arg_bot_url){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_bot_url, strlen(arg_bot_url));
		strcpy(obj->objs[4]->name, "bot_url");
	}


	//parse argument string
	if (arg_store_product){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_store_product, strlen(arg_store_product));
		strcpy(obj->objs[5]->name, "store_product");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_paymentFormMethod(const char * arg_url, const char * arg_title)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "paymentFormMethod");
	int i;
	obj->id = 0x88f8f21b;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_url){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[0]->name, "url");
	}


	//parse argument string
	if (arg_title){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[1]->name, "title");
	}

	return obj;
}

tlo_t * tl_emojiStatusEmpty()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "emojiStatusEmpty");
	int i;
	obj->id = 0x2de11aae;
	return obj;
}

tlo_t * tl_emojiStatus(long arg_document_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "emojiStatus");
	int i;
	obj->id = 0x929b619d;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_document_id);
	strcpy(obj->objs[0]->name, "document_id");
	return obj;
}

tlo_t * tl_emojiStatusUntil(long arg_document_id, int arg_until)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "emojiStatusUntil");
	int i;
	obj->id = 0xfa30a8c7;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_document_id);
	strcpy(obj->objs[0]->name, "document_id");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_until);
	strcpy(obj->objs[1]->name, "until");
	return obj;
}

tlo_t * tl_account_emojiStatusesNotModified()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_emojiStatusesNotModified");
	int i;
	obj->id = 0xd08ce645;
	return obj;
}

tlo_t * tl_account_emojiStatuses(long arg_hash, EmojiStatus *arg_statuses, int len_arg_statuses)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_emojiStatuses");
	int i;
	obj->id = 0x90c467d1;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");

	//parse argument Vector<EmojiStatus>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "statuses");
	if (arg_statuses){
		for(i=0; i<len_arg_statuses; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_statuses[i]->id);
			buf_cat(obj->objs[1]->value, arg_statuses[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_reactionEmpty()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "reactionEmpty");
	int i;
	obj->id = 0x79f5d419;
	return obj;
}

tlo_t * tl_reactionEmoji(const char * arg_emoticon)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "reactionEmoji");
	int i;
	obj->id = 0x1b2286b8;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_emoticon){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_emoticon, strlen(arg_emoticon));
		strcpy(obj->objs[0]->name, "emoticon");
	}

	return obj;
}

tlo_t * tl_reactionCustomEmoji(long arg_document_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "reactionCustomEmoji");
	int i;
	obj->id = 0x8935fc73;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_document_id);
	strcpy(obj->objs[0]->name, "document_id");
	return obj;
}

tlo_t * tl_reactionPaid()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "reactionPaid");
	int i;
	obj->id = 0x523da4eb;
	return obj;
}

tlo_t * tl_chatReactionsNone()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatReactionsNone");
	int i;
	obj->id = 0xeafc32bc;
	return obj;
}

tlo_t * tl_chatReactionsAll(bool arg_allow_custom)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatReactionsAll");
	int i;
	obj->id = 0x52928bca;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_allow_custom);
	strcpy(obj->objs[1]->name, "allow_custom");
	if (arg_allow_custom)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_chatReactionsSome(Reaction *arg_reactions, int len_arg_reactions)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatReactionsSome");
	int i;
	obj->id = 0x661d4037;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<Reaction>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "reactions");
	if (arg_reactions){
		for(i=0; i<len_arg_reactions; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_reactions[i]->id);
			buf_cat(obj->objs[0]->value, arg_reactions[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_messages_reactionsNotModified()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_reactionsNotModified");
	int i;
	obj->id = 0xb06fdbdf;
	return obj;
}

tlo_t * tl_messages_reactions(long arg_hash, Reaction *arg_reactions, int len_arg_reactions)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_reactions");
	int i;
	obj->id = 0xeafdf716;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");

	//parse argument Vector<Reaction>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "reactions");
	if (arg_reactions){
		for(i=0; i<len_arg_reactions; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_reactions[i]->id);
			buf_cat(obj->objs[1]->value, arg_reactions[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_emailVerifyPurposeLoginSetup(const char * arg_phone_number, const char * arg_phone_code_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "emailVerifyPurposeLoginSetup");
	int i;
	obj->id = 0x4345be73;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_phone_number){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_phone_number, strlen(arg_phone_number));
		strcpy(obj->objs[0]->name, "phone_number");
	}


	//parse argument string
	if (arg_phone_code_hash){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_phone_code_hash, strlen(arg_phone_code_hash));
		strcpy(obj->objs[1]->name, "phone_code_hash");
	}

	return obj;
}

tlo_t * tl_emailVerifyPurposeLoginChange()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "emailVerifyPurposeLoginChange");
	int i;
	obj->id = 0x527d22eb;
	return obj;
}

tlo_t * tl_emailVerifyPurposePassport()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "emailVerifyPurposePassport");
	int i;
	obj->id = 0xbbf51685;
	return obj;
}

tlo_t * tl_emailVerificationCode(const char * arg_code)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "emailVerificationCode");
	int i;
	obj->id = 0x922e55a9;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_code){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_code, strlen(arg_code));
		strcpy(obj->objs[0]->name, "code");
	}

	return obj;
}

tlo_t * tl_emailVerificationGoogle(const char * arg_token)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "emailVerificationGoogle");
	int i;
	obj->id = 0xdb909ec2;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_token){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_token, strlen(arg_token));
		strcpy(obj->objs[0]->name, "token");
	}

	return obj;
}

tlo_t * tl_emailVerificationApple(const char * arg_token)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "emailVerificationApple");
	int i;
	obj->id = 0x96d074fd;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_token){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_token, strlen(arg_token));
		strcpy(obj->objs[0]->name, "token");
	}

	return obj;
}

tlo_t * tl_account_emailVerified(const char * arg_email)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_emailVerified");
	int i;
	obj->id = 0x2b96cd1b;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_email){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_email, strlen(arg_email));
		strcpy(obj->objs[0]->name, "email");
	}

	return obj;
}

tlo_t * tl_account_emailVerifiedLogin(const char * arg_email, auth_SentCode arg_sent_code)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_emailVerifiedLogin");
	int i;
	obj->id = 0xe1bb0d61;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_email){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_email, strlen(arg_email));
		strcpy(obj->objs[0]->name, "email");
	}


	//parse argument auth_SentCode
	if (arg_sent_code){
		obj->objs[1] = arg_sent_code;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "sent_code");
	}

	return obj;
}

tlo_t * tl_premiumSubscriptionOption(bool arg_current, bool arg_can_purchase_upgrade, const char * arg_transaction, int arg_months, const char * arg_currency, long arg_amount, const char * arg_bot_url, const char * arg_store_product)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "premiumSubscriptionOption");
	int i;
	obj->id = 0x5f2d1df2;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_current);
	strcpy(obj->objs[1]->name, "current");
	if (arg_current)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 2;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_can_purchase_upgrade);
	strcpy(obj->objs[2]->name, "can_purchase_upgrade");
	if (arg_can_purchase_upgrade)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument string
	if (arg_transaction){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 3;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_transaction, strlen(arg_transaction));
		strcpy(obj->objs[3]->name, "transaction");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_months);
	strcpy(obj->objs[4]->name, "months");

	//parse argument string
	if (arg_currency){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_currency, strlen(arg_currency));
		strcpy(obj->objs[5]->name, "currency");
	}


	//parse argument long
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_LONG;
	obj->objs[6]->value = 
		buf_add_ui64(arg_amount);
	strcpy(obj->objs[6]->name, "amount");

	//parse argument string
	if (arg_bot_url){
		obj->objs[7] = NEW(tlo_t, return NULL);
		obj->objs[7]->flag_num = 0;
		obj->objs[7]->flag_bit = 0;
		obj->objs[7]->type = TYPE_STRING;
		obj->objs[7]->value = 
			buf_add((ui8_t *)arg_bot_url, strlen(arg_bot_url));
		strcpy(obj->objs[7]->name, "bot_url");
	}


	//parse argument string
	if (arg_store_product){
		obj->objs[8] = NEW(tlo_t, return NULL);
		obj->objs[8]->flag_num = 1;
		obj->objs[8]->flag_bit = 0;
		obj->objs[8]->type = TYPE_STRING;
		obj->objs[8]->value = 
			buf_add((ui8_t *)arg_store_product, strlen(arg_store_product));
		strcpy(obj->objs[8]->name, "store_product");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_sendAsPeer(bool arg_premium_required, Peer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "sendAsPeer");
	int i;
	obj->id = 0xb81c7034;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_premium_required);
	strcpy(obj->objs[1]->name, "premium_required");
	if (arg_premium_required)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument Peer
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messageExtendedMediaPreview(int arg_w, int arg_h, PhotoSize arg_thumb, int arg_video_duration)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageExtendedMediaPreview");
	int i;
	obj->id = 0xad628cc8;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_w);
	strcpy(obj->objs[1]->name, "w");
	if (arg_w)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_h);
	strcpy(obj->objs[2]->name, "h");
	if (arg_h)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument PhotoSize
	if (arg_thumb){
		obj->objs[3] = arg_thumb;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 1;
	strcpy(obj->objs[3]->name, "thumb");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 2;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_video_duration);
	strcpy(obj->objs[4]->name, "video_duration");
	if (arg_video_duration)
		flagsv[nflags-1] |= (1 << 2);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messageExtendedMedia(MessageMedia arg_media)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageExtendedMedia");
	int i;
	obj->id = 0xee479c64;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument MessageMedia
	if (arg_media){
		obj->objs[0] = arg_media;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "media");
	}

	return obj;
}

tlo_t * tl_stickerKeyword(long arg_document_id, const char * *arg_keyword, int len_arg_keyword)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stickerKeyword");
	int i;
	obj->id = 0xfcfeb29c;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_document_id);
	strcpy(obj->objs[0]->name, "document_id");

	//parse argument Vector<string>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "keyword");
	if (arg_keyword){
		for(i=0; i<len_arg_keyword; ++i){
			int len = strlen(arg_keyword[i]);
			buf_t b = buf_add((ui8_t *)arg_keyword[i], len);
			buf_cat(obj->objs[1]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_username(bool arg_editable, bool arg_active, const char * arg_username)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "username");
	int i;
	obj->id = 0xb4073647;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_editable);
	strcpy(obj->objs[1]->name, "editable");
	if (arg_editable)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_active);
	strcpy(obj->objs[2]->name, "active");
	if (arg_active)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument string
	if (arg_username){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_username, strlen(arg_username));
		strcpy(obj->objs[3]->name, "username");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_forumTopicDeleted(int arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "forumTopicDeleted");
	int i;
	obj->id = 0x023f109b;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[0]->name, "id");
	return obj;
}

tlo_t * tl_forumTopic(bool arg_my, bool arg_closed, bool arg_pinned, bool arg_short, bool arg_hidden, int arg_id, int arg_date, const char * arg_title, int arg_icon_color, long arg_icon_emoji_id, int arg_top_message, int arg_read_inbox_max_id, int arg_read_outbox_max_id, int arg_unread_count, int arg_unread_mentions_count, int arg_unread_reactions_count, Peer arg_from_id, PeerNotifySettings arg_notify_settings, DraftMessage arg_draft)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "forumTopic");
	int i;
	obj->id = 0x71701da9;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 20;
	obj->objs = 
		(tlo_t **)MALLOC(20 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_my);
	strcpy(obj->objs[1]->name, "my");
	if (arg_my)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 2;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_closed);
	strcpy(obj->objs[2]->name, "closed");
	if (arg_closed)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 3;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_pinned);
	strcpy(obj->objs[3]->name, "pinned");
	if (arg_pinned)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 5;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_short);
	strcpy(obj->objs[4]->name, "short");
	if (arg_short)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 6;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_hidden);
	strcpy(obj->objs[5]->name, "hidden");
	if (arg_hidden)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[6]->name, "id");

	//parse argument int
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[7]->name, "date");

	//parse argument string
	if (arg_title){
		obj->objs[8] = NEW(tlo_t, return NULL);
		obj->objs[8]->flag_num = 0;
		obj->objs[8]->flag_bit = 0;
		obj->objs[8]->type = TYPE_STRING;
		obj->objs[8]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[8]->name, "title");
	}


	//parse argument int
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 0;
	obj->objs[9]->flag_bit = 0;
	obj->objs[9]->type = TYPE_INT;
	obj->objs[9]->value = 
		buf_add_ui32(arg_icon_color);
	strcpy(obj->objs[9]->name, "icon_color");

	//parse argument long
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 1;
	obj->objs[10]->flag_bit = 0;
	obj->objs[10]->type = TYPE_LONG;
	obj->objs[10]->value = 
		buf_add_ui64(arg_icon_emoji_id);
	strcpy(obj->objs[10]->name, "icon_emoji_id");
	if (arg_icon_emoji_id)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[11] = NEW(tlo_t, return NULL);
	obj->objs[11]->flag_num = 0;
	obj->objs[11]->flag_bit = 0;
	obj->objs[11]->type = TYPE_INT;
	obj->objs[11]->value = 
		buf_add_ui32(arg_top_message);
	strcpy(obj->objs[11]->name, "top_message");

	//parse argument int
	obj->objs[12] = NEW(tlo_t, return NULL);
	obj->objs[12]->flag_num = 0;
	obj->objs[12]->flag_bit = 0;
	obj->objs[12]->type = TYPE_INT;
	obj->objs[12]->value = 
		buf_add_ui32(arg_read_inbox_max_id);
	strcpy(obj->objs[12]->name, "read_inbox_max_id");

	//parse argument int
	obj->objs[13] = NEW(tlo_t, return NULL);
	obj->objs[13]->flag_num = 0;
	obj->objs[13]->flag_bit = 0;
	obj->objs[13]->type = TYPE_INT;
	obj->objs[13]->value = 
		buf_add_ui32(arg_read_outbox_max_id);
	strcpy(obj->objs[13]->name, "read_outbox_max_id");

	//parse argument int
	obj->objs[14] = NEW(tlo_t, return NULL);
	obj->objs[14]->flag_num = 0;
	obj->objs[14]->flag_bit = 0;
	obj->objs[14]->type = TYPE_INT;
	obj->objs[14]->value = 
		buf_add_ui32(arg_unread_count);
	strcpy(obj->objs[14]->name, "unread_count");

	//parse argument int
	obj->objs[15] = NEW(tlo_t, return NULL);
	obj->objs[15]->flag_num = 0;
	obj->objs[15]->flag_bit = 0;
	obj->objs[15]->type = TYPE_INT;
	obj->objs[15]->value = 
		buf_add_ui32(arg_unread_mentions_count);
	strcpy(obj->objs[15]->name, "unread_mentions_count");

	//parse argument int
	obj->objs[16] = NEW(tlo_t, return NULL);
	obj->objs[16]->flag_num = 0;
	obj->objs[16]->flag_bit = 0;
	obj->objs[16]->type = TYPE_INT;
	obj->objs[16]->value = 
		buf_add_ui32(arg_unread_reactions_count);
	strcpy(obj->objs[16]->name, "unread_reactions_count");

	//parse argument Peer
	if (arg_from_id){
		obj->objs[17] = arg_from_id;
		obj->objs[17]->flag_num = 0;
		obj->objs[17]->flag_bit = 0;
	strcpy(obj->objs[17]->name, "from_id");
	}


	//parse argument PeerNotifySettings
	if (arg_notify_settings){
		obj->objs[18] = arg_notify_settings;
		obj->objs[18]->flag_num = 0;
		obj->objs[18]->flag_bit = 0;
	strcpy(obj->objs[18]->name, "notify_settings");
	}


	//parse argument DraftMessage
	if (arg_draft){
		obj->objs[19] = arg_draft;
		obj->objs[19]->flag_num = 1;
		obj->objs[19]->flag_bit = 4;
	strcpy(obj->objs[19]->name, "draft");
		flagsv[nflags-1] |= (1 << 4);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_forumTopics(bool arg_order_by_create_date, int arg_count, ForumTopic *arg_topics, int len_arg_topics, Message *arg_messages, int len_arg_messages, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users, int arg_pts)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_forumTopics");
	int i;
	obj->id = 0x367617d3;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_order_by_create_date);
	strcpy(obj->objs[1]->name, "order_by_create_date");
	if (arg_order_by_create_date)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[2]->name, "count");

	//parse argument Vector<ForumTopic>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "topics");
	if (arg_topics){
		for(i=0; i<len_arg_topics; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_topics[i]->id);
			buf_cat(obj->objs[3]->value, arg_topics[i]->value);
		}
	}


	//parse argument Vector<Message>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "messages");
	if (arg_messages){
		for(i=0; i<len_arg_messages; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_messages[i]->id);
			buf_cat(obj->objs[4]->value, arg_messages[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_VECTOR;
	strcpy(obj->objs[5]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[5]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[5]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_VECTOR;
	strcpy(obj->objs[6]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[6]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[6]->value, arg_users[i]->value);
		}
	}


	//parse argument int
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_pts);
	strcpy(obj->objs[7]->name, "pts");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_defaultHistoryTTL(int arg_period)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "defaultHistoryTTL");
	int i;
	obj->id = 0x43b46b20;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_period);
	strcpy(obj->objs[0]->name, "period");
	return obj;
}

tlo_t * tl_exportedContactToken(const char * arg_url, int arg_expires)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "exportedContactToken");
	int i;
	obj->id = 0x41bf109b;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_url){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[0]->name, "url");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_expires);
	strcpy(obj->objs[1]->name, "expires");
	return obj;
}

tlo_t * tl_requestPeerTypeUser(Bool arg_bot, Bool arg_premium)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "requestPeerTypeUser");
	int i;
	obj->id = 0x5f3b8a00;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument Bool
	if (arg_bot){
		obj->objs[1] = arg_bot;
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "bot");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument Bool
	if (arg_premium){
		obj->objs[2] = arg_premium;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 1;
	strcpy(obj->objs[2]->name, "premium");
		flagsv[nflags-1] |= (1 << 1);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_requestPeerTypeChat(bool arg_creator, bool arg_bot_participant, Bool arg_has_username, Bool arg_forum, ChatAdminRights arg_user_admin_rights, ChatAdminRights arg_bot_admin_rights)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "requestPeerTypeChat");
	int i;
	obj->id = 0xc9f06e1b;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_creator);
	strcpy(obj->objs[1]->name, "creator");
	if (arg_creator)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 5;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_bot_participant);
	strcpy(obj->objs[2]->name, "bot_participant");
	if (arg_bot_participant)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument Bool
	if (arg_has_username){
		obj->objs[3] = arg_has_username;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 3;
	strcpy(obj->objs[3]->name, "has_username");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument Bool
	if (arg_forum){
		obj->objs[4] = arg_forum;
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 4;
	strcpy(obj->objs[4]->name, "forum");
		flagsv[nflags-1] |= (1 << 4);
	}


	//parse argument ChatAdminRights
	if (arg_user_admin_rights){
		obj->objs[5] = arg_user_admin_rights;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 1;
	strcpy(obj->objs[5]->name, "user_admin_rights");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument ChatAdminRights
	if (arg_bot_admin_rights){
		obj->objs[6] = arg_bot_admin_rights;
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 2;
	strcpy(obj->objs[6]->name, "bot_admin_rights");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_requestPeerTypeBroadcast(bool arg_creator, Bool arg_has_username, ChatAdminRights arg_user_admin_rights, ChatAdminRights arg_bot_admin_rights)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "requestPeerTypeBroadcast");
	int i;
	obj->id = 0x339bef6c;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_creator);
	strcpy(obj->objs[1]->name, "creator");
	if (arg_creator)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument Bool
	if (arg_has_username){
		obj->objs[2] = arg_has_username;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 3;
	strcpy(obj->objs[2]->name, "has_username");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument ChatAdminRights
	if (arg_user_admin_rights){
		obj->objs[3] = arg_user_admin_rights;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 1;
	strcpy(obj->objs[3]->name, "user_admin_rights");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument ChatAdminRights
	if (arg_bot_admin_rights){
		obj->objs[4] = arg_bot_admin_rights;
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 2;
	strcpy(obj->objs[4]->name, "bot_admin_rights");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_emojiListNotModified()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "emojiListNotModified");
	int i;
	obj->id = 0x481eadfa;
	return obj;
}

tlo_t * tl_emojiList(long arg_hash, long *arg_document_id, int len_arg_document_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "emojiList");
	int i;
	obj->id = 0x7a1e11d1;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");

	//parse argument Vector<long>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "document_id");
	if (arg_document_id){
		for(i=0; i<len_arg_document_id; ++i){
			buf_t b = buf_add_ui64(arg_document_id[i]);
			buf_cat(obj->objs[1]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_emojiGroup(const char * arg_title, long arg_icon_emoji_id, const char * *arg_emoticons, int len_arg_emoticons)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "emojiGroup");
	int i;
	obj->id = 0x7a9abda9;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_title){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[0]->name, "title");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_icon_emoji_id);
	strcpy(obj->objs[1]->name, "icon_emoji_id");

	//parse argument Vector<string>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "emoticons");
	if (arg_emoticons){
		for(i=0; i<len_arg_emoticons; ++i){
			int len = strlen(arg_emoticons[i]);
			buf_t b = buf_add((ui8_t *)arg_emoticons[i], len);
			buf_cat(obj->objs[2]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_emojiGroupGreeting(const char * arg_title, long arg_icon_emoji_id, const char * *arg_emoticons, int len_arg_emoticons)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "emojiGroupGreeting");
	int i;
	obj->id = 0x80d26cc7;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_title){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[0]->name, "title");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_icon_emoji_id);
	strcpy(obj->objs[1]->name, "icon_emoji_id");

	//parse argument Vector<string>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "emoticons");
	if (arg_emoticons){
		for(i=0; i<len_arg_emoticons; ++i){
			int len = strlen(arg_emoticons[i]);
			buf_t b = buf_add((ui8_t *)arg_emoticons[i], len);
			buf_cat(obj->objs[2]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_emojiGroupPremium(const char * arg_title, long arg_icon_emoji_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "emojiGroupPremium");
	int i;
	obj->id = 0x093bcf34;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_title){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[0]->name, "title");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_icon_emoji_id);
	strcpy(obj->objs[1]->name, "icon_emoji_id");
	return obj;
}

tlo_t * tl_messages_emojiGroupsNotModified()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_emojiGroupsNotModified");
	int i;
	obj->id = 0x6fb4ad87;
	return obj;
}

tlo_t * tl_messages_emojiGroups(int arg_hash, EmojiGroup *arg_groups, int len_arg_groups)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_emojiGroups");
	int i;
	obj->id = 0x881fb94b;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_hash);
	strcpy(obj->objs[0]->name, "hash");

	//parse argument Vector<EmojiGroup>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "groups");
	if (arg_groups){
		for(i=0; i<len_arg_groups; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_groups[i]->id);
			buf_cat(obj->objs[1]->value, arg_groups[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_textWithEntities(const char * arg_text, MessageEntity *arg_entities, int len_arg_entities)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "textWithEntities");
	int i;
	obj->id = 0x751f3146;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_text){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[0]->name, "text");
	}


	//parse argument Vector<MessageEntity>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "entities");
	if (arg_entities){
		for(i=0; i<len_arg_entities; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_entities[i]->id);
			buf_cat(obj->objs[1]->value, arg_entities[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_messages_translateResult(TextWithEntities *arg_result, int len_arg_result)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_translateResult");
	int i;
	obj->id = 0x33db32f8;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<TextWithEntities>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "result");
	if (arg_result){
		for(i=0; i<len_arg_result; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_result[i]->id);
			buf_cat(obj->objs[0]->value, arg_result[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_autoSaveSettings(bool arg_photos, bool arg_videos, long arg_video_max_size)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "autoSaveSettings");
	int i;
	obj->id = 0xc84834ce;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_photos);
	strcpy(obj->objs[1]->name, "photos");
	if (arg_photos)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_videos);
	strcpy(obj->objs[2]->name, "videos");
	if (arg_videos)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_video_max_size);
	strcpy(obj->objs[3]->name, "video_max_size");
	if (arg_video_max_size)
		flagsv[nflags-1] |= (1 << 2);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_autoSaveException(Peer arg_peer, AutoSaveSettings arg_settings)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "autoSaveException");
	int i;
	obj->id = 0x81602d47;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument AutoSaveSettings
	if (arg_settings){
		obj->objs[1] = arg_settings;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "settings");
	}

	return obj;
}

tlo_t * tl_account_autoSaveSettings(AutoSaveSettings arg_users_settings, AutoSaveSettings arg_chats_settings, AutoSaveSettings arg_broadcasts_settings, AutoSaveException *arg_exceptions, int len_arg_exceptions, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_autoSaveSettings");
	int i;
	obj->id = 0x4c3e069d;
	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument AutoSaveSettings
	if (arg_users_settings){
		obj->objs[0] = arg_users_settings;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "users_settings");
	}


	//parse argument AutoSaveSettings
	if (arg_chats_settings){
		obj->objs[1] = arg_chats_settings;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "chats_settings");
	}


	//parse argument AutoSaveSettings
	if (arg_broadcasts_settings){
		obj->objs[2] = arg_broadcasts_settings;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "broadcasts_settings");
	}


	//parse argument Vector<AutoSaveException>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "exceptions");
	if (arg_exceptions){
		for(i=0; i<len_arg_exceptions; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_exceptions[i]->id);
			buf_cat(obj->objs[3]->value, arg_exceptions[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[4]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_VECTOR;
	strcpy(obj->objs[5]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[5]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[5]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_help_appConfigNotModified()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_appConfigNotModified");
	int i;
	obj->id = 0x7cde641d;
	return obj;
}

tlo_t * tl_help_appConfig(int arg_hash, JSONValue arg_config)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_appConfig");
	int i;
	obj->id = 0xdd18782e;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_hash);
	strcpy(obj->objs[0]->name, "hash");

	//parse argument JSONValue
	if (arg_config){
		obj->objs[1] = arg_config;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "config");
	}

	return obj;
}

tlo_t * tl_inputBotAppID(long arg_id, long arg_access_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputBotAppID");
	int i;
	obj->id = 0xa920bd7a;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[1]->name, "access_hash");
	return obj;
}

tlo_t * tl_inputBotAppShortName(InputUser arg_bot_id, const char * arg_short_name)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputBotAppShortName");
	int i;
	obj->id = 0x908c0407;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputUser
	if (arg_bot_id){
		obj->objs[0] = arg_bot_id;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "bot_id");
	}


	//parse argument string
	if (arg_short_name){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_short_name, strlen(arg_short_name));
		strcpy(obj->objs[1]->name, "short_name");
	}

	return obj;
}

tlo_t * tl_botAppNotModified()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "botAppNotModified");
	int i;
	obj->id = 0x5da674b7;
	return obj;
}

tlo_t * tl_botApp(long arg_id, long arg_access_hash, const char * arg_short_name, const char * arg_title, const char * arg_description, Photo arg_photo, Document arg_document, long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "botApp");
	int i;
	obj->id = 0x95fcd1d6;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[1]->name, "id");

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_access_hash);
	strcpy(obj->objs[2]->name, "access_hash");

	//parse argument string
	if (arg_short_name){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_short_name, strlen(arg_short_name));
		strcpy(obj->objs[3]->name, "short_name");
	}


	//parse argument string
	if (arg_title){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[4]->name, "title");
	}


	//parse argument string
	if (arg_description){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_description, strlen(arg_description));
		strcpy(obj->objs[5]->name, "description");
	}


	//parse argument Photo
	if (arg_photo){
		obj->objs[6] = arg_photo;
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
	strcpy(obj->objs[6]->name, "photo");
	}


	//parse argument Document
	if (arg_document){
		obj->objs[7] = arg_document;
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 0;
	strcpy(obj->objs[7]->name, "document");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument long
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 0;
	obj->objs[8]->flag_bit = 0;
	obj->objs[8]->type = TYPE_LONG;
	obj->objs[8]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[8]->name, "hash");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_botApp(bool arg_inactive, bool arg_request_write_access, bool arg_has_settings, BotApp arg_app)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_botApp");
	int i;
	obj->id = 0xeb50adf5;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_inactive);
	strcpy(obj->objs[1]->name, "inactive");
	if (arg_inactive)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_request_write_access);
	strcpy(obj->objs[2]->name, "request_write_access");
	if (arg_request_write_access)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_has_settings);
	strcpy(obj->objs[3]->name, "has_settings");
	if (arg_has_settings)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument BotApp
	if (arg_app){
		obj->objs[4] = arg_app;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "app");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inlineBotWebView(const char * arg_text, const char * arg_url)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inlineBotWebView");
	int i;
	obj->id = 0xb57295d5;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_text){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[0]->name, "text");
	}


	//parse argument string
	if (arg_url){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[1]->name, "url");
	}

	return obj;
}

tlo_t * tl_readParticipantDate(long arg_user_id, int arg_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "readParticipantDate");
	int i;
	obj->id = 0x4a4ff172;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[0]->name, "user_id");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[1]->name, "date");
	return obj;
}

tlo_t * tl_inputChatlistDialogFilter(int arg_filter_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputChatlistDialogFilter");
	int i;
	obj->id = 0xf3e0da33;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_filter_id);
	strcpy(obj->objs[0]->name, "filter_id");
	return obj;
}

tlo_t * tl_exportedChatlistInvite(const char * arg_title, const char * arg_url, Peer *arg_peers, int len_arg_peers)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "exportedChatlistInvite");
	int i;
	obj->id = 0x0c5181ac;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_title){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[1]->name, "title");
	}


	//parse argument string
	if (arg_url){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[2]->name, "url");
	}


	//parse argument Vector<Peer>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "peers");
	if (arg_peers){
		for(i=0; i<len_arg_peers; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_peers[i]->id);
			buf_cat(obj->objs[3]->value, arg_peers[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_chatlists_exportedChatlistInvite(DialogFilter arg_filter, ExportedChatlistInvite arg_invite)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatlists_exportedChatlistInvite");
	int i;
	obj->id = 0x10e6e3a6;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument DialogFilter
	if (arg_filter){
		obj->objs[0] = arg_filter;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "filter");
	}


	//parse argument ExportedChatlistInvite
	if (arg_invite){
		obj->objs[1] = arg_invite;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "invite");
	}

	return obj;
}

tlo_t * tl_chatlists_exportedInvites(ExportedChatlistInvite *arg_invites, int len_arg_invites, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatlists_exportedInvites");
	int i;
	obj->id = 0x10ab6dc7;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<ExportedChatlistInvite>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "invites");
	if (arg_invites){
		for(i=0; i<len_arg_invites; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_invites[i]->id);
			buf_cat(obj->objs[0]->value, arg_invites[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[1]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[2]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_chatlists_chatlistInviteAlready(int arg_filter_id, Peer *arg_missing_peers, int len_arg_missing_peers, Peer *arg_already_peers, int len_arg_already_peers, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatlists_chatlistInviteAlready");
	int i;
	obj->id = 0xfa87f659;
	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_filter_id);
	strcpy(obj->objs[0]->name, "filter_id");

	//parse argument Vector<Peer>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "missing_peers");
	if (arg_missing_peers){
		for(i=0; i<len_arg_missing_peers; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_missing_peers[i]->id);
			buf_cat(obj->objs[1]->value, arg_missing_peers[i]->value);
		}
	}


	//parse argument Vector<Peer>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "already_peers");
	if (arg_already_peers){
		for(i=0; i<len_arg_already_peers; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_already_peers[i]->id);
			buf_cat(obj->objs[2]->value, arg_already_peers[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[3]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[4]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_chatlists_chatlistInvite(const char * arg_title, const char * arg_emoticon, Peer *arg_peers, int len_arg_peers, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatlists_chatlistInvite");
	int i;
	obj->id = 0x1dcd839d;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_title){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[1]->name, "title");
	}


	//parse argument string
	if (arg_emoticon){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_emoticon, strlen(arg_emoticon));
		strcpy(obj->objs[2]->name, "emoticon");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument Vector<Peer>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "peers");
	if (arg_peers){
		for(i=0; i<len_arg_peers; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_peers[i]->id);
			buf_cat(obj->objs[3]->value, arg_peers[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[4]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_VECTOR;
	strcpy(obj->objs[5]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[5]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[5]->value, arg_users[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_chatlists_chatlistUpdates(Peer *arg_missing_peers, int len_arg_missing_peers, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatlists_chatlistUpdates");
	int i;
	obj->id = 0x93bd878d;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<Peer>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "missing_peers");
	if (arg_missing_peers){
		for(i=0; i<len_arg_missing_peers; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_missing_peers[i]->id);
			buf_cat(obj->objs[0]->value, arg_missing_peers[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[1]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[2]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_bots_botInfo(const char * arg_name, const char * arg_about, const char * arg_description)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "bots_botInfo");
	int i;
	obj->id = 0xe8a775b0;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_name){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_name, strlen(arg_name));
		strcpy(obj->objs[0]->name, "name");
	}


	//parse argument string
	if (arg_about){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_about, strlen(arg_about));
		strcpy(obj->objs[1]->name, "about");
	}


	//parse argument string
	if (arg_description){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_description, strlen(arg_description));
		strcpy(obj->objs[2]->name, "description");
	}

	return obj;
}

tlo_t * tl_messagePeerVote(Peer arg_peer, unsigned char * arg_option, int len_arg_option, int arg_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messagePeerVote");
	int i;
	obj->id = 0xb6cc2d5c;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument bytes
	if (arg_option){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_option, len_arg_option);
		strcpy(obj->objs[1]->name, "option");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[2]->name, "date");
	return obj;
}

tlo_t * tl_messagePeerVoteInputOption(Peer arg_peer, int arg_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messagePeerVoteInputOption");
	int i;
	obj->id = 0x74cda504;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[1]->name, "date");
	return obj;
}

tlo_t * tl_messagePeerVoteMultiple(Peer arg_peer, unsigned char * *arg_options, int len_arg_options, int arg_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messagePeerVoteMultiple");
	int i;
	obj->id = 0x4628f6e6;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument Vector<bytes>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "options");
	if (arg_options){
		for(i=0; i<len_arg_options; ++i){
			int len = *(int *)(arg_options[i]);
			ui8_t *p = &(arg_options[i][4]);
			buf_t b = buf_add(p, len);
			buf_cat(obj->objs[1]->value, b);
		}
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[2]->name, "date");
	return obj;
}

tlo_t * tl_storyViews(bool arg_has_viewers, int arg_views_count, int arg_forwards_count, ReactionCount *arg_reactions, int len_arg_reactions, int arg_reactions_count, long *arg_recent_viewers, int len_arg_recent_viewers)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "storyViews");
	int i;
	obj->id = 0x8d595cd6;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_has_viewers);
	strcpy(obj->objs[1]->name, "has_viewers");
	if (arg_has_viewers)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_views_count);
	strcpy(obj->objs[2]->name, "views_count");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_forwards_count);
	strcpy(obj->objs[3]->name, "forwards_count");
	if (arg_forwards_count)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument Vector<ReactionCount>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 3;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "reactions");
	if (arg_reactions){
		for(i=0; i<len_arg_reactions; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_reactions[i]->id);
			buf_cat(obj->objs[4]->value, arg_reactions[i]->value);
		}
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 4;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_reactions_count);
	strcpy(obj->objs[5]->name, "reactions_count");
	if (arg_reactions_count)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument Vector<long>
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_VECTOR;
	strcpy(obj->objs[6]->name, "recent_viewers");
	if (arg_recent_viewers){
		for(i=0; i<len_arg_recent_viewers; ++i){
			buf_t b = buf_add_ui64(arg_recent_viewers[i]);
			buf_cat(obj->objs[6]->value, b);
		}
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_storyItemDeleted(int arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "storyItemDeleted");
	int i;
	obj->id = 0x51e6ee4f;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[0]->name, "id");
	return obj;
}

tlo_t * tl_storyItemSkipped(bool arg_close_friends, int arg_id, int arg_date, int arg_expire_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "storyItemSkipped");
	int i;
	obj->id = 0xffadc913;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 8;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_close_friends);
	strcpy(obj->objs[1]->name, "close_friends");
	if (arg_close_friends)
		flagsv[nflags-1] |= (1 << 8);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[2]->name, "id");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[3]->name, "date");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_expire_date);
	strcpy(obj->objs[4]->name, "expire_date");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_storyItem(bool arg_pinned, bool arg_public, bool arg_close_friends, bool arg_min, bool arg_noforwards, bool arg_edited, bool arg_contacts, bool arg_selected_contacts, bool arg_out, int arg_id, int arg_date, Peer arg_from_id, StoryFwdHeader arg_fwd_from, int arg_expire_date, const char * arg_caption, MessageEntity *arg_entities, int len_arg_entities, MessageMedia arg_media, MediaArea *arg_media_areas, int len_arg_media_areas, PrivacyRule *arg_privacy, int len_arg_privacy, StoryViews arg_views, Reaction arg_sent_reaction)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "storyItem");
	int i;
	obj->id = 0x79b26a24;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 22;
	obj->objs = 
		(tlo_t **)MALLOC(22 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 5;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_pinned);
	strcpy(obj->objs[1]->name, "pinned");
	if (arg_pinned)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 7;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_public);
	strcpy(obj->objs[2]->name, "public");
	if (arg_public)
		flagsv[nflags-1] |= (1 << 7);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 8;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_close_friends);
	strcpy(obj->objs[3]->name, "close_friends");
	if (arg_close_friends)
		flagsv[nflags-1] |= (1 << 8);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 9;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_min);
	strcpy(obj->objs[4]->name, "min");
	if (arg_min)
		flagsv[nflags-1] |= (1 << 9);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 10;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_noforwards);
	strcpy(obj->objs[5]->name, "noforwards");
	if (arg_noforwards)
		flagsv[nflags-1] |= (1 << 10);

	//parse argument true
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 11;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_edited);
	strcpy(obj->objs[6]->name, "edited");
	if (arg_edited)
		flagsv[nflags-1] |= (1 << 11);

	//parse argument true
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 12;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_contacts);
	strcpy(obj->objs[7]->name, "contacts");
	if (arg_contacts)
		flagsv[nflags-1] |= (1 << 12);

	//parse argument true
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 13;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_selected_contacts);
	strcpy(obj->objs[8]->name, "selected_contacts");
	if (arg_selected_contacts)
		flagsv[nflags-1] |= (1 << 13);

	//parse argument true
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 1;
	obj->objs[9]->flag_bit = 16;
	obj->objs[9]->type = TYPE_INT;
	obj->objs[9]->value = 
		buf_add_ui32(arg_out);
	strcpy(obj->objs[9]->name, "out");
	if (arg_out)
		flagsv[nflags-1] |= (1 << 16);

	//parse argument int
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 0;
	obj->objs[10]->flag_bit = 0;
	obj->objs[10]->type = TYPE_INT;
	obj->objs[10]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[10]->name, "id");

	//parse argument int
	obj->objs[11] = NEW(tlo_t, return NULL);
	obj->objs[11]->flag_num = 0;
	obj->objs[11]->flag_bit = 0;
	obj->objs[11]->type = TYPE_INT;
	obj->objs[11]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[11]->name, "date");

	//parse argument Peer
	if (arg_from_id){
		obj->objs[12] = arg_from_id;
		obj->objs[12]->flag_num = 1;
		obj->objs[12]->flag_bit = 18;
	strcpy(obj->objs[12]->name, "from_id");
		flagsv[nflags-1] |= (1 << 18);
	}


	//parse argument StoryFwdHeader
	if (arg_fwd_from){
		obj->objs[13] = arg_fwd_from;
		obj->objs[13]->flag_num = 1;
		obj->objs[13]->flag_bit = 17;
	strcpy(obj->objs[13]->name, "fwd_from");
		flagsv[nflags-1] |= (1 << 17);
	}


	//parse argument int
	obj->objs[14] = NEW(tlo_t, return NULL);
	obj->objs[14]->flag_num = 0;
	obj->objs[14]->flag_bit = 0;
	obj->objs[14]->type = TYPE_INT;
	obj->objs[14]->value = 
		buf_add_ui32(arg_expire_date);
	strcpy(obj->objs[14]->name, "expire_date");

	//parse argument string
	if (arg_caption){
		obj->objs[15] = NEW(tlo_t, return NULL);
		obj->objs[15]->flag_num = 1;
		obj->objs[15]->flag_bit = 0;
		obj->objs[15]->type = TYPE_STRING;
		obj->objs[15]->value = 
			buf_add((ui8_t *)arg_caption, strlen(arg_caption));
		strcpy(obj->objs[15]->name, "caption");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument Vector<MessageEntity>
	obj->objs[16] = NEW(tlo_t, return NULL);
	obj->objs[16]->flag_num = 1;
	obj->objs[16]->flag_bit = 1;
	obj->objs[16]->type = TYPE_VECTOR;
	strcpy(obj->objs[16]->name, "entities");
	if (arg_entities){
		for(i=0; i<len_arg_entities; ++i){
			obj->objs[16]->value = buf_add_ui32(arg_entities[i]->id);
			buf_cat(obj->objs[16]->value, arg_entities[i]->value);
		}
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument MessageMedia
	if (arg_media){
		obj->objs[17] = arg_media;
		obj->objs[17]->flag_num = 0;
		obj->objs[17]->flag_bit = 0;
	strcpy(obj->objs[17]->name, "media");
	}


	//parse argument Vector<MediaArea>
	obj->objs[18] = NEW(tlo_t, return NULL);
	obj->objs[18]->flag_num = 1;
	obj->objs[18]->flag_bit = 14;
	obj->objs[18]->type = TYPE_VECTOR;
	strcpy(obj->objs[18]->name, "media_areas");
	if (arg_media_areas){
		for(i=0; i<len_arg_media_areas; ++i){
			obj->objs[18]->value = buf_add_ui32(arg_media_areas[i]->id);
			buf_cat(obj->objs[18]->value, arg_media_areas[i]->value);
		}
		flagsv[nflags-1] |= (1 << 14);
	}


	//parse argument Vector<PrivacyRule>
	obj->objs[19] = NEW(tlo_t, return NULL);
	obj->objs[19]->flag_num = 1;
	obj->objs[19]->flag_bit = 2;
	obj->objs[19]->type = TYPE_VECTOR;
	strcpy(obj->objs[19]->name, "privacy");
	if (arg_privacy){
		for(i=0; i<len_arg_privacy; ++i){
			obj->objs[19]->value = buf_add_ui32(arg_privacy[i]->id);
			buf_cat(obj->objs[19]->value, arg_privacy[i]->value);
		}
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument StoryViews
	if (arg_views){
		obj->objs[20] = arg_views;
		obj->objs[20]->flag_num = 1;
		obj->objs[20]->flag_bit = 3;
	strcpy(obj->objs[20]->name, "views");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument Reaction
	if (arg_sent_reaction){
		obj->objs[21] = arg_sent_reaction;
		obj->objs[21]->flag_num = 1;
		obj->objs[21]->flag_bit = 15;
	strcpy(obj->objs[21]->name, "sent_reaction");
		flagsv[nflags-1] |= (1 << 15);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_stories_allStoriesNotModified(const char * arg_state, StoriesStealthMode arg_stealth_mode)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stories_allStoriesNotModified");
	int i;
	obj->id = 0x1158fe3e;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_state){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_state, strlen(arg_state));
		strcpy(obj->objs[1]->name, "state");
	}


	//parse argument StoriesStealthMode
	if (arg_stealth_mode){
		obj->objs[2] = arg_stealth_mode;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "stealth_mode");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_stories_allStories(bool arg_has_more, int arg_count, const char * arg_state, PeerStories *arg_peer_stories, int len_arg_peer_stories, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users, StoriesStealthMode arg_stealth_mode)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stories_allStories");
	int i;
	obj->id = 0x6efc5e81;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_has_more);
	strcpy(obj->objs[1]->name, "has_more");
	if (arg_has_more)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[2]->name, "count");

	//parse argument string
	if (arg_state){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_state, strlen(arg_state));
		strcpy(obj->objs[3]->name, "state");
	}


	//parse argument Vector<PeerStories>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "peer_stories");
	if (arg_peer_stories){
		for(i=0; i<len_arg_peer_stories; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_peer_stories[i]->id);
			buf_cat(obj->objs[4]->value, arg_peer_stories[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_VECTOR;
	strcpy(obj->objs[5]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[5]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[5]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_VECTOR;
	strcpy(obj->objs[6]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[6]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[6]->value, arg_users[i]->value);
		}
	}


	//parse argument StoriesStealthMode
	if (arg_stealth_mode){
		obj->objs[7] = arg_stealth_mode;
		obj->objs[7]->flag_num = 0;
		obj->objs[7]->flag_bit = 0;
	strcpy(obj->objs[7]->name, "stealth_mode");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_stories_stories(int arg_count, StoryItem *arg_stories, int len_arg_stories, int *arg_pinned_to_top, int len_arg_pinned_to_top, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stories_stories");
	int i;
	obj->id = 0x63c3dd0a;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[1]->name, "count");

	//parse argument Vector<StoryItem>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "stories");
	if (arg_stories){
		for(i=0; i<len_arg_stories; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_stories[i]->id);
			buf_cat(obj->objs[2]->value, arg_stories[i]->value);
		}
	}


	//parse argument Vector<int>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "pinned_to_top");
	if (arg_pinned_to_top){
		for(i=0; i<len_arg_pinned_to_top; ++i){
			buf_t b = buf_add_ui32(arg_pinned_to_top[i]);
			buf_cat(obj->objs[3]->value, b);
		}
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument Vector<Chat>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[4]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_VECTOR;
	strcpy(obj->objs[5]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[5]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[5]->value, arg_users[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_storyView(bool arg_blocked, bool arg_blocked_my_stories_from, long arg_user_id, int arg_date, Reaction arg_reaction)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "storyView");
	int i;
	obj->id = 0xb0bdeac5;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_blocked);
	strcpy(obj->objs[1]->name, "blocked");
	if (arg_blocked)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_blocked_my_stories_from);
	strcpy(obj->objs[2]->name, "blocked_my_stories_from");
	if (arg_blocked_my_stories_from)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[3]->name, "user_id");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[4]->name, "date");

	//parse argument Reaction
	if (arg_reaction){
		obj->objs[5] = arg_reaction;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 2;
	strcpy(obj->objs[5]->name, "reaction");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_storyViewPublicForward(bool arg_blocked, bool arg_blocked_my_stories_from, Message arg_message)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "storyViewPublicForward");
	int i;
	obj->id = 0x9083670b;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_blocked);
	strcpy(obj->objs[1]->name, "blocked");
	if (arg_blocked)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_blocked_my_stories_from);
	strcpy(obj->objs[2]->name, "blocked_my_stories_from");
	if (arg_blocked_my_stories_from)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument Message
	if (arg_message){
		obj->objs[3] = arg_message;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "message");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_storyViewPublicRepost(bool arg_blocked, bool arg_blocked_my_stories_from, Peer arg_peer_id, StoryItem arg_story)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "storyViewPublicRepost");
	int i;
	obj->id = 0xbd74cf49;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_blocked);
	strcpy(obj->objs[1]->name, "blocked");
	if (arg_blocked)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_blocked_my_stories_from);
	strcpy(obj->objs[2]->name, "blocked_my_stories_from");
	if (arg_blocked_my_stories_from)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument Peer
	if (arg_peer_id){
		obj->objs[3] = arg_peer_id;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "peer_id");
	}


	//parse argument StoryItem
	if (arg_story){
		obj->objs[4] = arg_story;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "story");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_stories_storyViewsList(int arg_count, int arg_views_count, int arg_forwards_count, int arg_reactions_count, StoryView *arg_views, int len_arg_views, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users, const char * arg_next_offset)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stories_storyViewsList");
	int i;
	obj->id = 0x59d78fc5;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[1]->name, "count");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_views_count);
	strcpy(obj->objs[2]->name, "views_count");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_forwards_count);
	strcpy(obj->objs[3]->name, "forwards_count");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_reactions_count);
	strcpy(obj->objs[4]->name, "reactions_count");

	//parse argument Vector<StoryView>
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_VECTOR;
	strcpy(obj->objs[5]->name, "views");
	if (arg_views){
		for(i=0; i<len_arg_views; ++i){
			obj->objs[5]->value = buf_add_ui32(arg_views[i]->id);
			buf_cat(obj->objs[5]->value, arg_views[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_VECTOR;
	strcpy(obj->objs[6]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[6]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[6]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_VECTOR;
	strcpy(obj->objs[7]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[7]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[7]->value, arg_users[i]->value);
		}
	}


	//parse argument string
	if (arg_next_offset){
		obj->objs[8] = NEW(tlo_t, return NULL);
		obj->objs[8]->flag_num = 1;
		obj->objs[8]->flag_bit = 0;
		obj->objs[8]->type = TYPE_STRING;
		obj->objs[8]->value = 
			buf_add((ui8_t *)arg_next_offset, strlen(arg_next_offset));
		strcpy(obj->objs[8]->name, "next_offset");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_stories_storyViews(StoryViews *arg_views, int len_arg_views, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stories_storyViews");
	int i;
	obj->id = 0xde9eed1d;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<StoryViews>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "views");
	if (arg_views){
		for(i=0; i<len_arg_views; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_views[i]->id);
			buf_cat(obj->objs[0]->value, arg_views[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[1]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_inputReplyToMessage(int arg_reply_to_msg_id, int arg_top_msg_id, InputPeer arg_reply_to_peer_id, const char * arg_quote_text, MessageEntity *arg_quote_entities, int len_arg_quote_entities, int arg_quote_offset)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputReplyToMessage");
	int i;
	obj->id = 0x22c0f6d5;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_reply_to_msg_id);
	strcpy(obj->objs[1]->name, "reply_to_msg_id");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_top_msg_id);
	strcpy(obj->objs[2]->name, "top_msg_id");
	if (arg_top_msg_id)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputPeer
	if (arg_reply_to_peer_id){
		obj->objs[3] = arg_reply_to_peer_id;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 1;
	strcpy(obj->objs[3]->name, "reply_to_peer_id");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument string
	if (arg_quote_text){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 2;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_quote_text, strlen(arg_quote_text));
		strcpy(obj->objs[4]->name, "quote_text");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument Vector<MessageEntity>
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 3;
	obj->objs[5]->type = TYPE_VECTOR;
	strcpy(obj->objs[5]->name, "quote_entities");
	if (arg_quote_entities){
		for(i=0; i<len_arg_quote_entities; ++i){
			obj->objs[5]->value = buf_add_ui32(arg_quote_entities[i]->id);
			buf_cat(obj->objs[5]->value, arg_quote_entities[i]->value);
		}
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 4;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_quote_offset);
	strcpy(obj->objs[6]->name, "quote_offset");
	if (arg_quote_offset)
		flagsv[nflags-1] |= (1 << 4);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputReplyToStory(InputPeer arg_peer, int arg_story_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputReplyToStory");
	int i;
	obj->id = 0x5881323a;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_story_id);
	strcpy(obj->objs[1]->name, "story_id");
	return obj;
}

tlo_t * tl_exportedStoryLink(const char * arg_link)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "exportedStoryLink");
	int i;
	obj->id = 0x3fc9053b;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_link){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_link, strlen(arg_link));
		strcpy(obj->objs[0]->name, "link");
	}

	return obj;
}

tlo_t * tl_storiesStealthMode(int arg_active_until_date, int arg_cooldown_until_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "storiesStealthMode");
	int i;
	obj->id = 0x712e27fd;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_active_until_date);
	strcpy(obj->objs[1]->name, "active_until_date");
	if (arg_active_until_date)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_cooldown_until_date);
	strcpy(obj->objs[2]->name, "cooldown_until_date");
	if (arg_cooldown_until_date)
		flagsv[nflags-1] |= (1 << 1);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_mediaAreaCoordinates(double arg_x, double arg_y, double arg_w, double arg_h, double arg_rotation, double arg_radius)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "mediaAreaCoordinates");
	int i;
	obj->id = 0xcfc9e002;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument double
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_x);
	strcpy(obj->objs[1]->name, "x");

	//parse argument double
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_y);
	strcpy(obj->objs[2]->name, "y");

	//parse argument double
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_w);
	strcpy(obj->objs[3]->name, "w");

	//parse argument double
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_h);
	strcpy(obj->objs[4]->name, "h");

	//parse argument double
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_LONG;
	obj->objs[5]->value = 
		buf_add_ui64(arg_rotation);
	strcpy(obj->objs[5]->name, "rotation");

	//parse argument double
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_LONG;
	obj->objs[6]->value = 
		buf_add_ui64(arg_radius);
	strcpy(obj->objs[6]->name, "radius");
	if (arg_radius)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_mediaAreaVenue(MediaAreaCoordinates arg_coordinates, GeoPoint arg_geo, const char * arg_title, const char * arg_address, const char * arg_provider, const char * arg_venue_id, const char * arg_venue_type)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "mediaAreaVenue");
	int i;
	obj->id = 0xbe82db9c;
	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument MediaAreaCoordinates
	if (arg_coordinates){
		obj->objs[0] = arg_coordinates;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "coordinates");
	}


	//parse argument GeoPoint
	if (arg_geo){
		obj->objs[1] = arg_geo;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "geo");
	}


	//parse argument string
	if (arg_title){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[2]->name, "title");
	}


	//parse argument string
	if (arg_address){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_address, strlen(arg_address));
		strcpy(obj->objs[3]->name, "address");
	}


	//parse argument string
	if (arg_provider){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_provider, strlen(arg_provider));
		strcpy(obj->objs[4]->name, "provider");
	}


	//parse argument string
	if (arg_venue_id){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_venue_id, strlen(arg_venue_id));
		strcpy(obj->objs[5]->name, "venue_id");
	}


	//parse argument string
	if (arg_venue_type){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_venue_type, strlen(arg_venue_type));
		strcpy(obj->objs[6]->name, "venue_type");
	}

	return obj;
}

tlo_t * tl_inputMediaAreaVenue(MediaAreaCoordinates arg_coordinates, long arg_query_id, const char * arg_result_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMediaAreaVenue");
	int i;
	obj->id = 0xb282217f;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument MediaAreaCoordinates
	if (arg_coordinates){
		obj->objs[0] = arg_coordinates;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "coordinates");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_query_id);
	strcpy(obj->objs[1]->name, "query_id");

	//parse argument string
	if (arg_result_id){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_result_id, strlen(arg_result_id));
		strcpy(obj->objs[2]->name, "result_id");
	}

	return obj;
}

tlo_t * tl_mediaAreaGeoPoint(MediaAreaCoordinates arg_coordinates, GeoPoint arg_geo, GeoPointAddress arg_address)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "mediaAreaGeoPoint");
	int i;
	obj->id = 0xcad5452d;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument MediaAreaCoordinates
	if (arg_coordinates){
		obj->objs[1] = arg_coordinates;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "coordinates");
	}


	//parse argument GeoPoint
	if (arg_geo){
		obj->objs[2] = arg_geo;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "geo");
	}


	//parse argument GeoPointAddress
	if (arg_address){
		obj->objs[3] = arg_address;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "address");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_mediaAreaSuggestedReaction(bool arg_dark, bool arg_flipped, MediaAreaCoordinates arg_coordinates, Reaction arg_reaction)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "mediaAreaSuggestedReaction");
	int i;
	obj->id = 0x14455871;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_dark);
	strcpy(obj->objs[1]->name, "dark");
	if (arg_dark)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_flipped);
	strcpy(obj->objs[2]->name, "flipped");
	if (arg_flipped)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument MediaAreaCoordinates
	if (arg_coordinates){
		obj->objs[3] = arg_coordinates;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "coordinates");
	}


	//parse argument Reaction
	if (arg_reaction){
		obj->objs[4] = arg_reaction;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "reaction");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_mediaAreaChannelPost(MediaAreaCoordinates arg_coordinates, long arg_channel_id, int arg_msg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "mediaAreaChannelPost");
	int i;
	obj->id = 0x770416af;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument MediaAreaCoordinates
	if (arg_coordinates){
		obj->objs[0] = arg_coordinates;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "coordinates");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_channel_id);
	strcpy(obj->objs[1]->name, "channel_id");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[2]->name, "msg_id");
	return obj;
}

tlo_t * tl_inputMediaAreaChannelPost(MediaAreaCoordinates arg_coordinates, InputChannel arg_channel, int arg_msg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputMediaAreaChannelPost");
	int i;
	obj->id = 0x2271f2bf;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument MediaAreaCoordinates
	if (arg_coordinates){
		obj->objs[0] = arg_coordinates;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "coordinates");
	}


	//parse argument InputChannel
	if (arg_channel){
		obj->objs[1] = arg_channel;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "channel");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[2]->name, "msg_id");
	return obj;
}

tlo_t * tl_mediaAreaUrl(MediaAreaCoordinates arg_coordinates, const char * arg_url)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "mediaAreaUrl");
	int i;
	obj->id = 0x37381085;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument MediaAreaCoordinates
	if (arg_coordinates){
		obj->objs[0] = arg_coordinates;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "coordinates");
	}


	//parse argument string
	if (arg_url){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[1]->name, "url");
	}

	return obj;
}

tlo_t * tl_mediaAreaWeather(MediaAreaCoordinates arg_coordinates, const char * arg_emoji, double arg_temperature_c, int arg_color)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "mediaAreaWeather");
	int i;
	obj->id = 0x49a6549c;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument MediaAreaCoordinates
	if (arg_coordinates){
		obj->objs[0] = arg_coordinates;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "coordinates");
	}


	//parse argument string
	if (arg_emoji){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_emoji, strlen(arg_emoji));
		strcpy(obj->objs[1]->name, "emoji");
	}


	//parse argument double
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_temperature_c);
	strcpy(obj->objs[2]->name, "temperature_c");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_color);
	strcpy(obj->objs[3]->name, "color");
	return obj;
}

tlo_t * tl_peerStories(Peer arg_peer, int arg_max_read_id, StoryItem *arg_stories, int len_arg_stories)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "peerStories");
	int i;
	obj->id = 0x9a35e999;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument Peer
	if (arg_peer){
		obj->objs[1] = arg_peer;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "peer");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_max_read_id);
	strcpy(obj->objs[2]->name, "max_read_id");
	if (arg_max_read_id)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument Vector<StoryItem>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "stories");
	if (arg_stories){
		for(i=0; i<len_arg_stories; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_stories[i]->id);
			buf_cat(obj->objs[3]->value, arg_stories[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_stories_peerStories(PeerStories arg_stories, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stories_peerStories");
	int i;
	obj->id = 0xcae68768;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument PeerStories
	if (arg_stories){
		obj->objs[0] = arg_stories;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "stories");
	}


	//parse argument Vector<Chat>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[1]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[2]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_messages_webPage(WebPage arg_webpage, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_webPage");
	int i;
	obj->id = 0xfd5e12bd;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument WebPage
	if (arg_webpage){
		obj->objs[0] = arg_webpage;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "webpage");
	}


	//parse argument Vector<Chat>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[1]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[2]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_premiumGiftCodeOption(int arg_users, int arg_months, const char * arg_store_product, int arg_store_quantity, const char * arg_currency, long arg_amount)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "premiumGiftCodeOption");
	int i;
	obj->id = 0x257e962b;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_users);
	strcpy(obj->objs[1]->name, "users");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_months);
	strcpy(obj->objs[2]->name, "months");

	//parse argument string
	if (arg_store_product){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_store_product, strlen(arg_store_product));
		strcpy(obj->objs[3]->name, "store_product");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 1;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_store_quantity);
	strcpy(obj->objs[4]->name, "store_quantity");
	if (arg_store_quantity)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument string
	if (arg_currency){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_currency, strlen(arg_currency));
		strcpy(obj->objs[5]->name, "currency");
	}


	//parse argument long
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_LONG;
	obj->objs[6]->value = 
		buf_add_ui64(arg_amount);
	strcpy(obj->objs[6]->name, "amount");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_payments_checkedGiftCode(bool arg_via_giveaway, Peer arg_from_id, int arg_giveaway_msg_id, long arg_to_id, int arg_date, int arg_months, int arg_used_date, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_checkedGiftCode");
	int i;
	obj->id = 0x284a1096;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 10;
	obj->objs = 
		(tlo_t **)MALLOC(10 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 2;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_via_giveaway);
	strcpy(obj->objs[1]->name, "via_giveaway");
	if (arg_via_giveaway)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument Peer
	if (arg_from_id){
		obj->objs[2] = arg_from_id;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 4;
	strcpy(obj->objs[2]->name, "from_id");
		flagsv[nflags-1] |= (1 << 4);
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 3;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_giveaway_msg_id);
	strcpy(obj->objs[3]->name, "giveaway_msg_id");
	if (arg_giveaway_msg_id)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument long
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_to_id);
	strcpy(obj->objs[4]->name, "to_id");
	if (arg_to_id)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[5]->name, "date");

	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_months);
	strcpy(obj->objs[6]->name, "months");

	//parse argument int
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 1;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_used_date);
	strcpy(obj->objs[7]->name, "used_date");
	if (arg_used_date)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument Vector<Chat>
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 0;
	obj->objs[8]->flag_bit = 0;
	obj->objs[8]->type = TYPE_VECTOR;
	strcpy(obj->objs[8]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[8]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[8]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 0;
	obj->objs[9]->flag_bit = 0;
	obj->objs[9]->type = TYPE_VECTOR;
	strcpy(obj->objs[9]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[9]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[9]->value, arg_users[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_payments_giveawayInfo(bool arg_participating, bool arg_preparing_results, int arg_start_date, int arg_joined_too_early_date, long arg_admin_disallowed_chat_id, const char * arg_disallowed_country)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_giveawayInfo");
	int i;
	obj->id = 0x4367daa0;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_participating);
	strcpy(obj->objs[1]->name, "participating");
	if (arg_participating)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 3;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_preparing_results);
	strcpy(obj->objs[2]->name, "preparing_results");
	if (arg_preparing_results)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_start_date);
	strcpy(obj->objs[3]->name, "start_date");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 1;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_joined_too_early_date);
	strcpy(obj->objs[4]->name, "joined_too_early_date");
	if (arg_joined_too_early_date)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument long
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 2;
	obj->objs[5]->type = TYPE_LONG;
	obj->objs[5]->value = 
		buf_add_ui64(arg_admin_disallowed_chat_id);
	strcpy(obj->objs[5]->name, "admin_disallowed_chat_id");
	if (arg_admin_disallowed_chat_id)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument string
	if (arg_disallowed_country){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 4;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_disallowed_country, strlen(arg_disallowed_country));
		strcpy(obj->objs[6]->name, "disallowed_country");
		flagsv[nflags-1] |= (1 << 4);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_payments_giveawayInfoResults(bool arg_winner, bool arg_refunded, int arg_start_date, const char * arg_gift_code_slug, long arg_stars_prize, int arg_finish_date, int arg_winners_count, int arg_activated_count)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_giveawayInfoResults");
	int i;
	obj->id = 0xe175e66f;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_winner);
	strcpy(obj->objs[1]->name, "winner");
	if (arg_winner)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_refunded);
	strcpy(obj->objs[2]->name, "refunded");
	if (arg_refunded)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_start_date);
	strcpy(obj->objs[3]->name, "start_date");

	//parse argument string
	if (arg_gift_code_slug){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 3;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_gift_code_slug, strlen(arg_gift_code_slug));
		strcpy(obj->objs[4]->name, "gift_code_slug");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument long
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 4;
	obj->objs[5]->type = TYPE_LONG;
	obj->objs[5]->value = 
		buf_add_ui64(arg_stars_prize);
	strcpy(obj->objs[5]->name, "stars_prize");
	if (arg_stars_prize)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_finish_date);
	strcpy(obj->objs[6]->name, "finish_date");

	//parse argument int
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_winners_count);
	strcpy(obj->objs[7]->name, "winners_count");

	//parse argument int
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 2;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_activated_count);
	strcpy(obj->objs[8]->name, "activated_count");
	if (arg_activated_count)
		flagsv[nflags-1] |= (1 << 2);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_prepaidGiveaway(long arg_id, int arg_months, int arg_quantity, int arg_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "prepaidGiveaway");
	int i;
	obj->id = 0xb2539d54;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_months);
	strcpy(obj->objs[1]->name, "months");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_quantity);
	strcpy(obj->objs[2]->name, "quantity");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[3]->name, "date");
	return obj;
}

tlo_t * tl_prepaidStarsGiveaway(long arg_id, long arg_stars, int arg_quantity, int arg_boosts, int arg_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "prepaidStarsGiveaway");
	int i;
	obj->id = 0x9a9d77e0;
	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_stars);
	strcpy(obj->objs[1]->name, "stars");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_quantity);
	strcpy(obj->objs[2]->name, "quantity");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_boosts);
	strcpy(obj->objs[3]->name, "boosts");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[4]->name, "date");
	return obj;
}

tlo_t * tl_boost(bool arg_gift, bool arg_giveaway, bool arg_unclaimed, const char * arg_id, long arg_user_id, int arg_giveaway_msg_id, int arg_date, int arg_expires, const char * arg_used_gift_slug, int arg_multiplier, long arg_stars)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "boost");
	int i;
	obj->id = 0x4b3e14d6;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 12;
	obj->objs = 
		(tlo_t **)MALLOC(12 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_gift);
	strcpy(obj->objs[1]->name, "gift");
	if (arg_gift)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 2;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_giveaway);
	strcpy(obj->objs[2]->name, "giveaway");
	if (arg_giveaway)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 3;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_unclaimed);
	strcpy(obj->objs[3]->name, "unclaimed");
	if (arg_unclaimed)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument string
	if (arg_id){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_id, strlen(arg_id));
		strcpy(obj->objs[4]->name, "id");
	}


	//parse argument long
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_LONG;
	obj->objs[5]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[5]->name, "user_id");
	if (arg_user_id)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 2;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_giveaway_msg_id);
	strcpy(obj->objs[6]->name, "giveaway_msg_id");
	if (arg_giveaway_msg_id)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument int
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[7]->name, "date");

	//parse argument int
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 0;
	obj->objs[8]->flag_bit = 0;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_expires);
	strcpy(obj->objs[8]->name, "expires");

	//parse argument string
	if (arg_used_gift_slug){
		obj->objs[9] = NEW(tlo_t, return NULL);
		obj->objs[9]->flag_num = 1;
		obj->objs[9]->flag_bit = 4;
		obj->objs[9]->type = TYPE_STRING;
		obj->objs[9]->value = 
			buf_add((ui8_t *)arg_used_gift_slug, strlen(arg_used_gift_slug));
		strcpy(obj->objs[9]->name, "used_gift_slug");
		flagsv[nflags-1] |= (1 << 4);
	}


	//parse argument int
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 1;
	obj->objs[10]->flag_bit = 5;
	obj->objs[10]->type = TYPE_INT;
	obj->objs[10]->value = 
		buf_add_ui32(arg_multiplier);
	strcpy(obj->objs[10]->name, "multiplier");
	if (arg_multiplier)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument long
	obj->objs[11] = NEW(tlo_t, return NULL);
	obj->objs[11]->flag_num = 1;
	obj->objs[11]->flag_bit = 6;
	obj->objs[11]->type = TYPE_LONG;
	obj->objs[11]->value = 
		buf_add_ui64(arg_stars);
	strcpy(obj->objs[11]->name, "stars");
	if (arg_stars)
		flagsv[nflags-1] |= (1 << 6);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_premium_boostsList(int arg_count, Boost *arg_boosts, int len_arg_boosts, const char * arg_next_offset, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "premium_boostsList");
	int i;
	obj->id = 0x86f8613c;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[1]->name, "count");

	//parse argument Vector<Boost>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "boosts");
	if (arg_boosts){
		for(i=0; i<len_arg_boosts; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_boosts[i]->id);
			buf_cat(obj->objs[2]->value, arg_boosts[i]->value);
		}
	}


	//parse argument string
	if (arg_next_offset){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_next_offset, strlen(arg_next_offset));
		strcpy(obj->objs[3]->name, "next_offset");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument Vector<User>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[4]->value, arg_users[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_myBoost(int arg_slot, Peer arg_peer, int arg_date, int arg_expires, int arg_cooldown_until_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "myBoost");
	int i;
	obj->id = 0xc448415c;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_slot);
	strcpy(obj->objs[1]->name, "slot");

	//parse argument Peer
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[3]->name, "date");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_expires);
	strcpy(obj->objs[4]->name, "expires");

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 1;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_cooldown_until_date);
	strcpy(obj->objs[5]->name, "cooldown_until_date");
	if (arg_cooldown_until_date)
		flagsv[nflags-1] |= (1 << 1);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_premium_myBoosts(MyBoost *arg_my_boosts, int len_arg_my_boosts, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "premium_myBoosts");
	int i;
	obj->id = 0x9ae228e2;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<MyBoost>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "my_boosts");
	if (arg_my_boosts){
		for(i=0; i<len_arg_my_boosts; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_my_boosts[i]->id);
			buf_cat(obj->objs[0]->value, arg_my_boosts[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[1]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[2]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_premium_boostsStatus(bool arg_my_boost, int arg_level, int arg_current_level_boosts, int arg_boosts, int arg_gift_boosts, int arg_next_level_boosts, StatsPercentValue arg_premium_audience, const char * arg_boost_url, PrepaidGiveaway *arg_prepaid_giveaways, int len_arg_prepaid_giveaways, int *arg_my_boost_slots, int len_arg_my_boost_slots)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "premium_boostsStatus");
	int i;
	obj->id = 0x4959427a;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 11;
	obj->objs = 
		(tlo_t **)MALLOC(11 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 2;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_my_boost);
	strcpy(obj->objs[1]->name, "my_boost");
	if (arg_my_boost)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_level);
	strcpy(obj->objs[2]->name, "level");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_current_level_boosts);
	strcpy(obj->objs[3]->name, "current_level_boosts");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_boosts);
	strcpy(obj->objs[4]->name, "boosts");

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 4;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_gift_boosts);
	strcpy(obj->objs[5]->name, "gift_boosts");
	if (arg_gift_boosts)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_next_level_boosts);
	strcpy(obj->objs[6]->name, "next_level_boosts");
	if (arg_next_level_boosts)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument StatsPercentValue
	if (arg_premium_audience){
		obj->objs[7] = arg_premium_audience;
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 1;
	strcpy(obj->objs[7]->name, "premium_audience");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument string
	if (arg_boost_url){
		obj->objs[8] = NEW(tlo_t, return NULL);
		obj->objs[8]->flag_num = 0;
		obj->objs[8]->flag_bit = 0;
		obj->objs[8]->type = TYPE_STRING;
		obj->objs[8]->value = 
			buf_add((ui8_t *)arg_boost_url, strlen(arg_boost_url));
		strcpy(obj->objs[8]->name, "boost_url");
	}


	//parse argument Vector<PrepaidGiveaway>
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 1;
	obj->objs[9]->flag_bit = 3;
	obj->objs[9]->type = TYPE_VECTOR;
	strcpy(obj->objs[9]->name, "prepaid_giveaways");
	if (arg_prepaid_giveaways){
		for(i=0; i<len_arg_prepaid_giveaways; ++i){
			obj->objs[9]->value = buf_add_ui32(arg_prepaid_giveaways[i]->id);
			buf_cat(obj->objs[9]->value, arg_prepaid_giveaways[i]->value);
		}
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument Vector<int>
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 1;
	obj->objs[10]->flag_bit = 2;
	obj->objs[10]->type = TYPE_VECTOR;
	strcpy(obj->objs[10]->name, "my_boost_slots");
	if (arg_my_boost_slots){
		for(i=0; i<len_arg_my_boost_slots; ++i){
			buf_t b = buf_add_ui32(arg_my_boost_slots[i]);
			buf_cat(obj->objs[10]->value, b);
		}
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_storyFwdHeader(bool arg_modified, Peer arg_from, const char * arg_from_name, int arg_story_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "storyFwdHeader");
	int i;
	obj->id = 0xb826e150;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 3;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_modified);
	strcpy(obj->objs[1]->name, "modified");
	if (arg_modified)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument Peer
	if (arg_from){
		obj->objs[2] = arg_from;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "from");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_from_name){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 1;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_from_name, strlen(arg_from_name));
		strcpy(obj->objs[3]->name, "from_name");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 2;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_story_id);
	strcpy(obj->objs[4]->name, "story_id");
	if (arg_story_id)
		flagsv[nflags-1] |= (1 << 2);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_postInteractionCountersMessage(int arg_msg_id, int arg_views, int arg_forwards, int arg_reactions)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "postInteractionCountersMessage");
	int i;
	obj->id = 0xe7058e7f;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[0]->name, "msg_id");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_views);
	strcpy(obj->objs[1]->name, "views");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_forwards);
	strcpy(obj->objs[2]->name, "forwards");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_reactions);
	strcpy(obj->objs[3]->name, "reactions");
	return obj;
}

tlo_t * tl_postInteractionCountersStory(int arg_story_id, int arg_views, int arg_forwards, int arg_reactions)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "postInteractionCountersStory");
	int i;
	obj->id = 0x8a480e27;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_story_id);
	strcpy(obj->objs[0]->name, "story_id");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_views);
	strcpy(obj->objs[1]->name, "views");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_forwards);
	strcpy(obj->objs[2]->name, "forwards");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_reactions);
	strcpy(obj->objs[3]->name, "reactions");
	return obj;
}

tlo_t * tl_stats_storyStats(StatsGraph arg_views_graph, StatsGraph arg_reactions_by_emotion_graph)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stats_storyStats");
	int i;
	obj->id = 0x50cd067c;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument StatsGraph
	if (arg_views_graph){
		obj->objs[0] = arg_views_graph;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "views_graph");
	}


	//parse argument StatsGraph
	if (arg_reactions_by_emotion_graph){
		obj->objs[1] = arg_reactions_by_emotion_graph;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "reactions_by_emotion_graph");
	}

	return obj;
}

tlo_t * tl_publicForwardMessage(Message arg_message)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "publicForwardMessage");
	int i;
	obj->id = 0x01f2bf4a;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Message
	if (arg_message){
		obj->objs[0] = arg_message;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "message");
	}

	return obj;
}

tlo_t * tl_publicForwardStory(Peer arg_peer, StoryItem arg_story)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "publicForwardStory");
	int i;
	obj->id = 0xedf3add0;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument StoryItem
	if (arg_story){
		obj->objs[1] = arg_story;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "story");
	}

	return obj;
}

tlo_t * tl_stats_publicForwards(int arg_count, PublicForward *arg_forwards, int len_arg_forwards, const char * arg_next_offset, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stats_publicForwards");
	int i;
	obj->id = 0x93037e20;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[1]->name, "count");

	//parse argument Vector<PublicForward>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "forwards");
	if (arg_forwards){
		for(i=0; i<len_arg_forwards; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_forwards[i]->id);
			buf_cat(obj->objs[2]->value, arg_forwards[i]->value);
		}
	}


	//parse argument string
	if (arg_next_offset){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_next_offset, strlen(arg_next_offset));
		strcpy(obj->objs[3]->name, "next_offset");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument Vector<Chat>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[4]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_VECTOR;
	strcpy(obj->objs[5]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[5]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[5]->value, arg_users[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_peerColor(int arg_color, long arg_background_emoji_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "peerColor");
	int i;
	obj->id = 0xb54b5acf;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_color);
	strcpy(obj->objs[1]->name, "color");
	if (arg_color)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_background_emoji_id);
	strcpy(obj->objs[2]->name, "background_emoji_id");
	if (arg_background_emoji_id)
		flagsv[nflags-1] |= (1 << 1);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_help_peerColorSet(int *arg_colors, int len_arg_colors)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_peerColorSet");
	int i;
	obj->id = 0x26219a58;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<int>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "colors");
	if (arg_colors){
		for(i=0; i<len_arg_colors; ++i){
			buf_t b = buf_add_ui32(arg_colors[i]);
			buf_cat(obj->objs[0]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_help_peerColorProfileSet(int *arg_palette_colors, int len_arg_palette_colors, int *arg_bg_colors, int len_arg_bg_colors, int *arg_story_colors, int len_arg_story_colors)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_peerColorProfileSet");
	int i;
	obj->id = 0x767d61eb;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<int>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "palette_colors");
	if (arg_palette_colors){
		for(i=0; i<len_arg_palette_colors; ++i){
			buf_t b = buf_add_ui32(arg_palette_colors[i]);
			buf_cat(obj->objs[0]->value, b);
		}
	}


	//parse argument Vector<int>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "bg_colors");
	if (arg_bg_colors){
		for(i=0; i<len_arg_bg_colors; ++i){
			buf_t b = buf_add_ui32(arg_bg_colors[i]);
			buf_cat(obj->objs[1]->value, b);
		}
	}


	//parse argument Vector<int>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "story_colors");
	if (arg_story_colors){
		for(i=0; i<len_arg_story_colors; ++i){
			buf_t b = buf_add_ui32(arg_story_colors[i]);
			buf_cat(obj->objs[2]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_help_peerColorOption(bool arg_hidden, int arg_color_id, help_PeerColorSet arg_colors, help_PeerColorSet arg_dark_colors, int arg_channel_min_level, int arg_group_min_level)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_peerColorOption");
	int i;
	obj->id = 0xadec6ebe;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_hidden);
	strcpy(obj->objs[1]->name, "hidden");
	if (arg_hidden)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_color_id);
	strcpy(obj->objs[2]->name, "color_id");

	//parse argument help_PeerColorSet
	if (arg_colors){
		obj->objs[3] = arg_colors;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 1;
	strcpy(obj->objs[3]->name, "colors");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument help_PeerColorSet
	if (arg_dark_colors){
		obj->objs[4] = arg_dark_colors;
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 2;
	strcpy(obj->objs[4]->name, "dark_colors");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 3;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_channel_min_level);
	strcpy(obj->objs[5]->name, "channel_min_level");
	if (arg_channel_min_level)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 4;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_group_min_level);
	strcpy(obj->objs[6]->name, "group_min_level");
	if (arg_group_min_level)
		flagsv[nflags-1] |= (1 << 4);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_help_peerColorsNotModified()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_peerColorsNotModified");
	int i;
	obj->id = 0x2ba1f5ce;
	return obj;
}

tlo_t * tl_help_peerColors(int arg_hash, help_PeerColorOption *arg_colors, int len_arg_colors)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_peerColors");
	int i;
	obj->id = 0x00f8ed08;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_hash);
	strcpy(obj->objs[0]->name, "hash");

	//parse argument Vector<help_PeerColorOption>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "colors");
	if (arg_colors){
		for(i=0; i<len_arg_colors; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_colors[i]->id);
			buf_cat(obj->objs[1]->value, arg_colors[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_storyReaction(Peer arg_peer_id, int arg_date, Reaction arg_reaction)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "storyReaction");
	int i;
	obj->id = 0x6090d6d5;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer_id){
		obj->objs[0] = arg_peer_id;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer_id");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[1]->name, "date");

	//parse argument Reaction
	if (arg_reaction){
		obj->objs[2] = arg_reaction;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "reaction");
	}

	return obj;
}

tlo_t * tl_storyReactionPublicForward(Message arg_message)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "storyReactionPublicForward");
	int i;
	obj->id = 0xbbab2643;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Message
	if (arg_message){
		obj->objs[0] = arg_message;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "message");
	}

	return obj;
}

tlo_t * tl_storyReactionPublicRepost(Peer arg_peer_id, StoryItem arg_story)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "storyReactionPublicRepost");
	int i;
	obj->id = 0xcfcd0f13;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer_id){
		obj->objs[0] = arg_peer_id;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer_id");
	}


	//parse argument StoryItem
	if (arg_story){
		obj->objs[1] = arg_story;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "story");
	}

	return obj;
}

tlo_t * tl_stories_storyReactionsList(int arg_count, StoryReaction *arg_reactions, int len_arg_reactions, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users, const char * arg_next_offset)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stories_storyReactionsList");
	int i;
	obj->id = 0xaa5f789c;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[1]->name, "count");

	//parse argument Vector<StoryReaction>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "reactions");
	if (arg_reactions){
		for(i=0; i<len_arg_reactions; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_reactions[i]->id);
			buf_cat(obj->objs[2]->value, arg_reactions[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[3]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[4]->value, arg_users[i]->value);
		}
	}


	//parse argument string
	if (arg_next_offset){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_next_offset, strlen(arg_next_offset));
		strcpy(obj->objs[5]->name, "next_offset");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_savedDialog(bool arg_pinned, Peer arg_peer, int arg_top_message)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "savedDialog");
	int i;
	obj->id = 0xbd87cb6c;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 2;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_pinned);
	strcpy(obj->objs[1]->name, "pinned");
	if (arg_pinned)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument Peer
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_top_message);
	strcpy(obj->objs[3]->name, "top_message");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_savedDialogs(SavedDialog *arg_dialogs, int len_arg_dialogs, Message *arg_messages, int len_arg_messages, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_savedDialogs");
	int i;
	obj->id = 0xf83ae221;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<SavedDialog>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "dialogs");
	if (arg_dialogs){
		for(i=0; i<len_arg_dialogs; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_dialogs[i]->id);
			buf_cat(obj->objs[0]->value, arg_dialogs[i]->value);
		}
	}


	//parse argument Vector<Message>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "messages");
	if (arg_messages){
		for(i=0; i<len_arg_messages; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_messages[i]->id);
			buf_cat(obj->objs[1]->value, arg_messages[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[2]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[3]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_messages_savedDialogsSlice(int arg_count, SavedDialog *arg_dialogs, int len_arg_dialogs, Message *arg_messages, int len_arg_messages, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_savedDialogsSlice");
	int i;
	obj->id = 0x44ba9dd9;
	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[0]->name, "count");

	//parse argument Vector<SavedDialog>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "dialogs");
	if (arg_dialogs){
		for(i=0; i<len_arg_dialogs; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_dialogs[i]->id);
			buf_cat(obj->objs[1]->value, arg_dialogs[i]->value);
		}
	}


	//parse argument Vector<Message>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "messages");
	if (arg_messages){
		for(i=0; i<len_arg_messages; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_messages[i]->id);
			buf_cat(obj->objs[2]->value, arg_messages[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[3]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[4]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_messages_savedDialogsNotModified(int arg_count)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_savedDialogsNotModified");
	int i;
	obj->id = 0xc01f6fe8;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[0]->name, "count");
	return obj;
}

tlo_t * tl_savedReactionTag(Reaction arg_reaction, const char * arg_title, int arg_count)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "savedReactionTag");
	int i;
	obj->id = 0xcb6ff828;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument Reaction
	if (arg_reaction){
		obj->objs[1] = arg_reaction;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "reaction");
	}


	//parse argument string
	if (arg_title){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[2]->name, "title");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[3]->name, "count");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_savedReactionTagsNotModified()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_savedReactionTagsNotModified");
	int i;
	obj->id = 0x889b59ef;
	return obj;
}

tlo_t * tl_messages_savedReactionTags(SavedReactionTag *arg_tags, int len_arg_tags, long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_savedReactionTags");
	int i;
	obj->id = 0x3259950a;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<SavedReactionTag>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "tags");
	if (arg_tags){
		for(i=0; i<len_arg_tags; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_tags[i]->id);
			buf_cat(obj->objs[0]->value, arg_tags[i]->value);
		}
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[1]->name, "hash");
	return obj;
}

tlo_t * tl_outboxReadDate(int arg_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "outboxReadDate");
	int i;
	obj->id = 0x3bb842ac;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[0]->name, "date");
	return obj;
}

tlo_t * tl_smsjobs_eligibleToJoin(const char * arg_terms_url, int arg_monthly_sent_sms)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "smsjobs_eligibleToJoin");
	int i;
	obj->id = 0xdc8b44cf;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_terms_url){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_terms_url, strlen(arg_terms_url));
		strcpy(obj->objs[0]->name, "terms_url");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_monthly_sent_sms);
	strcpy(obj->objs[1]->name, "monthly_sent_sms");
	return obj;
}

tlo_t * tl_smsjobs_status(bool arg_allow_international, int arg_recent_sent, int arg_recent_since, int arg_recent_remains, int arg_total_sent, int arg_total_since, const char * arg_last_gift_slug, const char * arg_terms_url)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "smsjobs_status");
	int i;
	obj->id = 0x2aee9191;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_allow_international);
	strcpy(obj->objs[1]->name, "allow_international");
	if (arg_allow_international)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_recent_sent);
	strcpy(obj->objs[2]->name, "recent_sent");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_recent_since);
	strcpy(obj->objs[3]->name, "recent_since");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_recent_remains);
	strcpy(obj->objs[4]->name, "recent_remains");

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_total_sent);
	strcpy(obj->objs[5]->name, "total_sent");

	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_total_since);
	strcpy(obj->objs[6]->name, "total_since");

	//parse argument string
	if (arg_last_gift_slug){
		obj->objs[7] = NEW(tlo_t, return NULL);
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 1;
		obj->objs[7]->type = TYPE_STRING;
		obj->objs[7]->value = 
			buf_add((ui8_t *)arg_last_gift_slug, strlen(arg_last_gift_slug));
		strcpy(obj->objs[7]->name, "last_gift_slug");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument string
	if (arg_terms_url){
		obj->objs[8] = NEW(tlo_t, return NULL);
		obj->objs[8]->flag_num = 0;
		obj->objs[8]->flag_bit = 0;
		obj->objs[8]->type = TYPE_STRING;
		obj->objs[8]->value = 
			buf_add((ui8_t *)arg_terms_url, strlen(arg_terms_url));
		strcpy(obj->objs[8]->name, "terms_url");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_smsJob(const char * arg_job_id, const char * arg_phone_number, const char * arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "smsJob");
	int i;
	obj->id = 0xe6a1eeb8;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_job_id){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_job_id, strlen(arg_job_id));
		strcpy(obj->objs[0]->name, "job_id");
	}


	//parse argument string
	if (arg_phone_number){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_phone_number, strlen(arg_phone_number));
		strcpy(obj->objs[1]->name, "phone_number");
	}


	//parse argument string
	if (arg_text){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[2]->name, "text");
	}

	return obj;
}

tlo_t * tl_businessWeeklyOpen(int arg_start_minute, int arg_end_minute)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "businessWeeklyOpen");
	int i;
	obj->id = 0x120b1ab9;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_start_minute);
	strcpy(obj->objs[0]->name, "start_minute");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_end_minute);
	strcpy(obj->objs[1]->name, "end_minute");
	return obj;
}

tlo_t * tl_businessWorkHours(bool arg_open_now, const char * arg_timezone_id, BusinessWeeklyOpen *arg_weekly_open, int len_arg_weekly_open)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "businessWorkHours");
	int i;
	obj->id = 0x8c92b098;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_open_now);
	strcpy(obj->objs[1]->name, "open_now");
	if (arg_open_now)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument string
	if (arg_timezone_id){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_timezone_id, strlen(arg_timezone_id));
		strcpy(obj->objs[2]->name, "timezone_id");
	}


	//parse argument Vector<BusinessWeeklyOpen>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "weekly_open");
	if (arg_weekly_open){
		for(i=0; i<len_arg_weekly_open; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_weekly_open[i]->id);
			buf_cat(obj->objs[3]->value, arg_weekly_open[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_businessLocation(GeoPoint arg_geo_point, const char * arg_address)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "businessLocation");
	int i;
	obj->id = 0xac5c1af7;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument GeoPoint
	if (arg_geo_point){
		obj->objs[1] = arg_geo_point;
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "geo_point");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_address){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_address, strlen(arg_address));
		strcpy(obj->objs[2]->name, "address");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputBusinessRecipients(bool arg_existing_chats, bool arg_new_chats, bool arg_contacts, bool arg_non_contacts, bool arg_exclude_selected, InputUser *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputBusinessRecipients");
	int i;
	obj->id = 0x6f8b32aa;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_existing_chats);
	strcpy(obj->objs[1]->name, "existing_chats");
	if (arg_existing_chats)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_new_chats);
	strcpy(obj->objs[2]->name, "new_chats");
	if (arg_new_chats)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_contacts);
	strcpy(obj->objs[3]->name, "contacts");
	if (arg_contacts)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 3;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_non_contacts);
	strcpy(obj->objs[4]->name, "non_contacts");
	if (arg_non_contacts)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 5;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_exclude_selected);
	strcpy(obj->objs[5]->name, "exclude_selected");
	if (arg_exclude_selected)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument Vector<InputUser>
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 4;
	obj->objs[6]->type = TYPE_VECTOR;
	strcpy(obj->objs[6]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[6]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[6]->value, arg_users[i]->value);
		}
		flagsv[nflags-1] |= (1 << 4);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_businessRecipients(bool arg_existing_chats, bool arg_new_chats, bool arg_contacts, bool arg_non_contacts, bool arg_exclude_selected, long *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "businessRecipients");
	int i;
	obj->id = 0x21108ff7;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_existing_chats);
	strcpy(obj->objs[1]->name, "existing_chats");
	if (arg_existing_chats)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_new_chats);
	strcpy(obj->objs[2]->name, "new_chats");
	if (arg_new_chats)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_contacts);
	strcpy(obj->objs[3]->name, "contacts");
	if (arg_contacts)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 3;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_non_contacts);
	strcpy(obj->objs[4]->name, "non_contacts");
	if (arg_non_contacts)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 5;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_exclude_selected);
	strcpy(obj->objs[5]->name, "exclude_selected");
	if (arg_exclude_selected)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument Vector<long>
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 4;
	obj->objs[6]->type = TYPE_VECTOR;
	strcpy(obj->objs[6]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			buf_t b = buf_add_ui64(arg_users[i]);
			buf_cat(obj->objs[6]->value, b);
		}
		flagsv[nflags-1] |= (1 << 4);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_businessAwayMessageScheduleAlways()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "businessAwayMessageScheduleAlways");
	int i;
	obj->id = 0xc9b9e2b9;
	return obj;
}

tlo_t * tl_businessAwayMessageScheduleOutsideWorkHours()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "businessAwayMessageScheduleOutsideWorkHours");
	int i;
	obj->id = 0xc3f2f501;
	return obj;
}

tlo_t * tl_businessAwayMessageScheduleCustom(int arg_start_date, int arg_end_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "businessAwayMessageScheduleCustom");
	int i;
	obj->id = 0xcc4d9ecc;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_start_date);
	strcpy(obj->objs[0]->name, "start_date");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_end_date);
	strcpy(obj->objs[1]->name, "end_date");
	return obj;
}

tlo_t * tl_inputBusinessGreetingMessage(int arg_shortcut_id, InputBusinessRecipients arg_recipients, int arg_no_activity_days)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputBusinessGreetingMessage");
	int i;
	obj->id = 0x0194cb3b;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_shortcut_id);
	strcpy(obj->objs[0]->name, "shortcut_id");

	//parse argument InputBusinessRecipients
	if (arg_recipients){
		obj->objs[1] = arg_recipients;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "recipients");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_no_activity_days);
	strcpy(obj->objs[2]->name, "no_activity_days");
	return obj;
}

tlo_t * tl_businessGreetingMessage(int arg_shortcut_id, BusinessRecipients arg_recipients, int arg_no_activity_days)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "businessGreetingMessage");
	int i;
	obj->id = 0xe519abab;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_shortcut_id);
	strcpy(obj->objs[0]->name, "shortcut_id");

	//parse argument BusinessRecipients
	if (arg_recipients){
		obj->objs[1] = arg_recipients;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "recipients");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_no_activity_days);
	strcpy(obj->objs[2]->name, "no_activity_days");
	return obj;
}

tlo_t * tl_inputBusinessAwayMessage(bool arg_offline_only, int arg_shortcut_id, BusinessAwayMessageSchedule arg_schedule, InputBusinessRecipients arg_recipients)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputBusinessAwayMessage");
	int i;
	obj->id = 0x832175e0;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_offline_only);
	strcpy(obj->objs[1]->name, "offline_only");
	if (arg_offline_only)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_shortcut_id);
	strcpy(obj->objs[2]->name, "shortcut_id");

	//parse argument BusinessAwayMessageSchedule
	if (arg_schedule){
		obj->objs[3] = arg_schedule;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "schedule");
	}


	//parse argument InputBusinessRecipients
	if (arg_recipients){
		obj->objs[4] = arg_recipients;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "recipients");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_businessAwayMessage(bool arg_offline_only, int arg_shortcut_id, BusinessAwayMessageSchedule arg_schedule, BusinessRecipients arg_recipients)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "businessAwayMessage");
	int i;
	obj->id = 0xef156a5c;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_offline_only);
	strcpy(obj->objs[1]->name, "offline_only");
	if (arg_offline_only)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_shortcut_id);
	strcpy(obj->objs[2]->name, "shortcut_id");

	//parse argument BusinessAwayMessageSchedule
	if (arg_schedule){
		obj->objs[3] = arg_schedule;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "schedule");
	}


	//parse argument BusinessRecipients
	if (arg_recipients){
		obj->objs[4] = arg_recipients;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "recipients");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_timezone(const char * arg_id, const char * arg_name, int arg_utc_offset)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "timezone");
	int i;
	obj->id = 0xff9289f5;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_id){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_id, strlen(arg_id));
		strcpy(obj->objs[0]->name, "id");
	}


	//parse argument string
	if (arg_name){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_name, strlen(arg_name));
		strcpy(obj->objs[1]->name, "name");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_utc_offset);
	strcpy(obj->objs[2]->name, "utc_offset");
	return obj;
}

tlo_t * tl_help_timezonesListNotModified()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_timezonesListNotModified");
	int i;
	obj->id = 0x970708cc;
	return obj;
}

tlo_t * tl_help_timezonesList(Timezone *arg_timezones, int len_arg_timezones, int arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_timezonesList");
	int i;
	obj->id = 0x7b74ed71;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<Timezone>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "timezones");
	if (arg_timezones){
		for(i=0; i<len_arg_timezones; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_timezones[i]->id);
			buf_cat(obj->objs[0]->value, arg_timezones[i]->value);
		}
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_hash);
	strcpy(obj->objs[1]->name, "hash");
	return obj;
}

tlo_t * tl_quickReply(int arg_shortcut_id, const char * arg_shortcut, int arg_top_message, int arg_count)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "quickReply");
	int i;
	obj->id = 0x0697102b;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_shortcut_id);
	strcpy(obj->objs[0]->name, "shortcut_id");

	//parse argument string
	if (arg_shortcut){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_shortcut, strlen(arg_shortcut));
		strcpy(obj->objs[1]->name, "shortcut");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_top_message);
	strcpy(obj->objs[2]->name, "top_message");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[3]->name, "count");
	return obj;
}

tlo_t * tl_inputQuickReplyShortcut(const char * arg_shortcut)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputQuickReplyShortcut");
	int i;
	obj->id = 0x24596d41;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_shortcut){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_shortcut, strlen(arg_shortcut));
		strcpy(obj->objs[0]->name, "shortcut");
	}

	return obj;
}

tlo_t * tl_inputQuickReplyShortcutId(int arg_shortcut_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputQuickReplyShortcutId");
	int i;
	obj->id = 0x01190cf1;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_shortcut_id);
	strcpy(obj->objs[0]->name, "shortcut_id");
	return obj;
}

tlo_t * tl_messages_quickReplies(QuickReply *arg_quick_replies, int len_arg_quick_replies, Message *arg_messages, int len_arg_messages, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_quickReplies");
	int i;
	obj->id = 0xc68d6695;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<QuickReply>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "quick_replies");
	if (arg_quick_replies){
		for(i=0; i<len_arg_quick_replies; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_quick_replies[i]->id);
			buf_cat(obj->objs[0]->value, arg_quick_replies[i]->value);
		}
	}


	//parse argument Vector<Message>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "messages");
	if (arg_messages){
		for(i=0; i<len_arg_messages; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_messages[i]->id);
			buf_cat(obj->objs[1]->value, arg_messages[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[2]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[3]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_messages_quickRepliesNotModified()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_quickRepliesNotModified");
	int i;
	obj->id = 0x5f91eb5b;
	return obj;
}

tlo_t * tl_connectedBot(bool arg_can_reply, long arg_bot_id, BusinessBotRecipients arg_recipients)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "connectedBot");
	int i;
	obj->id = 0xbd068601;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_can_reply);
	strcpy(obj->objs[1]->name, "can_reply");
	if (arg_can_reply)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_bot_id);
	strcpy(obj->objs[2]->name, "bot_id");

	//parse argument BusinessBotRecipients
	if (arg_recipients){
		obj->objs[3] = arg_recipients;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "recipients");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_account_connectedBots(ConnectedBot *arg_connected_bots, int len_arg_connected_bots, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_connectedBots");
	int i;
	obj->id = 0x17d7f87b;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<ConnectedBot>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "connected_bots");
	if (arg_connected_bots){
		for(i=0; i<len_arg_connected_bots; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_connected_bots[i]->id);
			buf_cat(obj->objs[0]->value, arg_connected_bots[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[1]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_messages_dialogFilters(bool arg_tags_enabled, DialogFilter *arg_filters, int len_arg_filters)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_dialogFilters");
	int i;
	obj->id = 0x2ad93719;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_tags_enabled);
	strcpy(obj->objs[1]->name, "tags_enabled");
	if (arg_tags_enabled)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument Vector<DialogFilter>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "filters");
	if (arg_filters){
		for(i=0; i<len_arg_filters; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_filters[i]->id);
			buf_cat(obj->objs[2]->value, arg_filters[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_birthday(int arg_day, int arg_month, int arg_year)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "birthday");
	int i;
	obj->id = 0x6c8e1e06;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_day);
	strcpy(obj->objs[1]->name, "day");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_month);
	strcpy(obj->objs[2]->name, "month");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_year);
	strcpy(obj->objs[3]->name, "year");
	if (arg_year)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_botBusinessConnection(bool arg_can_reply, bool arg_disabled, const char * arg_connection_id, long arg_user_id, int arg_dc_id, int arg_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "botBusinessConnection");
	int i;
	obj->id = 0x896433b4;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_can_reply);
	strcpy(obj->objs[1]->name, "can_reply");
	if (arg_can_reply)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_disabled);
	strcpy(obj->objs[2]->name, "disabled");
	if (arg_disabled)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument string
	if (arg_connection_id){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_connection_id, strlen(arg_connection_id));
		strcpy(obj->objs[3]->name, "connection_id");
	}


	//parse argument long
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[4]->name, "user_id");

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_dc_id);
	strcpy(obj->objs[5]->name, "dc_id");

	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[6]->name, "date");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_inputBusinessIntro(const char * arg_title, const char * arg_description, InputDocument arg_sticker)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputBusinessIntro");
	int i;
	obj->id = 0x09c469cd;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_title){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[1]->name, "title");
	}


	//parse argument string
	if (arg_description){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_description, strlen(arg_description));
		strcpy(obj->objs[2]->name, "description");
	}


	//parse argument InputDocument
	if (arg_sticker){
		obj->objs[3] = arg_sticker;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "sticker");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_businessIntro(const char * arg_title, const char * arg_description, Document arg_sticker)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "businessIntro");
	int i;
	obj->id = 0x5a0a066d;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_title){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[1]->name, "title");
	}


	//parse argument string
	if (arg_description){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_description, strlen(arg_description));
		strcpy(obj->objs[2]->name, "description");
	}


	//parse argument Document
	if (arg_sticker){
		obj->objs[3] = arg_sticker;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "sticker");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_myStickers(int arg_count, StickerSetCovered *arg_sets, int len_arg_sets)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_myStickers");
	int i;
	obj->id = 0xfaff629d;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[0]->name, "count");

	//parse argument Vector<StickerSetCovered>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "sets");
	if (arg_sets){
		for(i=0; i<len_arg_sets; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_sets[i]->id);
			buf_cat(obj->objs[1]->value, arg_sets[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_inputCollectibleUsername(const char * arg_username)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputCollectibleUsername");
	int i;
	obj->id = 0xe39460a9;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_username){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_username, strlen(arg_username));
		strcpy(obj->objs[0]->name, "username");
	}

	return obj;
}

tlo_t * tl_inputCollectiblePhone(const char * arg_phone)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputCollectiblePhone");
	int i;
	obj->id = 0xa2e214a4;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_phone){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_phone, strlen(arg_phone));
		strcpy(obj->objs[0]->name, "phone");
	}

	return obj;
}

tlo_t * tl_fragment_collectibleInfo(int arg_purchase_date, const char * arg_currency, long arg_amount, const char * arg_crypto_currency, long arg_crypto_amount, const char * arg_url)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "fragment_collectibleInfo");
	int i;
	obj->id = 0x6ebdff91;
	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_purchase_date);
	strcpy(obj->objs[0]->name, "purchase_date");

	//parse argument string
	if (arg_currency){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_currency, strlen(arg_currency));
		strcpy(obj->objs[1]->name, "currency");
	}


	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_amount);
	strcpy(obj->objs[2]->name, "amount");

	//parse argument string
	if (arg_crypto_currency){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_crypto_currency, strlen(arg_crypto_currency));
		strcpy(obj->objs[3]->name, "crypto_currency");
	}


	//parse argument long
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_crypto_amount);
	strcpy(obj->objs[4]->name, "crypto_amount");

	//parse argument string
	if (arg_url){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[5]->name, "url");
	}

	return obj;
}

tlo_t * tl_inputBusinessBotRecipients(bool arg_existing_chats, bool arg_new_chats, bool arg_contacts, bool arg_non_contacts, bool arg_exclude_selected, InputUser *arg_users, int len_arg_users, InputUser *arg_exclude_users, int len_arg_exclude_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputBusinessBotRecipients");
	int i;
	obj->id = 0xc4e5921e;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_existing_chats);
	strcpy(obj->objs[1]->name, "existing_chats");
	if (arg_existing_chats)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_new_chats);
	strcpy(obj->objs[2]->name, "new_chats");
	if (arg_new_chats)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_contacts);
	strcpy(obj->objs[3]->name, "contacts");
	if (arg_contacts)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 3;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_non_contacts);
	strcpy(obj->objs[4]->name, "non_contacts");
	if (arg_non_contacts)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 5;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_exclude_selected);
	strcpy(obj->objs[5]->name, "exclude_selected");
	if (arg_exclude_selected)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument Vector<InputUser>
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 4;
	obj->objs[6]->type = TYPE_VECTOR;
	strcpy(obj->objs[6]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[6]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[6]->value, arg_users[i]->value);
		}
		flagsv[nflags-1] |= (1 << 4);
	}


	//parse argument Vector<InputUser>
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 6;
	obj->objs[7]->type = TYPE_VECTOR;
	strcpy(obj->objs[7]->name, "exclude_users");
	if (arg_exclude_users){
		for(i=0; i<len_arg_exclude_users; ++i){
			obj->objs[7]->value = buf_add_ui32(arg_exclude_users[i]->id);
			buf_cat(obj->objs[7]->value, arg_exclude_users[i]->value);
		}
		flagsv[nflags-1] |= (1 << 6);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_businessBotRecipients(bool arg_existing_chats, bool arg_new_chats, bool arg_contacts, bool arg_non_contacts, bool arg_exclude_selected, long *arg_users, int len_arg_users, long *arg_exclude_users, int len_arg_exclude_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "businessBotRecipients");
	int i;
	obj->id = 0xb88cf373;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_existing_chats);
	strcpy(obj->objs[1]->name, "existing_chats");
	if (arg_existing_chats)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_new_chats);
	strcpy(obj->objs[2]->name, "new_chats");
	if (arg_new_chats)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_contacts);
	strcpy(obj->objs[3]->name, "contacts");
	if (arg_contacts)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 3;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_non_contacts);
	strcpy(obj->objs[4]->name, "non_contacts");
	if (arg_non_contacts)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 5;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_exclude_selected);
	strcpy(obj->objs[5]->name, "exclude_selected");
	if (arg_exclude_selected)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument Vector<long>
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 4;
	obj->objs[6]->type = TYPE_VECTOR;
	strcpy(obj->objs[6]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			buf_t b = buf_add_ui64(arg_users[i]);
			buf_cat(obj->objs[6]->value, b);
		}
		flagsv[nflags-1] |= (1 << 4);
	}


	//parse argument Vector<long>
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 6;
	obj->objs[7]->type = TYPE_VECTOR;
	strcpy(obj->objs[7]->name, "exclude_users");
	if (arg_exclude_users){
		for(i=0; i<len_arg_exclude_users; ++i){
			buf_t b = buf_add_ui64(arg_exclude_users[i]);
			buf_cat(obj->objs[7]->value, b);
		}
		flagsv[nflags-1] |= (1 << 6);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_contactBirthday(long arg_contact_id, Birthday arg_birthday)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contactBirthday");
	int i;
	obj->id = 0x1d998733;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_contact_id);
	strcpy(obj->objs[0]->name, "contact_id");

	//parse argument Birthday
	if (arg_birthday){
		obj->objs[1] = arg_birthday;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "birthday");
	}

	return obj;
}

tlo_t * tl_contacts_contactBirthdays(ContactBirthday *arg_contacts, int len_arg_contacts, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_contactBirthdays");
	int i;
	obj->id = 0x114ff30d;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<ContactBirthday>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "contacts");
	if (arg_contacts){
		for(i=0; i<len_arg_contacts; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_contacts[i]->id);
			buf_cat(obj->objs[0]->value, arg_contacts[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[1]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_missingInvitee(bool arg_premium_would_allow_invite, bool arg_premium_required_for_pm, long arg_user_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "missingInvitee");
	int i;
	obj->id = 0x628c9224;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_premium_would_allow_invite);
	strcpy(obj->objs[1]->name, "premium_would_allow_invite");
	if (arg_premium_would_allow_invite)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_premium_required_for_pm);
	strcpy(obj->objs[2]->name, "premium_required_for_pm");
	if (arg_premium_required_for_pm)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[3]->name, "user_id");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_invitedUsers(Updates arg_updates, MissingInvitee *arg_missing_invitees, int len_arg_missing_invitees)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_invitedUsers");
	int i;
	obj->id = 0x7f5defa6;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Updates
	if (arg_updates){
		obj->objs[0] = arg_updates;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "updates");
	}


	//parse argument Vector<MissingInvitee>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "missing_invitees");
	if (arg_missing_invitees){
		for(i=0; i<len_arg_missing_invitees; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_missing_invitees[i]->id);
			buf_cat(obj->objs[1]->value, arg_missing_invitees[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_inputBusinessChatLink(const char * arg_message, MessageEntity *arg_entities, int len_arg_entities, const char * arg_title)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputBusinessChatLink");
	int i;
	obj->id = 0x11679fa7;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_message){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_message, strlen(arg_message));
		strcpy(obj->objs[1]->name, "message");
	}


	//parse argument Vector<MessageEntity>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "entities");
	if (arg_entities){
		for(i=0; i<len_arg_entities; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_entities[i]->id);
			buf_cat(obj->objs[2]->value, arg_entities[i]->value);
		}
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_title){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 1;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[3]->name, "title");
		flagsv[nflags-1] |= (1 << 1);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_businessChatLink(const char * arg_link, const char * arg_message, MessageEntity *arg_entities, int len_arg_entities, const char * arg_title, int arg_views)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "businessChatLink");
	int i;
	obj->id = 0xb4ae666f;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_link){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_link, strlen(arg_link));
		strcpy(obj->objs[1]->name, "link");
	}


	//parse argument string
	if (arg_message){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_message, strlen(arg_message));
		strcpy(obj->objs[2]->name, "message");
	}


	//parse argument Vector<MessageEntity>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "entities");
	if (arg_entities){
		for(i=0; i<len_arg_entities; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_entities[i]->id);
			buf_cat(obj->objs[3]->value, arg_entities[i]->value);
		}
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_title){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 1;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[4]->name, "title");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_views);
	strcpy(obj->objs[5]->name, "views");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_account_businessChatLinks(BusinessChatLink *arg_links, int len_arg_links, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_businessChatLinks");
	int i;
	obj->id = 0xec43a2d1;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<BusinessChatLink>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "links");
	if (arg_links){
		for(i=0; i<len_arg_links; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_links[i]->id);
			buf_cat(obj->objs[0]->value, arg_links[i]->value);
		}
	}


	//parse argument Vector<Chat>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[1]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[2]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_account_resolvedBusinessChatLinks(Peer arg_peer, const char * arg_message, MessageEntity *arg_entities, int len_arg_entities, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_resolvedBusinessChatLinks");
	int i;
	obj->id = 0x9a23af21;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument Peer
	if (arg_peer){
		obj->objs[1] = arg_peer;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "peer");
	}


	//parse argument string
	if (arg_message){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_message, strlen(arg_message));
		strcpy(obj->objs[2]->name, "message");
	}


	//parse argument Vector<MessageEntity>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "entities");
	if (arg_entities){
		for(i=0; i<len_arg_entities; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_entities[i]->id);
			buf_cat(obj->objs[3]->value, arg_entities[i]->value);
		}
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument Vector<Chat>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[4]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_VECTOR;
	strcpy(obj->objs[5]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[5]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[5]->value, arg_users[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_requestedPeerUser(long arg_user_id, const char * arg_first_name, const char * arg_last_name, const char * arg_username, Photo arg_photo)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "requestedPeerUser");
	int i;
	obj->id = 0xd62ff46a;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_user_id);
	strcpy(obj->objs[1]->name, "user_id");

	//parse argument string
	if (arg_first_name){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_first_name, strlen(arg_first_name));
		strcpy(obj->objs[2]->name, "first_name");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_last_name){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_last_name, strlen(arg_last_name));
		strcpy(obj->objs[3]->name, "last_name");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_username){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 1;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_username, strlen(arg_username));
		strcpy(obj->objs[4]->name, "username");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument Photo
	if (arg_photo){
		obj->objs[5] = arg_photo;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 2;
	strcpy(obj->objs[5]->name, "photo");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_requestedPeerChat(long arg_chat_id, const char * arg_title, Photo arg_photo)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "requestedPeerChat");
	int i;
	obj->id = 0x7307544f;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_chat_id);
	strcpy(obj->objs[1]->name, "chat_id");

	//parse argument string
	if (arg_title){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[2]->name, "title");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument Photo
	if (arg_photo){
		obj->objs[3] = arg_photo;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 2;
	strcpy(obj->objs[3]->name, "photo");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_requestedPeerChannel(long arg_channel_id, const char * arg_title, const char * arg_username, Photo arg_photo)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "requestedPeerChannel");
	int i;
	obj->id = 0x8ba403e4;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_channel_id);
	strcpy(obj->objs[1]->name, "channel_id");

	//parse argument string
	if (arg_title){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[2]->name, "title");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_username){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 1;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_username, strlen(arg_username));
		strcpy(obj->objs[3]->name, "username");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument Photo
	if (arg_photo){
		obj->objs[4] = arg_photo;
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 2;
	strcpy(obj->objs[4]->name, "photo");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_sponsoredMessageReportOption(const char * arg_text, unsigned char * arg_option, int len_arg_option)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "sponsoredMessageReportOption");
	int i;
	obj->id = 0x430d3150;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_text){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[0]->name, "text");
	}


	//parse argument bytes
	if (arg_option){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_option, len_arg_option);
		strcpy(obj->objs[1]->name, "option");
	}

	return obj;
}

tlo_t * tl_channels_sponsoredMessageReportResultChooseOption(const char * arg_title, SponsoredMessageReportOption *arg_options, int len_arg_options)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_sponsoredMessageReportResultChooseOption");
	int i;
	obj->id = 0x846f9e42;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_title){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[0]->name, "title");
	}


	//parse argument Vector<SponsoredMessageReportOption>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "options");
	if (arg_options){
		for(i=0; i<len_arg_options; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_options[i]->id);
			buf_cat(obj->objs[1]->value, arg_options[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_channels_sponsoredMessageReportResultAdsHidden()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_sponsoredMessageReportResultAdsHidden");
	int i;
	obj->id = 0x3e3bcf2f;
	return obj;
}

tlo_t * tl_channels_sponsoredMessageReportResultReported()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_sponsoredMessageReportResultReported");
	int i;
	obj->id = 0xad798849;
	return obj;
}

tlo_t * tl_stats_broadcastRevenueStats(StatsGraph arg_top_hours_graph, StatsGraph arg_revenue_graph, BroadcastRevenueBalances arg_balances, double arg_usd_rate)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stats_broadcastRevenueStats");
	int i;
	obj->id = 0x5407e297;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument StatsGraph
	if (arg_top_hours_graph){
		obj->objs[0] = arg_top_hours_graph;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "top_hours_graph");
	}


	//parse argument StatsGraph
	if (arg_revenue_graph){
		obj->objs[1] = arg_revenue_graph;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "revenue_graph");
	}


	//parse argument BroadcastRevenueBalances
	if (arg_balances){
		obj->objs[2] = arg_balances;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "balances");
	}


	//parse argument double
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_usd_rate);
	strcpy(obj->objs[3]->name, "usd_rate");
	return obj;
}

tlo_t * tl_stats_broadcastRevenueWithdrawalUrl(const char * arg_url)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stats_broadcastRevenueWithdrawalUrl");
	int i;
	obj->id = 0xec659737;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_url){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[0]->name, "url");
	}

	return obj;
}

tlo_t * tl_broadcastRevenueTransactionProceeds(long arg_amount, int arg_from_date, int arg_to_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "broadcastRevenueTransactionProceeds");
	int i;
	obj->id = 0x557e2cc4;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_amount);
	strcpy(obj->objs[0]->name, "amount");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_from_date);
	strcpy(obj->objs[1]->name, "from_date");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_to_date);
	strcpy(obj->objs[2]->name, "to_date");
	return obj;
}

tlo_t * tl_broadcastRevenueTransactionWithdrawal(bool arg_pending, bool arg_failed, long arg_amount, int arg_date, const char * arg_provider, int arg_transaction_date, const char * arg_transaction_url)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "broadcastRevenueTransactionWithdrawal");
	int i;
	obj->id = 0x5a590978;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_pending);
	strcpy(obj->objs[1]->name, "pending");
	if (arg_pending)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 2;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_failed);
	strcpy(obj->objs[2]->name, "failed");
	if (arg_failed)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_amount);
	strcpy(obj->objs[3]->name, "amount");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[4]->name, "date");

	//parse argument string
	if (arg_provider){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_provider, strlen(arg_provider));
		strcpy(obj->objs[5]->name, "provider");
	}


	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 1;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_transaction_date);
	strcpy(obj->objs[6]->name, "transaction_date");
	if (arg_transaction_date)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument string
	if (arg_transaction_url){
		obj->objs[7] = NEW(tlo_t, return NULL);
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 1;
		obj->objs[7]->type = TYPE_STRING;
		obj->objs[7]->value = 
			buf_add((ui8_t *)arg_transaction_url, strlen(arg_transaction_url));
		strcpy(obj->objs[7]->name, "transaction_url");
		flagsv[nflags-1] |= (1 << 1);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_broadcastRevenueTransactionRefund(long arg_amount, int arg_date, const char * arg_provider)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "broadcastRevenueTransactionRefund");
	int i;
	obj->id = 0x42d30d2e;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_amount);
	strcpy(obj->objs[0]->name, "amount");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[1]->name, "date");

	//parse argument string
	if (arg_provider){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_provider, strlen(arg_provider));
		strcpy(obj->objs[2]->name, "provider");
	}

	return obj;
}

tlo_t * tl_stats_broadcastRevenueTransactions(int arg_count, BroadcastRevenueTransaction *arg_transactions, int len_arg_transactions)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stats_broadcastRevenueTransactions");
	int i;
	obj->id = 0x87158466;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[0]->name, "count");

	//parse argument Vector<BroadcastRevenueTransaction>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "transactions");
	if (arg_transactions){
		for(i=0; i<len_arg_transactions; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_transactions[i]->id);
			buf_cat(obj->objs[1]->value, arg_transactions[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_reactionNotificationsFromContacts()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "reactionNotificationsFromContacts");
	int i;
	obj->id = 0xbac3a61a;
	return obj;
}

tlo_t * tl_reactionNotificationsFromAll()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "reactionNotificationsFromAll");
	int i;
	obj->id = 0x4b9e22a0;
	return obj;
}

tlo_t * tl_reactionsNotifySettings(ReactionNotificationsFrom arg_messages_notify_from, ReactionNotificationsFrom arg_stories_notify_from, NotificationSound arg_sound, Bool arg_show_previews)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "reactionsNotifySettings");
	int i;
	obj->id = 0x56e34970;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument ReactionNotificationsFrom
	if (arg_messages_notify_from){
		obj->objs[1] = arg_messages_notify_from;
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "messages_notify_from");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument ReactionNotificationsFrom
	if (arg_stories_notify_from){
		obj->objs[2] = arg_stories_notify_from;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 1;
	strcpy(obj->objs[2]->name, "stories_notify_from");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument NotificationSound
	if (arg_sound){
		obj->objs[3] = arg_sound;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "sound");
	}


	//parse argument Bool
	if (arg_show_previews){
		obj->objs[4] = arg_show_previews;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "show_previews");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_broadcastRevenueBalances(bool arg_withdrawal_enabled, long arg_current_balance, long arg_available_balance, long arg_overall_revenue)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "broadcastRevenueBalances");
	int i;
	obj->id = 0xc3ff71e7;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_withdrawal_enabled);
	strcpy(obj->objs[1]->name, "withdrawal_enabled");
	if (arg_withdrawal_enabled)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_current_balance);
	strcpy(obj->objs[2]->name, "current_balance");

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_available_balance);
	strcpy(obj->objs[3]->name, "available_balance");

	//parse argument long
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_overall_revenue);
	strcpy(obj->objs[4]->name, "overall_revenue");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_availableEffect(bool arg_premium_required, long arg_id, const char * arg_emoticon, long arg_static_icon_id, long arg_effect_sticker_id, long arg_effect_animation_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "availableEffect");
	int i;
	obj->id = 0x93c3e27e;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 2;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_premium_required);
	strcpy(obj->objs[1]->name, "premium_required");
	if (arg_premium_required)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[2]->name, "id");

	//parse argument string
	if (arg_emoticon){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_emoticon, strlen(arg_emoticon));
		strcpy(obj->objs[3]->name, "emoticon");
	}


	//parse argument long
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_static_icon_id);
	strcpy(obj->objs[4]->name, "static_icon_id");
	if (arg_static_icon_id)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument long
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_LONG;
	obj->objs[5]->value = 
		buf_add_ui64(arg_effect_sticker_id);
	strcpy(obj->objs[5]->name, "effect_sticker_id");

	//parse argument long
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 1;
	obj->objs[6]->type = TYPE_LONG;
	obj->objs[6]->value = 
		buf_add_ui64(arg_effect_animation_id);
	strcpy(obj->objs[6]->name, "effect_animation_id");
	if (arg_effect_animation_id)
		flagsv[nflags-1] |= (1 << 1);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_availableEffectsNotModified()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_availableEffectsNotModified");
	int i;
	obj->id = 0xd1ed9a5b;
	return obj;
}

tlo_t * tl_messages_availableEffects(int arg_hash, AvailableEffect *arg_effects, int len_arg_effects, Document *arg_documents, int len_arg_documents)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_availableEffects");
	int i;
	obj->id = 0xbddb616e;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_hash);
	strcpy(obj->objs[0]->name, "hash");

	//parse argument Vector<AvailableEffect>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "effects");
	if (arg_effects){
		for(i=0; i<len_arg_effects; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_effects[i]->id);
			buf_cat(obj->objs[1]->value, arg_effects[i]->value);
		}
	}


	//parse argument Vector<Document>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "documents");
	if (arg_documents){
		for(i=0; i<len_arg_documents; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_documents[i]->id);
			buf_cat(obj->objs[2]->value, arg_documents[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_factCheck(bool arg_need_check, const char * arg_country, TextWithEntities arg_text, long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "factCheck");
	int i;
	obj->id = 0xb89bfccf;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_need_check);
	strcpy(obj->objs[1]->name, "need_check");
	if (arg_need_check)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument string
	if (arg_country){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 1;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_country, strlen(arg_country));
		strcpy(obj->objs[2]->name, "country");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument TextWithEntities
	if (arg_text){
		obj->objs[3] = arg_text;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 1;
	strcpy(obj->objs[3]->name, "text");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument long
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[4]->name, "hash");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_starsTransactionPeerUnsupported()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "starsTransactionPeerUnsupported");
	int i;
	obj->id = 0x95f2bfe4;
	return obj;
}

tlo_t * tl_starsTransactionPeerAppStore()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "starsTransactionPeerAppStore");
	int i;
	obj->id = 0xb457b375;
	return obj;
}

tlo_t * tl_starsTransactionPeerPlayMarket()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "starsTransactionPeerPlayMarket");
	int i;
	obj->id = 0x7b560a0b;
	return obj;
}

tlo_t * tl_starsTransactionPeerPremiumBot()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "starsTransactionPeerPremiumBot");
	int i;
	obj->id = 0x250dbaf8;
	return obj;
}

tlo_t * tl_starsTransactionPeerFragment()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "starsTransactionPeerFragment");
	int i;
	obj->id = 0xe92fd902;
	return obj;
}

tlo_t * tl_starsTransactionPeer(Peer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "starsTransactionPeer");
	int i;
	obj->id = 0xd80da15d;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}

	return obj;
}

tlo_t * tl_starsTransactionPeerAds()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "starsTransactionPeerAds");
	int i;
	obj->id = 0x60682812;
	return obj;
}

tlo_t * tl_starsTopupOption(bool arg_extended, long arg_stars, const char * arg_store_product, const char * arg_currency, long arg_amount)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "starsTopupOption");
	int i;
	obj->id = 0x0bd915c0;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_extended);
	strcpy(obj->objs[1]->name, "extended");
	if (arg_extended)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_stars);
	strcpy(obj->objs[2]->name, "stars");

	//parse argument string
	if (arg_store_product){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_store_product, strlen(arg_store_product));
		strcpy(obj->objs[3]->name, "store_product");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_currency){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_currency, strlen(arg_currency));
		strcpy(obj->objs[4]->name, "currency");
	}


	//parse argument long
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_LONG;
	obj->objs[5]->value = 
		buf_add_ui64(arg_amount);
	strcpy(obj->objs[5]->name, "amount");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_starsTransaction(bool arg_refund, bool arg_pending, bool arg_failed, bool arg_gift, bool arg_reaction, const char * arg_id, long arg_stars, int arg_date, StarsTransactionPeer arg_peer, const char * arg_title, const char * arg_description, WebDocument arg_photo, int arg_transaction_date, const char * arg_transaction_url, unsigned char * arg_bot_payload, int len_arg_bot_payload, int arg_msg_id, MessageMedia *arg_extended_media, int len_arg_extended_media, int arg_subscription_period, int arg_giveaway_post_id, StarGift arg_stargift)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "starsTransaction");
	int i;
	obj->id = 0x0a9ee4c2;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 21;
	obj->objs = 
		(tlo_t **)MALLOC(21 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 3;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_refund);
	strcpy(obj->objs[1]->name, "refund");
	if (arg_refund)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 4;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_pending);
	strcpy(obj->objs[2]->name, "pending");
	if (arg_pending)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 6;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_failed);
	strcpy(obj->objs[3]->name, "failed");
	if (arg_failed)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 10;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_gift);
	strcpy(obj->objs[4]->name, "gift");
	if (arg_gift)
		flagsv[nflags-1] |= (1 << 10);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 11;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_reaction);
	strcpy(obj->objs[5]->name, "reaction");
	if (arg_reaction)
		flagsv[nflags-1] |= (1 << 11);

	//parse argument string
	if (arg_id){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_id, strlen(arg_id));
		strcpy(obj->objs[6]->name, "id");
	}


	//parse argument long
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_LONG;
	obj->objs[7]->value = 
		buf_add_ui64(arg_stars);
	strcpy(obj->objs[7]->name, "stars");

	//parse argument int
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 0;
	obj->objs[8]->flag_bit = 0;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[8]->name, "date");

	//parse argument StarsTransactionPeer
	if (arg_peer){
		obj->objs[9] = arg_peer;
		obj->objs[9]->flag_num = 0;
		obj->objs[9]->flag_bit = 0;
	strcpy(obj->objs[9]->name, "peer");
	}


	//parse argument string
	if (arg_title){
		obj->objs[10] = NEW(tlo_t, return NULL);
		obj->objs[10]->flag_num = 1;
		obj->objs[10]->flag_bit = 0;
		obj->objs[10]->type = TYPE_STRING;
		obj->objs[10]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[10]->name, "title");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_description){
		obj->objs[11] = NEW(tlo_t, return NULL);
		obj->objs[11]->flag_num = 1;
		obj->objs[11]->flag_bit = 1;
		obj->objs[11]->type = TYPE_STRING;
		obj->objs[11]->value = 
			buf_add((ui8_t *)arg_description, strlen(arg_description));
		strcpy(obj->objs[11]->name, "description");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument WebDocument
	if (arg_photo){
		obj->objs[12] = arg_photo;
		obj->objs[12]->flag_num = 1;
		obj->objs[12]->flag_bit = 2;
	strcpy(obj->objs[12]->name, "photo");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument int
	obj->objs[13] = NEW(tlo_t, return NULL);
	obj->objs[13]->flag_num = 1;
	obj->objs[13]->flag_bit = 5;
	obj->objs[13]->type = TYPE_INT;
	obj->objs[13]->value = 
		buf_add_ui32(arg_transaction_date);
	strcpy(obj->objs[13]->name, "transaction_date");
	if (arg_transaction_date)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument string
	if (arg_transaction_url){
		obj->objs[14] = NEW(tlo_t, return NULL);
		obj->objs[14]->flag_num = 1;
		obj->objs[14]->flag_bit = 5;
		obj->objs[14]->type = TYPE_STRING;
		obj->objs[14]->value = 
			buf_add((ui8_t *)arg_transaction_url, strlen(arg_transaction_url));
		strcpy(obj->objs[14]->name, "transaction_url");
		flagsv[nflags-1] |= (1 << 5);
	}


	//parse argument bytes
	if (arg_bot_payload){
		obj->objs[15] = NEW(tlo_t, return NULL);
		obj->objs[15]->flag_num = 1;
		obj->objs[15]->flag_bit = 7;
		obj->objs[15]->type = TYPE_BYTES;
		obj->objs[15]->value = 
			buf_add((ui8_t *)arg_bot_payload, len_arg_bot_payload);
		strcpy(obj->objs[15]->name, "bot_payload");
		flagsv[nflags-1] |= (1 << 7);
	}


	//parse argument int
	obj->objs[16] = NEW(tlo_t, return NULL);
	obj->objs[16]->flag_num = 1;
	obj->objs[16]->flag_bit = 8;
	obj->objs[16]->type = TYPE_INT;
	obj->objs[16]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[16]->name, "msg_id");
	if (arg_msg_id)
		flagsv[nflags-1] |= (1 << 8);

	//parse argument Vector<MessageMedia>
	obj->objs[17] = NEW(tlo_t, return NULL);
	obj->objs[17]->flag_num = 1;
	obj->objs[17]->flag_bit = 9;
	obj->objs[17]->type = TYPE_VECTOR;
	strcpy(obj->objs[17]->name, "extended_media");
	if (arg_extended_media){
		for(i=0; i<len_arg_extended_media; ++i){
			obj->objs[17]->value = buf_add_ui32(arg_extended_media[i]->id);
			buf_cat(obj->objs[17]->value, arg_extended_media[i]->value);
		}
		flagsv[nflags-1] |= (1 << 9);
	}


	//parse argument int
	obj->objs[18] = NEW(tlo_t, return NULL);
	obj->objs[18]->flag_num = 1;
	obj->objs[18]->flag_bit = 12;
	obj->objs[18]->type = TYPE_INT;
	obj->objs[18]->value = 
		buf_add_ui32(arg_subscription_period);
	strcpy(obj->objs[18]->name, "subscription_period");
	if (arg_subscription_period)
		flagsv[nflags-1] |= (1 << 12);

	//parse argument int
	obj->objs[19] = NEW(tlo_t, return NULL);
	obj->objs[19]->flag_num = 1;
	obj->objs[19]->flag_bit = 13;
	obj->objs[19]->type = TYPE_INT;
	obj->objs[19]->value = 
		buf_add_ui32(arg_giveaway_post_id);
	strcpy(obj->objs[19]->name, "giveaway_post_id");
	if (arg_giveaway_post_id)
		flagsv[nflags-1] |= (1 << 13);

	//parse argument StarGift
	if (arg_stargift){
		obj->objs[20] = arg_stargift;
		obj->objs[20]->flag_num = 1;
		obj->objs[20]->flag_bit = 14;
	strcpy(obj->objs[20]->name, "stargift");
		flagsv[nflags-1] |= (1 << 14);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_payments_starsStatus(long arg_balance, StarsSubscription *arg_subscriptions, int len_arg_subscriptions, const char * arg_subscriptions_next_offset, long arg_subscriptions_missing_balance, StarsTransaction *arg_history, int len_arg_history, const char * arg_next_offset, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_starsStatus");
	int i;
	obj->id = 0xbbfa316c;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_balance);
	strcpy(obj->objs[1]->name, "balance");

	//parse argument Vector<StarsSubscription>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "subscriptions");
	if (arg_subscriptions){
		for(i=0; i<len_arg_subscriptions; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_subscriptions[i]->id);
			buf_cat(obj->objs[2]->value, arg_subscriptions[i]->value);
		}
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument string
	if (arg_subscriptions_next_offset){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 2;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_subscriptions_next_offset, strlen(arg_subscriptions_next_offset));
		strcpy(obj->objs[3]->name, "subscriptions_next_offset");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument long
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 4;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_subscriptions_missing_balance);
	strcpy(obj->objs[4]->name, "subscriptions_missing_balance");
	if (arg_subscriptions_missing_balance)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument Vector<StarsTransaction>
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 3;
	obj->objs[5]->type = TYPE_VECTOR;
	strcpy(obj->objs[5]->name, "history");
	if (arg_history){
		for(i=0; i<len_arg_history; ++i){
			obj->objs[5]->value = buf_add_ui32(arg_history[i]->id);
			buf_cat(obj->objs[5]->value, arg_history[i]->value);
		}
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument string
	if (arg_next_offset){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 0;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_next_offset, strlen(arg_next_offset));
		strcpy(obj->objs[6]->name, "next_offset");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument Vector<Chat>
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_VECTOR;
	strcpy(obj->objs[7]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[7]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[7]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 0;
	obj->objs[8]->flag_bit = 0;
	obj->objs[8]->type = TYPE_VECTOR;
	strcpy(obj->objs[8]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[8]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[8]->value, arg_users[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_foundStory(Peer arg_peer, StoryItem arg_story)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "foundStory");
	int i;
	obj->id = 0xe87acbc0;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Peer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument StoryItem
	if (arg_story){
		obj->objs[1] = arg_story;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "story");
	}

	return obj;
}

tlo_t * tl_stories_foundStories(int arg_count, FoundStory *arg_stories, int len_arg_stories, const char * arg_next_offset, Chat *arg_chats, int len_arg_chats, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stories_foundStories");
	int i;
	obj->id = 0xe2de7737;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[1]->name, "count");

	//parse argument Vector<FoundStory>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "stories");
	if (arg_stories){
		for(i=0; i<len_arg_stories; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_stories[i]->id);
			buf_cat(obj->objs[2]->value, arg_stories[i]->value);
		}
	}


	//parse argument string
	if (arg_next_offset){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_next_offset, strlen(arg_next_offset));
		strcpy(obj->objs[3]->name, "next_offset");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument Vector<Chat>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "chats");
	if (arg_chats){
		for(i=0; i<len_arg_chats; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_chats[i]->id);
			buf_cat(obj->objs[4]->value, arg_chats[i]->value);
		}
	}


	//parse argument Vector<User>
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_VECTOR;
	strcpy(obj->objs[5]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[5]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[5]->value, arg_users[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_geoPointAddress(const char * arg_country_iso2, const char * arg_state, const char * arg_city, const char * arg_street)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "geoPointAddress");
	int i;
	obj->id = 0xde4c5d93;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_country_iso2){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_country_iso2, strlen(arg_country_iso2));
		strcpy(obj->objs[1]->name, "country_iso2");
	}


	//parse argument string
	if (arg_state){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_state, strlen(arg_state));
		strcpy(obj->objs[2]->name, "state");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_city){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 1;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_city, strlen(arg_city));
		strcpy(obj->objs[3]->name, "city");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument string
	if (arg_street){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 2;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_street, strlen(arg_street));
		strcpy(obj->objs[4]->name, "street");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_starsRevenueStatus(bool arg_withdrawal_enabled, long arg_current_balance, long arg_available_balance, long arg_overall_revenue, int arg_next_withdrawal_at)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "starsRevenueStatus");
	int i;
	obj->id = 0x79342946;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_withdrawal_enabled);
	strcpy(obj->objs[1]->name, "withdrawal_enabled");
	if (arg_withdrawal_enabled)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_current_balance);
	strcpy(obj->objs[2]->name, "current_balance");

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_available_balance);
	strcpy(obj->objs[3]->name, "available_balance");

	//parse argument long
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_overall_revenue);
	strcpy(obj->objs[4]->name, "overall_revenue");

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 1;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_next_withdrawal_at);
	strcpy(obj->objs[5]->name, "next_withdrawal_at");
	if (arg_next_withdrawal_at)
		flagsv[nflags-1] |= (1 << 1);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_payments_starsRevenueStats(StatsGraph arg_revenue_graph, StarsRevenueStatus arg_status, double arg_usd_rate)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_starsRevenueStats");
	int i;
	obj->id = 0xc92bb73b;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument StatsGraph
	if (arg_revenue_graph){
		obj->objs[0] = arg_revenue_graph;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "revenue_graph");
	}


	//parse argument StarsRevenueStatus
	if (arg_status){
		obj->objs[1] = arg_status;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "status");
	}


	//parse argument double
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_usd_rate);
	strcpy(obj->objs[2]->name, "usd_rate");
	return obj;
}

tlo_t * tl_payments_starsRevenueWithdrawalUrl(const char * arg_url)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_starsRevenueWithdrawalUrl");
	int i;
	obj->id = 0x1dab80b7;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_url){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[0]->name, "url");
	}

	return obj;
}

tlo_t * tl_payments_starsRevenueAdsAccountUrl(const char * arg_url)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_starsRevenueAdsAccountUrl");
	int i;
	obj->id = 0x394e7f21;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_url){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[0]->name, "url");
	}

	return obj;
}

tlo_t * tl_inputStarsTransaction(bool arg_refund, const char * arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "inputStarsTransaction");
	int i;
	obj->id = 0x206ae6d1;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_refund);
	strcpy(obj->objs[1]->name, "refund");
	if (arg_refund)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument string
	if (arg_id){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_id, strlen(arg_id));
		strcpy(obj->objs[2]->name, "id");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_starsGiftOption(bool arg_extended, long arg_stars, const char * arg_store_product, const char * arg_currency, long arg_amount)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "starsGiftOption");
	int i;
	obj->id = 0x5e0589f1;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_extended);
	strcpy(obj->objs[1]->name, "extended");
	if (arg_extended)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_stars);
	strcpy(obj->objs[2]->name, "stars");

	//parse argument string
	if (arg_store_product){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_store_product, strlen(arg_store_product));
		strcpy(obj->objs[3]->name, "store_product");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_currency){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_currency, strlen(arg_currency));
		strcpy(obj->objs[4]->name, "currency");
	}


	//parse argument long
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_LONG;
	obj->objs[5]->value = 
		buf_add_ui64(arg_amount);
	strcpy(obj->objs[5]->name, "amount");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_bots_popularAppBots(const char * arg_next_offset, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "bots_popularAppBots");
	int i;
	obj->id = 0x1991b13b;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_next_offset){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_next_offset, strlen(arg_next_offset));
		strcpy(obj->objs[1]->name, "next_offset");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument Vector<User>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[2]->value, arg_users[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_botPreviewMedia(int arg_date, MessageMedia arg_media)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "botPreviewMedia");
	int i;
	obj->id = 0x23e91ba3;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[0]->name, "date");

	//parse argument MessageMedia
	if (arg_media){
		obj->objs[1] = arg_media;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "media");
	}

	return obj;
}

tlo_t * tl_bots_previewInfo(BotPreviewMedia *arg_media, int len_arg_media, const char * *arg_lang_codes, int len_arg_lang_codes)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "bots_previewInfo");
	int i;
	obj->id = 0x0ca71d64;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<BotPreviewMedia>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "media");
	if (arg_media){
		for(i=0; i<len_arg_media; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_media[i]->id);
			buf_cat(obj->objs[0]->value, arg_media[i]->value);
		}
	}


	//parse argument Vector<string>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "lang_codes");
	if (arg_lang_codes){
		for(i=0; i<len_arg_lang_codes; ++i){
			int len = strlen(arg_lang_codes[i]);
			buf_t b = buf_add((ui8_t *)arg_lang_codes[i], len);
			buf_cat(obj->objs[1]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_starsSubscriptionPricing(int arg_period, long arg_amount)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "starsSubscriptionPricing");
	int i;
	obj->id = 0x05416d58;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_period);
	strcpy(obj->objs[0]->name, "period");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_amount);
	strcpy(obj->objs[1]->name, "amount");
	return obj;
}

tlo_t * tl_starsSubscription(bool arg_canceled, bool arg_can_refulfill, bool arg_missing_balance, const char * arg_id, Peer arg_peer, int arg_until_date, StarsSubscriptionPricing arg_pricing, const char * arg_chat_invite_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "starsSubscription");
	int i;
	obj->id = 0x538ecf18;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_canceled);
	strcpy(obj->objs[1]->name, "canceled");
	if (arg_canceled)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_can_refulfill);
	strcpy(obj->objs[2]->name, "can_refulfill");
	if (arg_can_refulfill)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_missing_balance);
	strcpy(obj->objs[3]->name, "missing_balance");
	if (arg_missing_balance)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument string
	if (arg_id){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_id, strlen(arg_id));
		strcpy(obj->objs[4]->name, "id");
	}


	//parse argument Peer
	if (arg_peer){
		obj->objs[5] = arg_peer;
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
	strcpy(obj->objs[5]->name, "peer");
	}


	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_until_date);
	strcpy(obj->objs[6]->name, "until_date");

	//parse argument StarsSubscriptionPricing
	if (arg_pricing){
		obj->objs[7] = arg_pricing;
		obj->objs[7]->flag_num = 0;
		obj->objs[7]->flag_bit = 0;
	strcpy(obj->objs[7]->name, "pricing");
	}


	//parse argument string
	if (arg_chat_invite_hash){
		obj->objs[8] = NEW(tlo_t, return NULL);
		obj->objs[8]->flag_num = 1;
		obj->objs[8]->flag_bit = 3;
		obj->objs[8]->type = TYPE_STRING;
		obj->objs[8]->value = 
			buf_add((ui8_t *)arg_chat_invite_hash, strlen(arg_chat_invite_hash));
		strcpy(obj->objs[8]->name, "chat_invite_hash");
		flagsv[nflags-1] |= (1 << 3);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messageReactor(bool arg_top, bool arg_my, bool arg_anonymous, Peer arg_peer_id, int arg_count)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageReactor");
	int i;
	obj->id = 0x4ba3a95a;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_top);
	strcpy(obj->objs[1]->name, "top");
	if (arg_top)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_my);
	strcpy(obj->objs[2]->name, "my");
	if (arg_my)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_anonymous);
	strcpy(obj->objs[3]->name, "anonymous");
	if (arg_anonymous)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument Peer
	if (arg_peer_id){
		obj->objs[4] = arg_peer_id;
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 3;
	strcpy(obj->objs[4]->name, "peer_id");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[5]->name, "count");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_starsGiveawayOption(bool arg_extended, bool arg_default, long arg_stars, int arg_yearly_boosts, const char * arg_store_product, const char * arg_currency, long arg_amount, StarsGiveawayWinnersOption *arg_winners, int len_arg_winners)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "starsGiveawayOption");
	int i;
	obj->id = 0x94ce852a;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_extended);
	strcpy(obj->objs[1]->name, "extended");
	if (arg_extended)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_default);
	strcpy(obj->objs[2]->name, "default");
	if (arg_default)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_stars);
	strcpy(obj->objs[3]->name, "stars");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_yearly_boosts);
	strcpy(obj->objs[4]->name, "yearly_boosts");

	//parse argument string
	if (arg_store_product){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 2;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_store_product, strlen(arg_store_product));
		strcpy(obj->objs[5]->name, "store_product");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument string
	if (arg_currency){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_currency, strlen(arg_currency));
		strcpy(obj->objs[6]->name, "currency");
	}


	//parse argument long
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_LONG;
	obj->objs[7]->value = 
		buf_add_ui64(arg_amount);
	strcpy(obj->objs[7]->name, "amount");

	//parse argument Vector<StarsGiveawayWinnersOption>
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 0;
	obj->objs[8]->flag_bit = 0;
	obj->objs[8]->type = TYPE_VECTOR;
	strcpy(obj->objs[8]->name, "winners");
	if (arg_winners){
		for(i=0; i<len_arg_winners; ++i){
			obj->objs[8]->value = buf_add_ui32(arg_winners[i]->id);
			buf_cat(obj->objs[8]->value, arg_winners[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_starsGiveawayWinnersOption(bool arg_default, int arg_users, long arg_per_user_stars)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "starsGiveawayWinnersOption");
	int i;
	obj->id = 0x54236209;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_default);
	strcpy(obj->objs[1]->name, "default");
	if (arg_default)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_users);
	strcpy(obj->objs[2]->name, "users");

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_per_user_stars);
	strcpy(obj->objs[3]->name, "per_user_stars");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_starGift(bool arg_limited, long arg_id, Document arg_sticker, long arg_stars, int arg_availability_remains, int arg_availability_total, long arg_convert_stars)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "starGift");
	int i;
	obj->id = 0xaea174ee;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_limited);
	strcpy(obj->objs[1]->name, "limited");
	if (arg_limited)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[2]->name, "id");

	//parse argument Document
	if (arg_sticker){
		obj->objs[3] = arg_sticker;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "sticker");
	}


	//parse argument long
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_stars);
	strcpy(obj->objs[4]->name, "stars");

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_availability_remains);
	strcpy(obj->objs[5]->name, "availability_remains");
	if (arg_availability_remains)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_availability_total);
	strcpy(obj->objs[6]->name, "availability_total");
	if (arg_availability_total)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument long
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_LONG;
	obj->objs[7]->value = 
		buf_add_ui64(arg_convert_stars);
	strcpy(obj->objs[7]->name, "convert_stars");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_payments_starGiftsNotModified()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_starGiftsNotModified");
	int i;
	obj->id = 0xa388a368;
	return obj;
}

tlo_t * tl_payments_starGifts(int arg_hash, StarGift *arg_gifts, int len_arg_gifts)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_starGifts");
	int i;
	obj->id = 0x901689ea;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_hash);
	strcpy(obj->objs[0]->name, "hash");

	//parse argument Vector<StarGift>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "gifts");
	if (arg_gifts){
		for(i=0; i<len_arg_gifts; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_gifts[i]->id);
			buf_cat(obj->objs[1]->value, arg_gifts[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_userStarGift(bool arg_name_hidden, bool arg_unsaved, long arg_from_id, int arg_date, StarGift arg_gift, TextWithEntities arg_message, int arg_msg_id, long arg_convert_stars)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "userStarGift");
	int i;
	obj->id = 0xeea49a6e;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_name_hidden);
	strcpy(obj->objs[1]->name, "name_hidden");
	if (arg_name_hidden)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 5;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_unsaved);
	strcpy(obj->objs[2]->name, "unsaved");
	if (arg_unsaved)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 1;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_from_id);
	strcpy(obj->objs[3]->name, "from_id");
	if (arg_from_id)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[4]->name, "date");

	//parse argument StarGift
	if (arg_gift){
		obj->objs[5] = arg_gift;
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
	strcpy(obj->objs[5]->name, "gift");
	}


	//parse argument TextWithEntities
	if (arg_message){
		obj->objs[6] = arg_message;
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 2;
	strcpy(obj->objs[6]->name, "message");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument int
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 3;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[7]->name, "msg_id");
	if (arg_msg_id)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument long
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 4;
	obj->objs[8]->type = TYPE_LONG;
	obj->objs[8]->value = 
		buf_add_ui64(arg_convert_stars);
	strcpy(obj->objs[8]->name, "convert_stars");
	if (arg_convert_stars)
		flagsv[nflags-1] |= (1 << 4);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_payments_userStarGifts(int arg_count, UserStarGift *arg_gifts, int len_arg_gifts, const char * arg_next_offset, User *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_userStarGifts");
	int i;
	obj->id = 0x6b65b517;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[1]->name, "count");

	//parse argument Vector<UserStarGift>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "gifts");
	if (arg_gifts){
		for(i=0; i<len_arg_gifts; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_gifts[i]->id);
			buf_cat(obj->objs[2]->value, arg_gifts[i]->value);
		}
	}


	//parse argument string
	if (arg_next_offset){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_next_offset, strlen(arg_next_offset));
		strcpy(obj->objs[3]->name, "next_offset");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument Vector<User>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[4]->value, arg_users[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messageReportOption(const char * arg_text, unsigned char * arg_option, int len_arg_option)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messageReportOption");
	int i;
	obj->id = 0x7903e3d9;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_text){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_text, strlen(arg_text));
		strcpy(obj->objs[0]->name, "text");
	}


	//parse argument bytes
	if (arg_option){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_option, len_arg_option);
		strcpy(obj->objs[1]->name, "option");
	}

	return obj;
}

tlo_t * tl_reportResultChooseOption(const char * arg_title, MessageReportOption *arg_options, int len_arg_options)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "reportResultChooseOption");
	int i;
	obj->id = 0xf0e4e0b6;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_title){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[0]->name, "title");
	}


	//parse argument Vector<MessageReportOption>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "options");
	if (arg_options){
		for(i=0; i<len_arg_options; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_options[i]->id);
			buf_cat(obj->objs[1]->value, arg_options[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_reportResultAddComment(bool arg_optional, unsigned char * arg_option, int len_arg_option)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "reportResultAddComment");
	int i;
	obj->id = 0x6f09ac31;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_optional);
	strcpy(obj->objs[1]->name, "optional");
	if (arg_optional)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument bytes
	if (arg_option){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_BYTES;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_option, len_arg_option);
		strcpy(obj->objs[2]->name, "option");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_reportResultReported()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "reportResultReported");
	int i;
	obj->id = 0x8db33c4b;
	return obj;
}

tlo_t * tl_invokeAfterMsg(long arg_msg_id, tlo_t * arg_query)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "invokeAfterMsg");
	int i;
	obj->id = 0xcb9f372d;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_msg_id);
	strcpy(obj->objs[0]->name, "msg_id");

	//parse argument !X
	if (arg_query){
		obj->objs[1] = arg_query;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "query");
	}

	return obj;
}

tlo_t * tl_invokeAfterMsgs(long *arg_msg_ids, int len_arg_msg_ids, tlo_t * arg_query)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "invokeAfterMsgs");
	int i;
	obj->id = 0x3dc4b4f0;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<long>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "msg_ids");
	if (arg_msg_ids){
		for(i=0; i<len_arg_msg_ids; ++i){
			buf_t b = buf_add_ui64(arg_msg_ids[i]);
			buf_cat(obj->objs[0]->value, b);
		}
	}


	//parse argument !X
	if (arg_query){
		obj->objs[1] = arg_query;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "query");
	}

	return obj;
}

tlo_t * tl_initConnection(int arg_api_id, const char * arg_device_model, const char * arg_system_version, const char * arg_app_version, const char * arg_system_lang_code, const char * arg_lang_pack, const char * arg_lang_code, InputClientProxy arg_proxy, JSONValue arg_params, tlo_t * arg_query)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "initConnection");
	int i;
	obj->id = 0xc1cd5ea9;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 11;
	obj->objs = 
		(tlo_t **)MALLOC(11 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_api_id);
	strcpy(obj->objs[1]->name, "api_id");

	//parse argument string
	if (arg_device_model){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_device_model, strlen(arg_device_model));
		strcpy(obj->objs[2]->name, "device_model");
	}


	//parse argument string
	if (arg_system_version){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_system_version, strlen(arg_system_version));
		strcpy(obj->objs[3]->name, "system_version");
	}


	//parse argument string
	if (arg_app_version){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_app_version, strlen(arg_app_version));
		strcpy(obj->objs[4]->name, "app_version");
	}


	//parse argument string
	if (arg_system_lang_code){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_system_lang_code, strlen(arg_system_lang_code));
		strcpy(obj->objs[5]->name, "system_lang_code");
	}


	//parse argument string
	if (arg_lang_pack){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_lang_pack, strlen(arg_lang_pack));
		strcpy(obj->objs[6]->name, "lang_pack");
	}


	//parse argument string
	if (arg_lang_code){
		obj->objs[7] = NEW(tlo_t, return NULL);
		obj->objs[7]->flag_num = 0;
		obj->objs[7]->flag_bit = 0;
		obj->objs[7]->type = TYPE_STRING;
		obj->objs[7]->value = 
			buf_add((ui8_t *)arg_lang_code, strlen(arg_lang_code));
		strcpy(obj->objs[7]->name, "lang_code");
	}


	//parse argument InputClientProxy
	if (arg_proxy){
		obj->objs[8] = arg_proxy;
		obj->objs[8]->flag_num = 1;
		obj->objs[8]->flag_bit = 0;
	strcpy(obj->objs[8]->name, "proxy");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument JSONValue
	if (arg_params){
		obj->objs[9] = arg_params;
		obj->objs[9]->flag_num = 1;
		obj->objs[9]->flag_bit = 1;
	strcpy(obj->objs[9]->name, "params");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument !X
	if (arg_query){
		obj->objs[10] = arg_query;
		obj->objs[10]->flag_num = 0;
		obj->objs[10]->flag_bit = 0;
	strcpy(obj->objs[10]->name, "query");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_invokeWithLayer(int arg_layer, tlo_t * arg_query)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "invokeWithLayer");
	int i;
	obj->id = 0xda9b0d0d;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_layer);
	strcpy(obj->objs[0]->name, "layer");

	//parse argument !X
	if (arg_query){
		obj->objs[1] = arg_query;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "query");
	}

	return obj;
}

tlo_t * tl_invokeWithoutUpdates(tlo_t * arg_query)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "invokeWithoutUpdates");
	int i;
	obj->id = 0xbf9459b7;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument !X
	if (arg_query){
		obj->objs[0] = arg_query;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "query");
	}

	return obj;
}

tlo_t * tl_invokeWithMessagesRange(MessageRange arg_range, tlo_t * arg_query)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "invokeWithMessagesRange");
	int i;
	obj->id = 0x365275f2;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument MessageRange
	if (arg_range){
		obj->objs[0] = arg_range;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "range");
	}


	//parse argument !X
	if (arg_query){
		obj->objs[1] = arg_query;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "query");
	}

	return obj;
}

tlo_t * tl_invokeWithTakeout(long arg_takeout_id, tlo_t * arg_query)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "invokeWithTakeout");
	int i;
	obj->id = 0xaca9fd2e;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_takeout_id);
	strcpy(obj->objs[0]->name, "takeout_id");

	//parse argument !X
	if (arg_query){
		obj->objs[1] = arg_query;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "query");
	}

	return obj;
}

tlo_t * tl_invokeWithBusinessConnection(const char * arg_connection_id, tlo_t * arg_query)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "invokeWithBusinessConnection");
	int i;
	obj->id = 0xdd289f8e;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_connection_id){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_connection_id, strlen(arg_connection_id));
		strcpy(obj->objs[0]->name, "connection_id");
	}


	//parse argument !X
	if (arg_query){
		obj->objs[1] = arg_query;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "query");
	}

	return obj;
}

tlo_t * tl_invokeWithGooglePlayIntegrity(const char * arg_nonce, const char * arg_token, tlo_t * arg_query)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "invokeWithGooglePlayIntegrity");
	int i;
	obj->id = 0x1df92984;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_nonce){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_nonce, strlen(arg_nonce));
		strcpy(obj->objs[0]->name, "nonce");
	}


	//parse argument string
	if (arg_token){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_token, strlen(arg_token));
		strcpy(obj->objs[1]->name, "token");
	}


	//parse argument !X
	if (arg_query){
		obj->objs[2] = arg_query;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "query");
	}

	return obj;
}

tlo_t * tl_invokeWithApnsSecret(const char * arg_nonce, const char * arg_secret, tlo_t * arg_query)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "invokeWithApnsSecret");
	int i;
	obj->id = 0x0dae54f8;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_nonce){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_nonce, strlen(arg_nonce));
		strcpy(obj->objs[0]->name, "nonce");
	}


	//parse argument string
	if (arg_secret){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_secret, strlen(arg_secret));
		strcpy(obj->objs[1]->name, "secret");
	}


	//parse argument !X
	if (arg_query){
		obj->objs[2] = arg_query;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "query");
	}

	return obj;
}

tlo_t * tl_auth_sendCode(const char * arg_phone_number, int arg_api_id, const char * arg_api_hash, CodeSettings arg_settings)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_sendCode");
	int i;
	obj->id = 0xa677244f;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_phone_number){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_phone_number, strlen(arg_phone_number));
		strcpy(obj->objs[0]->name, "phone_number");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_api_id);
	strcpy(obj->objs[1]->name, "api_id");

	//parse argument string
	if (arg_api_hash){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_api_hash, strlen(arg_api_hash));
		strcpy(obj->objs[2]->name, "api_hash");
	}


	//parse argument CodeSettings
	if (arg_settings){
		obj->objs[3] = arg_settings;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "settings");
	}

	return obj;
}

tlo_t * tl_auth_signUp(bool arg_no_joined_notifications, const char * arg_phone_number, const char * arg_phone_code_hash, const char * arg_first_name, const char * arg_last_name)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_signUp");
	int i;
	obj->id = 0xaac7b717;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_no_joined_notifications);
	strcpy(obj->objs[1]->name, "no_joined_notifications");
	if (arg_no_joined_notifications)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument string
	if (arg_phone_number){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_phone_number, strlen(arg_phone_number));
		strcpy(obj->objs[2]->name, "phone_number");
	}


	//parse argument string
	if (arg_phone_code_hash){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_phone_code_hash, strlen(arg_phone_code_hash));
		strcpy(obj->objs[3]->name, "phone_code_hash");
	}


	//parse argument string
	if (arg_first_name){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_first_name, strlen(arg_first_name));
		strcpy(obj->objs[4]->name, "first_name");
	}


	//parse argument string
	if (arg_last_name){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_last_name, strlen(arg_last_name));
		strcpy(obj->objs[5]->name, "last_name");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_auth_signIn(const char * arg_phone_number, const char * arg_phone_code_hash, const char * arg_phone_code, EmailVerification arg_email_verification)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_signIn");
	int i;
	obj->id = 0x8d52a951;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_phone_number){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_phone_number, strlen(arg_phone_number));
		strcpy(obj->objs[1]->name, "phone_number");
	}


	//parse argument string
	if (arg_phone_code_hash){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_phone_code_hash, strlen(arg_phone_code_hash));
		strcpy(obj->objs[2]->name, "phone_code_hash");
	}


	//parse argument string
	if (arg_phone_code){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_phone_code, strlen(arg_phone_code));
		strcpy(obj->objs[3]->name, "phone_code");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument EmailVerification
	if (arg_email_verification){
		obj->objs[4] = arg_email_verification;
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 1;
	strcpy(obj->objs[4]->name, "email_verification");
		flagsv[nflags-1] |= (1 << 1);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_auth_logOut()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_logOut");
	int i;
	obj->id = 0x3e72ba19;
	return obj;
}

tlo_t * tl_auth_resetAuthorizations()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_resetAuthorizations");
	int i;
	obj->id = 0x9fab0d1a;
	return obj;
}

tlo_t * tl_auth_exportAuthorization(int arg_dc_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_exportAuthorization");
	int i;
	obj->id = 0xe5bfffcd;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_dc_id);
	strcpy(obj->objs[0]->name, "dc_id");
	return obj;
}

tlo_t * tl_auth_importAuthorization(long arg_id, unsigned char * arg_bytes, int len_arg_bytes)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_importAuthorization");
	int i;
	obj->id = 0xa57a7dad;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_id);
	strcpy(obj->objs[0]->name, "id");

	//parse argument bytes
	if (arg_bytes){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_bytes, len_arg_bytes);
		strcpy(obj->objs[1]->name, "bytes");
	}

	return obj;
}

tlo_t * tl_auth_bindTempAuthKey(long arg_perm_auth_key_id, long arg_nonce, int arg_expires_at, unsigned char * arg_encrypted_message, int len_arg_encrypted_message)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_bindTempAuthKey");
	int i;
	obj->id = 0xcdd42a05;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_perm_auth_key_id);
	strcpy(obj->objs[0]->name, "perm_auth_key_id");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_nonce);
	strcpy(obj->objs[1]->name, "nonce");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_expires_at);
	strcpy(obj->objs[2]->name, "expires_at");

	//parse argument bytes
	if (arg_encrypted_message){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_BYTES;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_encrypted_message, len_arg_encrypted_message);
		strcpy(obj->objs[3]->name, "encrypted_message");
	}

	return obj;
}

tlo_t * tl_auth_importBotAuthorization(int arg_flags, int arg_api_id, const char * arg_api_hash, const char * arg_bot_auth_token)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_importBotAuthorization");
	int i;
	obj->id = 0x67a3ff2c;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_flags);
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_api_id);
	strcpy(obj->objs[1]->name, "api_id");

	//parse argument string
	if (arg_api_hash){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_api_hash, strlen(arg_api_hash));
		strcpy(obj->objs[2]->name, "api_hash");
	}


	//parse argument string
	if (arg_bot_auth_token){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_bot_auth_token, strlen(arg_bot_auth_token));
		strcpy(obj->objs[3]->name, "bot_auth_token");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_auth_checkPassword(InputCheckPasswordSRP arg_password)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_checkPassword");
	int i;
	obj->id = 0xd18b4d16;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputCheckPasswordSRP
	if (arg_password){
		obj->objs[0] = arg_password;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "password");
	}

	return obj;
}

tlo_t * tl_auth_requestPasswordRecovery()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_requestPasswordRecovery");
	int i;
	obj->id = 0xd897bc66;
	return obj;
}

tlo_t * tl_auth_recoverPassword(const char * arg_code, account_PasswordInputSettings arg_new_settings)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_recoverPassword");
	int i;
	obj->id = 0x37096c70;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_code){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_code, strlen(arg_code));
		strcpy(obj->objs[1]->name, "code");
	}


	//parse argument account_PasswordInputSettings
	if (arg_new_settings){
		obj->objs[2] = arg_new_settings;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "new_settings");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_auth_resendCode(const char * arg_phone_number, const char * arg_phone_code_hash, const char * arg_reason)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_resendCode");
	int i;
	obj->id = 0xcae47523;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_phone_number){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_phone_number, strlen(arg_phone_number));
		strcpy(obj->objs[1]->name, "phone_number");
	}


	//parse argument string
	if (arg_phone_code_hash){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_phone_code_hash, strlen(arg_phone_code_hash));
		strcpy(obj->objs[2]->name, "phone_code_hash");
	}


	//parse argument string
	if (arg_reason){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_reason, strlen(arg_reason));
		strcpy(obj->objs[3]->name, "reason");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_auth_cancelCode(const char * arg_phone_number, const char * arg_phone_code_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_cancelCode");
	int i;
	obj->id = 0x1f040578;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_phone_number){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_phone_number, strlen(arg_phone_number));
		strcpy(obj->objs[0]->name, "phone_number");
	}


	//parse argument string
	if (arg_phone_code_hash){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_phone_code_hash, strlen(arg_phone_code_hash));
		strcpy(obj->objs[1]->name, "phone_code_hash");
	}

	return obj;
}

tlo_t * tl_auth_dropTempAuthKeys(long *arg_except_auth_keys, int len_arg_except_auth_keys)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_dropTempAuthKeys");
	int i;
	obj->id = 0x8e48a188;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<long>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "except_auth_keys");
	if (arg_except_auth_keys){
		for(i=0; i<len_arg_except_auth_keys; ++i){
			buf_t b = buf_add_ui64(arg_except_auth_keys[i]);
			buf_cat(obj->objs[0]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_auth_exportLoginToken(int arg_api_id, const char * arg_api_hash, long *arg_except_ids, int len_arg_except_ids)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_exportLoginToken");
	int i;
	obj->id = 0xb7e085fe;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_api_id);
	strcpy(obj->objs[0]->name, "api_id");

	//parse argument string
	if (arg_api_hash){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_api_hash, strlen(arg_api_hash));
		strcpy(obj->objs[1]->name, "api_hash");
	}


	//parse argument Vector<long>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "except_ids");
	if (arg_except_ids){
		for(i=0; i<len_arg_except_ids; ++i){
			buf_t b = buf_add_ui64(arg_except_ids[i]);
			buf_cat(obj->objs[2]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_auth_importLoginToken(unsigned char * arg_token, int len_arg_token)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_importLoginToken");
	int i;
	obj->id = 0x95ac5ce4;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument bytes
	if (arg_token){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_BYTES;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_token, len_arg_token);
		strcpy(obj->objs[0]->name, "token");
	}

	return obj;
}

tlo_t * tl_auth_acceptLoginToken(unsigned char * arg_token, int len_arg_token)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_acceptLoginToken");
	int i;
	obj->id = 0xe894ad4d;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument bytes
	if (arg_token){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_BYTES;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_token, len_arg_token);
		strcpy(obj->objs[0]->name, "token");
	}

	return obj;
}

tlo_t * tl_auth_checkRecoveryPassword(const char * arg_code)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_checkRecoveryPassword");
	int i;
	obj->id = 0x0d36bf79;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_code){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_code, strlen(arg_code));
		strcpy(obj->objs[0]->name, "code");
	}

	return obj;
}

tlo_t * tl_auth_importWebTokenAuthorization(int arg_api_id, const char * arg_api_hash, const char * arg_web_auth_token)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_importWebTokenAuthorization");
	int i;
	obj->id = 0x2db873a9;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_api_id);
	strcpy(obj->objs[0]->name, "api_id");

	//parse argument string
	if (arg_api_hash){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_api_hash, strlen(arg_api_hash));
		strcpy(obj->objs[1]->name, "api_hash");
	}


	//parse argument string
	if (arg_web_auth_token){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_web_auth_token, strlen(arg_web_auth_token));
		strcpy(obj->objs[2]->name, "web_auth_token");
	}

	return obj;
}

tlo_t * tl_auth_requestFirebaseSms(const char * arg_phone_number, const char * arg_phone_code_hash, const char * arg_safety_net_token, const char * arg_play_integrity_token, const char * arg_ios_push_secret)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_requestFirebaseSms");
	int i;
	obj->id = 0x8e39261e;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_phone_number){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_phone_number, strlen(arg_phone_number));
		strcpy(obj->objs[1]->name, "phone_number");
	}


	//parse argument string
	if (arg_phone_code_hash){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_phone_code_hash, strlen(arg_phone_code_hash));
		strcpy(obj->objs[2]->name, "phone_code_hash");
	}


	//parse argument string
	if (arg_safety_net_token){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_safety_net_token, strlen(arg_safety_net_token));
		strcpy(obj->objs[3]->name, "safety_net_token");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_play_integrity_token){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 2;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_play_integrity_token, strlen(arg_play_integrity_token));
		strcpy(obj->objs[4]->name, "play_integrity_token");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument string
	if (arg_ios_push_secret){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 1;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_ios_push_secret, strlen(arg_ios_push_secret));
		strcpy(obj->objs[5]->name, "ios_push_secret");
		flagsv[nflags-1] |= (1 << 1);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_auth_resetLoginEmail(const char * arg_phone_number, const char * arg_phone_code_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_resetLoginEmail");
	int i;
	obj->id = 0x7e960193;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_phone_number){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_phone_number, strlen(arg_phone_number));
		strcpy(obj->objs[0]->name, "phone_number");
	}


	//parse argument string
	if (arg_phone_code_hash){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_phone_code_hash, strlen(arg_phone_code_hash));
		strcpy(obj->objs[1]->name, "phone_code_hash");
	}

	return obj;
}

tlo_t * tl_auth_reportMissingCode(const char * arg_phone_number, const char * arg_phone_code_hash, const char * arg_mnc)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "auth_reportMissingCode");
	int i;
	obj->id = 0xcb9deff6;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_phone_number){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_phone_number, strlen(arg_phone_number));
		strcpy(obj->objs[0]->name, "phone_number");
	}


	//parse argument string
	if (arg_phone_code_hash){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_phone_code_hash, strlen(arg_phone_code_hash));
		strcpy(obj->objs[1]->name, "phone_code_hash");
	}


	//parse argument string
	if (arg_mnc){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_mnc, strlen(arg_mnc));
		strcpy(obj->objs[2]->name, "mnc");
	}

	return obj;
}

tlo_t * tl_account_registerDevice(bool arg_no_muted, int arg_token_type, const char * arg_token, Bool arg_app_sandbox, unsigned char * arg_secret, int len_arg_secret, long *arg_other_uids, int len_arg_other_uids)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_registerDevice");
	int i;
	obj->id = 0xec86017a;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_no_muted);
	strcpy(obj->objs[1]->name, "no_muted");
	if (arg_no_muted)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_token_type);
	strcpy(obj->objs[2]->name, "token_type");

	//parse argument string
	if (arg_token){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_token, strlen(arg_token));
		strcpy(obj->objs[3]->name, "token");
	}


	//parse argument Bool
	if (arg_app_sandbox){
		obj->objs[4] = arg_app_sandbox;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "app_sandbox");
	}


	//parse argument bytes
	if (arg_secret){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_BYTES;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_secret, len_arg_secret);
		strcpy(obj->objs[5]->name, "secret");
	}


	//parse argument Vector<long>
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_VECTOR;
	strcpy(obj->objs[6]->name, "other_uids");
	if (arg_other_uids){
		for(i=0; i<len_arg_other_uids; ++i){
			buf_t b = buf_add_ui64(arg_other_uids[i]);
			buf_cat(obj->objs[6]->value, b);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_account_unregisterDevice(int arg_token_type, const char * arg_token, long *arg_other_uids, int len_arg_other_uids)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_unregisterDevice");
	int i;
	obj->id = 0x6a0d3206;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_token_type);
	strcpy(obj->objs[0]->name, "token_type");

	//parse argument string
	if (arg_token){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_token, strlen(arg_token));
		strcpy(obj->objs[1]->name, "token");
	}


	//parse argument Vector<long>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "other_uids");
	if (arg_other_uids){
		for(i=0; i<len_arg_other_uids; ++i){
			buf_t b = buf_add_ui64(arg_other_uids[i]);
			buf_cat(obj->objs[2]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_account_updateNotifySettings(InputNotifyPeer arg_peer, InputPeerNotifySettings arg_settings)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_updateNotifySettings");
	int i;
	obj->id = 0x84be5b93;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputNotifyPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument InputPeerNotifySettings
	if (arg_settings){
		obj->objs[1] = arg_settings;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "settings");
	}

	return obj;
}

tlo_t * tl_account_getNotifySettings(InputNotifyPeer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_getNotifySettings");
	int i;
	obj->id = 0x12b3ad31;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputNotifyPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}

	return obj;
}

tlo_t * tl_account_resetNotifySettings()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_resetNotifySettings");
	int i;
	obj->id = 0xdb7e1747;
	return obj;
}

tlo_t * tl_account_updateProfile(const char * arg_first_name, const char * arg_last_name, const char * arg_about)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_updateProfile");
	int i;
	obj->id = 0x78515775;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_first_name){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_first_name, strlen(arg_first_name));
		strcpy(obj->objs[1]->name, "first_name");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_last_name){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 1;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_last_name, strlen(arg_last_name));
		strcpy(obj->objs[2]->name, "last_name");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument string
	if (arg_about){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 2;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_about, strlen(arg_about));
		strcpy(obj->objs[3]->name, "about");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_account_updateStatus(Bool arg_offline)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_updateStatus");
	int i;
	obj->id = 0x6628562c;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Bool
	if (arg_offline){
		obj->objs[0] = arg_offline;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "offline");
	}

	return obj;
}

tlo_t * tl_account_getWallPapers(long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_getWallPapers");
	int i;
	obj->id = 0x07967d36;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_account_reportPeer(InputPeer arg_peer, ReportReason arg_reason, const char * arg_message)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_reportPeer");
	int i;
	obj->id = 0xc5ba3d86;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument ReportReason
	if (arg_reason){
		obj->objs[1] = arg_reason;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "reason");
	}


	//parse argument string
	if (arg_message){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_message, strlen(arg_message));
		strcpy(obj->objs[2]->name, "message");
	}

	return obj;
}

tlo_t * tl_account_checkUsername(const char * arg_username)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_checkUsername");
	int i;
	obj->id = 0x2714d86c;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_username){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_username, strlen(arg_username));
		strcpy(obj->objs[0]->name, "username");
	}

	return obj;
}

tlo_t * tl_account_updateUsername(const char * arg_username)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_updateUsername");
	int i;
	obj->id = 0x3e0bdd7c;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_username){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_username, strlen(arg_username));
		strcpy(obj->objs[0]->name, "username");
	}

	return obj;
}

tlo_t * tl_account_getPrivacy(InputPrivacyKey arg_key)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_getPrivacy");
	int i;
	obj->id = 0xdadbc950;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputPrivacyKey
	if (arg_key){
		obj->objs[0] = arg_key;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "key");
	}

	return obj;
}

tlo_t * tl_account_setPrivacy(InputPrivacyKey arg_key, InputPrivacyRule *arg_rules, int len_arg_rules)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_setPrivacy");
	int i;
	obj->id = 0xc9f81ce8;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPrivacyKey
	if (arg_key){
		obj->objs[0] = arg_key;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "key");
	}


	//parse argument Vector<InputPrivacyRule>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "rules");
	if (arg_rules){
		for(i=0; i<len_arg_rules; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_rules[i]->id);
			buf_cat(obj->objs[1]->value, arg_rules[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_account_deleteAccount(const char * arg_reason, InputCheckPasswordSRP arg_password)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_deleteAccount");
	int i;
	obj->id = 0xa2c0cf74;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_reason){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_reason, strlen(arg_reason));
		strcpy(obj->objs[1]->name, "reason");
	}


	//parse argument InputCheckPasswordSRP
	if (arg_password){
		obj->objs[2] = arg_password;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "password");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_account_getAccountTTL()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_getAccountTTL");
	int i;
	obj->id = 0x08fc711d;
	return obj;
}

tlo_t * tl_account_setAccountTTL(AccountDaysTTL arg_ttl)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_setAccountTTL");
	int i;
	obj->id = 0x2442485e;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument AccountDaysTTL
	if (arg_ttl){
		obj->objs[0] = arg_ttl;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "ttl");
	}

	return obj;
}

tlo_t * tl_account_sendChangePhoneCode(const char * arg_phone_number, CodeSettings arg_settings)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_sendChangePhoneCode");
	int i;
	obj->id = 0x82574ae5;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_phone_number){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_phone_number, strlen(arg_phone_number));
		strcpy(obj->objs[0]->name, "phone_number");
	}


	//parse argument CodeSettings
	if (arg_settings){
		obj->objs[1] = arg_settings;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "settings");
	}

	return obj;
}

tlo_t * tl_account_changePhone(const char * arg_phone_number, const char * arg_phone_code_hash, const char * arg_phone_code)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_changePhone");
	int i;
	obj->id = 0x70c32edb;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_phone_number){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_phone_number, strlen(arg_phone_number));
		strcpy(obj->objs[0]->name, "phone_number");
	}


	//parse argument string
	if (arg_phone_code_hash){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_phone_code_hash, strlen(arg_phone_code_hash));
		strcpy(obj->objs[1]->name, "phone_code_hash");
	}


	//parse argument string
	if (arg_phone_code){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_phone_code, strlen(arg_phone_code));
		strcpy(obj->objs[2]->name, "phone_code");
	}

	return obj;
}

tlo_t * tl_account_updateDeviceLocked(int arg_period)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_updateDeviceLocked");
	int i;
	obj->id = 0x38df3532;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_period);
	strcpy(obj->objs[0]->name, "period");
	return obj;
}

tlo_t * tl_account_getAuthorizations()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_getAuthorizations");
	int i;
	obj->id = 0xe320c158;
	return obj;
}

tlo_t * tl_account_resetAuthorization(long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_resetAuthorization");
	int i;
	obj->id = 0xdf77f3bc;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_account_getPassword()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_getPassword");
	int i;
	obj->id = 0x548a30f5;
	return obj;
}

tlo_t * tl_account_getPasswordSettings(InputCheckPasswordSRP arg_password)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_getPasswordSettings");
	int i;
	obj->id = 0x9cd4eaf9;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputCheckPasswordSRP
	if (arg_password){
		obj->objs[0] = arg_password;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "password");
	}

	return obj;
}

tlo_t * tl_account_updatePasswordSettings(InputCheckPasswordSRP arg_password, account_PasswordInputSettings arg_new_settings)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_updatePasswordSettings");
	int i;
	obj->id = 0xa59b102f;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputCheckPasswordSRP
	if (arg_password){
		obj->objs[0] = arg_password;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "password");
	}


	//parse argument account_PasswordInputSettings
	if (arg_new_settings){
		obj->objs[1] = arg_new_settings;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "new_settings");
	}

	return obj;
}

tlo_t * tl_account_sendConfirmPhoneCode(const char * arg_hash, CodeSettings arg_settings)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_sendConfirmPhoneCode");
	int i;
	obj->id = 0x1b3faa88;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_hash){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_hash, strlen(arg_hash));
		strcpy(obj->objs[0]->name, "hash");
	}


	//parse argument CodeSettings
	if (arg_settings){
		obj->objs[1] = arg_settings;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "settings");
	}

	return obj;
}

tlo_t * tl_account_confirmPhone(const char * arg_phone_code_hash, const char * arg_phone_code)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_confirmPhone");
	int i;
	obj->id = 0x5f2178c3;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_phone_code_hash){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_phone_code_hash, strlen(arg_phone_code_hash));
		strcpy(obj->objs[0]->name, "phone_code_hash");
	}


	//parse argument string
	if (arg_phone_code){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_phone_code, strlen(arg_phone_code));
		strcpy(obj->objs[1]->name, "phone_code");
	}

	return obj;
}

tlo_t * tl_account_getTmpPassword(InputCheckPasswordSRP arg_password, int arg_period)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_getTmpPassword");
	int i;
	obj->id = 0x449e0b51;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputCheckPasswordSRP
	if (arg_password){
		obj->objs[0] = arg_password;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "password");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_period);
	strcpy(obj->objs[1]->name, "period");
	return obj;
}

tlo_t * tl_account_getWebAuthorizations()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_getWebAuthorizations");
	int i;
	obj->id = 0x182e6d6f;
	return obj;
}

tlo_t * tl_account_resetWebAuthorization(long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_resetWebAuthorization");
	int i;
	obj->id = 0x2d01b9ef;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_account_resetWebAuthorizations()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_resetWebAuthorizations");
	int i;
	obj->id = 0x682d2594;
	return obj;
}

tlo_t * tl_account_getAllSecureValues()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_getAllSecureValues");
	int i;
	obj->id = 0xb288bc7d;
	return obj;
}

tlo_t * tl_account_getSecureValue(SecureValueType *arg_types, int len_arg_types)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_getSecureValue");
	int i;
	obj->id = 0x73665bc2;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<SecureValueType>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "types");
	if (arg_types){
		for(i=0; i<len_arg_types; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_types[i]->id);
			buf_cat(obj->objs[0]->value, arg_types[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_account_saveSecureValue(InputSecureValue arg_value, long arg_secure_secret_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_saveSecureValue");
	int i;
	obj->id = 0x899fe31d;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputSecureValue
	if (arg_value){
		obj->objs[0] = arg_value;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "value");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_secure_secret_id);
	strcpy(obj->objs[1]->name, "secure_secret_id");
	return obj;
}

tlo_t * tl_account_deleteSecureValue(SecureValueType *arg_types, int len_arg_types)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_deleteSecureValue");
	int i;
	obj->id = 0xb880bc4b;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<SecureValueType>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "types");
	if (arg_types){
		for(i=0; i<len_arg_types; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_types[i]->id);
			buf_cat(obj->objs[0]->value, arg_types[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_account_getAuthorizationForm(long arg_bot_id, const char * arg_scope, const char * arg_public_key)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_getAuthorizationForm");
	int i;
	obj->id = 0xa929597a;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_bot_id);
	strcpy(obj->objs[0]->name, "bot_id");

	//parse argument string
	if (arg_scope){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_scope, strlen(arg_scope));
		strcpy(obj->objs[1]->name, "scope");
	}


	//parse argument string
	if (arg_public_key){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_public_key, strlen(arg_public_key));
		strcpy(obj->objs[2]->name, "public_key");
	}

	return obj;
}

tlo_t * tl_account_acceptAuthorization(long arg_bot_id, const char * arg_scope, const char * arg_public_key, SecureValueHash *arg_value_hashes, int len_arg_value_hashes, SecureCredentialsEncrypted arg_credentials)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_acceptAuthorization");
	int i;
	obj->id = 0xf3ed4c73;
	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_bot_id);
	strcpy(obj->objs[0]->name, "bot_id");

	//parse argument string
	if (arg_scope){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_scope, strlen(arg_scope));
		strcpy(obj->objs[1]->name, "scope");
	}


	//parse argument string
	if (arg_public_key){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_public_key, strlen(arg_public_key));
		strcpy(obj->objs[2]->name, "public_key");
	}


	//parse argument Vector<SecureValueHash>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "value_hashes");
	if (arg_value_hashes){
		for(i=0; i<len_arg_value_hashes; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_value_hashes[i]->id);
			buf_cat(obj->objs[3]->value, arg_value_hashes[i]->value);
		}
	}


	//parse argument SecureCredentialsEncrypted
	if (arg_credentials){
		obj->objs[4] = arg_credentials;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "credentials");
	}

	return obj;
}

tlo_t * tl_account_sendVerifyPhoneCode(const char * arg_phone_number, CodeSettings arg_settings)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_sendVerifyPhoneCode");
	int i;
	obj->id = 0xa5a356f9;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_phone_number){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_phone_number, strlen(arg_phone_number));
		strcpy(obj->objs[0]->name, "phone_number");
	}


	//parse argument CodeSettings
	if (arg_settings){
		obj->objs[1] = arg_settings;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "settings");
	}

	return obj;
}

tlo_t * tl_account_verifyPhone(const char * arg_phone_number, const char * arg_phone_code_hash, const char * arg_phone_code)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_verifyPhone");
	int i;
	obj->id = 0x4dd3a7f6;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_phone_number){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_phone_number, strlen(arg_phone_number));
		strcpy(obj->objs[0]->name, "phone_number");
	}


	//parse argument string
	if (arg_phone_code_hash){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_phone_code_hash, strlen(arg_phone_code_hash));
		strcpy(obj->objs[1]->name, "phone_code_hash");
	}


	//parse argument string
	if (arg_phone_code){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_phone_code, strlen(arg_phone_code));
		strcpy(obj->objs[2]->name, "phone_code");
	}

	return obj;
}

tlo_t * tl_account_sendVerifyEmailCode(EmailVerifyPurpose arg_purpose, const char * arg_email)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_sendVerifyEmailCode");
	int i;
	obj->id = 0x98e037bb;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument EmailVerifyPurpose
	if (arg_purpose){
		obj->objs[0] = arg_purpose;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "purpose");
	}


	//parse argument string
	if (arg_email){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_email, strlen(arg_email));
		strcpy(obj->objs[1]->name, "email");
	}

	return obj;
}

tlo_t * tl_account_verifyEmail(EmailVerifyPurpose arg_purpose, EmailVerification arg_verification)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_verifyEmail");
	int i;
	obj->id = 0x032da4cf;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument EmailVerifyPurpose
	if (arg_purpose){
		obj->objs[0] = arg_purpose;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "purpose");
	}


	//parse argument EmailVerification
	if (arg_verification){
		obj->objs[1] = arg_verification;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "verification");
	}

	return obj;
}

tlo_t * tl_account_initTakeoutSession(bool arg_contacts, bool arg_message_users, bool arg_message_chats, bool arg_message_megagroups, bool arg_message_channels, bool arg_files, long arg_file_max_size)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_initTakeoutSession");
	int i;
	obj->id = 0x8ef3eab0;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_contacts);
	strcpy(obj->objs[1]->name, "contacts");
	if (arg_contacts)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_message_users);
	strcpy(obj->objs[2]->name, "message_users");
	if (arg_message_users)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_message_chats);
	strcpy(obj->objs[3]->name, "message_chats");
	if (arg_message_chats)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 3;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_message_megagroups);
	strcpy(obj->objs[4]->name, "message_megagroups");
	if (arg_message_megagroups)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 4;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_message_channels);
	strcpy(obj->objs[5]->name, "message_channels");
	if (arg_message_channels)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument true
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 5;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_files);
	strcpy(obj->objs[6]->name, "files");
	if (arg_files)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument long
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 5;
	obj->objs[7]->type = TYPE_LONG;
	obj->objs[7]->value = 
		buf_add_ui64(arg_file_max_size);
	strcpy(obj->objs[7]->name, "file_max_size");
	if (arg_file_max_size)
		flagsv[nflags-1] |= (1 << 5);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_account_finishTakeoutSession(bool arg_success)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_finishTakeoutSession");
	int i;
	obj->id = 0x1d2652ee;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_success);
	strcpy(obj->objs[1]->name, "success");
	if (arg_success)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_account_confirmPasswordEmail(const char * arg_code)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_confirmPasswordEmail");
	int i;
	obj->id = 0x8fdf1920;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_code){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_code, strlen(arg_code));
		strcpy(obj->objs[0]->name, "code");
	}

	return obj;
}

tlo_t * tl_account_resendPasswordEmail()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_resendPasswordEmail");
	int i;
	obj->id = 0x7a7f2a15;
	return obj;
}

tlo_t * tl_account_cancelPasswordEmail()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_cancelPasswordEmail");
	int i;
	obj->id = 0xc1cbd5b6;
	return obj;
}

tlo_t * tl_account_getContactSignUpNotification()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_getContactSignUpNotification");
	int i;
	obj->id = 0x9f07c728;
	return obj;
}

tlo_t * tl_account_setContactSignUpNotification(Bool arg_silent)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_setContactSignUpNotification");
	int i;
	obj->id = 0xcff43f61;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Bool
	if (arg_silent){
		obj->objs[0] = arg_silent;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "silent");
	}

	return obj;
}

tlo_t * tl_account_getNotifyExceptions(bool arg_compare_sound, bool arg_compare_stories, InputNotifyPeer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_getNotifyExceptions");
	int i;
	obj->id = 0x53577479;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_compare_sound);
	strcpy(obj->objs[1]->name, "compare_sound");
	if (arg_compare_sound)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 2;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_compare_stories);
	strcpy(obj->objs[2]->name, "compare_stories");
	if (arg_compare_stories)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument InputNotifyPeer
	if (arg_peer){
		obj->objs[3] = arg_peer;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "peer");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_account_getWallPaper(InputWallPaper arg_wallpaper)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_getWallPaper");
	int i;
	obj->id = 0xfc8ddbea;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputWallPaper
	if (arg_wallpaper){
		obj->objs[0] = arg_wallpaper;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "wallpaper");
	}

	return obj;
}

tlo_t * tl_account_uploadWallPaper(bool arg_for_chat, InputFile arg_file, const char * arg_mime_type, WallPaperSettings arg_settings)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_uploadWallPaper");
	int i;
	obj->id = 0xe39a8f03;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_for_chat);
	strcpy(obj->objs[1]->name, "for_chat");
	if (arg_for_chat)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputFile
	if (arg_file){
		obj->objs[2] = arg_file;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "file");
	}


	//parse argument string
	if (arg_mime_type){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_mime_type, strlen(arg_mime_type));
		strcpy(obj->objs[3]->name, "mime_type");
	}


	//parse argument WallPaperSettings
	if (arg_settings){
		obj->objs[4] = arg_settings;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "settings");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_account_saveWallPaper(InputWallPaper arg_wallpaper, Bool arg_unsave, WallPaperSettings arg_settings)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_saveWallPaper");
	int i;
	obj->id = 0x6c5a5b37;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputWallPaper
	if (arg_wallpaper){
		obj->objs[0] = arg_wallpaper;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "wallpaper");
	}


	//parse argument Bool
	if (arg_unsave){
		obj->objs[1] = arg_unsave;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "unsave");
	}


	//parse argument WallPaperSettings
	if (arg_settings){
		obj->objs[2] = arg_settings;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "settings");
	}

	return obj;
}

tlo_t * tl_account_installWallPaper(InputWallPaper arg_wallpaper, WallPaperSettings arg_settings)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_installWallPaper");
	int i;
	obj->id = 0xfeed5769;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputWallPaper
	if (arg_wallpaper){
		obj->objs[0] = arg_wallpaper;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "wallpaper");
	}


	//parse argument WallPaperSettings
	if (arg_settings){
		obj->objs[1] = arg_settings;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "settings");
	}

	return obj;
}

tlo_t * tl_account_resetWallPapers()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_resetWallPapers");
	int i;
	obj->id = 0xbb3b9804;
	return obj;
}

tlo_t * tl_account_getAutoDownloadSettings()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_getAutoDownloadSettings");
	int i;
	obj->id = 0x56da0b3f;
	return obj;
}

tlo_t * tl_account_saveAutoDownloadSettings(bool arg_low, bool arg_high, AutoDownloadSettings arg_settings)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_saveAutoDownloadSettings");
	int i;
	obj->id = 0x76f36233;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_low);
	strcpy(obj->objs[1]->name, "low");
	if (arg_low)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_high);
	strcpy(obj->objs[2]->name, "high");
	if (arg_high)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument AutoDownloadSettings
	if (arg_settings){
		obj->objs[3] = arg_settings;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "settings");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_account_uploadTheme(InputFile arg_file, InputFile arg_thumb, const char * arg_file_name, const char * arg_mime_type)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_uploadTheme");
	int i;
	obj->id = 0x1c3db333;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputFile
	if (arg_file){
		obj->objs[1] = arg_file;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "file");
	}


	//parse argument InputFile
	if (arg_thumb){
		obj->objs[2] = arg_thumb;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "thumb");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_file_name){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_file_name, strlen(arg_file_name));
		strcpy(obj->objs[3]->name, "file_name");
	}


	//parse argument string
	if (arg_mime_type){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_mime_type, strlen(arg_mime_type));
		strcpy(obj->objs[4]->name, "mime_type");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_account_createTheme(const char * arg_slug, const char * arg_title, InputDocument arg_document, InputThemeSettings *arg_settings, int len_arg_settings)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_createTheme");
	int i;
	obj->id = 0x652e4400;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_slug){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_slug, strlen(arg_slug));
		strcpy(obj->objs[1]->name, "slug");
	}


	//parse argument string
	if (arg_title){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[2]->name, "title");
	}


	//parse argument InputDocument
	if (arg_document){
		obj->objs[3] = arg_document;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 2;
	strcpy(obj->objs[3]->name, "document");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument Vector<InputThemeSettings>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 3;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "settings");
	if (arg_settings){
		for(i=0; i<len_arg_settings; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_settings[i]->id);
			buf_cat(obj->objs[4]->value, arg_settings[i]->value);
		}
		flagsv[nflags-1] |= (1 << 3);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_account_updateTheme(const char * arg_format, InputTheme arg_theme, const char * arg_slug, const char * arg_title, InputDocument arg_document, InputThemeSettings *arg_settings, int len_arg_settings)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_updateTheme");
	int i;
	obj->id = 0x2bf40ccc;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_format){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_format, strlen(arg_format));
		strcpy(obj->objs[1]->name, "format");
	}


	//parse argument InputTheme
	if (arg_theme){
		obj->objs[2] = arg_theme;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "theme");
	}


	//parse argument string
	if (arg_slug){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_slug, strlen(arg_slug));
		strcpy(obj->objs[3]->name, "slug");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_title){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 1;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[4]->name, "title");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument InputDocument
	if (arg_document){
		obj->objs[5] = arg_document;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 2;
	strcpy(obj->objs[5]->name, "document");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument Vector<InputThemeSettings>
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 3;
	obj->objs[6]->type = TYPE_VECTOR;
	strcpy(obj->objs[6]->name, "settings");
	if (arg_settings){
		for(i=0; i<len_arg_settings; ++i){
			obj->objs[6]->value = buf_add_ui32(arg_settings[i]->id);
			buf_cat(obj->objs[6]->value, arg_settings[i]->value);
		}
		flagsv[nflags-1] |= (1 << 3);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_account_saveTheme(InputTheme arg_theme, Bool arg_unsave)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_saveTheme");
	int i;
	obj->id = 0xf257106c;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputTheme
	if (arg_theme){
		obj->objs[0] = arg_theme;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "theme");
	}


	//parse argument Bool
	if (arg_unsave){
		obj->objs[1] = arg_unsave;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "unsave");
	}

	return obj;
}

tlo_t * tl_account_installTheme(bool arg_dark, InputTheme arg_theme, const char * arg_format, BaseTheme arg_base_theme)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_installTheme");
	int i;
	obj->id = 0xc727bb3b;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_dark);
	strcpy(obj->objs[1]->name, "dark");
	if (arg_dark)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputTheme
	if (arg_theme){
		obj->objs[2] = arg_theme;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 1;
	strcpy(obj->objs[2]->name, "theme");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument string
	if (arg_format){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 2;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_format, strlen(arg_format));
		strcpy(obj->objs[3]->name, "format");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument BaseTheme
	if (arg_base_theme){
		obj->objs[4] = arg_base_theme;
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 3;
	strcpy(obj->objs[4]->name, "base_theme");
		flagsv[nflags-1] |= (1 << 3);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_account_getTheme(const char * arg_format, InputTheme arg_theme)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_getTheme");
	int i;
	obj->id = 0x3a5869ec;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_format){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_format, strlen(arg_format));
		strcpy(obj->objs[0]->name, "format");
	}


	//parse argument InputTheme
	if (arg_theme){
		obj->objs[1] = arg_theme;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "theme");
	}

	return obj;
}

tlo_t * tl_account_getThemes(const char * arg_format, long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_getThemes");
	int i;
	obj->id = 0x7206e458;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_format){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_format, strlen(arg_format));
		strcpy(obj->objs[0]->name, "format");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[1]->name, "hash");
	return obj;
}

tlo_t * tl_account_setContentSettings(bool arg_sensitive_enabled)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_setContentSettings");
	int i;
	obj->id = 0xb574b16b;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_sensitive_enabled);
	strcpy(obj->objs[1]->name, "sensitive_enabled");
	if (arg_sensitive_enabled)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_account_getContentSettings()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_getContentSettings");
	int i;
	obj->id = 0x8b9b4dae;
	return obj;
}

tlo_t * tl_account_getMultiWallPapers(InputWallPaper *arg_wallpapers, int len_arg_wallpapers)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_getMultiWallPapers");
	int i;
	obj->id = 0x65ad71dc;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<InputWallPaper>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "wallpapers");
	if (arg_wallpapers){
		for(i=0; i<len_arg_wallpapers; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_wallpapers[i]->id);
			buf_cat(obj->objs[0]->value, arg_wallpapers[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_account_getGlobalPrivacySettings()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_getGlobalPrivacySettings");
	int i;
	obj->id = 0xeb2b4cf6;
	return obj;
}

tlo_t * tl_account_setGlobalPrivacySettings(GlobalPrivacySettings arg_settings)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_setGlobalPrivacySettings");
	int i;
	obj->id = 0x1edaaac2;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument GlobalPrivacySettings
	if (arg_settings){
		obj->objs[0] = arg_settings;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "settings");
	}

	return obj;
}

tlo_t * tl_account_reportProfilePhoto(InputPeer arg_peer, InputPhoto arg_photo_id, ReportReason arg_reason, const char * arg_message)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_reportProfilePhoto");
	int i;
	obj->id = 0xfa8cc6f5;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument InputPhoto
	if (arg_photo_id){
		obj->objs[1] = arg_photo_id;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "photo_id");
	}


	//parse argument ReportReason
	if (arg_reason){
		obj->objs[2] = arg_reason;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "reason");
	}


	//parse argument string
	if (arg_message){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_message, strlen(arg_message));
		strcpy(obj->objs[3]->name, "message");
	}

	return obj;
}

tlo_t * tl_account_resetPassword()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_resetPassword");
	int i;
	obj->id = 0x9308ce1b;
	return obj;
}

tlo_t * tl_account_declinePasswordReset()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_declinePasswordReset");
	int i;
	obj->id = 0x4c9409f6;
	return obj;
}

tlo_t * tl_account_getChatThemes(long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_getChatThemes");
	int i;
	obj->id = 0xd638de89;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_account_setAuthorizationTTL(int arg_authorization_ttl_days)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_setAuthorizationTTL");
	int i;
	obj->id = 0xbf899aa0;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_authorization_ttl_days);
	strcpy(obj->objs[0]->name, "authorization_ttl_days");
	return obj;
}

tlo_t * tl_account_changeAuthorizationSettings(bool arg_confirmed, long arg_hash, Bool arg_encrypted_requests_disabled, Bool arg_call_requests_disabled)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_changeAuthorizationSettings");
	int i;
	obj->id = 0x40f48462;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 3;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_confirmed);
	strcpy(obj->objs[1]->name, "confirmed");
	if (arg_confirmed)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[2]->name, "hash");

	//parse argument Bool
	if (arg_encrypted_requests_disabled){
		obj->objs[3] = arg_encrypted_requests_disabled;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "encrypted_requests_disabled");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument Bool
	if (arg_call_requests_disabled){
		obj->objs[4] = arg_call_requests_disabled;
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 1;
	strcpy(obj->objs[4]->name, "call_requests_disabled");
		flagsv[nflags-1] |= (1 << 1);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_account_getSavedRingtones(long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_getSavedRingtones");
	int i;
	obj->id = 0xe1902288;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_account_saveRingtone(InputDocument arg_id, Bool arg_unsave)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_saveRingtone");
	int i;
	obj->id = 0x3dea5b03;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputDocument
	if (arg_id){
		obj->objs[0] = arg_id;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "id");
	}


	//parse argument Bool
	if (arg_unsave){
		obj->objs[1] = arg_unsave;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "unsave");
	}

	return obj;
}

tlo_t * tl_account_uploadRingtone(InputFile arg_file, const char * arg_file_name, const char * arg_mime_type)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_uploadRingtone");
	int i;
	obj->id = 0x831a83a2;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputFile
	if (arg_file){
		obj->objs[0] = arg_file;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "file");
	}


	//parse argument string
	if (arg_file_name){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_file_name, strlen(arg_file_name));
		strcpy(obj->objs[1]->name, "file_name");
	}


	//parse argument string
	if (arg_mime_type){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_mime_type, strlen(arg_mime_type));
		strcpy(obj->objs[2]->name, "mime_type");
	}

	return obj;
}

tlo_t * tl_account_updateEmojiStatus(EmojiStatus arg_emoji_status)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_updateEmojiStatus");
	int i;
	obj->id = 0xfbd3de6b;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument EmojiStatus
	if (arg_emoji_status){
		obj->objs[0] = arg_emoji_status;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "emoji_status");
	}

	return obj;
}

tlo_t * tl_account_getDefaultEmojiStatuses(long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_getDefaultEmojiStatuses");
	int i;
	obj->id = 0xd6753386;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_account_getRecentEmojiStatuses(long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_getRecentEmojiStatuses");
	int i;
	obj->id = 0x0f578105;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_account_clearRecentEmojiStatuses()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_clearRecentEmojiStatuses");
	int i;
	obj->id = 0x18201aae;
	return obj;
}

tlo_t * tl_account_reorderUsernames(const char * *arg_order, int len_arg_order)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_reorderUsernames");
	int i;
	obj->id = 0xef500eab;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<string>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "order");
	if (arg_order){
		for(i=0; i<len_arg_order; ++i){
			int len = strlen(arg_order[i]);
			buf_t b = buf_add((ui8_t *)arg_order[i], len);
			buf_cat(obj->objs[0]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_account_toggleUsername(const char * arg_username, Bool arg_active)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_toggleUsername");
	int i;
	obj->id = 0x58d6b376;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_username){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_username, strlen(arg_username));
		strcpy(obj->objs[0]->name, "username");
	}


	//parse argument Bool
	if (arg_active){
		obj->objs[1] = arg_active;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "active");
	}

	return obj;
}

tlo_t * tl_account_getDefaultProfilePhotoEmojis(long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_getDefaultProfilePhotoEmojis");
	int i;
	obj->id = 0xe2750328;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_account_getDefaultGroupPhotoEmojis(long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_getDefaultGroupPhotoEmojis");
	int i;
	obj->id = 0x915860ae;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_account_getAutoSaveSettings()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_getAutoSaveSettings");
	int i;
	obj->id = 0xadcbbcda;
	return obj;
}

tlo_t * tl_account_saveAutoSaveSettings(bool arg_users, bool arg_chats, bool arg_broadcasts, InputPeer arg_peer, AutoSaveSettings arg_settings)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_saveAutoSaveSettings");
	int i;
	obj->id = 0xd69b8361;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_users);
	strcpy(obj->objs[1]->name, "users");
	if (arg_users)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_chats);
	strcpy(obj->objs[2]->name, "chats");
	if (arg_chats)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_broadcasts);
	strcpy(obj->objs[3]->name, "broadcasts");
	if (arg_broadcasts)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[4] = arg_peer;
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 3;
	strcpy(obj->objs[4]->name, "peer");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument AutoSaveSettings
	if (arg_settings){
		obj->objs[5] = arg_settings;
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
	strcpy(obj->objs[5]->name, "settings");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_account_deleteAutoSaveExceptions()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_deleteAutoSaveExceptions");
	int i;
	obj->id = 0x53bc0020;
	return obj;
}

tlo_t * tl_account_invalidateSignInCodes(const char * *arg_codes, int len_arg_codes)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_invalidateSignInCodes");
	int i;
	obj->id = 0xca8ae8ba;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<string>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "codes");
	if (arg_codes){
		for(i=0; i<len_arg_codes; ++i){
			int len = strlen(arg_codes[i]);
			buf_t b = buf_add((ui8_t *)arg_codes[i], len);
			buf_cat(obj->objs[0]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_account_updateColor(bool arg_for_profile, int arg_color, long arg_background_emoji_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_updateColor");
	int i;
	obj->id = 0x7cefa15d;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_for_profile);
	strcpy(obj->objs[1]->name, "for_profile");
	if (arg_for_profile)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 2;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_color);
	strcpy(obj->objs[2]->name, "color");
	if (arg_color)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_background_emoji_id);
	strcpy(obj->objs[3]->name, "background_emoji_id");
	if (arg_background_emoji_id)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_account_getDefaultBackgroundEmojis(long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_getDefaultBackgroundEmojis");
	int i;
	obj->id = 0xa60ab9ce;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_account_getChannelDefaultEmojiStatuses(long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_getChannelDefaultEmojiStatuses");
	int i;
	obj->id = 0x7727a7d5;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_account_getChannelRestrictedStatusEmojis(long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_getChannelRestrictedStatusEmojis");
	int i;
	obj->id = 0x35a9e0d5;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_account_updateBusinessWorkHours(BusinessWorkHours arg_business_work_hours)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_updateBusinessWorkHours");
	int i;
	obj->id = 0x4b00e066;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument BusinessWorkHours
	if (arg_business_work_hours){
		obj->objs[1] = arg_business_work_hours;
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "business_work_hours");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_account_updateBusinessLocation(InputGeoPoint arg_geo_point, const char * arg_address)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_updateBusinessLocation");
	int i;
	obj->id = 0x9e6b131a;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputGeoPoint
	if (arg_geo_point){
		obj->objs[1] = arg_geo_point;
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 1;
	strcpy(obj->objs[1]->name, "geo_point");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument string
	if (arg_address){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_address, strlen(arg_address));
		strcpy(obj->objs[2]->name, "address");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_account_updateBusinessGreetingMessage(InputBusinessGreetingMessage arg_message)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_updateBusinessGreetingMessage");
	int i;
	obj->id = 0x66cdafc4;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputBusinessGreetingMessage
	if (arg_message){
		obj->objs[1] = arg_message;
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "message");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_account_updateBusinessAwayMessage(InputBusinessAwayMessage arg_message)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_updateBusinessAwayMessage");
	int i;
	obj->id = 0xa26a7fa5;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputBusinessAwayMessage
	if (arg_message){
		obj->objs[1] = arg_message;
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "message");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_account_updateConnectedBot(bool arg_can_reply, bool arg_deleted, InputUser arg_bot, InputBusinessBotRecipients arg_recipients)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_updateConnectedBot");
	int i;
	obj->id = 0x43d8521d;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_can_reply);
	strcpy(obj->objs[1]->name, "can_reply");
	if (arg_can_reply)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_deleted);
	strcpy(obj->objs[2]->name, "deleted");
	if (arg_deleted)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument InputUser
	if (arg_bot){
		obj->objs[3] = arg_bot;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "bot");
	}


	//parse argument InputBusinessBotRecipients
	if (arg_recipients){
		obj->objs[4] = arg_recipients;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "recipients");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_account_getConnectedBots()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_getConnectedBots");
	int i;
	obj->id = 0x4ea4c80f;
	return obj;
}

tlo_t * tl_account_getBotBusinessConnection(const char * arg_connection_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_getBotBusinessConnection");
	int i;
	obj->id = 0x76a86270;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_connection_id){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_connection_id, strlen(arg_connection_id));
		strcpy(obj->objs[0]->name, "connection_id");
	}

	return obj;
}

tlo_t * tl_account_updateBusinessIntro(InputBusinessIntro arg_intro)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_updateBusinessIntro");
	int i;
	obj->id = 0xa614d034;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputBusinessIntro
	if (arg_intro){
		obj->objs[1] = arg_intro;
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "intro");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_account_toggleConnectedBotPaused(InputPeer arg_peer, Bool arg_paused)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_toggleConnectedBotPaused");
	int i;
	obj->id = 0x646e1097;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument Bool
	if (arg_paused){
		obj->objs[1] = arg_paused;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "paused");
	}

	return obj;
}

tlo_t * tl_account_disablePeerConnectedBot(InputPeer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_disablePeerConnectedBot");
	int i;
	obj->id = 0x5e437ed9;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}

	return obj;
}

tlo_t * tl_account_updateBirthday(Birthday arg_birthday)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_updateBirthday");
	int i;
	obj->id = 0xcc6e0c11;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument Birthday
	if (arg_birthday){
		obj->objs[1] = arg_birthday;
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "birthday");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_account_createBusinessChatLink(InputBusinessChatLink arg_link)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_createBusinessChatLink");
	int i;
	obj->id = 0x8851e68e;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputBusinessChatLink
	if (arg_link){
		obj->objs[0] = arg_link;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "link");
	}

	return obj;
}

tlo_t * tl_account_editBusinessChatLink(const char * arg_slug, InputBusinessChatLink arg_link)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_editBusinessChatLink");
	int i;
	obj->id = 0x8c3410af;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_slug){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_slug, strlen(arg_slug));
		strcpy(obj->objs[0]->name, "slug");
	}


	//parse argument InputBusinessChatLink
	if (arg_link){
		obj->objs[1] = arg_link;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "link");
	}

	return obj;
}

tlo_t * tl_account_deleteBusinessChatLink(const char * arg_slug)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_deleteBusinessChatLink");
	int i;
	obj->id = 0x60073674;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_slug){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_slug, strlen(arg_slug));
		strcpy(obj->objs[0]->name, "slug");
	}

	return obj;
}

tlo_t * tl_account_getBusinessChatLinks()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_getBusinessChatLinks");
	int i;
	obj->id = 0x6f70dde1;
	return obj;
}

tlo_t * tl_account_resolveBusinessChatLink(const char * arg_slug)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_resolveBusinessChatLink");
	int i;
	obj->id = 0x5492e5ee;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_slug){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_slug, strlen(arg_slug));
		strcpy(obj->objs[0]->name, "slug");
	}

	return obj;
}

tlo_t * tl_account_updatePersonalChannel(InputChannel arg_channel)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_updatePersonalChannel");
	int i;
	obj->id = 0xd94305e0;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}

	return obj;
}

tlo_t * tl_account_toggleSponsoredMessages(Bool arg_enabled)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_toggleSponsoredMessages");
	int i;
	obj->id = 0xb9d9a38d;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Bool
	if (arg_enabled){
		obj->objs[0] = arg_enabled;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "enabled");
	}

	return obj;
}

tlo_t * tl_account_getReactionsNotifySettings()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_getReactionsNotifySettings");
	int i;
	obj->id = 0x06dd654c;
	return obj;
}

tlo_t * tl_account_setReactionsNotifySettings(ReactionsNotifySettings arg_settings)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "account_setReactionsNotifySettings");
	int i;
	obj->id = 0x316ce548;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument ReactionsNotifySettings
	if (arg_settings){
		obj->objs[0] = arg_settings;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "settings");
	}

	return obj;
}

tlo_t * tl_users_getUsers(InputUser *arg_id, int len_arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "users_getUsers");
	int i;
	obj->id = 0x0d91a548;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<InputUser>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_id[i]->id);
			buf_cat(obj->objs[0]->value, arg_id[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_users_getFullUser(InputUser arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "users_getFullUser");
	int i;
	obj->id = 0xb60f5918;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputUser
	if (arg_id){
		obj->objs[0] = arg_id;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "id");
	}

	return obj;
}

tlo_t * tl_users_setSecureValueErrors(InputUser arg_id, SecureValueError *arg_errors, int len_arg_errors)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "users_setSecureValueErrors");
	int i;
	obj->id = 0x90c894b5;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputUser
	if (arg_id){
		obj->objs[0] = arg_id;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "id");
	}


	//parse argument Vector<SecureValueError>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "errors");
	if (arg_errors){
		for(i=0; i<len_arg_errors; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_errors[i]->id);
			buf_cat(obj->objs[1]->value, arg_errors[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_users_getIsPremiumRequiredToContact(InputUser *arg_id, int len_arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "users_getIsPremiumRequiredToContact");
	int i;
	obj->id = 0xa622aa10;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<InputUser>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_id[i]->id);
			buf_cat(obj->objs[0]->value, arg_id[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_contacts_getContactIDs(long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_getContactIDs");
	int i;
	obj->id = 0x7adc669d;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_contacts_getStatuses()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_getStatuses");
	int i;
	obj->id = 0xc4a353ee;
	return obj;
}

tlo_t * tl_contacts_getContacts(long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_getContacts");
	int i;
	obj->id = 0x5dd69e12;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_contacts_importContacts(InputContact *arg_contacts, int len_arg_contacts)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_importContacts");
	int i;
	obj->id = 0x2c800be5;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<InputContact>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "contacts");
	if (arg_contacts){
		for(i=0; i<len_arg_contacts; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_contacts[i]->id);
			buf_cat(obj->objs[0]->value, arg_contacts[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_contacts_deleteContacts(InputUser *arg_id, int len_arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_deleteContacts");
	int i;
	obj->id = 0x096a0e00;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<InputUser>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_id[i]->id);
			buf_cat(obj->objs[0]->value, arg_id[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_contacts_deleteByPhones(const char * *arg_phones, int len_arg_phones)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_deleteByPhones");
	int i;
	obj->id = 0x1013fd9e;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<string>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "phones");
	if (arg_phones){
		for(i=0; i<len_arg_phones; ++i){
			int len = strlen(arg_phones[i]);
			buf_t b = buf_add((ui8_t *)arg_phones[i], len);
			buf_cat(obj->objs[0]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_contacts_block(bool arg_my_stories_from, InputPeer arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_block");
	int i;
	obj->id = 0x2e2e8734;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_my_stories_from);
	strcpy(obj->objs[1]->name, "my_stories_from");
	if (arg_my_stories_from)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputPeer
	if (arg_id){
		obj->objs[2] = arg_id;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "id");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_contacts_unblock(bool arg_my_stories_from, InputPeer arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_unblock");
	int i;
	obj->id = 0xb550d328;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_my_stories_from);
	strcpy(obj->objs[1]->name, "my_stories_from");
	if (arg_my_stories_from)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputPeer
	if (arg_id){
		obj->objs[2] = arg_id;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "id");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_contacts_getBlocked(bool arg_my_stories_from, int arg_offset, int arg_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_getBlocked");
	int i;
	obj->id = 0x9a868f80;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_my_stories_from);
	strcpy(obj->objs[1]->name, "my_stories_from");
	if (arg_my_stories_from)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_offset);
	strcpy(obj->objs[2]->name, "offset");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[3]->name, "limit");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_contacts_search(const char * arg_q, int arg_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_search");
	int i;
	obj->id = 0x11f812d8;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_q){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_q, strlen(arg_q));
		strcpy(obj->objs[0]->name, "q");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[1]->name, "limit");
	return obj;
}

tlo_t * tl_contacts_resolveUsername(const char * arg_username)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_resolveUsername");
	int i;
	obj->id = 0xf93ccba3;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_username){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_username, strlen(arg_username));
		strcpy(obj->objs[0]->name, "username");
	}

	return obj;
}

tlo_t * tl_contacts_getTopPeers(bool arg_correspondents, bool arg_bots_pm, bool arg_bots_inline, bool arg_phone_calls, bool arg_forward_users, bool arg_forward_chats, bool arg_groups, bool arg_channels, bool arg_bots_app, int arg_offset, int arg_limit, long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_getTopPeers");
	int i;
	obj->id = 0x973478b6;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 13;
	obj->objs = 
		(tlo_t **)MALLOC(13 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_correspondents);
	strcpy(obj->objs[1]->name, "correspondents");
	if (arg_correspondents)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_bots_pm);
	strcpy(obj->objs[2]->name, "bots_pm");
	if (arg_bots_pm)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_bots_inline);
	strcpy(obj->objs[3]->name, "bots_inline");
	if (arg_bots_inline)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 3;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_phone_calls);
	strcpy(obj->objs[4]->name, "phone_calls");
	if (arg_phone_calls)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 4;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_forward_users);
	strcpy(obj->objs[5]->name, "forward_users");
	if (arg_forward_users)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument true
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 5;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_forward_chats);
	strcpy(obj->objs[6]->name, "forward_chats");
	if (arg_forward_chats)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument true
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 10;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_groups);
	strcpy(obj->objs[7]->name, "groups");
	if (arg_groups)
		flagsv[nflags-1] |= (1 << 10);

	//parse argument true
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 15;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_channels);
	strcpy(obj->objs[8]->name, "channels");
	if (arg_channels)
		flagsv[nflags-1] |= (1 << 15);

	//parse argument true
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 1;
	obj->objs[9]->flag_bit = 16;
	obj->objs[9]->type = TYPE_INT;
	obj->objs[9]->value = 
		buf_add_ui32(arg_bots_app);
	strcpy(obj->objs[9]->name, "bots_app");
	if (arg_bots_app)
		flagsv[nflags-1] |= (1 << 16);

	//parse argument int
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 0;
	obj->objs[10]->flag_bit = 0;
	obj->objs[10]->type = TYPE_INT;
	obj->objs[10]->value = 
		buf_add_ui32(arg_offset);
	strcpy(obj->objs[10]->name, "offset");

	//parse argument int
	obj->objs[11] = NEW(tlo_t, return NULL);
	obj->objs[11]->flag_num = 0;
	obj->objs[11]->flag_bit = 0;
	obj->objs[11]->type = TYPE_INT;
	obj->objs[11]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[11]->name, "limit");

	//parse argument long
	obj->objs[12] = NEW(tlo_t, return NULL);
	obj->objs[12]->flag_num = 0;
	obj->objs[12]->flag_bit = 0;
	obj->objs[12]->type = TYPE_LONG;
	obj->objs[12]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[12]->name, "hash");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_contacts_resetTopPeerRating(TopPeerCategory arg_category, InputPeer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_resetTopPeerRating");
	int i;
	obj->id = 0x1ae373ac;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument TopPeerCategory
	if (arg_category){
		obj->objs[0] = arg_category;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "category");
	}


	//parse argument InputPeer
	if (arg_peer){
		obj->objs[1] = arg_peer;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "peer");
	}

	return obj;
}

tlo_t * tl_contacts_resetSaved()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_resetSaved");
	int i;
	obj->id = 0x879537f1;
	return obj;
}

tlo_t * tl_contacts_getSaved()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_getSaved");
	int i;
	obj->id = 0x82f1e39f;
	return obj;
}

tlo_t * tl_contacts_toggleTopPeers(Bool arg_enabled)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_toggleTopPeers");
	int i;
	obj->id = 0x8514bdda;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Bool
	if (arg_enabled){
		obj->objs[0] = arg_enabled;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "enabled");
	}

	return obj;
}

tlo_t * tl_contacts_addContact(bool arg_add_phone_privacy_exception, InputUser arg_id, const char * arg_first_name, const char * arg_last_name, const char * arg_phone)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_addContact");
	int i;
	obj->id = 0xe8f463d0;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_add_phone_privacy_exception);
	strcpy(obj->objs[1]->name, "add_phone_privacy_exception");
	if (arg_add_phone_privacy_exception)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputUser
	if (arg_id){
		obj->objs[2] = arg_id;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "id");
	}


	//parse argument string
	if (arg_first_name){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_first_name, strlen(arg_first_name));
		strcpy(obj->objs[3]->name, "first_name");
	}


	//parse argument string
	if (arg_last_name){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_last_name, strlen(arg_last_name));
		strcpy(obj->objs[4]->name, "last_name");
	}


	//parse argument string
	if (arg_phone){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_phone, strlen(arg_phone));
		strcpy(obj->objs[5]->name, "phone");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_contacts_acceptContact(InputUser arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_acceptContact");
	int i;
	obj->id = 0xf831a20f;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputUser
	if (arg_id){
		obj->objs[0] = arg_id;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "id");
	}

	return obj;
}

tlo_t * tl_contacts_getLocated(bool arg_background, InputGeoPoint arg_geo_point, int arg_self_expires)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_getLocated");
	int i;
	obj->id = 0xd348bc44;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_background);
	strcpy(obj->objs[1]->name, "background");
	if (arg_background)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument InputGeoPoint
	if (arg_geo_point){
		obj->objs[2] = arg_geo_point;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "geo_point");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_self_expires);
	strcpy(obj->objs[3]->name, "self_expires");
	if (arg_self_expires)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_contacts_blockFromReplies(bool arg_delete_message, bool arg_delete_history, bool arg_report_spam, int arg_msg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_blockFromReplies");
	int i;
	obj->id = 0x29a8962c;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_delete_message);
	strcpy(obj->objs[1]->name, "delete_message");
	if (arg_delete_message)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_delete_history);
	strcpy(obj->objs[2]->name, "delete_history");
	if (arg_delete_history)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_report_spam);
	strcpy(obj->objs[3]->name, "report_spam");
	if (arg_report_spam)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[4]->name, "msg_id");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_contacts_resolvePhone(const char * arg_phone)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_resolvePhone");
	int i;
	obj->id = 0x8af94344;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_phone){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_phone, strlen(arg_phone));
		strcpy(obj->objs[0]->name, "phone");
	}

	return obj;
}

tlo_t * tl_contacts_exportContactToken()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_exportContactToken");
	int i;
	obj->id = 0xf8654027;
	return obj;
}

tlo_t * tl_contacts_importContactToken(const char * arg_token)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_importContactToken");
	int i;
	obj->id = 0x13005788;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_token){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_token, strlen(arg_token));
		strcpy(obj->objs[0]->name, "token");
	}

	return obj;
}

tlo_t * tl_contacts_editCloseFriends(long *arg_id, int len_arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_editCloseFriends");
	int i;
	obj->id = 0xba6705f0;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<long>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			buf_t b = buf_add_ui64(arg_id[i]);
			buf_cat(obj->objs[0]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_contacts_setBlocked(bool arg_my_stories_from, InputPeer *arg_id, int len_arg_id, int arg_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_setBlocked");
	int i;
	obj->id = 0x94c65c76;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_my_stories_from);
	strcpy(obj->objs[1]->name, "my_stories_from");
	if (arg_my_stories_from)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument Vector<InputPeer>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_id[i]->id);
			buf_cat(obj->objs[2]->value, arg_id[i]->value);
		}
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[3]->name, "limit");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_contacts_getBirthdays()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "contacts_getBirthdays");
	int i;
	obj->id = 0xdaeda864;
	return obj;
}

tlo_t * tl_messages_getMessages(InputMessage *arg_id, int len_arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getMessages");
	int i;
	obj->id = 0x63c66506;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<InputMessage>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_id[i]->id);
			buf_cat(obj->objs[0]->value, arg_id[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_messages_getDialogs(bool arg_exclude_pinned, int arg_folder_id, int arg_offset_date, int arg_offset_id, InputPeer arg_offset_peer, int arg_limit, long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getDialogs");
	int i;
	obj->id = 0xa0f4cb4f;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_exclude_pinned);
	strcpy(obj->objs[1]->name, "exclude_pinned");
	if (arg_exclude_pinned)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_folder_id);
	strcpy(obj->objs[2]->name, "folder_id");
	if (arg_folder_id)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_offset_date);
	strcpy(obj->objs[3]->name, "offset_date");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_offset_id);
	strcpy(obj->objs[4]->name, "offset_id");

	//parse argument InputPeer
	if (arg_offset_peer){
		obj->objs[5] = arg_offset_peer;
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
	strcpy(obj->objs[5]->name, "offset_peer");
	}


	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[6]->name, "limit");

	//parse argument long
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_LONG;
	obj->objs[7]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[7]->name, "hash");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_getHistory(InputPeer arg_peer, int arg_offset_id, int arg_offset_date, int arg_add_offset, int arg_limit, int arg_max_id, int arg_min_id, long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getHistory");
	int i;
	obj->id = 0x4423e6c5;
	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_offset_id);
	strcpy(obj->objs[1]->name, "offset_id");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_offset_date);
	strcpy(obj->objs[2]->name, "offset_date");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_add_offset);
	strcpy(obj->objs[3]->name, "add_offset");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[4]->name, "limit");

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_max_id);
	strcpy(obj->objs[5]->name, "max_id");

	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_min_id);
	strcpy(obj->objs[6]->name, "min_id");

	//parse argument long
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_LONG;
	obj->objs[7]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[7]->name, "hash");
	return obj;
}

tlo_t * tl_messages_search(InputPeer arg_peer, const char * arg_q, InputPeer arg_from_id, InputPeer arg_saved_peer_id, Reaction *arg_saved_reaction, int len_arg_saved_reaction, int arg_top_msg_id, MessagesFilter arg_filter, int arg_min_date, int arg_max_date, int arg_offset_id, int arg_add_offset, int arg_limit, int arg_max_id, int arg_min_id, long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_search");
	int i;
	obj->id = 0x29ee847a;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 16;
	obj->objs = 
		(tlo_t **)MALLOC(16 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[1] = arg_peer;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "peer");
	}


	//parse argument string
	if (arg_q){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_q, strlen(arg_q));
		strcpy(obj->objs[2]->name, "q");
	}


	//parse argument InputPeer
	if (arg_from_id){
		obj->objs[3] = arg_from_id;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "from_id");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument InputPeer
	if (arg_saved_peer_id){
		obj->objs[4] = arg_saved_peer_id;
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 2;
	strcpy(obj->objs[4]->name, "saved_peer_id");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument Vector<Reaction>
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 3;
	obj->objs[5]->type = TYPE_VECTOR;
	strcpy(obj->objs[5]->name, "saved_reaction");
	if (arg_saved_reaction){
		for(i=0; i<len_arg_saved_reaction; ++i){
			obj->objs[5]->value = buf_add_ui32(arg_saved_reaction[i]->id);
			buf_cat(obj->objs[5]->value, arg_saved_reaction[i]->value);
		}
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 1;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_top_msg_id);
	strcpy(obj->objs[6]->name, "top_msg_id");
	if (arg_top_msg_id)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument MessagesFilter
	if (arg_filter){
		obj->objs[7] = arg_filter;
		obj->objs[7]->flag_num = 0;
		obj->objs[7]->flag_bit = 0;
	strcpy(obj->objs[7]->name, "filter");
	}


	//parse argument int
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 0;
	obj->objs[8]->flag_bit = 0;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_min_date);
	strcpy(obj->objs[8]->name, "min_date");

	//parse argument int
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 0;
	obj->objs[9]->flag_bit = 0;
	obj->objs[9]->type = TYPE_INT;
	obj->objs[9]->value = 
		buf_add_ui32(arg_max_date);
	strcpy(obj->objs[9]->name, "max_date");

	//parse argument int
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 0;
	obj->objs[10]->flag_bit = 0;
	obj->objs[10]->type = TYPE_INT;
	obj->objs[10]->value = 
		buf_add_ui32(arg_offset_id);
	strcpy(obj->objs[10]->name, "offset_id");

	//parse argument int
	obj->objs[11] = NEW(tlo_t, return NULL);
	obj->objs[11]->flag_num = 0;
	obj->objs[11]->flag_bit = 0;
	obj->objs[11]->type = TYPE_INT;
	obj->objs[11]->value = 
		buf_add_ui32(arg_add_offset);
	strcpy(obj->objs[11]->name, "add_offset");

	//parse argument int
	obj->objs[12] = NEW(tlo_t, return NULL);
	obj->objs[12]->flag_num = 0;
	obj->objs[12]->flag_bit = 0;
	obj->objs[12]->type = TYPE_INT;
	obj->objs[12]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[12]->name, "limit");

	//parse argument int
	obj->objs[13] = NEW(tlo_t, return NULL);
	obj->objs[13]->flag_num = 0;
	obj->objs[13]->flag_bit = 0;
	obj->objs[13]->type = TYPE_INT;
	obj->objs[13]->value = 
		buf_add_ui32(arg_max_id);
	strcpy(obj->objs[13]->name, "max_id");

	//parse argument int
	obj->objs[14] = NEW(tlo_t, return NULL);
	obj->objs[14]->flag_num = 0;
	obj->objs[14]->flag_bit = 0;
	obj->objs[14]->type = TYPE_INT;
	obj->objs[14]->value = 
		buf_add_ui32(arg_min_id);
	strcpy(obj->objs[14]->name, "min_id");

	//parse argument long
	obj->objs[15] = NEW(tlo_t, return NULL);
	obj->objs[15]->flag_num = 0;
	obj->objs[15]->flag_bit = 0;
	obj->objs[15]->type = TYPE_LONG;
	obj->objs[15]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[15]->name, "hash");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_readHistory(InputPeer arg_peer, int arg_max_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_readHistory");
	int i;
	obj->id = 0x0e306d3a;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_max_id);
	strcpy(obj->objs[1]->name, "max_id");
	return obj;
}

tlo_t * tl_messages_deleteHistory(bool arg_just_clear, bool arg_revoke, InputPeer arg_peer, int arg_max_id, int arg_min_date, int arg_max_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_deleteHistory");
	int i;
	obj->id = 0xb08f922a;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_just_clear);
	strcpy(obj->objs[1]->name, "just_clear");
	if (arg_just_clear)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_revoke);
	strcpy(obj->objs[2]->name, "revoke");
	if (arg_revoke)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[3] = arg_peer;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "peer");
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_max_id);
	strcpy(obj->objs[4]->name, "max_id");

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 2;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_min_date);
	strcpy(obj->objs[5]->name, "min_date");
	if (arg_min_date)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 3;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_max_date);
	strcpy(obj->objs[6]->name, "max_date");
	if (arg_max_date)
		flagsv[nflags-1] |= (1 << 3);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_deleteMessages(bool arg_revoke, int *arg_id, int len_arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_deleteMessages");
	int i;
	obj->id = 0xe58e95d2;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_revoke);
	strcpy(obj->objs[1]->name, "revoke");
	if (arg_revoke)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument Vector<int>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			buf_t b = buf_add_ui32(arg_id[i]);
			buf_cat(obj->objs[2]->value, b);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_receivedMessages(int arg_max_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_receivedMessages");
	int i;
	obj->id = 0x05a954c0;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_max_id);
	strcpy(obj->objs[0]->name, "max_id");
	return obj;
}

tlo_t * tl_messages_setTyping(InputPeer arg_peer, int arg_top_msg_id, SendMessageAction arg_action)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_setTyping");
	int i;
	obj->id = 0x58943ee2;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[1] = arg_peer;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "peer");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_top_msg_id);
	strcpy(obj->objs[2]->name, "top_msg_id");
	if (arg_top_msg_id)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument SendMessageAction
	if (arg_action){
		obj->objs[3] = arg_action;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "action");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_sendMessage(bool arg_no_webpage, bool arg_silent, bool arg_background, bool arg_clear_draft, bool arg_noforwards, bool arg_update_stickersets_order, bool arg_invert_media, InputPeer arg_peer, InputReplyTo arg_reply_to, const char * arg_message, long arg_random_id, ReplyMarkup arg_reply_markup, MessageEntity *arg_entities, int len_arg_entities, int arg_schedule_date, InputPeer arg_send_as, InputQuickReplyShortcut arg_quick_reply_shortcut, long arg_effect)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_sendMessage");
	int i;
	obj->id = 0x983f9745;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 18;
	obj->objs = 
		(tlo_t **)MALLOC(18 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_no_webpage);
	strcpy(obj->objs[1]->name, "no_webpage");
	if (arg_no_webpage)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 5;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_silent);
	strcpy(obj->objs[2]->name, "silent");
	if (arg_silent)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 6;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_background);
	strcpy(obj->objs[3]->name, "background");
	if (arg_background)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 7;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_clear_draft);
	strcpy(obj->objs[4]->name, "clear_draft");
	if (arg_clear_draft)
		flagsv[nflags-1] |= (1 << 7);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 14;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_noforwards);
	strcpy(obj->objs[5]->name, "noforwards");
	if (arg_noforwards)
		flagsv[nflags-1] |= (1 << 14);

	//parse argument true
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 15;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_update_stickersets_order);
	strcpy(obj->objs[6]->name, "update_stickersets_order");
	if (arg_update_stickersets_order)
		flagsv[nflags-1] |= (1 << 15);

	//parse argument true
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 16;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_invert_media);
	strcpy(obj->objs[7]->name, "invert_media");
	if (arg_invert_media)
		flagsv[nflags-1] |= (1 << 16);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[8] = arg_peer;
		obj->objs[8]->flag_num = 0;
		obj->objs[8]->flag_bit = 0;
	strcpy(obj->objs[8]->name, "peer");
	}


	//parse argument InputReplyTo
	if (arg_reply_to){
		obj->objs[9] = arg_reply_to;
		obj->objs[9]->flag_num = 1;
		obj->objs[9]->flag_bit = 0;
	strcpy(obj->objs[9]->name, "reply_to");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_message){
		obj->objs[10] = NEW(tlo_t, return NULL);
		obj->objs[10]->flag_num = 0;
		obj->objs[10]->flag_bit = 0;
		obj->objs[10]->type = TYPE_STRING;
		obj->objs[10]->value = 
			buf_add((ui8_t *)arg_message, strlen(arg_message));
		strcpy(obj->objs[10]->name, "message");
	}


	//parse argument long
	obj->objs[11] = NEW(tlo_t, return NULL);
	obj->objs[11]->flag_num = 0;
	obj->objs[11]->flag_bit = 0;
	obj->objs[11]->type = TYPE_LONG;
	obj->objs[11]->value = 
		buf_add_ui64(arg_random_id);
	strcpy(obj->objs[11]->name, "random_id");

	//parse argument ReplyMarkup
	if (arg_reply_markup){
		obj->objs[12] = arg_reply_markup;
		obj->objs[12]->flag_num = 1;
		obj->objs[12]->flag_bit = 2;
	strcpy(obj->objs[12]->name, "reply_markup");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument Vector<MessageEntity>
	obj->objs[13] = NEW(tlo_t, return NULL);
	obj->objs[13]->flag_num = 1;
	obj->objs[13]->flag_bit = 3;
	obj->objs[13]->type = TYPE_VECTOR;
	strcpy(obj->objs[13]->name, "entities");
	if (arg_entities){
		for(i=0; i<len_arg_entities; ++i){
			obj->objs[13]->value = buf_add_ui32(arg_entities[i]->id);
			buf_cat(obj->objs[13]->value, arg_entities[i]->value);
		}
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument int
	obj->objs[14] = NEW(tlo_t, return NULL);
	obj->objs[14]->flag_num = 1;
	obj->objs[14]->flag_bit = 10;
	obj->objs[14]->type = TYPE_INT;
	obj->objs[14]->value = 
		buf_add_ui32(arg_schedule_date);
	strcpy(obj->objs[14]->name, "schedule_date");
	if (arg_schedule_date)
		flagsv[nflags-1] |= (1 << 10);

	//parse argument InputPeer
	if (arg_send_as){
		obj->objs[15] = arg_send_as;
		obj->objs[15]->flag_num = 1;
		obj->objs[15]->flag_bit = 13;
	strcpy(obj->objs[15]->name, "send_as");
		flagsv[nflags-1] |= (1 << 13);
	}


	//parse argument InputQuickReplyShortcut
	if (arg_quick_reply_shortcut){
		obj->objs[16] = arg_quick_reply_shortcut;
		obj->objs[16]->flag_num = 1;
		obj->objs[16]->flag_bit = 17;
	strcpy(obj->objs[16]->name, "quick_reply_shortcut");
		flagsv[nflags-1] |= (1 << 17);
	}


	//parse argument long
	obj->objs[17] = NEW(tlo_t, return NULL);
	obj->objs[17]->flag_num = 1;
	obj->objs[17]->flag_bit = 18;
	obj->objs[17]->type = TYPE_LONG;
	obj->objs[17]->value = 
		buf_add_ui64(arg_effect);
	strcpy(obj->objs[17]->name, "effect");
	if (arg_effect)
		flagsv[nflags-1] |= (1 << 18);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_sendMedia(bool arg_silent, bool arg_background, bool arg_clear_draft, bool arg_noforwards, bool arg_update_stickersets_order, bool arg_invert_media, InputPeer arg_peer, InputReplyTo arg_reply_to, InputMedia arg_media, const char * arg_message, long arg_random_id, ReplyMarkup arg_reply_markup, MessageEntity *arg_entities, int len_arg_entities, int arg_schedule_date, InputPeer arg_send_as, InputQuickReplyShortcut arg_quick_reply_shortcut, long arg_effect)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_sendMedia");
	int i;
	obj->id = 0x7852834e;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 18;
	obj->objs = 
		(tlo_t **)MALLOC(18 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 5;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_silent);
	strcpy(obj->objs[1]->name, "silent");
	if (arg_silent)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 6;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_background);
	strcpy(obj->objs[2]->name, "background");
	if (arg_background)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 7;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_clear_draft);
	strcpy(obj->objs[3]->name, "clear_draft");
	if (arg_clear_draft)
		flagsv[nflags-1] |= (1 << 7);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 14;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_noforwards);
	strcpy(obj->objs[4]->name, "noforwards");
	if (arg_noforwards)
		flagsv[nflags-1] |= (1 << 14);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 15;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_update_stickersets_order);
	strcpy(obj->objs[5]->name, "update_stickersets_order");
	if (arg_update_stickersets_order)
		flagsv[nflags-1] |= (1 << 15);

	//parse argument true
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 16;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_invert_media);
	strcpy(obj->objs[6]->name, "invert_media");
	if (arg_invert_media)
		flagsv[nflags-1] |= (1 << 16);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[7] = arg_peer;
		obj->objs[7]->flag_num = 0;
		obj->objs[7]->flag_bit = 0;
	strcpy(obj->objs[7]->name, "peer");
	}


	//parse argument InputReplyTo
	if (arg_reply_to){
		obj->objs[8] = arg_reply_to;
		obj->objs[8]->flag_num = 1;
		obj->objs[8]->flag_bit = 0;
	strcpy(obj->objs[8]->name, "reply_to");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument InputMedia
	if (arg_media){
		obj->objs[9] = arg_media;
		obj->objs[9]->flag_num = 0;
		obj->objs[9]->flag_bit = 0;
	strcpy(obj->objs[9]->name, "media");
	}


	//parse argument string
	if (arg_message){
		obj->objs[10] = NEW(tlo_t, return NULL);
		obj->objs[10]->flag_num = 0;
		obj->objs[10]->flag_bit = 0;
		obj->objs[10]->type = TYPE_STRING;
		obj->objs[10]->value = 
			buf_add((ui8_t *)arg_message, strlen(arg_message));
		strcpy(obj->objs[10]->name, "message");
	}


	//parse argument long
	obj->objs[11] = NEW(tlo_t, return NULL);
	obj->objs[11]->flag_num = 0;
	obj->objs[11]->flag_bit = 0;
	obj->objs[11]->type = TYPE_LONG;
	obj->objs[11]->value = 
		buf_add_ui64(arg_random_id);
	strcpy(obj->objs[11]->name, "random_id");

	//parse argument ReplyMarkup
	if (arg_reply_markup){
		obj->objs[12] = arg_reply_markup;
		obj->objs[12]->flag_num = 1;
		obj->objs[12]->flag_bit = 2;
	strcpy(obj->objs[12]->name, "reply_markup");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument Vector<MessageEntity>
	obj->objs[13] = NEW(tlo_t, return NULL);
	obj->objs[13]->flag_num = 1;
	obj->objs[13]->flag_bit = 3;
	obj->objs[13]->type = TYPE_VECTOR;
	strcpy(obj->objs[13]->name, "entities");
	if (arg_entities){
		for(i=0; i<len_arg_entities; ++i){
			obj->objs[13]->value = buf_add_ui32(arg_entities[i]->id);
			buf_cat(obj->objs[13]->value, arg_entities[i]->value);
		}
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument int
	obj->objs[14] = NEW(tlo_t, return NULL);
	obj->objs[14]->flag_num = 1;
	obj->objs[14]->flag_bit = 10;
	obj->objs[14]->type = TYPE_INT;
	obj->objs[14]->value = 
		buf_add_ui32(arg_schedule_date);
	strcpy(obj->objs[14]->name, "schedule_date");
	if (arg_schedule_date)
		flagsv[nflags-1] |= (1 << 10);

	//parse argument InputPeer
	if (arg_send_as){
		obj->objs[15] = arg_send_as;
		obj->objs[15]->flag_num = 1;
		obj->objs[15]->flag_bit = 13;
	strcpy(obj->objs[15]->name, "send_as");
		flagsv[nflags-1] |= (1 << 13);
	}


	//parse argument InputQuickReplyShortcut
	if (arg_quick_reply_shortcut){
		obj->objs[16] = arg_quick_reply_shortcut;
		obj->objs[16]->flag_num = 1;
		obj->objs[16]->flag_bit = 17;
	strcpy(obj->objs[16]->name, "quick_reply_shortcut");
		flagsv[nflags-1] |= (1 << 17);
	}


	//parse argument long
	obj->objs[17] = NEW(tlo_t, return NULL);
	obj->objs[17]->flag_num = 1;
	obj->objs[17]->flag_bit = 18;
	obj->objs[17]->type = TYPE_LONG;
	obj->objs[17]->value = 
		buf_add_ui64(arg_effect);
	strcpy(obj->objs[17]->name, "effect");
	if (arg_effect)
		flagsv[nflags-1] |= (1 << 18);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_forwardMessages(bool arg_silent, bool arg_background, bool arg_with_my_score, bool arg_drop_author, bool arg_drop_media_captions, bool arg_noforwards, InputPeer arg_from_peer, int *arg_id, int len_arg_id, long *arg_random_id, int len_arg_random_id, InputPeer arg_to_peer, int arg_top_msg_id, int arg_schedule_date, InputPeer arg_send_as, InputQuickReplyShortcut arg_quick_reply_shortcut)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_forwardMessages");
	int i;
	obj->id = 0xd5039208;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 15;
	obj->objs = 
		(tlo_t **)MALLOC(15 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 5;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_silent);
	strcpy(obj->objs[1]->name, "silent");
	if (arg_silent)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 6;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_background);
	strcpy(obj->objs[2]->name, "background");
	if (arg_background)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 8;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_with_my_score);
	strcpy(obj->objs[3]->name, "with_my_score");
	if (arg_with_my_score)
		flagsv[nflags-1] |= (1 << 8);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 11;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_drop_author);
	strcpy(obj->objs[4]->name, "drop_author");
	if (arg_drop_author)
		flagsv[nflags-1] |= (1 << 11);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 12;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_drop_media_captions);
	strcpy(obj->objs[5]->name, "drop_media_captions");
	if (arg_drop_media_captions)
		flagsv[nflags-1] |= (1 << 12);

	//parse argument true
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 14;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_noforwards);
	strcpy(obj->objs[6]->name, "noforwards");
	if (arg_noforwards)
		flagsv[nflags-1] |= (1 << 14);

	//parse argument InputPeer
	if (arg_from_peer){
		obj->objs[7] = arg_from_peer;
		obj->objs[7]->flag_num = 0;
		obj->objs[7]->flag_bit = 0;
	strcpy(obj->objs[7]->name, "from_peer");
	}


	//parse argument Vector<int>
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 0;
	obj->objs[8]->flag_bit = 0;
	obj->objs[8]->type = TYPE_VECTOR;
	strcpy(obj->objs[8]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			buf_t b = buf_add_ui32(arg_id[i]);
			buf_cat(obj->objs[8]->value, b);
		}
	}


	//parse argument Vector<long>
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 0;
	obj->objs[9]->flag_bit = 0;
	obj->objs[9]->type = TYPE_VECTOR;
	strcpy(obj->objs[9]->name, "random_id");
	if (arg_random_id){
		for(i=0; i<len_arg_random_id; ++i){
			buf_t b = buf_add_ui64(arg_random_id[i]);
			buf_cat(obj->objs[9]->value, b);
		}
	}


	//parse argument InputPeer
	if (arg_to_peer){
		obj->objs[10] = arg_to_peer;
		obj->objs[10]->flag_num = 0;
		obj->objs[10]->flag_bit = 0;
	strcpy(obj->objs[10]->name, "to_peer");
	}


	//parse argument int
	obj->objs[11] = NEW(tlo_t, return NULL);
	obj->objs[11]->flag_num = 1;
	obj->objs[11]->flag_bit = 9;
	obj->objs[11]->type = TYPE_INT;
	obj->objs[11]->value = 
		buf_add_ui32(arg_top_msg_id);
	strcpy(obj->objs[11]->name, "top_msg_id");
	if (arg_top_msg_id)
		flagsv[nflags-1] |= (1 << 9);

	//parse argument int
	obj->objs[12] = NEW(tlo_t, return NULL);
	obj->objs[12]->flag_num = 1;
	obj->objs[12]->flag_bit = 10;
	obj->objs[12]->type = TYPE_INT;
	obj->objs[12]->value = 
		buf_add_ui32(arg_schedule_date);
	strcpy(obj->objs[12]->name, "schedule_date");
	if (arg_schedule_date)
		flagsv[nflags-1] |= (1 << 10);

	//parse argument InputPeer
	if (arg_send_as){
		obj->objs[13] = arg_send_as;
		obj->objs[13]->flag_num = 1;
		obj->objs[13]->flag_bit = 13;
	strcpy(obj->objs[13]->name, "send_as");
		flagsv[nflags-1] |= (1 << 13);
	}


	//parse argument InputQuickReplyShortcut
	if (arg_quick_reply_shortcut){
		obj->objs[14] = arg_quick_reply_shortcut;
		obj->objs[14]->flag_num = 1;
		obj->objs[14]->flag_bit = 17;
	strcpy(obj->objs[14]->name, "quick_reply_shortcut");
		flagsv[nflags-1] |= (1 << 17);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_reportSpam(InputPeer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_reportSpam");
	int i;
	obj->id = 0xcf1592db;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}

	return obj;
}

tlo_t * tl_messages_getPeerSettings(InputPeer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getPeerSettings");
	int i;
	obj->id = 0xefd9a6a2;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}

	return obj;
}

tlo_t * tl_messages_report(InputPeer arg_peer, int *arg_id, int len_arg_id, unsigned char * arg_option, int len_arg_option, const char * arg_message)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_report");
	int i;
	obj->id = 0xfc78af9b;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument Vector<int>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			buf_t b = buf_add_ui32(arg_id[i]);
			buf_cat(obj->objs[1]->value, b);
		}
	}


	//parse argument bytes
	if (arg_option){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_BYTES;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_option, len_arg_option);
		strcpy(obj->objs[2]->name, "option");
	}


	//parse argument string
	if (arg_message){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_message, strlen(arg_message));
		strcpy(obj->objs[3]->name, "message");
	}

	return obj;
}

tlo_t * tl_messages_getChats(long *arg_id, int len_arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getChats");
	int i;
	obj->id = 0x49e9528f;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<long>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			buf_t b = buf_add_ui64(arg_id[i]);
			buf_cat(obj->objs[0]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_messages_getFullChat(long arg_chat_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getFullChat");
	int i;
	obj->id = 0xaeb00b34;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_chat_id);
	strcpy(obj->objs[0]->name, "chat_id");
	return obj;
}

tlo_t * tl_messages_editChatTitle(long arg_chat_id, const char * arg_title)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_editChatTitle");
	int i;
	obj->id = 0x73783ffd;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_chat_id);
	strcpy(obj->objs[0]->name, "chat_id");

	//parse argument string
	if (arg_title){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[1]->name, "title");
	}

	return obj;
}

tlo_t * tl_messages_editChatPhoto(long arg_chat_id, InputChatPhoto arg_photo)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_editChatPhoto");
	int i;
	obj->id = 0x35ddd674;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_chat_id);
	strcpy(obj->objs[0]->name, "chat_id");

	//parse argument InputChatPhoto
	if (arg_photo){
		obj->objs[1] = arg_photo;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "photo");
	}

	return obj;
}

tlo_t * tl_messages_addChatUser(long arg_chat_id, InputUser arg_user_id, int arg_fwd_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_addChatUser");
	int i;
	obj->id = 0xcbc6d107;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_chat_id);
	strcpy(obj->objs[0]->name, "chat_id");

	//parse argument InputUser
	if (arg_user_id){
		obj->objs[1] = arg_user_id;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "user_id");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_fwd_limit);
	strcpy(obj->objs[2]->name, "fwd_limit");
	return obj;
}

tlo_t * tl_messages_deleteChatUser(bool arg_revoke_history, long arg_chat_id, InputUser arg_user_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_deleteChatUser");
	int i;
	obj->id = 0xa2185cab;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_revoke_history);
	strcpy(obj->objs[1]->name, "revoke_history");
	if (arg_revoke_history)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_chat_id);
	strcpy(obj->objs[2]->name, "chat_id");

	//parse argument InputUser
	if (arg_user_id){
		obj->objs[3] = arg_user_id;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "user_id");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_createChat(InputUser *arg_users, int len_arg_users, const char * arg_title, int arg_ttl_period)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_createChat");
	int i;
	obj->id = 0x92ceddd4;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument Vector<InputUser>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[1]->value, arg_users[i]->value);
		}
	}


	//parse argument string
	if (arg_title){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[2]->name, "title");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_ttl_period);
	strcpy(obj->objs[3]->name, "ttl_period");
	if (arg_ttl_period)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_getDhConfig(int arg_version, int arg_random_length)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getDhConfig");
	int i;
	obj->id = 0x26cf8950;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_version);
	strcpy(obj->objs[0]->name, "version");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_random_length);
	strcpy(obj->objs[1]->name, "random_length");
	return obj;
}

tlo_t * tl_messages_requestEncryption(InputUser arg_user_id, int arg_random_id, unsigned char * arg_g_a, int len_arg_g_a)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_requestEncryption");
	int i;
	obj->id = 0xf64daf43;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputUser
	if (arg_user_id){
		obj->objs[0] = arg_user_id;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "user_id");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_random_id);
	strcpy(obj->objs[1]->name, "random_id");

	//parse argument bytes
	if (arg_g_a){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_BYTES;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_g_a, len_arg_g_a);
		strcpy(obj->objs[2]->name, "g_a");
	}

	return obj;
}

tlo_t * tl_messages_acceptEncryption(InputEncryptedChat arg_peer, unsigned char * arg_g_b, int len_arg_g_b, long arg_key_fingerprint)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_acceptEncryption");
	int i;
	obj->id = 0x3dbc0415;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputEncryptedChat
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument bytes
	if (arg_g_b){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_g_b, len_arg_g_b);
		strcpy(obj->objs[1]->name, "g_b");
	}


	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_key_fingerprint);
	strcpy(obj->objs[2]->name, "key_fingerprint");
	return obj;
}

tlo_t * tl_messages_discardEncryption(bool arg_delete_history, int arg_chat_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_discardEncryption");
	int i;
	obj->id = 0xf393aea0;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_delete_history);
	strcpy(obj->objs[1]->name, "delete_history");
	if (arg_delete_history)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_chat_id);
	strcpy(obj->objs[2]->name, "chat_id");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_setEncryptedTyping(InputEncryptedChat arg_peer, Bool arg_typing)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_setEncryptedTyping");
	int i;
	obj->id = 0x791451ed;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputEncryptedChat
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument Bool
	if (arg_typing){
		obj->objs[1] = arg_typing;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "typing");
	}

	return obj;
}

tlo_t * tl_messages_readEncryptedHistory(InputEncryptedChat arg_peer, int arg_max_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_readEncryptedHistory");
	int i;
	obj->id = 0x7f4b690a;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputEncryptedChat
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_max_date);
	strcpy(obj->objs[1]->name, "max_date");
	return obj;
}

tlo_t * tl_messages_sendEncrypted(bool arg_silent, InputEncryptedChat arg_peer, long arg_random_id, unsigned char * arg_data, int len_arg_data)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_sendEncrypted");
	int i;
	obj->id = 0x44fa7a15;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_silent);
	strcpy(obj->objs[1]->name, "silent");
	if (arg_silent)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputEncryptedChat
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_random_id);
	strcpy(obj->objs[3]->name, "random_id");

	//parse argument bytes
	if (arg_data){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_BYTES;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_data, len_arg_data);
		strcpy(obj->objs[4]->name, "data");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_sendEncryptedFile(bool arg_silent, InputEncryptedChat arg_peer, long arg_random_id, unsigned char * arg_data, int len_arg_data, InputEncryptedFile arg_file)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_sendEncryptedFile");
	int i;
	obj->id = 0x5559481d;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_silent);
	strcpy(obj->objs[1]->name, "silent");
	if (arg_silent)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputEncryptedChat
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_random_id);
	strcpy(obj->objs[3]->name, "random_id");

	//parse argument bytes
	if (arg_data){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_BYTES;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_data, len_arg_data);
		strcpy(obj->objs[4]->name, "data");
	}


	//parse argument InputEncryptedFile
	if (arg_file){
		obj->objs[5] = arg_file;
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
	strcpy(obj->objs[5]->name, "file");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_sendEncryptedService(InputEncryptedChat arg_peer, long arg_random_id, unsigned char * arg_data, int len_arg_data)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_sendEncryptedService");
	int i;
	obj->id = 0x32d439a4;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputEncryptedChat
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_random_id);
	strcpy(obj->objs[1]->name, "random_id");

	//parse argument bytes
	if (arg_data){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_BYTES;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_data, len_arg_data);
		strcpy(obj->objs[2]->name, "data");
	}

	return obj;
}

tlo_t * tl_messages_receivedQueue(int arg_max_qts)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_receivedQueue");
	int i;
	obj->id = 0x55a5bb66;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_max_qts);
	strcpy(obj->objs[0]->name, "max_qts");
	return obj;
}

tlo_t * tl_messages_reportEncryptedSpam(InputEncryptedChat arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_reportEncryptedSpam");
	int i;
	obj->id = 0x4b0c8c0f;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputEncryptedChat
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}

	return obj;
}

tlo_t * tl_messages_readMessageContents(int *arg_id, int len_arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_readMessageContents");
	int i;
	obj->id = 0x36a73f77;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<int>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			buf_t b = buf_add_ui32(arg_id[i]);
			buf_cat(obj->objs[0]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_messages_getStickers(const char * arg_emoticon, long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getStickers");
	int i;
	obj->id = 0xd5a5d3a1;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_emoticon){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_emoticon, strlen(arg_emoticon));
		strcpy(obj->objs[0]->name, "emoticon");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[1]->name, "hash");
	return obj;
}

tlo_t * tl_messages_getAllStickers(long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getAllStickers");
	int i;
	obj->id = 0xb8a0a1a8;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_messages_getWebPagePreview(const char * arg_message, MessageEntity *arg_entities, int len_arg_entities)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getWebPagePreview");
	int i;
	obj->id = 0x8b68b0cc;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_message){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_message, strlen(arg_message));
		strcpy(obj->objs[1]->name, "message");
	}


	//parse argument Vector<MessageEntity>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 3;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "entities");
	if (arg_entities){
		for(i=0; i<len_arg_entities; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_entities[i]->id);
			buf_cat(obj->objs[2]->value, arg_entities[i]->value);
		}
		flagsv[nflags-1] |= (1 << 3);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_exportChatInvite(bool arg_legacy_revoke_permanent, bool arg_request_needed, InputPeer arg_peer, int arg_expire_date, int arg_usage_limit, const char * arg_title, StarsSubscriptionPricing arg_subscription_pricing)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_exportChatInvite");
	int i;
	obj->id = 0xa455de90;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 2;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_legacy_revoke_permanent);
	strcpy(obj->objs[1]->name, "legacy_revoke_permanent");
	if (arg_legacy_revoke_permanent)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 3;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_request_needed);
	strcpy(obj->objs[2]->name, "request_needed");
	if (arg_request_needed)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[3] = arg_peer;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "peer");
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_expire_date);
	strcpy(obj->objs[4]->name, "expire_date");
	if (arg_expire_date)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 1;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_usage_limit);
	strcpy(obj->objs[5]->name, "usage_limit");
	if (arg_usage_limit)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument string
	if (arg_title){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 4;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[6]->name, "title");
		flagsv[nflags-1] |= (1 << 4);
	}


	//parse argument StarsSubscriptionPricing
	if (arg_subscription_pricing){
		obj->objs[7] = arg_subscription_pricing;
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 5;
	strcpy(obj->objs[7]->name, "subscription_pricing");
		flagsv[nflags-1] |= (1 << 5);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_checkChatInvite(const char * arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_checkChatInvite");
	int i;
	obj->id = 0x3eadb1bb;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_hash){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_hash, strlen(arg_hash));
		strcpy(obj->objs[0]->name, "hash");
	}

	return obj;
}

tlo_t * tl_messages_importChatInvite(const char * arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_importChatInvite");
	int i;
	obj->id = 0x6c50051c;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_hash){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_hash, strlen(arg_hash));
		strcpy(obj->objs[0]->name, "hash");
	}

	return obj;
}

tlo_t * tl_messages_getStickerSet(InputStickerSet arg_stickerset, int arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getStickerSet");
	int i;
	obj->id = 0xc8a0ec74;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputStickerSet
	if (arg_stickerset){
		obj->objs[0] = arg_stickerset;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "stickerset");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_hash);
	strcpy(obj->objs[1]->name, "hash");
	return obj;
}

tlo_t * tl_messages_installStickerSet(InputStickerSet arg_stickerset, Bool arg_archived)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_installStickerSet");
	int i;
	obj->id = 0xc78fe460;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputStickerSet
	if (arg_stickerset){
		obj->objs[0] = arg_stickerset;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "stickerset");
	}


	//parse argument Bool
	if (arg_archived){
		obj->objs[1] = arg_archived;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "archived");
	}

	return obj;
}

tlo_t * tl_messages_uninstallStickerSet(InputStickerSet arg_stickerset)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_uninstallStickerSet");
	int i;
	obj->id = 0xf96e55de;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputStickerSet
	if (arg_stickerset){
		obj->objs[0] = arg_stickerset;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "stickerset");
	}

	return obj;
}

tlo_t * tl_messages_startBot(InputUser arg_bot, InputPeer arg_peer, long arg_random_id, const char * arg_start_param)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_startBot");
	int i;
	obj->id = 0xe6df7378;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument InputUser
	if (arg_bot){
		obj->objs[0] = arg_bot;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "bot");
	}


	//parse argument InputPeer
	if (arg_peer){
		obj->objs[1] = arg_peer;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "peer");
	}


	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_random_id);
	strcpy(obj->objs[2]->name, "random_id");

	//parse argument string
	if (arg_start_param){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_start_param, strlen(arg_start_param));
		strcpy(obj->objs[3]->name, "start_param");
	}

	return obj;
}

tlo_t * tl_messages_getMessagesViews(InputPeer arg_peer, int *arg_id, int len_arg_id, Bool arg_increment)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getMessagesViews");
	int i;
	obj->id = 0x5784d3e1;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument Vector<int>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			buf_t b = buf_add_ui32(arg_id[i]);
			buf_cat(obj->objs[1]->value, b);
		}
	}


	//parse argument Bool
	if (arg_increment){
		obj->objs[2] = arg_increment;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "increment");
	}

	return obj;
}

tlo_t * tl_messages_editChatAdmin(long arg_chat_id, InputUser arg_user_id, Bool arg_is_admin)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_editChatAdmin");
	int i;
	obj->id = 0xa85bd1c2;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_chat_id);
	strcpy(obj->objs[0]->name, "chat_id");

	//parse argument InputUser
	if (arg_user_id){
		obj->objs[1] = arg_user_id;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "user_id");
	}


	//parse argument Bool
	if (arg_is_admin){
		obj->objs[2] = arg_is_admin;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "is_admin");
	}

	return obj;
}

tlo_t * tl_messages_migrateChat(long arg_chat_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_migrateChat");
	int i;
	obj->id = 0xa2875319;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_chat_id);
	strcpy(obj->objs[0]->name, "chat_id");
	return obj;
}

tlo_t * tl_messages_searchGlobal(bool arg_broadcasts_only, int arg_folder_id, const char * arg_q, MessagesFilter arg_filter, int arg_min_date, int arg_max_date, int arg_offset_rate, InputPeer arg_offset_peer, int arg_offset_id, int arg_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_searchGlobal");
	int i;
	obj->id = 0x4bc6589a;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 11;
	obj->objs = 
		(tlo_t **)MALLOC(11 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_broadcasts_only);
	strcpy(obj->objs[1]->name, "broadcasts_only");
	if (arg_broadcasts_only)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_folder_id);
	strcpy(obj->objs[2]->name, "folder_id");
	if (arg_folder_id)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument string
	if (arg_q){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_q, strlen(arg_q));
		strcpy(obj->objs[3]->name, "q");
	}


	//parse argument MessagesFilter
	if (arg_filter){
		obj->objs[4] = arg_filter;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "filter");
	}


	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_min_date);
	strcpy(obj->objs[5]->name, "min_date");

	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_max_date);
	strcpy(obj->objs[6]->name, "max_date");

	//parse argument int
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_offset_rate);
	strcpy(obj->objs[7]->name, "offset_rate");

	//parse argument InputPeer
	if (arg_offset_peer){
		obj->objs[8] = arg_offset_peer;
		obj->objs[8]->flag_num = 0;
		obj->objs[8]->flag_bit = 0;
	strcpy(obj->objs[8]->name, "offset_peer");
	}


	//parse argument int
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 0;
	obj->objs[9]->flag_bit = 0;
	obj->objs[9]->type = TYPE_INT;
	obj->objs[9]->value = 
		buf_add_ui32(arg_offset_id);
	strcpy(obj->objs[9]->name, "offset_id");

	//parse argument int
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 0;
	obj->objs[10]->flag_bit = 0;
	obj->objs[10]->type = TYPE_INT;
	obj->objs[10]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[10]->name, "limit");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_reorderStickerSets(bool arg_masks, bool arg_emojis, long *arg_order, int len_arg_order)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_reorderStickerSets");
	int i;
	obj->id = 0x78337739;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_masks);
	strcpy(obj->objs[1]->name, "masks");
	if (arg_masks)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_emojis);
	strcpy(obj->objs[2]->name, "emojis");
	if (arg_emojis)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument Vector<long>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "order");
	if (arg_order){
		for(i=0; i<len_arg_order; ++i){
			buf_t b = buf_add_ui64(arg_order[i]);
			buf_cat(obj->objs[3]->value, b);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_getDocumentByHash(unsigned char * arg_sha256, int len_arg_sha256, long arg_size, const char * arg_mime_type)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getDocumentByHash");
	int i;
	obj->id = 0xb1f2061f;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument bytes
	if (arg_sha256){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_BYTES;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_sha256, len_arg_sha256);
		strcpy(obj->objs[0]->name, "sha256");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_size);
	strcpy(obj->objs[1]->name, "size");

	//parse argument string
	if (arg_mime_type){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_mime_type, strlen(arg_mime_type));
		strcpy(obj->objs[2]->name, "mime_type");
	}

	return obj;
}

tlo_t * tl_messages_getSavedGifs(long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getSavedGifs");
	int i;
	obj->id = 0x5cf09635;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_messages_saveGif(InputDocument arg_id, Bool arg_unsave)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_saveGif");
	int i;
	obj->id = 0x327a30cb;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputDocument
	if (arg_id){
		obj->objs[0] = arg_id;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "id");
	}


	//parse argument Bool
	if (arg_unsave){
		obj->objs[1] = arg_unsave;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "unsave");
	}

	return obj;
}

tlo_t * tl_messages_getInlineBotResults(InputUser arg_bot, InputPeer arg_peer, InputGeoPoint arg_geo_point, const char * arg_query, const char * arg_offset)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getInlineBotResults");
	int i;
	obj->id = 0x514e999d;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputUser
	if (arg_bot){
		obj->objs[1] = arg_bot;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "bot");
	}


	//parse argument InputPeer
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//parse argument InputGeoPoint
	if (arg_geo_point){
		obj->objs[3] = arg_geo_point;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "geo_point");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_query){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_query, strlen(arg_query));
		strcpy(obj->objs[4]->name, "query");
	}


	//parse argument string
	if (arg_offset){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_offset, strlen(arg_offset));
		strcpy(obj->objs[5]->name, "offset");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_setInlineBotResults(bool arg_gallery, bool arg_private, long arg_query_id, InputBotInlineResult *arg_results, int len_arg_results, int arg_cache_time, const char * arg_next_offset, InlineBotSwitchPM arg_switch_pm, InlineBotWebView arg_switch_webview)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_setInlineBotResults");
	int i;
	obj->id = 0xbb12a419;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_gallery);
	strcpy(obj->objs[1]->name, "gallery");
	if (arg_gallery)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_private);
	strcpy(obj->objs[2]->name, "private");
	if (arg_private)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_query_id);
	strcpy(obj->objs[3]->name, "query_id");

	//parse argument Vector<InputBotInlineResult>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "results");
	if (arg_results){
		for(i=0; i<len_arg_results; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_results[i]->id);
			buf_cat(obj->objs[4]->value, arg_results[i]->value);
		}
	}


	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_cache_time);
	strcpy(obj->objs[5]->name, "cache_time");

	//parse argument string
	if (arg_next_offset){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 2;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_next_offset, strlen(arg_next_offset));
		strcpy(obj->objs[6]->name, "next_offset");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument InlineBotSwitchPM
	if (arg_switch_pm){
		obj->objs[7] = arg_switch_pm;
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 3;
	strcpy(obj->objs[7]->name, "switch_pm");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument InlineBotWebView
	if (arg_switch_webview){
		obj->objs[8] = arg_switch_webview;
		obj->objs[8]->flag_num = 1;
		obj->objs[8]->flag_bit = 4;
	strcpy(obj->objs[8]->name, "switch_webview");
		flagsv[nflags-1] |= (1 << 4);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_sendInlineBotResult(bool arg_silent, bool arg_background, bool arg_clear_draft, bool arg_hide_via, InputPeer arg_peer, InputReplyTo arg_reply_to, long arg_random_id, long arg_query_id, const char * arg_id, int arg_schedule_date, InputPeer arg_send_as, InputQuickReplyShortcut arg_quick_reply_shortcut)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_sendInlineBotResult");
	int i;
	obj->id = 0x3ebee86a;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 13;
	obj->objs = 
		(tlo_t **)MALLOC(13 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 5;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_silent);
	strcpy(obj->objs[1]->name, "silent");
	if (arg_silent)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 6;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_background);
	strcpy(obj->objs[2]->name, "background");
	if (arg_background)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 7;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_clear_draft);
	strcpy(obj->objs[3]->name, "clear_draft");
	if (arg_clear_draft)
		flagsv[nflags-1] |= (1 << 7);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 11;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_hide_via);
	strcpy(obj->objs[4]->name, "hide_via");
	if (arg_hide_via)
		flagsv[nflags-1] |= (1 << 11);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[5] = arg_peer;
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
	strcpy(obj->objs[5]->name, "peer");
	}


	//parse argument InputReplyTo
	if (arg_reply_to){
		obj->objs[6] = arg_reply_to;
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 0;
	strcpy(obj->objs[6]->name, "reply_to");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument long
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_LONG;
	obj->objs[7]->value = 
		buf_add_ui64(arg_random_id);
	strcpy(obj->objs[7]->name, "random_id");

	//parse argument long
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 0;
	obj->objs[8]->flag_bit = 0;
	obj->objs[8]->type = TYPE_LONG;
	obj->objs[8]->value = 
		buf_add_ui64(arg_query_id);
	strcpy(obj->objs[8]->name, "query_id");

	//parse argument string
	if (arg_id){
		obj->objs[9] = NEW(tlo_t, return NULL);
		obj->objs[9]->flag_num = 0;
		obj->objs[9]->flag_bit = 0;
		obj->objs[9]->type = TYPE_STRING;
		obj->objs[9]->value = 
			buf_add((ui8_t *)arg_id, strlen(arg_id));
		strcpy(obj->objs[9]->name, "id");
	}


	//parse argument int
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 1;
	obj->objs[10]->flag_bit = 10;
	obj->objs[10]->type = TYPE_INT;
	obj->objs[10]->value = 
		buf_add_ui32(arg_schedule_date);
	strcpy(obj->objs[10]->name, "schedule_date");
	if (arg_schedule_date)
		flagsv[nflags-1] |= (1 << 10);

	//parse argument InputPeer
	if (arg_send_as){
		obj->objs[11] = arg_send_as;
		obj->objs[11]->flag_num = 1;
		obj->objs[11]->flag_bit = 13;
	strcpy(obj->objs[11]->name, "send_as");
		flagsv[nflags-1] |= (1 << 13);
	}


	//parse argument InputQuickReplyShortcut
	if (arg_quick_reply_shortcut){
		obj->objs[12] = arg_quick_reply_shortcut;
		obj->objs[12]->flag_num = 1;
		obj->objs[12]->flag_bit = 17;
	strcpy(obj->objs[12]->name, "quick_reply_shortcut");
		flagsv[nflags-1] |= (1 << 17);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_getMessageEditData(InputPeer arg_peer, int arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getMessageEditData");
	int i;
	obj->id = 0xfda68d36;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[1]->name, "id");
	return obj;
}

tlo_t * tl_messages_editMessage(bool arg_no_webpage, bool arg_invert_media, InputPeer arg_peer, int arg_id, const char * arg_message, InputMedia arg_media, ReplyMarkup arg_reply_markup, MessageEntity *arg_entities, int len_arg_entities, int arg_schedule_date, int arg_quick_reply_shortcut_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_editMessage");
	int i;
	obj->id = 0xdfd14005;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 11;
	obj->objs = 
		(tlo_t **)MALLOC(11 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_no_webpage);
	strcpy(obj->objs[1]->name, "no_webpage");
	if (arg_no_webpage)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 16;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_invert_media);
	strcpy(obj->objs[2]->name, "invert_media");
	if (arg_invert_media)
		flagsv[nflags-1] |= (1 << 16);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[3] = arg_peer;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "peer");
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[4]->name, "id");

	//parse argument string
	if (arg_message){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 11;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_message, strlen(arg_message));
		strcpy(obj->objs[5]->name, "message");
		flagsv[nflags-1] |= (1 << 11);
	}


	//parse argument InputMedia
	if (arg_media){
		obj->objs[6] = arg_media;
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 14;
	strcpy(obj->objs[6]->name, "media");
		flagsv[nflags-1] |= (1 << 14);
	}


	//parse argument ReplyMarkup
	if (arg_reply_markup){
		obj->objs[7] = arg_reply_markup;
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 2;
	strcpy(obj->objs[7]->name, "reply_markup");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument Vector<MessageEntity>
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 3;
	obj->objs[8]->type = TYPE_VECTOR;
	strcpy(obj->objs[8]->name, "entities");
	if (arg_entities){
		for(i=0; i<len_arg_entities; ++i){
			obj->objs[8]->value = buf_add_ui32(arg_entities[i]->id);
			buf_cat(obj->objs[8]->value, arg_entities[i]->value);
		}
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument int
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 1;
	obj->objs[9]->flag_bit = 15;
	obj->objs[9]->type = TYPE_INT;
	obj->objs[9]->value = 
		buf_add_ui32(arg_schedule_date);
	strcpy(obj->objs[9]->name, "schedule_date");
	if (arg_schedule_date)
		flagsv[nflags-1] |= (1 << 15);

	//parse argument int
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 1;
	obj->objs[10]->flag_bit = 17;
	obj->objs[10]->type = TYPE_INT;
	obj->objs[10]->value = 
		buf_add_ui32(arg_quick_reply_shortcut_id);
	strcpy(obj->objs[10]->name, "quick_reply_shortcut_id");
	if (arg_quick_reply_shortcut_id)
		flagsv[nflags-1] |= (1 << 17);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_editInlineBotMessage(bool arg_no_webpage, bool arg_invert_media, InputBotInlineMessageID arg_id, const char * arg_message, InputMedia arg_media, ReplyMarkup arg_reply_markup, MessageEntity *arg_entities, int len_arg_entities)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_editInlineBotMessage");
	int i;
	obj->id = 0x83557dba;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_no_webpage);
	strcpy(obj->objs[1]->name, "no_webpage");
	if (arg_no_webpage)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 16;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_invert_media);
	strcpy(obj->objs[2]->name, "invert_media");
	if (arg_invert_media)
		flagsv[nflags-1] |= (1 << 16);

	//parse argument InputBotInlineMessageID
	if (arg_id){
		obj->objs[3] = arg_id;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "id");
	}


	//parse argument string
	if (arg_message){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 11;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_message, strlen(arg_message));
		strcpy(obj->objs[4]->name, "message");
		flagsv[nflags-1] |= (1 << 11);
	}


	//parse argument InputMedia
	if (arg_media){
		obj->objs[5] = arg_media;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 14;
	strcpy(obj->objs[5]->name, "media");
		flagsv[nflags-1] |= (1 << 14);
	}


	//parse argument ReplyMarkup
	if (arg_reply_markup){
		obj->objs[6] = arg_reply_markup;
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 2;
	strcpy(obj->objs[6]->name, "reply_markup");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument Vector<MessageEntity>
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 3;
	obj->objs[7]->type = TYPE_VECTOR;
	strcpy(obj->objs[7]->name, "entities");
	if (arg_entities){
		for(i=0; i<len_arg_entities; ++i){
			obj->objs[7]->value = buf_add_ui32(arg_entities[i]->id);
			buf_cat(obj->objs[7]->value, arg_entities[i]->value);
		}
		flagsv[nflags-1] |= (1 << 3);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_getBotCallbackAnswer(bool arg_game, InputPeer arg_peer, int arg_msg_id, unsigned char * arg_data, int len_arg_data, InputCheckPasswordSRP arg_password)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getBotCallbackAnswer");
	int i;
	obj->id = 0x9342ca07;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_game);
	strcpy(obj->objs[1]->name, "game");
	if (arg_game)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[3]->name, "msg_id");

	//parse argument bytes
	if (arg_data){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_BYTES;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_data, len_arg_data);
		strcpy(obj->objs[4]->name, "data");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument InputCheckPasswordSRP
	if (arg_password){
		obj->objs[5] = arg_password;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 2;
	strcpy(obj->objs[5]->name, "password");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_setBotCallbackAnswer(bool arg_alert, long arg_query_id, const char * arg_message, const char * arg_url, int arg_cache_time)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_setBotCallbackAnswer");
	int i;
	obj->id = 0xd58f130a;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_alert);
	strcpy(obj->objs[1]->name, "alert");
	if (arg_alert)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_query_id);
	strcpy(obj->objs[2]->name, "query_id");

	//parse argument string
	if (arg_message){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_message, strlen(arg_message));
		strcpy(obj->objs[3]->name, "message");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_url){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 2;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[4]->name, "url");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_cache_time);
	strcpy(obj->objs[5]->name, "cache_time");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_getPeerDialogs(InputDialogPeer *arg_peers, int len_arg_peers)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getPeerDialogs");
	int i;
	obj->id = 0xe470bcfd;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<InputDialogPeer>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "peers");
	if (arg_peers){
		for(i=0; i<len_arg_peers; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_peers[i]->id);
			buf_cat(obj->objs[0]->value, arg_peers[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_messages_saveDraft(bool arg_no_webpage, bool arg_invert_media, InputReplyTo arg_reply_to, InputPeer arg_peer, const char * arg_message, MessageEntity *arg_entities, int len_arg_entities, InputMedia arg_media, long arg_effect)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_saveDraft");
	int i;
	obj->id = 0xd372c5ce;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_no_webpage);
	strcpy(obj->objs[1]->name, "no_webpage");
	if (arg_no_webpage)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 6;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_invert_media);
	strcpy(obj->objs[2]->name, "invert_media");
	if (arg_invert_media)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument InputReplyTo
	if (arg_reply_to){
		obj->objs[3] = arg_reply_to;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 4;
	strcpy(obj->objs[3]->name, "reply_to");
		flagsv[nflags-1] |= (1 << 4);
	}


	//parse argument InputPeer
	if (arg_peer){
		obj->objs[4] = arg_peer;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "peer");
	}


	//parse argument string
	if (arg_message){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_message, strlen(arg_message));
		strcpy(obj->objs[5]->name, "message");
	}


	//parse argument Vector<MessageEntity>
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 3;
	obj->objs[6]->type = TYPE_VECTOR;
	strcpy(obj->objs[6]->name, "entities");
	if (arg_entities){
		for(i=0; i<len_arg_entities; ++i){
			obj->objs[6]->value = buf_add_ui32(arg_entities[i]->id);
			buf_cat(obj->objs[6]->value, arg_entities[i]->value);
		}
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument InputMedia
	if (arg_media){
		obj->objs[7] = arg_media;
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 5;
	strcpy(obj->objs[7]->name, "media");
		flagsv[nflags-1] |= (1 << 5);
	}


	//parse argument long
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 7;
	obj->objs[8]->type = TYPE_LONG;
	obj->objs[8]->value = 
		buf_add_ui64(arg_effect);
	strcpy(obj->objs[8]->name, "effect");
	if (arg_effect)
		flagsv[nflags-1] |= (1 << 7);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_getAllDrafts()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getAllDrafts");
	int i;
	obj->id = 0x6a3f8d65;
	return obj;
}

tlo_t * tl_messages_getFeaturedStickers(long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getFeaturedStickers");
	int i;
	obj->id = 0x64780b14;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_messages_readFeaturedStickers(long *arg_id, int len_arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_readFeaturedStickers");
	int i;
	obj->id = 0x5b118126;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<long>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			buf_t b = buf_add_ui64(arg_id[i]);
			buf_cat(obj->objs[0]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_messages_getRecentStickers(bool arg_attached, long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getRecentStickers");
	int i;
	obj->id = 0x9da9403b;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_attached);
	strcpy(obj->objs[1]->name, "attached");
	if (arg_attached)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[2]->name, "hash");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_saveRecentSticker(bool arg_attached, InputDocument arg_id, Bool arg_unsave)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_saveRecentSticker");
	int i;
	obj->id = 0x392718f8;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_attached);
	strcpy(obj->objs[1]->name, "attached");
	if (arg_attached)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputDocument
	if (arg_id){
		obj->objs[2] = arg_id;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "id");
	}


	//parse argument Bool
	if (arg_unsave){
		obj->objs[3] = arg_unsave;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "unsave");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_clearRecentStickers(bool arg_attached)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_clearRecentStickers");
	int i;
	obj->id = 0x8999602d;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_attached);
	strcpy(obj->objs[1]->name, "attached");
	if (arg_attached)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_getArchivedStickers(bool arg_masks, bool arg_emojis, long arg_offset_id, int arg_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getArchivedStickers");
	int i;
	obj->id = 0x57f17692;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_masks);
	strcpy(obj->objs[1]->name, "masks");
	if (arg_masks)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_emojis);
	strcpy(obj->objs[2]->name, "emojis");
	if (arg_emojis)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_offset_id);
	strcpy(obj->objs[3]->name, "offset_id");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[4]->name, "limit");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_getMaskStickers(long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getMaskStickers");
	int i;
	obj->id = 0x640f82b8;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_messages_getAttachedStickers(InputStickeredMedia arg_media)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getAttachedStickers");
	int i;
	obj->id = 0xcc5b67cc;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputStickeredMedia
	if (arg_media){
		obj->objs[0] = arg_media;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "media");
	}

	return obj;
}

tlo_t * tl_messages_setGameScore(bool arg_edit_message, bool arg_force, InputPeer arg_peer, int arg_id, InputUser arg_user_id, int arg_score)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_setGameScore");
	int i;
	obj->id = 0x8ef8ecc0;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_edit_message);
	strcpy(obj->objs[1]->name, "edit_message");
	if (arg_edit_message)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_force);
	strcpy(obj->objs[2]->name, "force");
	if (arg_force)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[3] = arg_peer;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "peer");
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[4]->name, "id");

	//parse argument InputUser
	if (arg_user_id){
		obj->objs[5] = arg_user_id;
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
	strcpy(obj->objs[5]->name, "user_id");
	}


	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_score);
	strcpy(obj->objs[6]->name, "score");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_setInlineGameScore(bool arg_edit_message, bool arg_force, InputBotInlineMessageID arg_id, InputUser arg_user_id, int arg_score)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_setInlineGameScore");
	int i;
	obj->id = 0x15ad9f64;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_edit_message);
	strcpy(obj->objs[1]->name, "edit_message");
	if (arg_edit_message)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_force);
	strcpy(obj->objs[2]->name, "force");
	if (arg_force)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument InputBotInlineMessageID
	if (arg_id){
		obj->objs[3] = arg_id;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "id");
	}


	//parse argument InputUser
	if (arg_user_id){
		obj->objs[4] = arg_user_id;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "user_id");
	}


	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_score);
	strcpy(obj->objs[5]->name, "score");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_getGameHighScores(InputPeer arg_peer, int arg_id, InputUser arg_user_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getGameHighScores");
	int i;
	obj->id = 0xe822649d;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[1]->name, "id");

	//parse argument InputUser
	if (arg_user_id){
		obj->objs[2] = arg_user_id;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "user_id");
	}

	return obj;
}

tlo_t * tl_messages_getInlineGameHighScores(InputBotInlineMessageID arg_id, InputUser arg_user_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getInlineGameHighScores");
	int i;
	obj->id = 0x0f635e1b;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputBotInlineMessageID
	if (arg_id){
		obj->objs[0] = arg_id;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "id");
	}


	//parse argument InputUser
	if (arg_user_id){
		obj->objs[1] = arg_user_id;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "user_id");
	}

	return obj;
}

tlo_t * tl_messages_getCommonChats(InputUser arg_user_id, long arg_max_id, int arg_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getCommonChats");
	int i;
	obj->id = 0xe40ca104;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputUser
	if (arg_user_id){
		obj->objs[0] = arg_user_id;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "user_id");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_max_id);
	strcpy(obj->objs[1]->name, "max_id");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[2]->name, "limit");
	return obj;
}

tlo_t * tl_messages_getWebPage(const char * arg_url, int arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getWebPage");
	int i;
	obj->id = 0x8d9692a3;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_url){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[0]->name, "url");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_hash);
	strcpy(obj->objs[1]->name, "hash");
	return obj;
}

tlo_t * tl_messages_toggleDialogPin(bool arg_pinned, InputDialogPeer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_toggleDialogPin");
	int i;
	obj->id = 0xa731e257;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_pinned);
	strcpy(obj->objs[1]->name, "pinned");
	if (arg_pinned)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputDialogPeer
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_reorderPinnedDialogs(bool arg_force, int arg_folder_id, InputDialogPeer *arg_order, int len_arg_order)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_reorderPinnedDialogs");
	int i;
	obj->id = 0x3b1adf37;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_force);
	strcpy(obj->objs[1]->name, "force");
	if (arg_force)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_folder_id);
	strcpy(obj->objs[2]->name, "folder_id");

	//parse argument Vector<InputDialogPeer>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "order");
	if (arg_order){
		for(i=0; i<len_arg_order; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_order[i]->id);
			buf_cat(obj->objs[3]->value, arg_order[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_getPinnedDialogs(int arg_folder_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getPinnedDialogs");
	int i;
	obj->id = 0xd6b94df2;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_folder_id);
	strcpy(obj->objs[0]->name, "folder_id");
	return obj;
}

tlo_t * tl_messages_setBotShippingResults(long arg_query_id, const char * arg_error, ShippingOption *arg_shipping_options, int len_arg_shipping_options)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_setBotShippingResults");
	int i;
	obj->id = 0xe5f672fa;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_query_id);
	strcpy(obj->objs[1]->name, "query_id");

	//parse argument string
	if (arg_error){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_error, strlen(arg_error));
		strcpy(obj->objs[2]->name, "error");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument Vector<ShippingOption>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 1;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "shipping_options");
	if (arg_shipping_options){
		for(i=0; i<len_arg_shipping_options; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_shipping_options[i]->id);
			buf_cat(obj->objs[3]->value, arg_shipping_options[i]->value);
		}
		flagsv[nflags-1] |= (1 << 1);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_setBotPrecheckoutResults(bool arg_success, long arg_query_id, const char * arg_error)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_setBotPrecheckoutResults");
	int i;
	obj->id = 0x09c2dd95;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_success);
	strcpy(obj->objs[1]->name, "success");
	if (arg_success)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_query_id);
	strcpy(obj->objs[2]->name, "query_id");

	//parse argument string
	if (arg_error){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_error, strlen(arg_error));
		strcpy(obj->objs[3]->name, "error");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_uploadMedia(const char * arg_business_connection_id, InputPeer arg_peer, InputMedia arg_media)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_uploadMedia");
	int i;
	obj->id = 0x14967978;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_business_connection_id){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_business_connection_id, strlen(arg_business_connection_id));
		strcpy(obj->objs[1]->name, "business_connection_id");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument InputPeer
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//parse argument InputMedia
	if (arg_media){
		obj->objs[3] = arg_media;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "media");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_sendScreenshotNotification(InputPeer arg_peer, InputReplyTo arg_reply_to, long arg_random_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_sendScreenshotNotification");
	int i;
	obj->id = 0xa1405817;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument InputReplyTo
	if (arg_reply_to){
		obj->objs[1] = arg_reply_to;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "reply_to");
	}


	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_random_id);
	strcpy(obj->objs[2]->name, "random_id");
	return obj;
}

tlo_t * tl_messages_getFavedStickers(long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getFavedStickers");
	int i;
	obj->id = 0x04f1aaa9;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_messages_faveSticker(InputDocument arg_id, Bool arg_unfave)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_faveSticker");
	int i;
	obj->id = 0xb9ffc55b;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputDocument
	if (arg_id){
		obj->objs[0] = arg_id;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "id");
	}


	//parse argument Bool
	if (arg_unfave){
		obj->objs[1] = arg_unfave;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "unfave");
	}

	return obj;
}

tlo_t * tl_messages_getUnreadMentions(InputPeer arg_peer, int arg_top_msg_id, int arg_offset_id, int arg_add_offset, int arg_limit, int arg_max_id, int arg_min_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getUnreadMentions");
	int i;
	obj->id = 0xf107e790;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[1] = arg_peer;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "peer");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_top_msg_id);
	strcpy(obj->objs[2]->name, "top_msg_id");
	if (arg_top_msg_id)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_offset_id);
	strcpy(obj->objs[3]->name, "offset_id");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_add_offset);
	strcpy(obj->objs[4]->name, "add_offset");

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[5]->name, "limit");

	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_max_id);
	strcpy(obj->objs[6]->name, "max_id");

	//parse argument int
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_min_id);
	strcpy(obj->objs[7]->name, "min_id");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_readMentions(InputPeer arg_peer, int arg_top_msg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_readMentions");
	int i;
	obj->id = 0x36e5bf4d;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[1] = arg_peer;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "peer");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_top_msg_id);
	strcpy(obj->objs[2]->name, "top_msg_id");
	if (arg_top_msg_id)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_getRecentLocations(InputPeer arg_peer, int arg_limit, long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getRecentLocations");
	int i;
	obj->id = 0x702a40e0;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[1]->name, "limit");

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[2]->name, "hash");
	return obj;
}

tlo_t * tl_messages_sendMultiMedia(bool arg_silent, bool arg_background, bool arg_clear_draft, bool arg_noforwards, bool arg_update_stickersets_order, bool arg_invert_media, InputPeer arg_peer, InputReplyTo arg_reply_to, InputSingleMedia *arg_multi_media, int len_arg_multi_media, int arg_schedule_date, InputPeer arg_send_as, InputQuickReplyShortcut arg_quick_reply_shortcut, long arg_effect)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_sendMultiMedia");
	int i;
	obj->id = 0x37b74355;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 14;
	obj->objs = 
		(tlo_t **)MALLOC(14 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 5;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_silent);
	strcpy(obj->objs[1]->name, "silent");
	if (arg_silent)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 6;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_background);
	strcpy(obj->objs[2]->name, "background");
	if (arg_background)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 7;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_clear_draft);
	strcpy(obj->objs[3]->name, "clear_draft");
	if (arg_clear_draft)
		flagsv[nflags-1] |= (1 << 7);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 14;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_noforwards);
	strcpy(obj->objs[4]->name, "noforwards");
	if (arg_noforwards)
		flagsv[nflags-1] |= (1 << 14);

	//parse argument true
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 15;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_update_stickersets_order);
	strcpy(obj->objs[5]->name, "update_stickersets_order");
	if (arg_update_stickersets_order)
		flagsv[nflags-1] |= (1 << 15);

	//parse argument true
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 16;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_invert_media);
	strcpy(obj->objs[6]->name, "invert_media");
	if (arg_invert_media)
		flagsv[nflags-1] |= (1 << 16);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[7] = arg_peer;
		obj->objs[7]->flag_num = 0;
		obj->objs[7]->flag_bit = 0;
	strcpy(obj->objs[7]->name, "peer");
	}


	//parse argument InputReplyTo
	if (arg_reply_to){
		obj->objs[8] = arg_reply_to;
		obj->objs[8]->flag_num = 1;
		obj->objs[8]->flag_bit = 0;
	strcpy(obj->objs[8]->name, "reply_to");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument Vector<InputSingleMedia>
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 0;
	obj->objs[9]->flag_bit = 0;
	obj->objs[9]->type = TYPE_VECTOR;
	strcpy(obj->objs[9]->name, "multi_media");
	if (arg_multi_media){
		for(i=0; i<len_arg_multi_media; ++i){
			obj->objs[9]->value = buf_add_ui32(arg_multi_media[i]->id);
			buf_cat(obj->objs[9]->value, arg_multi_media[i]->value);
		}
	}


	//parse argument int
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 1;
	obj->objs[10]->flag_bit = 10;
	obj->objs[10]->type = TYPE_INT;
	obj->objs[10]->value = 
		buf_add_ui32(arg_schedule_date);
	strcpy(obj->objs[10]->name, "schedule_date");
	if (arg_schedule_date)
		flagsv[nflags-1] |= (1 << 10);

	//parse argument InputPeer
	if (arg_send_as){
		obj->objs[11] = arg_send_as;
		obj->objs[11]->flag_num = 1;
		obj->objs[11]->flag_bit = 13;
	strcpy(obj->objs[11]->name, "send_as");
		flagsv[nflags-1] |= (1 << 13);
	}


	//parse argument InputQuickReplyShortcut
	if (arg_quick_reply_shortcut){
		obj->objs[12] = arg_quick_reply_shortcut;
		obj->objs[12]->flag_num = 1;
		obj->objs[12]->flag_bit = 17;
	strcpy(obj->objs[12]->name, "quick_reply_shortcut");
		flagsv[nflags-1] |= (1 << 17);
	}


	//parse argument long
	obj->objs[13] = NEW(tlo_t, return NULL);
	obj->objs[13]->flag_num = 1;
	obj->objs[13]->flag_bit = 18;
	obj->objs[13]->type = TYPE_LONG;
	obj->objs[13]->value = 
		buf_add_ui64(arg_effect);
	strcpy(obj->objs[13]->name, "effect");
	if (arg_effect)
		flagsv[nflags-1] |= (1 << 18);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_uploadEncryptedFile(InputEncryptedChat arg_peer, InputEncryptedFile arg_file)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_uploadEncryptedFile");
	int i;
	obj->id = 0x5057c497;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputEncryptedChat
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument InputEncryptedFile
	if (arg_file){
		obj->objs[1] = arg_file;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "file");
	}

	return obj;
}

tlo_t * tl_messages_searchStickerSets(bool arg_exclude_featured, const char * arg_q, long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_searchStickerSets");
	int i;
	obj->id = 0x35705b8a;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_exclude_featured);
	strcpy(obj->objs[1]->name, "exclude_featured");
	if (arg_exclude_featured)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument string
	if (arg_q){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_q, strlen(arg_q));
		strcpy(obj->objs[2]->name, "q");
	}


	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[3]->name, "hash");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_getSplitRanges()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getSplitRanges");
	int i;
	obj->id = 0x1cff7e08;
	return obj;
}

tlo_t * tl_messages_markDialogUnread(bool arg_unread, InputDialogPeer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_markDialogUnread");
	int i;
	obj->id = 0xc286d98f;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_unread);
	strcpy(obj->objs[1]->name, "unread");
	if (arg_unread)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputDialogPeer
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_getDialogUnreadMarks()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getDialogUnreadMarks");
	int i;
	obj->id = 0x22e24e22;
	return obj;
}

tlo_t * tl_messages_clearAllDrafts()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_clearAllDrafts");
	int i;
	obj->id = 0x7e58ee9c;
	return obj;
}

tlo_t * tl_messages_updatePinnedMessage(bool arg_silent, bool arg_unpin, bool arg_pm_oneside, InputPeer arg_peer, int arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_updatePinnedMessage");
	int i;
	obj->id = 0xd2aaf7ec;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_silent);
	strcpy(obj->objs[1]->name, "silent");
	if (arg_silent)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_unpin);
	strcpy(obj->objs[2]->name, "unpin");
	if (arg_unpin)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_pm_oneside);
	strcpy(obj->objs[3]->name, "pm_oneside");
	if (arg_pm_oneside)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[4] = arg_peer;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "peer");
	}


	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[5]->name, "id");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_sendVote(InputPeer arg_peer, int arg_msg_id, unsigned char * *arg_options, int len_arg_options)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_sendVote");
	int i;
	obj->id = 0x10ea6184;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[1]->name, "msg_id");

	//parse argument Vector<bytes>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "options");
	if (arg_options){
		for(i=0; i<len_arg_options; ++i){
			int len = *(int *)(arg_options[i]);
			ui8_t *p = &(arg_options[i][4]);
			buf_t b = buf_add(p, len);
			buf_cat(obj->objs[2]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_messages_getPollResults(InputPeer arg_peer, int arg_msg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getPollResults");
	int i;
	obj->id = 0x73bb643b;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[1]->name, "msg_id");
	return obj;
}

tlo_t * tl_messages_getOnlines(InputPeer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getOnlines");
	int i;
	obj->id = 0x6e2be050;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}

	return obj;
}

tlo_t * tl_messages_editChatAbout(InputPeer arg_peer, const char * arg_about)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_editChatAbout");
	int i;
	obj->id = 0xdef60797;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument string
	if (arg_about){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_about, strlen(arg_about));
		strcpy(obj->objs[1]->name, "about");
	}

	return obj;
}

tlo_t * tl_messages_editChatDefaultBannedRights(InputPeer arg_peer, ChatBannedRights arg_banned_rights)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_editChatDefaultBannedRights");
	int i;
	obj->id = 0xa5866b41;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument ChatBannedRights
	if (arg_banned_rights){
		obj->objs[1] = arg_banned_rights;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "banned_rights");
	}

	return obj;
}

tlo_t * tl_messages_getEmojiKeywords(const char * arg_lang_code)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getEmojiKeywords");
	int i;
	obj->id = 0x35a0e062;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_lang_code){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_lang_code, strlen(arg_lang_code));
		strcpy(obj->objs[0]->name, "lang_code");
	}

	return obj;
}

tlo_t * tl_messages_getEmojiKeywordsDifference(const char * arg_lang_code, int arg_from_version)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getEmojiKeywordsDifference");
	int i;
	obj->id = 0x1508b6af;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_lang_code){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_lang_code, strlen(arg_lang_code));
		strcpy(obj->objs[0]->name, "lang_code");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_from_version);
	strcpy(obj->objs[1]->name, "from_version");
	return obj;
}

tlo_t * tl_messages_getEmojiKeywordsLanguages(const char * *arg_lang_codes, int len_arg_lang_codes)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getEmojiKeywordsLanguages");
	int i;
	obj->id = 0x4e9963b2;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<string>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "lang_codes");
	if (arg_lang_codes){
		for(i=0; i<len_arg_lang_codes; ++i){
			int len = strlen(arg_lang_codes[i]);
			buf_t b = buf_add((ui8_t *)arg_lang_codes[i], len);
			buf_cat(obj->objs[0]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_messages_getEmojiURL(const char * arg_lang_code)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getEmojiURL");
	int i;
	obj->id = 0xd5b10c26;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_lang_code){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_lang_code, strlen(arg_lang_code));
		strcpy(obj->objs[0]->name, "lang_code");
	}

	return obj;
}

tlo_t * tl_messages_getSearchCounters(InputPeer arg_peer, InputPeer arg_saved_peer_id, int arg_top_msg_id, MessagesFilter *arg_filters, int len_arg_filters)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getSearchCounters");
	int i;
	obj->id = 0x1bbcf300;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[1] = arg_peer;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "peer");
	}


	//parse argument InputPeer
	if (arg_saved_peer_id){
		obj->objs[2] = arg_saved_peer_id;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 2;
	strcpy(obj->objs[2]->name, "saved_peer_id");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_top_msg_id);
	strcpy(obj->objs[3]->name, "top_msg_id");
	if (arg_top_msg_id)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument Vector<MessagesFilter>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "filters");
	if (arg_filters){
		for(i=0; i<len_arg_filters; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_filters[i]->id);
			buf_cat(obj->objs[4]->value, arg_filters[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_requestUrlAuth(InputPeer arg_peer, int arg_msg_id, int arg_button_id, const char * arg_url)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_requestUrlAuth");
	int i;
	obj->id = 0x198fb446;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[1] = arg_peer;
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 1;
	strcpy(obj->objs[1]->name, "peer");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[2]->name, "msg_id");
	if (arg_msg_id)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 1;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_button_id);
	strcpy(obj->objs[3]->name, "button_id");
	if (arg_button_id)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument string
	if (arg_url){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 2;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[4]->name, "url");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_acceptUrlAuth(bool arg_write_allowed, InputPeer arg_peer, int arg_msg_id, int arg_button_id, const char * arg_url)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_acceptUrlAuth");
	int i;
	obj->id = 0xb12c7125;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_write_allowed);
	strcpy(obj->objs[1]->name, "write_allowed");
	if (arg_write_allowed)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 1;
	strcpy(obj->objs[2]->name, "peer");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 1;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[3]->name, "msg_id");
	if (arg_msg_id)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 1;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_button_id);
	strcpy(obj->objs[4]->name, "button_id");
	if (arg_button_id)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument string
	if (arg_url){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 2;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[5]->name, "url");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_hidePeerSettingsBar(InputPeer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_hidePeerSettingsBar");
	int i;
	obj->id = 0x4facb138;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}

	return obj;
}

tlo_t * tl_messages_getScheduledHistory(InputPeer arg_peer, long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getScheduledHistory");
	int i;
	obj->id = 0xf516760b;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[1]->name, "hash");
	return obj;
}

tlo_t * tl_messages_getScheduledMessages(InputPeer arg_peer, int *arg_id, int len_arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getScheduledMessages");
	int i;
	obj->id = 0xbdbb0464;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument Vector<int>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			buf_t b = buf_add_ui32(arg_id[i]);
			buf_cat(obj->objs[1]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_messages_sendScheduledMessages(InputPeer arg_peer, int *arg_id, int len_arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_sendScheduledMessages");
	int i;
	obj->id = 0xbd38850a;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument Vector<int>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			buf_t b = buf_add_ui32(arg_id[i]);
			buf_cat(obj->objs[1]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_messages_deleteScheduledMessages(InputPeer arg_peer, int *arg_id, int len_arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_deleteScheduledMessages");
	int i;
	obj->id = 0x59ae2b16;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument Vector<int>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			buf_t b = buf_add_ui32(arg_id[i]);
			buf_cat(obj->objs[1]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_messages_getPollVotes(InputPeer arg_peer, int arg_id, unsigned char * arg_option, int len_arg_option, const char * arg_offset, int arg_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getPollVotes");
	int i;
	obj->id = 0xb86e380e;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[1] = arg_peer;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "peer");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[2]->name, "id");

	//parse argument bytes
	if (arg_option){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_BYTES;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_option, len_arg_option);
		strcpy(obj->objs[3]->name, "option");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_offset){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 1;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_offset, strlen(arg_offset));
		strcpy(obj->objs[4]->name, "offset");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[5]->name, "limit");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_toggleStickerSets(bool arg_uninstall, bool arg_archive, bool arg_unarchive, InputStickerSet *arg_stickersets, int len_arg_stickersets)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_toggleStickerSets");
	int i;
	obj->id = 0xb5052fea;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_uninstall);
	strcpy(obj->objs[1]->name, "uninstall");
	if (arg_uninstall)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_archive);
	strcpy(obj->objs[2]->name, "archive");
	if (arg_archive)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_unarchive);
	strcpy(obj->objs[3]->name, "unarchive");
	if (arg_unarchive)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument Vector<InputStickerSet>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "stickersets");
	if (arg_stickersets){
		for(i=0; i<len_arg_stickersets; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_stickersets[i]->id);
			buf_cat(obj->objs[4]->value, arg_stickersets[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_getDialogFilters()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getDialogFilters");
	int i;
	obj->id = 0xefd48c89;
	return obj;
}

tlo_t * tl_messages_getSuggestedDialogFilters()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getSuggestedDialogFilters");
	int i;
	obj->id = 0xa29cd42c;
	return obj;
}

tlo_t * tl_messages_updateDialogFilter(int arg_id, DialogFilter arg_filter)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_updateDialogFilter");
	int i;
	obj->id = 0x1ad4a04a;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[1]->name, "id");

	//parse argument DialogFilter
	if (arg_filter){
		obj->objs[2] = arg_filter;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "filter");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_updateDialogFiltersOrder(int *arg_order, int len_arg_order)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_updateDialogFiltersOrder");
	int i;
	obj->id = 0xc563c1e4;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<int>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "order");
	if (arg_order){
		for(i=0; i<len_arg_order; ++i){
			buf_t b = buf_add_ui32(arg_order[i]);
			buf_cat(obj->objs[0]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_messages_getOldFeaturedStickers(int arg_offset, int arg_limit, long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getOldFeaturedStickers");
	int i;
	obj->id = 0x7ed094a1;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_offset);
	strcpy(obj->objs[0]->name, "offset");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[1]->name, "limit");

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[2]->name, "hash");
	return obj;
}

tlo_t * tl_messages_getReplies(InputPeer arg_peer, int arg_msg_id, int arg_offset_id, int arg_offset_date, int arg_add_offset, int arg_limit, int arg_max_id, int arg_min_id, long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getReplies");
	int i;
	obj->id = 0x22ddd30c;
	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[1]->name, "msg_id");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_offset_id);
	strcpy(obj->objs[2]->name, "offset_id");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_offset_date);
	strcpy(obj->objs[3]->name, "offset_date");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_add_offset);
	strcpy(obj->objs[4]->name, "add_offset");

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[5]->name, "limit");

	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_max_id);
	strcpy(obj->objs[6]->name, "max_id");

	//parse argument int
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_min_id);
	strcpy(obj->objs[7]->name, "min_id");

	//parse argument long
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 0;
	obj->objs[8]->flag_bit = 0;
	obj->objs[8]->type = TYPE_LONG;
	obj->objs[8]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[8]->name, "hash");
	return obj;
}

tlo_t * tl_messages_getDiscussionMessage(InputPeer arg_peer, int arg_msg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getDiscussionMessage");
	int i;
	obj->id = 0x446972fd;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[1]->name, "msg_id");
	return obj;
}

tlo_t * tl_messages_readDiscussion(InputPeer arg_peer, int arg_msg_id, int arg_read_max_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_readDiscussion");
	int i;
	obj->id = 0xf731a9f4;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[1]->name, "msg_id");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_read_max_id);
	strcpy(obj->objs[2]->name, "read_max_id");
	return obj;
}

tlo_t * tl_messages_unpinAllMessages(InputPeer arg_peer, int arg_top_msg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_unpinAllMessages");
	int i;
	obj->id = 0xee22b9a8;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[1] = arg_peer;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "peer");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_top_msg_id);
	strcpy(obj->objs[2]->name, "top_msg_id");
	if (arg_top_msg_id)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_deleteChat(long arg_chat_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_deleteChat");
	int i;
	obj->id = 0x5bd0ee50;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_chat_id);
	strcpy(obj->objs[0]->name, "chat_id");
	return obj;
}

tlo_t * tl_messages_deletePhoneCallHistory(bool arg_revoke)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_deletePhoneCallHistory");
	int i;
	obj->id = 0xf9cbe409;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_revoke);
	strcpy(obj->objs[1]->name, "revoke");
	if (arg_revoke)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_checkHistoryImport(const char * arg_import_head)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_checkHistoryImport");
	int i;
	obj->id = 0x43fe19f3;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_import_head){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_import_head, strlen(arg_import_head));
		strcpy(obj->objs[0]->name, "import_head");
	}

	return obj;
}

tlo_t * tl_messages_initHistoryImport(InputPeer arg_peer, InputFile arg_file, int arg_media_count)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_initHistoryImport");
	int i;
	obj->id = 0x34090c3b;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument InputFile
	if (arg_file){
		obj->objs[1] = arg_file;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "file");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_media_count);
	strcpy(obj->objs[2]->name, "media_count");
	return obj;
}

tlo_t * tl_messages_uploadImportedMedia(InputPeer arg_peer, long arg_import_id, const char * arg_file_name, InputMedia arg_media)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_uploadImportedMedia");
	int i;
	obj->id = 0x2a862092;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_import_id);
	strcpy(obj->objs[1]->name, "import_id");

	//parse argument string
	if (arg_file_name){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_file_name, strlen(arg_file_name));
		strcpy(obj->objs[2]->name, "file_name");
	}


	//parse argument InputMedia
	if (arg_media){
		obj->objs[3] = arg_media;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "media");
	}

	return obj;
}

tlo_t * tl_messages_startHistoryImport(InputPeer arg_peer, long arg_import_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_startHistoryImport");
	int i;
	obj->id = 0xb43df344;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_import_id);
	strcpy(obj->objs[1]->name, "import_id");
	return obj;
}

tlo_t * tl_messages_getExportedChatInvites(bool arg_revoked, InputPeer arg_peer, InputUser arg_admin_id, int arg_offset_date, const char * arg_offset_link, int arg_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getExportedChatInvites");
	int i;
	obj->id = 0xa2b5a3f6;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 3;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_revoked);
	strcpy(obj->objs[1]->name, "revoked");
	if (arg_revoked)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//parse argument InputUser
	if (arg_admin_id){
		obj->objs[3] = arg_admin_id;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "admin_id");
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 2;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_offset_date);
	strcpy(obj->objs[4]->name, "offset_date");
	if (arg_offset_date)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument string
	if (arg_offset_link){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 2;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_offset_link, strlen(arg_offset_link));
		strcpy(obj->objs[5]->name, "offset_link");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[6]->name, "limit");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_getExportedChatInvite(InputPeer arg_peer, const char * arg_link)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getExportedChatInvite");
	int i;
	obj->id = 0x73746f5c;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument string
	if (arg_link){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_link, strlen(arg_link));
		strcpy(obj->objs[1]->name, "link");
	}

	return obj;
}

tlo_t * tl_messages_editExportedChatInvite(bool arg_revoked, InputPeer arg_peer, const char * arg_link, int arg_expire_date, int arg_usage_limit, Bool arg_request_needed, const char * arg_title)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_editExportedChatInvite");
	int i;
	obj->id = 0xbdca2f75;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 2;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_revoked);
	strcpy(obj->objs[1]->name, "revoked");
	if (arg_revoked)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//parse argument string
	if (arg_link){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_link, strlen(arg_link));
		strcpy(obj->objs[3]->name, "link");
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_expire_date);
	strcpy(obj->objs[4]->name, "expire_date");
	if (arg_expire_date)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 1;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_usage_limit);
	strcpy(obj->objs[5]->name, "usage_limit");
	if (arg_usage_limit)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument Bool
	if (arg_request_needed){
		obj->objs[6] = arg_request_needed;
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 3;
	strcpy(obj->objs[6]->name, "request_needed");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument string
	if (arg_title){
		obj->objs[7] = NEW(tlo_t, return NULL);
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 4;
		obj->objs[7]->type = TYPE_STRING;
		obj->objs[7]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[7]->name, "title");
		flagsv[nflags-1] |= (1 << 4);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_deleteRevokedExportedChatInvites(InputPeer arg_peer, InputUser arg_admin_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_deleteRevokedExportedChatInvites");
	int i;
	obj->id = 0x56987bd5;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument InputUser
	if (arg_admin_id){
		obj->objs[1] = arg_admin_id;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "admin_id");
	}

	return obj;
}

tlo_t * tl_messages_deleteExportedChatInvite(InputPeer arg_peer, const char * arg_link)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_deleteExportedChatInvite");
	int i;
	obj->id = 0xd464a42b;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument string
	if (arg_link){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_link, strlen(arg_link));
		strcpy(obj->objs[1]->name, "link");
	}

	return obj;
}

tlo_t * tl_messages_getAdminsWithInvites(InputPeer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getAdminsWithInvites");
	int i;
	obj->id = 0x3920e6ef;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}

	return obj;
}

tlo_t * tl_messages_getChatInviteImporters(bool arg_requested, bool arg_subscription_expired, InputPeer arg_peer, const char * arg_link, const char * arg_q, int arg_offset_date, InputUser arg_offset_user, int arg_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getChatInviteImporters");
	int i;
	obj->id = 0xdf04dd4e;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_requested);
	strcpy(obj->objs[1]->name, "requested");
	if (arg_requested)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 3;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_subscription_expired);
	strcpy(obj->objs[2]->name, "subscription_expired");
	if (arg_subscription_expired)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[3] = arg_peer;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "peer");
	}


	//parse argument string
	if (arg_link){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 1;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_link, strlen(arg_link));
		strcpy(obj->objs[4]->name, "link");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument string
	if (arg_q){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 2;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_q, strlen(arg_q));
		strcpy(obj->objs[5]->name, "q");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_offset_date);
	strcpy(obj->objs[6]->name, "offset_date");

	//parse argument InputUser
	if (arg_offset_user){
		obj->objs[7] = arg_offset_user;
		obj->objs[7]->flag_num = 0;
		obj->objs[7]->flag_bit = 0;
	strcpy(obj->objs[7]->name, "offset_user");
	}


	//parse argument int
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 0;
	obj->objs[8]->flag_bit = 0;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[8]->name, "limit");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_setHistoryTTL(InputPeer arg_peer, int arg_period)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_setHistoryTTL");
	int i;
	obj->id = 0xb80e5fe4;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_period);
	strcpy(obj->objs[1]->name, "period");
	return obj;
}

tlo_t * tl_messages_checkHistoryImportPeer(InputPeer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_checkHistoryImportPeer");
	int i;
	obj->id = 0x5dc60f03;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}

	return obj;
}

tlo_t * tl_messages_setChatTheme(InputPeer arg_peer, const char * arg_emoticon)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_setChatTheme");
	int i;
	obj->id = 0xe63be13f;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument string
	if (arg_emoticon){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_emoticon, strlen(arg_emoticon));
		strcpy(obj->objs[1]->name, "emoticon");
	}

	return obj;
}

tlo_t * tl_messages_getMessageReadParticipants(InputPeer arg_peer, int arg_msg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getMessageReadParticipants");
	int i;
	obj->id = 0x31c1c44f;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[1]->name, "msg_id");
	return obj;
}

tlo_t * tl_messages_getSearchResultsCalendar(InputPeer arg_peer, InputPeer arg_saved_peer_id, MessagesFilter arg_filter, int arg_offset_id, int arg_offset_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getSearchResultsCalendar");
	int i;
	obj->id = 0x6aa3f6bd;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[1] = arg_peer;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "peer");
	}


	//parse argument InputPeer
	if (arg_saved_peer_id){
		obj->objs[2] = arg_saved_peer_id;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 2;
	strcpy(obj->objs[2]->name, "saved_peer_id");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument MessagesFilter
	if (arg_filter){
		obj->objs[3] = arg_filter;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "filter");
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_offset_id);
	strcpy(obj->objs[4]->name, "offset_id");

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_offset_date);
	strcpy(obj->objs[5]->name, "offset_date");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_getSearchResultsPositions(InputPeer arg_peer, InputPeer arg_saved_peer_id, MessagesFilter arg_filter, int arg_offset_id, int arg_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getSearchResultsPositions");
	int i;
	obj->id = 0x9c7f2f10;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[1] = arg_peer;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "peer");
	}


	//parse argument InputPeer
	if (arg_saved_peer_id){
		obj->objs[2] = arg_saved_peer_id;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 2;
	strcpy(obj->objs[2]->name, "saved_peer_id");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument MessagesFilter
	if (arg_filter){
		obj->objs[3] = arg_filter;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "filter");
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_offset_id);
	strcpy(obj->objs[4]->name, "offset_id");

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[5]->name, "limit");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_hideChatJoinRequest(bool arg_approved, InputPeer arg_peer, InputUser arg_user_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_hideChatJoinRequest");
	int i;
	obj->id = 0x7fe7e815;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_approved);
	strcpy(obj->objs[1]->name, "approved");
	if (arg_approved)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//parse argument InputUser
	if (arg_user_id){
		obj->objs[3] = arg_user_id;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "user_id");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_hideAllChatJoinRequests(bool arg_approved, InputPeer arg_peer, const char * arg_link)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_hideAllChatJoinRequests");
	int i;
	obj->id = 0xe085f4ea;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_approved);
	strcpy(obj->objs[1]->name, "approved");
	if (arg_approved)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//parse argument string
	if (arg_link){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 1;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_link, strlen(arg_link));
		strcpy(obj->objs[3]->name, "link");
		flagsv[nflags-1] |= (1 << 1);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_toggleNoForwards(InputPeer arg_peer, Bool arg_enabled)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_toggleNoForwards");
	int i;
	obj->id = 0xb11eafa2;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument Bool
	if (arg_enabled){
		obj->objs[1] = arg_enabled;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "enabled");
	}

	return obj;
}

tlo_t * tl_messages_saveDefaultSendAs(InputPeer arg_peer, InputPeer arg_send_as)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_saveDefaultSendAs");
	int i;
	obj->id = 0xccfddf96;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument InputPeer
	if (arg_send_as){
		obj->objs[1] = arg_send_as;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "send_as");
	}

	return obj;
}

tlo_t * tl_messages_sendReaction(bool arg_big, bool arg_add_to_recent, InputPeer arg_peer, int arg_msg_id, Reaction *arg_reaction, int len_arg_reaction)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_sendReaction");
	int i;
	obj->id = 0xd30d78d4;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_big);
	strcpy(obj->objs[1]->name, "big");
	if (arg_big)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 2;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_add_to_recent);
	strcpy(obj->objs[2]->name, "add_to_recent");
	if (arg_add_to_recent)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[3] = arg_peer;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "peer");
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[4]->name, "msg_id");

	//parse argument Vector<Reaction>
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_VECTOR;
	strcpy(obj->objs[5]->name, "reaction");
	if (arg_reaction){
		for(i=0; i<len_arg_reaction; ++i){
			obj->objs[5]->value = buf_add_ui32(arg_reaction[i]->id);
			buf_cat(obj->objs[5]->value, arg_reaction[i]->value);
		}
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_getMessagesReactions(InputPeer arg_peer, int *arg_id, int len_arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getMessagesReactions");
	int i;
	obj->id = 0x8bba90e6;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument Vector<int>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			buf_t b = buf_add_ui32(arg_id[i]);
			buf_cat(obj->objs[1]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_messages_getMessageReactionsList(InputPeer arg_peer, int arg_id, Reaction arg_reaction, const char * arg_offset, int arg_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getMessageReactionsList");
	int i;
	obj->id = 0x461b3f48;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[1] = arg_peer;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "peer");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[2]->name, "id");

	//parse argument Reaction
	if (arg_reaction){
		obj->objs[3] = arg_reaction;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "reaction");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_offset){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 1;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_offset, strlen(arg_offset));
		strcpy(obj->objs[4]->name, "offset");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[5]->name, "limit");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_setChatAvailableReactions(InputPeer arg_peer, ChatReactions arg_available_reactions, int arg_reactions_limit, Bool arg_paid_enabled)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_setChatAvailableReactions");
	int i;
	obj->id = 0x864b2581;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[1] = arg_peer;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "peer");
	}


	//parse argument ChatReactions
	if (arg_available_reactions){
		obj->objs[2] = arg_available_reactions;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "available_reactions");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_reactions_limit);
	strcpy(obj->objs[3]->name, "reactions_limit");
	if (arg_reactions_limit)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument Bool
	if (arg_paid_enabled){
		obj->objs[4] = arg_paid_enabled;
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 1;
	strcpy(obj->objs[4]->name, "paid_enabled");
		flagsv[nflags-1] |= (1 << 1);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_getAvailableReactions(int arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getAvailableReactions");
	int i;
	obj->id = 0x18dea0ac;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_messages_setDefaultReaction(Reaction arg_reaction)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_setDefaultReaction");
	int i;
	obj->id = 0x4f47a016;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Reaction
	if (arg_reaction){
		obj->objs[0] = arg_reaction;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "reaction");
	}

	return obj;
}

tlo_t * tl_messages_translateText(InputPeer arg_peer, int *arg_id, int len_arg_id, TextWithEntities *arg_text, int len_arg_text, const char * arg_to_lang)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_translateText");
	int i;
	obj->id = 0x63183030;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[1] = arg_peer;
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "peer");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument Vector<int>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			buf_t b = buf_add_ui32(arg_id[i]);
			buf_cat(obj->objs[2]->value, b);
		}
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument Vector<TextWithEntities>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 1;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "text");
	if (arg_text){
		for(i=0; i<len_arg_text; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_text[i]->id);
			buf_cat(obj->objs[3]->value, arg_text[i]->value);
		}
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument string
	if (arg_to_lang){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_to_lang, strlen(arg_to_lang));
		strcpy(obj->objs[4]->name, "to_lang");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_getUnreadReactions(InputPeer arg_peer, int arg_top_msg_id, int arg_offset_id, int arg_add_offset, int arg_limit, int arg_max_id, int arg_min_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getUnreadReactions");
	int i;
	obj->id = 0x3223495b;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[1] = arg_peer;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "peer");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_top_msg_id);
	strcpy(obj->objs[2]->name, "top_msg_id");
	if (arg_top_msg_id)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_offset_id);
	strcpy(obj->objs[3]->name, "offset_id");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_add_offset);
	strcpy(obj->objs[4]->name, "add_offset");

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[5]->name, "limit");

	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_max_id);
	strcpy(obj->objs[6]->name, "max_id");

	//parse argument int
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_min_id);
	strcpy(obj->objs[7]->name, "min_id");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_readReactions(InputPeer arg_peer, int arg_top_msg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_readReactions");
	int i;
	obj->id = 0x54aa7f8e;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[1] = arg_peer;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "peer");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_top_msg_id);
	strcpy(obj->objs[2]->name, "top_msg_id");
	if (arg_top_msg_id)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_searchSentMedia(const char * arg_q, MessagesFilter arg_filter, int arg_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_searchSentMedia");
	int i;
	obj->id = 0x107e31a0;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_q){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_q, strlen(arg_q));
		strcpy(obj->objs[0]->name, "q");
	}


	//parse argument MessagesFilter
	if (arg_filter){
		obj->objs[1] = arg_filter;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "filter");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[2]->name, "limit");
	return obj;
}

tlo_t * tl_messages_getAttachMenuBots(long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getAttachMenuBots");
	int i;
	obj->id = 0x16fcc2cb;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_messages_getAttachMenuBot(InputUser arg_bot)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getAttachMenuBot");
	int i;
	obj->id = 0x77216192;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputUser
	if (arg_bot){
		obj->objs[0] = arg_bot;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "bot");
	}

	return obj;
}

tlo_t * tl_messages_toggleBotInAttachMenu(bool arg_write_allowed, InputUser arg_bot, Bool arg_enabled)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_toggleBotInAttachMenu");
	int i;
	obj->id = 0x69f59d69;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_write_allowed);
	strcpy(obj->objs[1]->name, "write_allowed");
	if (arg_write_allowed)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputUser
	if (arg_bot){
		obj->objs[2] = arg_bot;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "bot");
	}


	//parse argument Bool
	if (arg_enabled){
		obj->objs[3] = arg_enabled;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "enabled");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_requestWebView(bool arg_from_bot_menu, bool arg_silent, bool arg_compact, InputPeer arg_peer, InputUser arg_bot, const char * arg_url, const char * arg_start_param, DataJSON arg_theme_params, const char * arg_platform, InputReplyTo arg_reply_to, InputPeer arg_send_as)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_requestWebView");
	int i;
	obj->id = 0x269dc2c1;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 12;
	obj->objs = 
		(tlo_t **)MALLOC(12 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 4;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_from_bot_menu);
	strcpy(obj->objs[1]->name, "from_bot_menu");
	if (arg_from_bot_menu)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 5;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_silent);
	strcpy(obj->objs[2]->name, "silent");
	if (arg_silent)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 7;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_compact);
	strcpy(obj->objs[3]->name, "compact");
	if (arg_compact)
		flagsv[nflags-1] |= (1 << 7);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[4] = arg_peer;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "peer");
	}


	//parse argument InputUser
	if (arg_bot){
		obj->objs[5] = arg_bot;
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
	strcpy(obj->objs[5]->name, "bot");
	}


	//parse argument string
	if (arg_url){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 1;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[6]->name, "url");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument string
	if (arg_start_param){
		obj->objs[7] = NEW(tlo_t, return NULL);
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 3;
		obj->objs[7]->type = TYPE_STRING;
		obj->objs[7]->value = 
			buf_add((ui8_t *)arg_start_param, strlen(arg_start_param));
		strcpy(obj->objs[7]->name, "start_param");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument DataJSON
	if (arg_theme_params){
		obj->objs[8] = arg_theme_params;
		obj->objs[8]->flag_num = 1;
		obj->objs[8]->flag_bit = 2;
	strcpy(obj->objs[8]->name, "theme_params");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument string
	if (arg_platform){
		obj->objs[9] = NEW(tlo_t, return NULL);
		obj->objs[9]->flag_num = 0;
		obj->objs[9]->flag_bit = 0;
		obj->objs[9]->type = TYPE_STRING;
		obj->objs[9]->value = 
			buf_add((ui8_t *)arg_platform, strlen(arg_platform));
		strcpy(obj->objs[9]->name, "platform");
	}


	//parse argument InputReplyTo
	if (arg_reply_to){
		obj->objs[10] = arg_reply_to;
		obj->objs[10]->flag_num = 1;
		obj->objs[10]->flag_bit = 0;
	strcpy(obj->objs[10]->name, "reply_to");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument InputPeer
	if (arg_send_as){
		obj->objs[11] = arg_send_as;
		obj->objs[11]->flag_num = 1;
		obj->objs[11]->flag_bit = 13;
	strcpy(obj->objs[11]->name, "send_as");
		flagsv[nflags-1] |= (1 << 13);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_prolongWebView(bool arg_silent, InputPeer arg_peer, InputUser arg_bot, long arg_query_id, InputReplyTo arg_reply_to, InputPeer arg_send_as)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_prolongWebView");
	int i;
	obj->id = 0xb0d81a83;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 5;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_silent);
	strcpy(obj->objs[1]->name, "silent");
	if (arg_silent)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//parse argument InputUser
	if (arg_bot){
		obj->objs[3] = arg_bot;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "bot");
	}


	//parse argument long
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_query_id);
	strcpy(obj->objs[4]->name, "query_id");

	//parse argument InputReplyTo
	if (arg_reply_to){
		obj->objs[5] = arg_reply_to;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 0;
	strcpy(obj->objs[5]->name, "reply_to");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument InputPeer
	if (arg_send_as){
		obj->objs[6] = arg_send_as;
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 13;
	strcpy(obj->objs[6]->name, "send_as");
		flagsv[nflags-1] |= (1 << 13);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_requestSimpleWebView(bool arg_from_switch_webview, bool arg_from_side_menu, bool arg_compact, InputUser arg_bot, const char * arg_url, const char * arg_start_param, DataJSON arg_theme_params, const char * arg_platform)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_requestSimpleWebView");
	int i;
	obj->id = 0x413a3e73;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_from_switch_webview);
	strcpy(obj->objs[1]->name, "from_switch_webview");
	if (arg_from_switch_webview)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 2;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_from_side_menu);
	strcpy(obj->objs[2]->name, "from_side_menu");
	if (arg_from_side_menu)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 7;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_compact);
	strcpy(obj->objs[3]->name, "compact");
	if (arg_compact)
		flagsv[nflags-1] |= (1 << 7);

	//parse argument InputUser
	if (arg_bot){
		obj->objs[4] = arg_bot;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "bot");
	}


	//parse argument string
	if (arg_url){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 3;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_url, strlen(arg_url));
		strcpy(obj->objs[5]->name, "url");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument string
	if (arg_start_param){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 4;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_start_param, strlen(arg_start_param));
		strcpy(obj->objs[6]->name, "start_param");
		flagsv[nflags-1] |= (1 << 4);
	}


	//parse argument DataJSON
	if (arg_theme_params){
		obj->objs[7] = arg_theme_params;
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 0;
	strcpy(obj->objs[7]->name, "theme_params");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_platform){
		obj->objs[8] = NEW(tlo_t, return NULL);
		obj->objs[8]->flag_num = 0;
		obj->objs[8]->flag_bit = 0;
		obj->objs[8]->type = TYPE_STRING;
		obj->objs[8]->value = 
			buf_add((ui8_t *)arg_platform, strlen(arg_platform));
		strcpy(obj->objs[8]->name, "platform");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_sendWebViewResultMessage(const char * arg_bot_query_id, InputBotInlineResult arg_result)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_sendWebViewResultMessage");
	int i;
	obj->id = 0x0a4314f5;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_bot_query_id){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_bot_query_id, strlen(arg_bot_query_id));
		strcpy(obj->objs[0]->name, "bot_query_id");
	}


	//parse argument InputBotInlineResult
	if (arg_result){
		obj->objs[1] = arg_result;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "result");
	}

	return obj;
}

tlo_t * tl_messages_sendWebViewData(InputUser arg_bot, long arg_random_id, const char * arg_button_text, const char * arg_data)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_sendWebViewData");
	int i;
	obj->id = 0xdc0242c8;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument InputUser
	if (arg_bot){
		obj->objs[0] = arg_bot;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "bot");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_random_id);
	strcpy(obj->objs[1]->name, "random_id");

	//parse argument string
	if (arg_button_text){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_button_text, strlen(arg_button_text));
		strcpy(obj->objs[2]->name, "button_text");
	}


	//parse argument string
	if (arg_data){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_data, strlen(arg_data));
		strcpy(obj->objs[3]->name, "data");
	}

	return obj;
}

tlo_t * tl_messages_transcribeAudio(InputPeer arg_peer, int arg_msg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_transcribeAudio");
	int i;
	obj->id = 0x269e9a49;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[1]->name, "msg_id");
	return obj;
}

tlo_t * tl_messages_rateTranscribedAudio(InputPeer arg_peer, int arg_msg_id, long arg_transcription_id, Bool arg_good)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_rateTranscribedAudio");
	int i;
	obj->id = 0x7f1d072f;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[1]->name, "msg_id");

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_transcription_id);
	strcpy(obj->objs[2]->name, "transcription_id");

	//parse argument Bool
	if (arg_good){
		obj->objs[3] = arg_good;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "good");
	}

	return obj;
}

tlo_t * tl_messages_getCustomEmojiDocuments(long *arg_document_id, int len_arg_document_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getCustomEmojiDocuments");
	int i;
	obj->id = 0xd9ab0f54;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<long>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "document_id");
	if (arg_document_id){
		for(i=0; i<len_arg_document_id; ++i){
			buf_t b = buf_add_ui64(arg_document_id[i]);
			buf_cat(obj->objs[0]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_messages_getEmojiStickers(long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getEmojiStickers");
	int i;
	obj->id = 0xfbfca18f;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_messages_getFeaturedEmojiStickers(long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getFeaturedEmojiStickers");
	int i;
	obj->id = 0x0ecf6736;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_messages_reportReaction(InputPeer arg_peer, int arg_id, InputPeer arg_reaction_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_reportReaction");
	int i;
	obj->id = 0x3f64c076;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[1]->name, "id");

	//parse argument InputPeer
	if (arg_reaction_peer){
		obj->objs[2] = arg_reaction_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "reaction_peer");
	}

	return obj;
}

tlo_t * tl_messages_getTopReactions(int arg_limit, long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getTopReactions");
	int i;
	obj->id = 0xbb8125ba;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[0]->name, "limit");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[1]->name, "hash");
	return obj;
}

tlo_t * tl_messages_getRecentReactions(int arg_limit, long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getRecentReactions");
	int i;
	obj->id = 0x39461db2;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[0]->name, "limit");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[1]->name, "hash");
	return obj;
}

tlo_t * tl_messages_clearRecentReactions()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_clearRecentReactions");
	int i;
	obj->id = 0x9dfeefb4;
	return obj;
}

tlo_t * tl_messages_getExtendedMedia(InputPeer arg_peer, int *arg_id, int len_arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getExtendedMedia");
	int i;
	obj->id = 0x84f80814;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument Vector<int>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			buf_t b = buf_add_ui32(arg_id[i]);
			buf_cat(obj->objs[1]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_messages_setDefaultHistoryTTL(int arg_period)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_setDefaultHistoryTTL");
	int i;
	obj->id = 0x9eb51445;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_period);
	strcpy(obj->objs[0]->name, "period");
	return obj;
}

tlo_t * tl_messages_getDefaultHistoryTTL()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getDefaultHistoryTTL");
	int i;
	obj->id = 0x658b7188;
	return obj;
}

tlo_t * tl_messages_sendBotRequestedPeer(InputPeer arg_peer, int arg_msg_id, int arg_button_id, InputPeer *arg_requested_peers, int len_arg_requested_peers)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_sendBotRequestedPeer");
	int i;
	obj->id = 0x91b2d060;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[1]->name, "msg_id");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_button_id);
	strcpy(obj->objs[2]->name, "button_id");

	//parse argument Vector<InputPeer>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "requested_peers");
	if (arg_requested_peers){
		for(i=0; i<len_arg_requested_peers; ++i){
			obj->objs[3]->value = buf_add_ui32(arg_requested_peers[i]->id);
			buf_cat(obj->objs[3]->value, arg_requested_peers[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_messages_getEmojiGroups(int arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getEmojiGroups");
	int i;
	obj->id = 0x7488ce5b;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_messages_getEmojiStatusGroups(int arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getEmojiStatusGroups");
	int i;
	obj->id = 0x2ecd56cd;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_messages_getEmojiProfilePhotoGroups(int arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getEmojiProfilePhotoGroups");
	int i;
	obj->id = 0x21a548f3;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_messages_searchCustomEmoji(const char * arg_emoticon, long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_searchCustomEmoji");
	int i;
	obj->id = 0x2c11c0d7;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_emoticon){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_emoticon, strlen(arg_emoticon));
		strcpy(obj->objs[0]->name, "emoticon");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[1]->name, "hash");
	return obj;
}

tlo_t * tl_messages_togglePeerTranslations(bool arg_disabled, InputPeer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_togglePeerTranslations");
	int i;
	obj->id = 0xe47cb579;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_disabled);
	strcpy(obj->objs[1]->name, "disabled");
	if (arg_disabled)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_getBotApp(InputBotApp arg_app, long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getBotApp");
	int i;
	obj->id = 0x34fdc5c3;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputBotApp
	if (arg_app){
		obj->objs[0] = arg_app;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "app");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[1]->name, "hash");
	return obj;
}

tlo_t * tl_messages_requestAppWebView(bool arg_write_allowed, bool arg_compact, InputPeer arg_peer, InputBotApp arg_app, const char * arg_start_param, DataJSON arg_theme_params, const char * arg_platform)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_requestAppWebView");
	int i;
	obj->id = 0x53618bce;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_write_allowed);
	strcpy(obj->objs[1]->name, "write_allowed");
	if (arg_write_allowed)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 7;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_compact);
	strcpy(obj->objs[2]->name, "compact");
	if (arg_compact)
		flagsv[nflags-1] |= (1 << 7);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[3] = arg_peer;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "peer");
	}


	//parse argument InputBotApp
	if (arg_app){
		obj->objs[4] = arg_app;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "app");
	}


	//parse argument string
	if (arg_start_param){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 1;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_start_param, strlen(arg_start_param));
		strcpy(obj->objs[5]->name, "start_param");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument DataJSON
	if (arg_theme_params){
		obj->objs[6] = arg_theme_params;
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 2;
	strcpy(obj->objs[6]->name, "theme_params");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument string
	if (arg_platform){
		obj->objs[7] = NEW(tlo_t, return NULL);
		obj->objs[7]->flag_num = 0;
		obj->objs[7]->flag_bit = 0;
		obj->objs[7]->type = TYPE_STRING;
		obj->objs[7]->value = 
			buf_add((ui8_t *)arg_platform, strlen(arg_platform));
		strcpy(obj->objs[7]->name, "platform");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_setChatWallPaper(bool arg_for_both, bool arg_revert, InputPeer arg_peer, InputWallPaper arg_wallpaper, WallPaperSettings arg_settings, int arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_setChatWallPaper");
	int i;
	obj->id = 0x8ffacae1;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 3;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_for_both);
	strcpy(obj->objs[1]->name, "for_both");
	if (arg_for_both)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 4;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_revert);
	strcpy(obj->objs[2]->name, "revert");
	if (arg_revert)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[3] = arg_peer;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "peer");
	}


	//parse argument InputWallPaper
	if (arg_wallpaper){
		obj->objs[4] = arg_wallpaper;
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "wallpaper");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument WallPaperSettings
	if (arg_settings){
		obj->objs[5] = arg_settings;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 2;
	strcpy(obj->objs[5]->name, "settings");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 1;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[6]->name, "id");
	if (arg_id)
		flagsv[nflags-1] |= (1 << 1);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_searchEmojiStickerSets(bool arg_exclude_featured, const char * arg_q, long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_searchEmojiStickerSets");
	int i;
	obj->id = 0x92b4494c;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_exclude_featured);
	strcpy(obj->objs[1]->name, "exclude_featured");
	if (arg_exclude_featured)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument string
	if (arg_q){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_q, strlen(arg_q));
		strcpy(obj->objs[2]->name, "q");
	}


	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[3]->name, "hash");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_getSavedDialogs(bool arg_exclude_pinned, int arg_offset_date, int arg_offset_id, InputPeer arg_offset_peer, int arg_limit, long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getSavedDialogs");
	int i;
	obj->id = 0x5381d21a;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_exclude_pinned);
	strcpy(obj->objs[1]->name, "exclude_pinned");
	if (arg_exclude_pinned)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_offset_date);
	strcpy(obj->objs[2]->name, "offset_date");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_offset_id);
	strcpy(obj->objs[3]->name, "offset_id");

	//parse argument InputPeer
	if (arg_offset_peer){
		obj->objs[4] = arg_offset_peer;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "offset_peer");
	}


	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[5]->name, "limit");

	//parse argument long
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_LONG;
	obj->objs[6]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[6]->name, "hash");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_getSavedHistory(InputPeer arg_peer, int arg_offset_id, int arg_offset_date, int arg_add_offset, int arg_limit, int arg_max_id, int arg_min_id, long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getSavedHistory");
	int i;
	obj->id = 0x3d9a414d;
	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_offset_id);
	strcpy(obj->objs[1]->name, "offset_id");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_offset_date);
	strcpy(obj->objs[2]->name, "offset_date");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_add_offset);
	strcpy(obj->objs[3]->name, "add_offset");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[4]->name, "limit");

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_max_id);
	strcpy(obj->objs[5]->name, "max_id");

	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_min_id);
	strcpy(obj->objs[6]->name, "min_id");

	//parse argument long
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_LONG;
	obj->objs[7]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[7]->name, "hash");
	return obj;
}

tlo_t * tl_messages_deleteSavedHistory(InputPeer arg_peer, int arg_max_id, int arg_min_date, int arg_max_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_deleteSavedHistory");
	int i;
	obj->id = 0x6e98102b;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[1] = arg_peer;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "peer");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_max_id);
	strcpy(obj->objs[2]->name, "max_id");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_min_date);
	strcpy(obj->objs[3]->name, "min_date");
	if (arg_min_date)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 3;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_max_date);
	strcpy(obj->objs[4]->name, "max_date");
	if (arg_max_date)
		flagsv[nflags-1] |= (1 << 3);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_getPinnedSavedDialogs()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getPinnedSavedDialogs");
	int i;
	obj->id = 0xd63d94e0;
	return obj;
}

tlo_t * tl_messages_toggleSavedDialogPin(bool arg_pinned, InputDialogPeer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_toggleSavedDialogPin");
	int i;
	obj->id = 0xac81bbde;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_pinned);
	strcpy(obj->objs[1]->name, "pinned");
	if (arg_pinned)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputDialogPeer
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_reorderPinnedSavedDialogs(bool arg_force, InputDialogPeer *arg_order, int len_arg_order)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_reorderPinnedSavedDialogs");
	int i;
	obj->id = 0x8b716587;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_force);
	strcpy(obj->objs[1]->name, "force");
	if (arg_force)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument Vector<InputDialogPeer>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "order");
	if (arg_order){
		for(i=0; i<len_arg_order; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_order[i]->id);
			buf_cat(obj->objs[2]->value, arg_order[i]->value);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_getSavedReactionTags(InputPeer arg_peer, long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getSavedReactionTags");
	int i;
	obj->id = 0x3637e05b;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[1] = arg_peer;
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "peer");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[2]->name, "hash");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_updateSavedReactionTag(Reaction arg_reaction, const char * arg_title)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_updateSavedReactionTag");
	int i;
	obj->id = 0x60297dec;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument Reaction
	if (arg_reaction){
		obj->objs[1] = arg_reaction;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "reaction");
	}


	//parse argument string
	if (arg_title){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[2]->name, "title");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_getDefaultTagReactions(long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getDefaultTagReactions");
	int i;
	obj->id = 0xbdf93428;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_messages_getOutboxReadDate(InputPeer arg_peer, int arg_msg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getOutboxReadDate");
	int i;
	obj->id = 0x8c4bfe5d;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[1]->name, "msg_id");
	return obj;
}

tlo_t * tl_messages_getQuickReplies(long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getQuickReplies");
	int i;
	obj->id = 0xd483f2a8;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_messages_reorderQuickReplies(int *arg_order, int len_arg_order)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_reorderQuickReplies");
	int i;
	obj->id = 0x60331907;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<int>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "order");
	if (arg_order){
		for(i=0; i<len_arg_order; ++i){
			buf_t b = buf_add_ui32(arg_order[i]);
			buf_cat(obj->objs[0]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_messages_checkQuickReplyShortcut(const char * arg_shortcut)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_checkQuickReplyShortcut");
	int i;
	obj->id = 0xf1d0fbd3;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_shortcut){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_shortcut, strlen(arg_shortcut));
		strcpy(obj->objs[0]->name, "shortcut");
	}

	return obj;
}

tlo_t * tl_messages_editQuickReplyShortcut(int arg_shortcut_id, const char * arg_shortcut)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_editQuickReplyShortcut");
	int i;
	obj->id = 0x5c003cef;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_shortcut_id);
	strcpy(obj->objs[0]->name, "shortcut_id");

	//parse argument string
	if (arg_shortcut){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_shortcut, strlen(arg_shortcut));
		strcpy(obj->objs[1]->name, "shortcut");
	}

	return obj;
}

tlo_t * tl_messages_deleteQuickReplyShortcut(int arg_shortcut_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_deleteQuickReplyShortcut");
	int i;
	obj->id = 0x3cc04740;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_shortcut_id);
	strcpy(obj->objs[0]->name, "shortcut_id");
	return obj;
}

tlo_t * tl_messages_getQuickReplyMessages(int arg_shortcut_id, int *arg_id, int len_arg_id, long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getQuickReplyMessages");
	int i;
	obj->id = 0x94a495c3;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_shortcut_id);
	strcpy(obj->objs[1]->name, "shortcut_id");

	//parse argument Vector<int>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			buf_t b = buf_add_ui32(arg_id[i]);
			buf_cat(obj->objs[2]->value, b);
		}
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[3]->name, "hash");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_sendQuickReplyMessages(InputPeer arg_peer, int arg_shortcut_id, int *arg_id, int len_arg_id, long *arg_random_id, int len_arg_random_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_sendQuickReplyMessages");
	int i;
	obj->id = 0x6c750de1;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_shortcut_id);
	strcpy(obj->objs[1]->name, "shortcut_id");

	//parse argument Vector<int>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			buf_t b = buf_add_ui32(arg_id[i]);
			buf_cat(obj->objs[2]->value, b);
		}
	}


	//parse argument Vector<long>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "random_id");
	if (arg_random_id){
		for(i=0; i<len_arg_random_id; ++i){
			buf_t b = buf_add_ui64(arg_random_id[i]);
			buf_cat(obj->objs[3]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_messages_deleteQuickReplyMessages(int arg_shortcut_id, int *arg_id, int len_arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_deleteQuickReplyMessages");
	int i;
	obj->id = 0xe105e910;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_shortcut_id);
	strcpy(obj->objs[0]->name, "shortcut_id");

	//parse argument Vector<int>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			buf_t b = buf_add_ui32(arg_id[i]);
			buf_cat(obj->objs[1]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_messages_toggleDialogFilterTags(Bool arg_enabled)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_toggleDialogFilterTags");
	int i;
	obj->id = 0xfd2dda49;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Bool
	if (arg_enabled){
		obj->objs[0] = arg_enabled;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "enabled");
	}

	return obj;
}

tlo_t * tl_messages_getMyStickers(long arg_offset_id, int arg_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getMyStickers");
	int i;
	obj->id = 0xd0b5e1fc;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_offset_id);
	strcpy(obj->objs[0]->name, "offset_id");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[1]->name, "limit");
	return obj;
}

tlo_t * tl_messages_getEmojiStickerGroups(int arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getEmojiStickerGroups");
	int i;
	obj->id = 0x1dd840f5;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_messages_getAvailableEffects(int arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getAvailableEffects");
	int i;
	obj->id = 0xdea20a39;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_messages_editFactCheck(InputPeer arg_peer, int arg_msg_id, TextWithEntities arg_text)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_editFactCheck");
	int i;
	obj->id = 0x0589ee75;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[1]->name, "msg_id");

	//parse argument TextWithEntities
	if (arg_text){
		obj->objs[2] = arg_text;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "text");
	}

	return obj;
}

tlo_t * tl_messages_deleteFactCheck(InputPeer arg_peer, int arg_msg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_deleteFactCheck");
	int i;
	obj->id = 0xd1da940c;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[1]->name, "msg_id");
	return obj;
}

tlo_t * tl_messages_getFactCheck(InputPeer arg_peer, int *arg_msg_id, int len_arg_msg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getFactCheck");
	int i;
	obj->id = 0xb9cdc5ee;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument Vector<int>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "msg_id");
	if (arg_msg_id){
		for(i=0; i<len_arg_msg_id; ++i){
			buf_t b = buf_add_ui32(arg_msg_id[i]);
			buf_cat(obj->objs[1]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_messages_requestMainWebView(bool arg_compact, InputPeer arg_peer, InputUser arg_bot, const char * arg_start_param, DataJSON arg_theme_params, const char * arg_platform)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_requestMainWebView");
	int i;
	obj->id = 0xc9e01e7b;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 7;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_compact);
	strcpy(obj->objs[1]->name, "compact");
	if (arg_compact)
		flagsv[nflags-1] |= (1 << 7);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//parse argument InputUser
	if (arg_bot){
		obj->objs[3] = arg_bot;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "bot");
	}


	//parse argument string
	if (arg_start_param){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 1;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_start_param, strlen(arg_start_param));
		strcpy(obj->objs[4]->name, "start_param");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument DataJSON
	if (arg_theme_params){
		obj->objs[5] = arg_theme_params;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 0;
	strcpy(obj->objs[5]->name, "theme_params");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_platform){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_platform, strlen(arg_platform));
		strcpy(obj->objs[6]->name, "platform");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_sendPaidReaction(InputPeer arg_peer, int arg_msg_id, int arg_count, long arg_random_id, Bool arg_private)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_sendPaidReaction");
	int i;
	obj->id = 0x9dd6a67b;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[1] = arg_peer;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "peer");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[2]->name, "msg_id");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_count);
	strcpy(obj->objs[3]->name, "count");

	//parse argument long
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_random_id);
	strcpy(obj->objs[4]->name, "random_id");

	//parse argument Bool
	if (arg_private){
		obj->objs[5] = arg_private;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 0;
	strcpy(obj->objs[5]->name, "private");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_messages_togglePaidReactionPrivacy(InputPeer arg_peer, int arg_msg_id, Bool arg_private)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_togglePaidReactionPrivacy");
	int i;
	obj->id = 0x849ad397;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[1]->name, "msg_id");

	//parse argument Bool
	if (arg_private){
		obj->objs[2] = arg_private;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "private");
	}

	return obj;
}

tlo_t * tl_messages_getPaidReactionPrivacy()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "messages_getPaidReactionPrivacy");
	int i;
	obj->id = 0x472455aa;
	return obj;
}

tlo_t * tl_updates_getState()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updates_getState");
	int i;
	obj->id = 0xedd4882a;
	return obj;
}

tlo_t * tl_updates_getDifference(int arg_pts, int arg_pts_limit, int arg_pts_total_limit, int arg_date, int arg_qts, int arg_qts_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updates_getDifference");
	int i;
	obj->id = 0x19c2f763;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_pts);
	strcpy(obj->objs[1]->name, "pts");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_pts_limit);
	strcpy(obj->objs[2]->name, "pts_limit");
	if (arg_pts_limit)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_pts_total_limit);
	strcpy(obj->objs[3]->name, "pts_total_limit");
	if (arg_pts_total_limit)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_date);
	strcpy(obj->objs[4]->name, "date");

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_qts);
	strcpy(obj->objs[5]->name, "qts");

	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 2;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_qts_limit);
	strcpy(obj->objs[6]->name, "qts_limit");
	if (arg_qts_limit)
		flagsv[nflags-1] |= (1 << 2);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_updates_getChannelDifference(bool arg_force, InputChannel arg_channel, ChannelMessagesFilter arg_filter, int arg_pts, int arg_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "updates_getChannelDifference");
	int i;
	obj->id = 0x03173d78;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_force);
	strcpy(obj->objs[1]->name, "force");
	if (arg_force)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[2] = arg_channel;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "channel");
	}


	//parse argument ChannelMessagesFilter
	if (arg_filter){
		obj->objs[3] = arg_filter;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "filter");
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_pts);
	strcpy(obj->objs[4]->name, "pts");

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[5]->name, "limit");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_photos_updateProfilePhoto(bool arg_fallback, InputUser arg_bot, InputPhoto arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "photos_updateProfilePhoto");
	int i;
	obj->id = 0x09e82039;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_fallback);
	strcpy(obj->objs[1]->name, "fallback");
	if (arg_fallback)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputUser
	if (arg_bot){
		obj->objs[2] = arg_bot;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 1;
	strcpy(obj->objs[2]->name, "bot");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument InputPhoto
	if (arg_id){
		obj->objs[3] = arg_id;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "id");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_photos_uploadProfilePhoto(bool arg_fallback, InputUser arg_bot, InputFile arg_file, InputFile arg_video, double arg_video_start_ts, VideoSize arg_video_emoji_markup)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "photos_uploadProfilePhoto");
	int i;
	obj->id = 0x0388a3b5;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 3;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_fallback);
	strcpy(obj->objs[1]->name, "fallback");
	if (arg_fallback)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument InputUser
	if (arg_bot){
		obj->objs[2] = arg_bot;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 5;
	strcpy(obj->objs[2]->name, "bot");
		flagsv[nflags-1] |= (1 << 5);
	}


	//parse argument InputFile
	if (arg_file){
		obj->objs[3] = arg_file;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "file");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument InputFile
	if (arg_video){
		obj->objs[4] = arg_video;
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 1;
	strcpy(obj->objs[4]->name, "video");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument double
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 2;
	obj->objs[5]->type = TYPE_LONG;
	obj->objs[5]->value = 
		buf_add_ui64(arg_video_start_ts);
	strcpy(obj->objs[5]->name, "video_start_ts");
	if (arg_video_start_ts)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument VideoSize
	if (arg_video_emoji_markup){
		obj->objs[6] = arg_video_emoji_markup;
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 4;
	strcpy(obj->objs[6]->name, "video_emoji_markup");
		flagsv[nflags-1] |= (1 << 4);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_photos_deletePhotos(InputPhoto *arg_id, int len_arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "photos_deletePhotos");
	int i;
	obj->id = 0x87cf7f2f;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<InputPhoto>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_id[i]->id);
			buf_cat(obj->objs[0]->value, arg_id[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_photos_getUserPhotos(InputUser arg_user_id, int arg_offset, long arg_max_id, int arg_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "photos_getUserPhotos");
	int i;
	obj->id = 0x91cd32a8;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument InputUser
	if (arg_user_id){
		obj->objs[0] = arg_user_id;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "user_id");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_offset);
	strcpy(obj->objs[1]->name, "offset");

	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_max_id);
	strcpy(obj->objs[2]->name, "max_id");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[3]->name, "limit");
	return obj;
}

tlo_t * tl_photos_uploadContactProfilePhoto(bool arg_suggest, bool arg_save, InputUser arg_user_id, InputFile arg_file, InputFile arg_video, double arg_video_start_ts, VideoSize arg_video_emoji_markup)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "photos_uploadContactProfilePhoto");
	int i;
	obj->id = 0xe14c4a71;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 3;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_suggest);
	strcpy(obj->objs[1]->name, "suggest");
	if (arg_suggest)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 4;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_save);
	strcpy(obj->objs[2]->name, "save");
	if (arg_save)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument InputUser
	if (arg_user_id){
		obj->objs[3] = arg_user_id;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "user_id");
	}


	//parse argument InputFile
	if (arg_file){
		obj->objs[4] = arg_file;
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "file");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument InputFile
	if (arg_video){
		obj->objs[5] = arg_video;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 1;
	strcpy(obj->objs[5]->name, "video");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument double
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 2;
	obj->objs[6]->type = TYPE_LONG;
	obj->objs[6]->value = 
		buf_add_ui64(arg_video_start_ts);
	strcpy(obj->objs[6]->name, "video_start_ts");
	if (arg_video_start_ts)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument VideoSize
	if (arg_video_emoji_markup){
		obj->objs[7] = arg_video_emoji_markup;
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 5;
	strcpy(obj->objs[7]->name, "video_emoji_markup");
		flagsv[nflags-1] |= (1 << 5);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_upload_saveFilePart(long arg_file_id, int arg_file_part, unsigned char * arg_bytes, int len_arg_bytes)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "upload_saveFilePart");
	int i;
	obj->id = 0xb304a621;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_file_id);
	strcpy(obj->objs[0]->name, "file_id");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_file_part);
	strcpy(obj->objs[1]->name, "file_part");

	//parse argument bytes
	if (arg_bytes){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_BYTES;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_bytes, len_arg_bytes);
		strcpy(obj->objs[2]->name, "bytes");
	}

	return obj;
}

tlo_t * tl_upload_getFile(bool arg_precise, bool arg_cdn_supported, InputFileLocation arg_location, long arg_offset, int arg_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "upload_getFile");
	int i;
	obj->id = 0xbe5335be;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_precise);
	strcpy(obj->objs[1]->name, "precise");
	if (arg_precise)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_cdn_supported);
	strcpy(obj->objs[2]->name, "cdn_supported");
	if (arg_cdn_supported)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument InputFileLocation
	if (arg_location){
		obj->objs[3] = arg_location;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "location");
	}


	//parse argument long
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_offset);
	strcpy(obj->objs[4]->name, "offset");

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[5]->name, "limit");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_upload_saveBigFilePart(long arg_file_id, int arg_file_part, int arg_file_total_parts, unsigned char * arg_bytes, int len_arg_bytes)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "upload_saveBigFilePart");
	int i;
	obj->id = 0xde7b673d;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_file_id);
	strcpy(obj->objs[0]->name, "file_id");

	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_file_part);
	strcpy(obj->objs[1]->name, "file_part");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_file_total_parts);
	strcpy(obj->objs[2]->name, "file_total_parts");

	//parse argument bytes
	if (arg_bytes){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_BYTES;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_bytes, len_arg_bytes);
		strcpy(obj->objs[3]->name, "bytes");
	}

	return obj;
}

tlo_t * tl_upload_getWebFile(InputWebFileLocation arg_location, int arg_offset, int arg_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "upload_getWebFile");
	int i;
	obj->id = 0x24e6818d;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputWebFileLocation
	if (arg_location){
		obj->objs[0] = arg_location;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "location");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_offset);
	strcpy(obj->objs[1]->name, "offset");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[2]->name, "limit");
	return obj;
}

tlo_t * tl_upload_getCdnFile(unsigned char * arg_file_token, int len_arg_file_token, long arg_offset, int arg_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "upload_getCdnFile");
	int i;
	obj->id = 0x395f69da;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument bytes
	if (arg_file_token){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_BYTES;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_file_token, len_arg_file_token);
		strcpy(obj->objs[0]->name, "file_token");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_offset);
	strcpy(obj->objs[1]->name, "offset");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[2]->name, "limit");
	return obj;
}

tlo_t * tl_upload_reuploadCdnFile(unsigned char * arg_file_token, int len_arg_file_token, unsigned char * arg_request_token, int len_arg_request_token)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "upload_reuploadCdnFile");
	int i;
	obj->id = 0x9b2754a8;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument bytes
	if (arg_file_token){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_BYTES;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_file_token, len_arg_file_token);
		strcpy(obj->objs[0]->name, "file_token");
	}


	//parse argument bytes
	if (arg_request_token){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_request_token, len_arg_request_token);
		strcpy(obj->objs[1]->name, "request_token");
	}

	return obj;
}

tlo_t * tl_upload_getCdnFileHashes(unsigned char * arg_file_token, int len_arg_file_token, long arg_offset)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "upload_getCdnFileHashes");
	int i;
	obj->id = 0x91dc3f31;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument bytes
	if (arg_file_token){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_BYTES;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_file_token, len_arg_file_token);
		strcpy(obj->objs[0]->name, "file_token");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_offset);
	strcpy(obj->objs[1]->name, "offset");
	return obj;
}

tlo_t * tl_upload_getFileHashes(InputFileLocation arg_location, long arg_offset)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "upload_getFileHashes");
	int i;
	obj->id = 0x9156982a;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputFileLocation
	if (arg_location){
		obj->objs[0] = arg_location;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "location");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_offset);
	strcpy(obj->objs[1]->name, "offset");
	return obj;
}

tlo_t * tl_help_getConfig()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_getConfig");
	int i;
	obj->id = 0xc4f9186b;
	return obj;
}

tlo_t * tl_help_getNearestDc()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_getNearestDc");
	int i;
	obj->id = 0x1fb33026;
	return obj;
}

tlo_t * tl_help_getAppUpdate(const char * arg_source)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_getAppUpdate");
	int i;
	obj->id = 0x522d5a7d;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_source){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_source, strlen(arg_source));
		strcpy(obj->objs[0]->name, "source");
	}

	return obj;
}

tlo_t * tl_help_getInviteText()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_getInviteText");
	int i;
	obj->id = 0x4d392343;
	return obj;
}

tlo_t * tl_help_getSupport()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_getSupport");
	int i;
	obj->id = 0x9cdf08cd;
	return obj;
}

tlo_t * tl_help_setBotUpdatesStatus(int arg_pending_updates_count, const char * arg_message)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_setBotUpdatesStatus");
	int i;
	obj->id = 0xec22cfcd;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_pending_updates_count);
	strcpy(obj->objs[0]->name, "pending_updates_count");

	//parse argument string
	if (arg_message){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_message, strlen(arg_message));
		strcpy(obj->objs[1]->name, "message");
	}

	return obj;
}

tlo_t * tl_help_getCdnConfig()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_getCdnConfig");
	int i;
	obj->id = 0x52029342;
	return obj;
}

tlo_t * tl_help_getRecentMeUrls(const char * arg_referer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_getRecentMeUrls");
	int i;
	obj->id = 0x3dc0f114;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_referer){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_referer, strlen(arg_referer));
		strcpy(obj->objs[0]->name, "referer");
	}

	return obj;
}

tlo_t * tl_help_getTermsOfServiceUpdate()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_getTermsOfServiceUpdate");
	int i;
	obj->id = 0x2ca51fd1;
	return obj;
}

tlo_t * tl_help_acceptTermsOfService(DataJSON arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_acceptTermsOfService");
	int i;
	obj->id = 0xee72f79a;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument DataJSON
	if (arg_id){
		obj->objs[0] = arg_id;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "id");
	}

	return obj;
}

tlo_t * tl_help_getDeepLinkInfo(const char * arg_path)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_getDeepLinkInfo");
	int i;
	obj->id = 0x3fedc75f;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_path){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_path, strlen(arg_path));
		strcpy(obj->objs[0]->name, "path");
	}

	return obj;
}

tlo_t * tl_help_getAppConfig(int arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_getAppConfig");
	int i;
	obj->id = 0x61e3f854;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_help_saveAppLog(InputAppEvent *arg_events, int len_arg_events)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_saveAppLog");
	int i;
	obj->id = 0x6f02f748;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<InputAppEvent>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "events");
	if (arg_events){
		for(i=0; i<len_arg_events; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_events[i]->id);
			buf_cat(obj->objs[0]->value, arg_events[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_help_getPassportConfig(int arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_getPassportConfig");
	int i;
	obj->id = 0xc661ad08;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_help_getSupportName()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_getSupportName");
	int i;
	obj->id = 0xd360e72c;
	return obj;
}

tlo_t * tl_help_getUserInfo(InputUser arg_user_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_getUserInfo");
	int i;
	obj->id = 0x038a08d3;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputUser
	if (arg_user_id){
		obj->objs[0] = arg_user_id;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "user_id");
	}

	return obj;
}

tlo_t * tl_help_editUserInfo(InputUser arg_user_id, const char * arg_message, MessageEntity *arg_entities, int len_arg_entities)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_editUserInfo");
	int i;
	obj->id = 0x66b91b70;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputUser
	if (arg_user_id){
		obj->objs[0] = arg_user_id;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "user_id");
	}


	//parse argument string
	if (arg_message){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_message, strlen(arg_message));
		strcpy(obj->objs[1]->name, "message");
	}


	//parse argument Vector<MessageEntity>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "entities");
	if (arg_entities){
		for(i=0; i<len_arg_entities; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_entities[i]->id);
			buf_cat(obj->objs[2]->value, arg_entities[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_help_getPromoData()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_getPromoData");
	int i;
	obj->id = 0xc0977421;
	return obj;
}

tlo_t * tl_help_hidePromoData(InputPeer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_hidePromoData");
	int i;
	obj->id = 0x1e251c95;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}

	return obj;
}

tlo_t * tl_help_dismissSuggestion(InputPeer arg_peer, const char * arg_suggestion)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_dismissSuggestion");
	int i;
	obj->id = 0xf50dbaa1;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument string
	if (arg_suggestion){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_suggestion, strlen(arg_suggestion));
		strcpy(obj->objs[1]->name, "suggestion");
	}

	return obj;
}

tlo_t * tl_help_getCountriesList(const char * arg_lang_code, int arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_getCountriesList");
	int i;
	obj->id = 0x735787a8;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_lang_code){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_lang_code, strlen(arg_lang_code));
		strcpy(obj->objs[0]->name, "lang_code");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_hash);
	strcpy(obj->objs[1]->name, "hash");
	return obj;
}

tlo_t * tl_help_getPremiumPromo()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_getPremiumPromo");
	int i;
	obj->id = 0xb81b93d4;
	return obj;
}

tlo_t * tl_help_getPeerColors(int arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_getPeerColors");
	int i;
	obj->id = 0xda80f42f;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_help_getPeerProfileColors(int arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_getPeerProfileColors");
	int i;
	obj->id = 0xabcfa9fd;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_help_getTimezonesList(int arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "help_getTimezonesList");
	int i;
	obj->id = 0x49b30240;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_channels_readHistory(InputChannel arg_channel, int arg_max_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_readHistory");
	int i;
	obj->id = 0xcc104937;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_max_id);
	strcpy(obj->objs[1]->name, "max_id");
	return obj;
}

tlo_t * tl_channels_deleteMessages(InputChannel arg_channel, int *arg_id, int len_arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_deleteMessages");
	int i;
	obj->id = 0x84c1fd4e;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument Vector<int>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			buf_t b = buf_add_ui32(arg_id[i]);
			buf_cat(obj->objs[1]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_channels_reportSpam(InputChannel arg_channel, InputPeer arg_participant, int *arg_id, int len_arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_reportSpam");
	int i;
	obj->id = 0xf44a8315;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument InputPeer
	if (arg_participant){
		obj->objs[1] = arg_participant;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "participant");
	}


	//parse argument Vector<int>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			buf_t b = buf_add_ui32(arg_id[i]);
			buf_cat(obj->objs[2]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_channels_getMessages(InputChannel arg_channel, InputMessage *arg_id, int len_arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_getMessages");
	int i;
	obj->id = 0xad8c9a23;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument Vector<InputMessage>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_id[i]->id);
			buf_cat(obj->objs[1]->value, arg_id[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_channels_getParticipants(InputChannel arg_channel, ChannelParticipantsFilter arg_filter, int arg_offset, int arg_limit, long arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_getParticipants");
	int i;
	obj->id = 0x77ced9d0;
	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument ChannelParticipantsFilter
	if (arg_filter){
		obj->objs[1] = arg_filter;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "filter");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_offset);
	strcpy(obj->objs[2]->name, "offset");

	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[3]->name, "limit");

	//parse argument long
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_hash);
	strcpy(obj->objs[4]->name, "hash");
	return obj;
}

tlo_t * tl_channels_getParticipant(InputChannel arg_channel, InputPeer arg_participant)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_getParticipant");
	int i;
	obj->id = 0xa0ab6cc6;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument InputPeer
	if (arg_participant){
		obj->objs[1] = arg_participant;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "participant");
	}

	return obj;
}

tlo_t * tl_channels_getChannels(InputChannel *arg_id, int len_arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_getChannels");
	int i;
	obj->id = 0x0a7f6bbb;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<InputChannel>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_id[i]->id);
			buf_cat(obj->objs[0]->value, arg_id[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_channels_getFullChannel(InputChannel arg_channel)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_getFullChannel");
	int i;
	obj->id = 0x08736a09;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}

	return obj;
}

tlo_t * tl_channels_createChannel(bool arg_broadcast, bool arg_megagroup, bool arg_for_import, bool arg_forum, const char * arg_title, const char * arg_about, InputGeoPoint arg_geo_point, const char * arg_address, int arg_ttl_period)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_createChannel");
	int i;
	obj->id = 0x91006707;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 10;
	obj->objs = 
		(tlo_t **)MALLOC(10 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_broadcast);
	strcpy(obj->objs[1]->name, "broadcast");
	if (arg_broadcast)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_megagroup);
	strcpy(obj->objs[2]->name, "megagroup");
	if (arg_megagroup)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 3;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_for_import);
	strcpy(obj->objs[3]->name, "for_import");
	if (arg_for_import)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument true
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 5;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_forum);
	strcpy(obj->objs[4]->name, "forum");
	if (arg_forum)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument string
	if (arg_title){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[5]->name, "title");
	}


	//parse argument string
	if (arg_about){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_about, strlen(arg_about));
		strcpy(obj->objs[6]->name, "about");
	}


	//parse argument InputGeoPoint
	if (arg_geo_point){
		obj->objs[7] = arg_geo_point;
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 2;
	strcpy(obj->objs[7]->name, "geo_point");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument string
	if (arg_address){
		obj->objs[8] = NEW(tlo_t, return NULL);
		obj->objs[8]->flag_num = 1;
		obj->objs[8]->flag_bit = 2;
		obj->objs[8]->type = TYPE_STRING;
		obj->objs[8]->value = 
			buf_add((ui8_t *)arg_address, strlen(arg_address));
		strcpy(obj->objs[8]->name, "address");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument int
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 1;
	obj->objs[9]->flag_bit = 4;
	obj->objs[9]->type = TYPE_INT;
	obj->objs[9]->value = 
		buf_add_ui32(arg_ttl_period);
	strcpy(obj->objs[9]->name, "ttl_period");
	if (arg_ttl_period)
		flagsv[nflags-1] |= (1 << 4);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_channels_editAdmin(InputChannel arg_channel, InputUser arg_user_id, ChatAdminRights arg_admin_rights, const char * arg_rank)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_editAdmin");
	int i;
	obj->id = 0xd33c8902;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument InputUser
	if (arg_user_id){
		obj->objs[1] = arg_user_id;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "user_id");
	}


	//parse argument ChatAdminRights
	if (arg_admin_rights){
		obj->objs[2] = arg_admin_rights;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "admin_rights");
	}


	//parse argument string
	if (arg_rank){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_rank, strlen(arg_rank));
		strcpy(obj->objs[3]->name, "rank");
	}

	return obj;
}

tlo_t * tl_channels_editTitle(InputChannel arg_channel, const char * arg_title)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_editTitle");
	int i;
	obj->id = 0x566decd0;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument string
	if (arg_title){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[1]->name, "title");
	}

	return obj;
}

tlo_t * tl_channels_editPhoto(InputChannel arg_channel, InputChatPhoto arg_photo)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_editPhoto");
	int i;
	obj->id = 0xf12e57c9;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument InputChatPhoto
	if (arg_photo){
		obj->objs[1] = arg_photo;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "photo");
	}

	return obj;
}

tlo_t * tl_channels_checkUsername(InputChannel arg_channel, const char * arg_username)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_checkUsername");
	int i;
	obj->id = 0x10e6bd2c;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument string
	if (arg_username){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_username, strlen(arg_username));
		strcpy(obj->objs[1]->name, "username");
	}

	return obj;
}

tlo_t * tl_channels_updateUsername(InputChannel arg_channel, const char * arg_username)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_updateUsername");
	int i;
	obj->id = 0x3514b3de;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument string
	if (arg_username){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_username, strlen(arg_username));
		strcpy(obj->objs[1]->name, "username");
	}

	return obj;
}

tlo_t * tl_channels_joinChannel(InputChannel arg_channel)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_joinChannel");
	int i;
	obj->id = 0x24b524c5;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}

	return obj;
}

tlo_t * tl_channels_leaveChannel(InputChannel arg_channel)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_leaveChannel");
	int i;
	obj->id = 0xf836aa95;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}

	return obj;
}

tlo_t * tl_channels_inviteToChannel(InputChannel arg_channel, InputUser *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_inviteToChannel");
	int i;
	obj->id = 0xc9e33d54;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument Vector<InputUser>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[1]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_channels_deleteChannel(InputChannel arg_channel)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_deleteChannel");
	int i;
	obj->id = 0xc0111fe3;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}

	return obj;
}

tlo_t * tl_channels_exportMessageLink(bool arg_grouped, bool arg_thread, InputChannel arg_channel, int arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_exportMessageLink");
	int i;
	obj->id = 0xe63fadeb;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_grouped);
	strcpy(obj->objs[1]->name, "grouped");
	if (arg_grouped)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_thread);
	strcpy(obj->objs[2]->name, "thread");
	if (arg_thread)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[3] = arg_channel;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "channel");
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[4]->name, "id");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_channels_toggleSignatures(bool arg_signatures_enabled, bool arg_profiles_enabled, InputChannel arg_channel)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_toggleSignatures");
	int i;
	obj->id = 0x418d549c;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_signatures_enabled);
	strcpy(obj->objs[1]->name, "signatures_enabled");
	if (arg_signatures_enabled)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_profiles_enabled);
	strcpy(obj->objs[2]->name, "profiles_enabled");
	if (arg_profiles_enabled)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[3] = arg_channel;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "channel");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_channels_getAdminedPublicChannels(bool arg_by_location, bool arg_check_limit, bool arg_for_personal)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_getAdminedPublicChannels");
	int i;
	obj->id = 0xf8b036af;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_by_location);
	strcpy(obj->objs[1]->name, "by_location");
	if (arg_by_location)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_check_limit);
	strcpy(obj->objs[2]->name, "check_limit");
	if (arg_check_limit)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_for_personal);
	strcpy(obj->objs[3]->name, "for_personal");
	if (arg_for_personal)
		flagsv[nflags-1] |= (1 << 2);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_channels_editBanned(InputChannel arg_channel, InputPeer arg_participant, ChatBannedRights arg_banned_rights)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_editBanned");
	int i;
	obj->id = 0x96e6cd81;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument InputPeer
	if (arg_participant){
		obj->objs[1] = arg_participant;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "participant");
	}


	//parse argument ChatBannedRights
	if (arg_banned_rights){
		obj->objs[2] = arg_banned_rights;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "banned_rights");
	}

	return obj;
}

tlo_t * tl_channels_getAdminLog(InputChannel arg_channel, const char * arg_q, ChannelAdminLogEventsFilter arg_events_filter, InputUser *arg_admins, int len_arg_admins, long arg_max_id, long arg_min_id, int arg_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_getAdminLog");
	int i;
	obj->id = 0x33ddf480;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[1] = arg_channel;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "channel");
	}


	//parse argument string
	if (arg_q){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_q, strlen(arg_q));
		strcpy(obj->objs[2]->name, "q");
	}


	//parse argument ChannelAdminLogEventsFilter
	if (arg_events_filter){
		obj->objs[3] = arg_events_filter;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "events_filter");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument Vector<InputUser>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 1;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "admins");
	if (arg_admins){
		for(i=0; i<len_arg_admins; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_admins[i]->id);
			buf_cat(obj->objs[4]->value, arg_admins[i]->value);
		}
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument long
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_LONG;
	obj->objs[5]->value = 
		buf_add_ui64(arg_max_id);
	strcpy(obj->objs[5]->name, "max_id");

	//parse argument long
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_LONG;
	obj->objs[6]->value = 
		buf_add_ui64(arg_min_id);
	strcpy(obj->objs[6]->name, "min_id");

	//parse argument int
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[7]->name, "limit");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_channels_setStickers(InputChannel arg_channel, InputStickerSet arg_stickerset)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_setStickers");
	int i;
	obj->id = 0xea8ca4f9;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument InputStickerSet
	if (arg_stickerset){
		obj->objs[1] = arg_stickerset;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "stickerset");
	}

	return obj;
}

tlo_t * tl_channels_readMessageContents(InputChannel arg_channel, int *arg_id, int len_arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_readMessageContents");
	int i;
	obj->id = 0xeab5dc38;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument Vector<int>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			buf_t b = buf_add_ui32(arg_id[i]);
			buf_cat(obj->objs[1]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_channels_deleteHistory(bool arg_for_everyone, InputChannel arg_channel, int arg_max_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_deleteHistory");
	int i;
	obj->id = 0x9baa9647;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_for_everyone);
	strcpy(obj->objs[1]->name, "for_everyone");
	if (arg_for_everyone)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[2] = arg_channel;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "channel");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_max_id);
	strcpy(obj->objs[3]->name, "max_id");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_channels_togglePreHistoryHidden(InputChannel arg_channel, Bool arg_enabled)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_togglePreHistoryHidden");
	int i;
	obj->id = 0xeabbb94c;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument Bool
	if (arg_enabled){
		obj->objs[1] = arg_enabled;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "enabled");
	}

	return obj;
}

tlo_t * tl_channels_getLeftChannels(int arg_offset)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_getLeftChannels");
	int i;
	obj->id = 0x8341ecc0;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_offset);
	strcpy(obj->objs[0]->name, "offset");
	return obj;
}

tlo_t * tl_channels_getGroupsForDiscussion()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_getGroupsForDiscussion");
	int i;
	obj->id = 0xf5dad378;
	return obj;
}

tlo_t * tl_channels_setDiscussionGroup(InputChannel arg_broadcast, InputChannel arg_group)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_setDiscussionGroup");
	int i;
	obj->id = 0x40582bb2;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_broadcast){
		obj->objs[0] = arg_broadcast;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "broadcast");
	}


	//parse argument InputChannel
	if (arg_group){
		obj->objs[1] = arg_group;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "group");
	}

	return obj;
}

tlo_t * tl_channels_editCreator(InputChannel arg_channel, InputUser arg_user_id, InputCheckPasswordSRP arg_password)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_editCreator");
	int i;
	obj->id = 0x8f38cd1f;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument InputUser
	if (arg_user_id){
		obj->objs[1] = arg_user_id;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "user_id");
	}


	//parse argument InputCheckPasswordSRP
	if (arg_password){
		obj->objs[2] = arg_password;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "password");
	}

	return obj;
}

tlo_t * tl_channels_editLocation(InputChannel arg_channel, InputGeoPoint arg_geo_point, const char * arg_address)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_editLocation");
	int i;
	obj->id = 0x58e63f6d;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument InputGeoPoint
	if (arg_geo_point){
		obj->objs[1] = arg_geo_point;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "geo_point");
	}


	//parse argument string
	if (arg_address){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_address, strlen(arg_address));
		strcpy(obj->objs[2]->name, "address");
	}

	return obj;
}

tlo_t * tl_channels_toggleSlowMode(InputChannel arg_channel, int arg_seconds)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_toggleSlowMode");
	int i;
	obj->id = 0xedd49ef0;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_seconds);
	strcpy(obj->objs[1]->name, "seconds");
	return obj;
}

tlo_t * tl_channels_getInactiveChannels()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_getInactiveChannels");
	int i;
	obj->id = 0x11e831ee;
	return obj;
}

tlo_t * tl_channels_convertToGigagroup(InputChannel arg_channel)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_convertToGigagroup");
	int i;
	obj->id = 0x0b290c69;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}

	return obj;
}

tlo_t * tl_channels_viewSponsoredMessage(InputChannel arg_channel, unsigned char * arg_random_id, int len_arg_random_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_viewSponsoredMessage");
	int i;
	obj->id = 0xbeaedb94;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument bytes
	if (arg_random_id){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_random_id, len_arg_random_id);
		strcpy(obj->objs[1]->name, "random_id");
	}

	return obj;
}

tlo_t * tl_channels_getSponsoredMessages(InputChannel arg_channel)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_getSponsoredMessages");
	int i;
	obj->id = 0xec210fbf;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}

	return obj;
}

tlo_t * tl_channels_getSendAs(InputPeer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_getSendAs");
	int i;
	obj->id = 0x0dc770ee;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}

	return obj;
}

tlo_t * tl_channels_deleteParticipantHistory(InputChannel arg_channel, InputPeer arg_participant)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_deleteParticipantHistory");
	int i;
	obj->id = 0x367544db;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument InputPeer
	if (arg_participant){
		obj->objs[1] = arg_participant;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "participant");
	}

	return obj;
}

tlo_t * tl_channels_toggleJoinToSend(InputChannel arg_channel, Bool arg_enabled)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_toggleJoinToSend");
	int i;
	obj->id = 0xe4cb9580;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument Bool
	if (arg_enabled){
		obj->objs[1] = arg_enabled;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "enabled");
	}

	return obj;
}

tlo_t * tl_channels_toggleJoinRequest(InputChannel arg_channel, Bool arg_enabled)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_toggleJoinRequest");
	int i;
	obj->id = 0x4c2985b6;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument Bool
	if (arg_enabled){
		obj->objs[1] = arg_enabled;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "enabled");
	}

	return obj;
}

tlo_t * tl_channels_reorderUsernames(InputChannel arg_channel, const char * *arg_order, int len_arg_order)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_reorderUsernames");
	int i;
	obj->id = 0xb45ced1d;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument Vector<string>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "order");
	if (arg_order){
		for(i=0; i<len_arg_order; ++i){
			int len = strlen(arg_order[i]);
			buf_t b = buf_add((ui8_t *)arg_order[i], len);
			buf_cat(obj->objs[1]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_channels_toggleUsername(InputChannel arg_channel, const char * arg_username, Bool arg_active)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_toggleUsername");
	int i;
	obj->id = 0x50f24105;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument string
	if (arg_username){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_username, strlen(arg_username));
		strcpy(obj->objs[1]->name, "username");
	}


	//parse argument Bool
	if (arg_active){
		obj->objs[2] = arg_active;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "active");
	}

	return obj;
}

tlo_t * tl_channels_deactivateAllUsernames(InputChannel arg_channel)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_deactivateAllUsernames");
	int i;
	obj->id = 0x0a245dd3;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}

	return obj;
}

tlo_t * tl_channels_toggleForum(InputChannel arg_channel, Bool arg_enabled)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_toggleForum");
	int i;
	obj->id = 0xa4298b29;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument Bool
	if (arg_enabled){
		obj->objs[1] = arg_enabled;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "enabled");
	}

	return obj;
}

tlo_t * tl_channels_createForumTopic(InputChannel arg_channel, const char * arg_title, int arg_icon_color, long arg_icon_emoji_id, long arg_random_id, InputPeer arg_send_as)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_createForumTopic");
	int i;
	obj->id = 0xf40c0224;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[1] = arg_channel;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "channel");
	}


	//parse argument string
	if (arg_title){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[2]->name, "title");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_icon_color);
	strcpy(obj->objs[3]->name, "icon_color");
	if (arg_icon_color)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument long
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 3;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_icon_emoji_id);
	strcpy(obj->objs[4]->name, "icon_emoji_id");
	if (arg_icon_emoji_id)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument long
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_LONG;
	obj->objs[5]->value = 
		buf_add_ui64(arg_random_id);
	strcpy(obj->objs[5]->name, "random_id");

	//parse argument InputPeer
	if (arg_send_as){
		obj->objs[6] = arg_send_as;
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 2;
	strcpy(obj->objs[6]->name, "send_as");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_channels_getForumTopics(InputChannel arg_channel, const char * arg_q, int arg_offset_date, int arg_offset_id, int arg_offset_topic, int arg_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_getForumTopics");
	int i;
	obj->id = 0x0de560d1;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[1] = arg_channel;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "channel");
	}


	//parse argument string
	if (arg_q){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_q, strlen(arg_q));
		strcpy(obj->objs[2]->name, "q");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_offset_date);
	strcpy(obj->objs[3]->name, "offset_date");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_offset_id);
	strcpy(obj->objs[4]->name, "offset_id");

	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_offset_topic);
	strcpy(obj->objs[5]->name, "offset_topic");

	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[6]->name, "limit");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_channels_getForumTopicsByID(InputChannel arg_channel, int *arg_topics, int len_arg_topics)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_getForumTopicsByID");
	int i;
	obj->id = 0xb0831eb9;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument Vector<int>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "topics");
	if (arg_topics){
		for(i=0; i<len_arg_topics; ++i){
			buf_t b = buf_add_ui32(arg_topics[i]);
			buf_cat(obj->objs[1]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_channels_editForumTopic(InputChannel arg_channel, int arg_topic_id, const char * arg_title, long arg_icon_emoji_id, Bool arg_closed, Bool arg_hidden)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_editForumTopic");
	int i;
	obj->id = 0xf4dfa185;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[1] = arg_channel;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "channel");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_topic_id);
	strcpy(obj->objs[2]->name, "topic_id");

	//parse argument string
	if (arg_title){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[3]->name, "title");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument long
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 1;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_icon_emoji_id);
	strcpy(obj->objs[4]->name, "icon_emoji_id");
	if (arg_icon_emoji_id)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument Bool
	if (arg_closed){
		obj->objs[5] = arg_closed;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 2;
	strcpy(obj->objs[5]->name, "closed");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument Bool
	if (arg_hidden){
		obj->objs[6] = arg_hidden;
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 3;
	strcpy(obj->objs[6]->name, "hidden");
		flagsv[nflags-1] |= (1 << 3);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_channels_updatePinnedForumTopic(InputChannel arg_channel, int arg_topic_id, Bool arg_pinned)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_updatePinnedForumTopic");
	int i;
	obj->id = 0x6c2d9026;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_topic_id);
	strcpy(obj->objs[1]->name, "topic_id");

	//parse argument Bool
	if (arg_pinned){
		obj->objs[2] = arg_pinned;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "pinned");
	}

	return obj;
}

tlo_t * tl_channels_deleteTopicHistory(InputChannel arg_channel, int arg_top_msg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_deleteTopicHistory");
	int i;
	obj->id = 0x34435f2d;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_top_msg_id);
	strcpy(obj->objs[1]->name, "top_msg_id");
	return obj;
}

tlo_t * tl_channels_reorderPinnedForumTopics(bool arg_force, InputChannel arg_channel, int *arg_order, int len_arg_order)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_reorderPinnedForumTopics");
	int i;
	obj->id = 0x2950a18f;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_force);
	strcpy(obj->objs[1]->name, "force");
	if (arg_force)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[2] = arg_channel;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "channel");
	}


	//parse argument Vector<int>
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_VECTOR;
	strcpy(obj->objs[3]->name, "order");
	if (arg_order){
		for(i=0; i<len_arg_order; ++i){
			buf_t b = buf_add_ui32(arg_order[i]);
			buf_cat(obj->objs[3]->value, b);
		}
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_channels_toggleAntiSpam(InputChannel arg_channel, Bool arg_enabled)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_toggleAntiSpam");
	int i;
	obj->id = 0x68f3e4eb;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument Bool
	if (arg_enabled){
		obj->objs[1] = arg_enabled;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "enabled");
	}

	return obj;
}

tlo_t * tl_channels_reportAntiSpamFalsePositive(InputChannel arg_channel, int arg_msg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_reportAntiSpamFalsePositive");
	int i;
	obj->id = 0xa850a693;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[1]->name, "msg_id");
	return obj;
}

tlo_t * tl_channels_toggleParticipantsHidden(InputChannel arg_channel, Bool arg_enabled)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_toggleParticipantsHidden");
	int i;
	obj->id = 0x6a6e7854;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument Bool
	if (arg_enabled){
		obj->objs[1] = arg_enabled;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "enabled");
	}

	return obj;
}

tlo_t * tl_channels_clickSponsoredMessage(bool arg_media, bool arg_fullscreen, InputChannel arg_channel, unsigned char * arg_random_id, int len_arg_random_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_clickSponsoredMessage");
	int i;
	obj->id = 0x01445d75;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_media);
	strcpy(obj->objs[1]->name, "media");
	if (arg_media)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_fullscreen);
	strcpy(obj->objs[2]->name, "fullscreen");
	if (arg_fullscreen)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[3] = arg_channel;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "channel");
	}


	//parse argument bytes
	if (arg_random_id){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_BYTES;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_random_id, len_arg_random_id);
		strcpy(obj->objs[4]->name, "random_id");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_channels_updateColor(bool arg_for_profile, InputChannel arg_channel, int arg_color, long arg_background_emoji_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_updateColor");
	int i;
	obj->id = 0xd8aa3671;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_for_profile);
	strcpy(obj->objs[1]->name, "for_profile");
	if (arg_for_profile)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[2] = arg_channel;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "channel");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_color);
	strcpy(obj->objs[3]->name, "color");
	if (arg_color)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument long
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_LONG;
	obj->objs[4]->value = 
		buf_add_ui64(arg_background_emoji_id);
	strcpy(obj->objs[4]->name, "background_emoji_id");
	if (arg_background_emoji_id)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_channels_toggleViewForumAsMessages(InputChannel arg_channel, Bool arg_enabled)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_toggleViewForumAsMessages");
	int i;
	obj->id = 0x9738bb15;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument Bool
	if (arg_enabled){
		obj->objs[1] = arg_enabled;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "enabled");
	}

	return obj;
}

tlo_t * tl_channels_getChannelRecommendations(InputChannel arg_channel)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_getChannelRecommendations");
	int i;
	obj->id = 0x25a71742;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[1] = arg_channel;
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "channel");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_channels_updateEmojiStatus(InputChannel arg_channel, EmojiStatus arg_emoji_status)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_updateEmojiStatus");
	int i;
	obj->id = 0xf0d3e6a8;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument EmojiStatus
	if (arg_emoji_status){
		obj->objs[1] = arg_emoji_status;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "emoji_status");
	}

	return obj;
}

tlo_t * tl_channels_setBoostsToUnblockRestrictions(InputChannel arg_channel, int arg_boosts)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_setBoostsToUnblockRestrictions");
	int i;
	obj->id = 0xad399cee;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_boosts);
	strcpy(obj->objs[1]->name, "boosts");
	return obj;
}

tlo_t * tl_channels_setEmojiStickers(InputChannel arg_channel, InputStickerSet arg_stickerset)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_setEmojiStickers");
	int i;
	obj->id = 0x3cd930b7;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument InputStickerSet
	if (arg_stickerset){
		obj->objs[1] = arg_stickerset;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "stickerset");
	}

	return obj;
}

tlo_t * tl_channels_reportSponsoredMessage(InputChannel arg_channel, unsigned char * arg_random_id, int len_arg_random_id, unsigned char * arg_option, int len_arg_option)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_reportSponsoredMessage");
	int i;
	obj->id = 0xaf8ff6b9;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument bytes
	if (arg_random_id){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_random_id, len_arg_random_id);
		strcpy(obj->objs[1]->name, "random_id");
	}


	//parse argument bytes
	if (arg_option){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_BYTES;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_option, len_arg_option);
		strcpy(obj->objs[2]->name, "option");
	}

	return obj;
}

tlo_t * tl_channels_restrictSponsoredMessages(InputChannel arg_channel, Bool arg_restricted)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_restrictSponsoredMessages");
	int i;
	obj->id = 0x9ae91519;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument Bool
	if (arg_restricted){
		obj->objs[1] = arg_restricted;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "restricted");
	}

	return obj;
}

tlo_t * tl_channels_searchPosts(const char * arg_hashtag, int arg_offset_rate, InputPeer arg_offset_peer, int arg_offset_id, int arg_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "channels_searchPosts");
	int i;
	obj->id = 0xd19f987b;
	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_hashtag){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_hashtag, strlen(arg_hashtag));
		strcpy(obj->objs[0]->name, "hashtag");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_offset_rate);
	strcpy(obj->objs[1]->name, "offset_rate");

	//parse argument InputPeer
	if (arg_offset_peer){
		obj->objs[2] = arg_offset_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "offset_peer");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_offset_id);
	strcpy(obj->objs[3]->name, "offset_id");

	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[4]->name, "limit");
	return obj;
}

tlo_t * tl_bots_sendCustomRequest(const char * arg_custom_method, DataJSON arg_params)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "bots_sendCustomRequest");
	int i;
	obj->id = 0xaa2769ed;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_custom_method){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_custom_method, strlen(arg_custom_method));
		strcpy(obj->objs[0]->name, "custom_method");
	}


	//parse argument DataJSON
	if (arg_params){
		obj->objs[1] = arg_params;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "params");
	}

	return obj;
}

tlo_t * tl_bots_answerWebhookJSONQuery(long arg_query_id, DataJSON arg_data)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "bots_answerWebhookJSONQuery");
	int i;
	obj->id = 0xe6213f4d;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_query_id);
	strcpy(obj->objs[0]->name, "query_id");

	//parse argument DataJSON
	if (arg_data){
		obj->objs[1] = arg_data;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "data");
	}

	return obj;
}

tlo_t * tl_bots_setBotCommands(BotCommandScope arg_scope, const char * arg_lang_code, BotCommand *arg_commands, int len_arg_commands)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "bots_setBotCommands");
	int i;
	obj->id = 0x0517165a;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument BotCommandScope
	if (arg_scope){
		obj->objs[0] = arg_scope;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "scope");
	}


	//parse argument string
	if (arg_lang_code){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_lang_code, strlen(arg_lang_code));
		strcpy(obj->objs[1]->name, "lang_code");
	}


	//parse argument Vector<BotCommand>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "commands");
	if (arg_commands){
		for(i=0; i<len_arg_commands; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_commands[i]->id);
			buf_cat(obj->objs[2]->value, arg_commands[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_bots_resetBotCommands(BotCommandScope arg_scope, const char * arg_lang_code)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "bots_resetBotCommands");
	int i;
	obj->id = 0x3d8de0f9;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument BotCommandScope
	if (arg_scope){
		obj->objs[0] = arg_scope;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "scope");
	}


	//parse argument string
	if (arg_lang_code){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_lang_code, strlen(arg_lang_code));
		strcpy(obj->objs[1]->name, "lang_code");
	}

	return obj;
}

tlo_t * tl_bots_getBotCommands(BotCommandScope arg_scope, const char * arg_lang_code)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "bots_getBotCommands");
	int i;
	obj->id = 0xe34c0dd6;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument BotCommandScope
	if (arg_scope){
		obj->objs[0] = arg_scope;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "scope");
	}


	//parse argument string
	if (arg_lang_code){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_lang_code, strlen(arg_lang_code));
		strcpy(obj->objs[1]->name, "lang_code");
	}

	return obj;
}

tlo_t * tl_bots_setBotMenuButton(InputUser arg_user_id, BotMenuButton arg_button)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "bots_setBotMenuButton");
	int i;
	obj->id = 0x4504d54f;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputUser
	if (arg_user_id){
		obj->objs[0] = arg_user_id;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "user_id");
	}


	//parse argument BotMenuButton
	if (arg_button){
		obj->objs[1] = arg_button;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "button");
	}

	return obj;
}

tlo_t * tl_bots_getBotMenuButton(InputUser arg_user_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "bots_getBotMenuButton");
	int i;
	obj->id = 0x9c60eb28;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputUser
	if (arg_user_id){
		obj->objs[0] = arg_user_id;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "user_id");
	}

	return obj;
}

tlo_t * tl_bots_setBotBroadcastDefaultAdminRights(ChatAdminRights arg_admin_rights)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "bots_setBotBroadcastDefaultAdminRights");
	int i;
	obj->id = 0x788464e1;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument ChatAdminRights
	if (arg_admin_rights){
		obj->objs[0] = arg_admin_rights;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "admin_rights");
	}

	return obj;
}

tlo_t * tl_bots_setBotGroupDefaultAdminRights(ChatAdminRights arg_admin_rights)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "bots_setBotGroupDefaultAdminRights");
	int i;
	obj->id = 0x925ec9ea;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument ChatAdminRights
	if (arg_admin_rights){
		obj->objs[0] = arg_admin_rights;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "admin_rights");
	}

	return obj;
}

tlo_t * tl_bots_setBotInfo(InputUser arg_bot, const char * arg_lang_code, const char * arg_name, const char * arg_about, const char * arg_description)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "bots_setBotInfo");
	int i;
	obj->id = 0x10cf3123;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputUser
	if (arg_bot){
		obj->objs[1] = arg_bot;
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 2;
	strcpy(obj->objs[1]->name, "bot");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument string
	if (arg_lang_code){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_lang_code, strlen(arg_lang_code));
		strcpy(obj->objs[2]->name, "lang_code");
	}


	//parse argument string
	if (arg_name){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 3;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_name, strlen(arg_name));
		strcpy(obj->objs[3]->name, "name");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument string
	if (arg_about){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_about, strlen(arg_about));
		strcpy(obj->objs[4]->name, "about");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_description){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 1;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_description, strlen(arg_description));
		strcpy(obj->objs[5]->name, "description");
		flagsv[nflags-1] |= (1 << 1);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_bots_getBotInfo(InputUser arg_bot, const char * arg_lang_code)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "bots_getBotInfo");
	int i;
	obj->id = 0xdcd914fd;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputUser
	if (arg_bot){
		obj->objs[1] = arg_bot;
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "bot");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_lang_code){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_lang_code, strlen(arg_lang_code));
		strcpy(obj->objs[2]->name, "lang_code");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_bots_reorderUsernames(InputUser arg_bot, const char * *arg_order, int len_arg_order)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "bots_reorderUsernames");
	int i;
	obj->id = 0x9709b1c2;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputUser
	if (arg_bot){
		obj->objs[0] = arg_bot;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "bot");
	}


	//parse argument Vector<string>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "order");
	if (arg_order){
		for(i=0; i<len_arg_order; ++i){
			int len = strlen(arg_order[i]);
			buf_t b = buf_add((ui8_t *)arg_order[i], len);
			buf_cat(obj->objs[1]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_bots_toggleUsername(InputUser arg_bot, const char * arg_username, Bool arg_active)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "bots_toggleUsername");
	int i;
	obj->id = 0x053ca973;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputUser
	if (arg_bot){
		obj->objs[0] = arg_bot;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "bot");
	}


	//parse argument string
	if (arg_username){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_username, strlen(arg_username));
		strcpy(obj->objs[1]->name, "username");
	}


	//parse argument Bool
	if (arg_active){
		obj->objs[2] = arg_active;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "active");
	}

	return obj;
}

tlo_t * tl_bots_canSendMessage(InputUser arg_bot)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "bots_canSendMessage");
	int i;
	obj->id = 0x1359f4e6;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputUser
	if (arg_bot){
		obj->objs[0] = arg_bot;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "bot");
	}

	return obj;
}

tlo_t * tl_bots_allowSendMessage(InputUser arg_bot)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "bots_allowSendMessage");
	int i;
	obj->id = 0xf132e3ef;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputUser
	if (arg_bot){
		obj->objs[0] = arg_bot;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "bot");
	}

	return obj;
}

tlo_t * tl_bots_invokeWebViewCustomMethod(InputUser arg_bot, const char * arg_custom_method, DataJSON arg_params)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "bots_invokeWebViewCustomMethod");
	int i;
	obj->id = 0x087fc5e7;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputUser
	if (arg_bot){
		obj->objs[0] = arg_bot;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "bot");
	}


	//parse argument string
	if (arg_custom_method){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_custom_method, strlen(arg_custom_method));
		strcpy(obj->objs[1]->name, "custom_method");
	}


	//parse argument DataJSON
	if (arg_params){
		obj->objs[2] = arg_params;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "params");
	}

	return obj;
}

tlo_t * tl_bots_getPopularAppBots(const char * arg_offset, int arg_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "bots_getPopularAppBots");
	int i;
	obj->id = 0xc2510192;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_offset){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_offset, strlen(arg_offset));
		strcpy(obj->objs[0]->name, "offset");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[1]->name, "limit");
	return obj;
}

tlo_t * tl_bots_addPreviewMedia(InputUser arg_bot, const char * arg_lang_code, InputMedia arg_media)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "bots_addPreviewMedia");
	int i;
	obj->id = 0x17aeb75a;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputUser
	if (arg_bot){
		obj->objs[0] = arg_bot;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "bot");
	}


	//parse argument string
	if (arg_lang_code){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_lang_code, strlen(arg_lang_code));
		strcpy(obj->objs[1]->name, "lang_code");
	}


	//parse argument InputMedia
	if (arg_media){
		obj->objs[2] = arg_media;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "media");
	}

	return obj;
}

tlo_t * tl_bots_editPreviewMedia(InputUser arg_bot, const char * arg_lang_code, InputMedia arg_media, InputMedia arg_new_media)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "bots_editPreviewMedia");
	int i;
	obj->id = 0x8525606f;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument InputUser
	if (arg_bot){
		obj->objs[0] = arg_bot;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "bot");
	}


	//parse argument string
	if (arg_lang_code){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_lang_code, strlen(arg_lang_code));
		strcpy(obj->objs[1]->name, "lang_code");
	}


	//parse argument InputMedia
	if (arg_media){
		obj->objs[2] = arg_media;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "media");
	}


	//parse argument InputMedia
	if (arg_new_media){
		obj->objs[3] = arg_new_media;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "new_media");
	}

	return obj;
}

tlo_t * tl_bots_deletePreviewMedia(InputUser arg_bot, const char * arg_lang_code, InputMedia *arg_media, int len_arg_media)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "bots_deletePreviewMedia");
	int i;
	obj->id = 0x2d0135b3;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputUser
	if (arg_bot){
		obj->objs[0] = arg_bot;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "bot");
	}


	//parse argument string
	if (arg_lang_code){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_lang_code, strlen(arg_lang_code));
		strcpy(obj->objs[1]->name, "lang_code");
	}


	//parse argument Vector<InputMedia>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "media");
	if (arg_media){
		for(i=0; i<len_arg_media; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_media[i]->id);
			buf_cat(obj->objs[2]->value, arg_media[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_bots_reorderPreviewMedias(InputUser arg_bot, const char * arg_lang_code, InputMedia *arg_order, int len_arg_order)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "bots_reorderPreviewMedias");
	int i;
	obj->id = 0xb627f3aa;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputUser
	if (arg_bot){
		obj->objs[0] = arg_bot;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "bot");
	}


	//parse argument string
	if (arg_lang_code){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_lang_code, strlen(arg_lang_code));
		strcpy(obj->objs[1]->name, "lang_code");
	}


	//parse argument Vector<InputMedia>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "order");
	if (arg_order){
		for(i=0; i<len_arg_order; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_order[i]->id);
			buf_cat(obj->objs[2]->value, arg_order[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_bots_getPreviewInfo(InputUser arg_bot, const char * arg_lang_code)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "bots_getPreviewInfo");
	int i;
	obj->id = 0x423ab3ad;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputUser
	if (arg_bot){
		obj->objs[0] = arg_bot;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "bot");
	}


	//parse argument string
	if (arg_lang_code){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_lang_code, strlen(arg_lang_code));
		strcpy(obj->objs[1]->name, "lang_code");
	}

	return obj;
}

tlo_t * tl_bots_getPreviewMedias(InputUser arg_bot)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "bots_getPreviewMedias");
	int i;
	obj->id = 0xa2a5594d;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputUser
	if (arg_bot){
		obj->objs[0] = arg_bot;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "bot");
	}

	return obj;
}

tlo_t * tl_payments_getPaymentForm(InputInvoice arg_invoice, DataJSON arg_theme_params)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_getPaymentForm");
	int i;
	obj->id = 0x37148dbb;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputInvoice
	if (arg_invoice){
		obj->objs[1] = arg_invoice;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "invoice");
	}


	//parse argument DataJSON
	if (arg_theme_params){
		obj->objs[2] = arg_theme_params;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "theme_params");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_payments_getPaymentReceipt(InputPeer arg_peer, int arg_msg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_getPaymentReceipt");
	int i;
	obj->id = 0x2478d1cc;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[1]->name, "msg_id");
	return obj;
}

tlo_t * tl_payments_validateRequestedInfo(bool arg_save, InputInvoice arg_invoice, PaymentRequestedInfo arg_info)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_validateRequestedInfo");
	int i;
	obj->id = 0xb6c8f12b;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_save);
	strcpy(obj->objs[1]->name, "save");
	if (arg_save)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputInvoice
	if (arg_invoice){
		obj->objs[2] = arg_invoice;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "invoice");
	}


	//parse argument PaymentRequestedInfo
	if (arg_info){
		obj->objs[3] = arg_info;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "info");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_payments_sendPaymentForm(long arg_form_id, InputInvoice arg_invoice, const char * arg_requested_info_id, const char * arg_shipping_option_id, InputPaymentCredentials arg_credentials, long arg_tip_amount)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_sendPaymentForm");
	int i;
	obj->id = 0x2d03522f;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_form_id);
	strcpy(obj->objs[1]->name, "form_id");

	//parse argument InputInvoice
	if (arg_invoice){
		obj->objs[2] = arg_invoice;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "invoice");
	}


	//parse argument string
	if (arg_requested_info_id){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_requested_info_id, strlen(arg_requested_info_id));
		strcpy(obj->objs[3]->name, "requested_info_id");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_shipping_option_id){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 1;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_shipping_option_id, strlen(arg_shipping_option_id));
		strcpy(obj->objs[4]->name, "shipping_option_id");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument InputPaymentCredentials
	if (arg_credentials){
		obj->objs[5] = arg_credentials;
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
	strcpy(obj->objs[5]->name, "credentials");
	}


	//parse argument long
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 2;
	obj->objs[6]->type = TYPE_LONG;
	obj->objs[6]->value = 
		buf_add_ui64(arg_tip_amount);
	strcpy(obj->objs[6]->name, "tip_amount");
	if (arg_tip_amount)
		flagsv[nflags-1] |= (1 << 2);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_payments_getSavedInfo()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_getSavedInfo");
	int i;
	obj->id = 0x227d824b;
	return obj;
}

tlo_t * tl_payments_clearSavedInfo(bool arg_credentials, bool arg_info)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_clearSavedInfo");
	int i;
	obj->id = 0xd83d70c1;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_credentials);
	strcpy(obj->objs[1]->name, "credentials");
	if (arg_credentials)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_info);
	strcpy(obj->objs[2]->name, "info");
	if (arg_info)
		flagsv[nflags-1] |= (1 << 1);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_payments_getBankCardData(const char * arg_number)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_getBankCardData");
	int i;
	obj->id = 0x2e79d779;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_number){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_number, strlen(arg_number));
		strcpy(obj->objs[0]->name, "number");
	}

	return obj;
}

tlo_t * tl_payments_exportInvoice(InputMedia arg_invoice_media)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_exportInvoice");
	int i;
	obj->id = 0x0f91b065;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputMedia
	if (arg_invoice_media){
		obj->objs[0] = arg_invoice_media;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "invoice_media");
	}

	return obj;
}

tlo_t * tl_payments_assignAppStoreTransaction(unsigned char * arg_receipt, int len_arg_receipt, InputStorePaymentPurpose arg_purpose)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_assignAppStoreTransaction");
	int i;
	obj->id = 0x80ed747d;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument bytes
	if (arg_receipt){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_BYTES;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_receipt, len_arg_receipt);
		strcpy(obj->objs[0]->name, "receipt");
	}


	//parse argument InputStorePaymentPurpose
	if (arg_purpose){
		obj->objs[1] = arg_purpose;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "purpose");
	}

	return obj;
}

tlo_t * tl_payments_assignPlayMarketTransaction(DataJSON arg_receipt, InputStorePaymentPurpose arg_purpose)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_assignPlayMarketTransaction");
	int i;
	obj->id = 0xdffd50d3;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument DataJSON
	if (arg_receipt){
		obj->objs[0] = arg_receipt;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "receipt");
	}


	//parse argument InputStorePaymentPurpose
	if (arg_purpose){
		obj->objs[1] = arg_purpose;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "purpose");
	}

	return obj;
}

tlo_t * tl_payments_canPurchasePremium(InputStorePaymentPurpose arg_purpose)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_canPurchasePremium");
	int i;
	obj->id = 0x9fc19eb6;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputStorePaymentPurpose
	if (arg_purpose){
		obj->objs[0] = arg_purpose;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "purpose");
	}

	return obj;
}

tlo_t * tl_payments_getPremiumGiftCodeOptions(InputPeer arg_boost_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_getPremiumGiftCodeOptions");
	int i;
	obj->id = 0x2757ba54;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputPeer
	if (arg_boost_peer){
		obj->objs[1] = arg_boost_peer;
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "boost_peer");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_payments_checkGiftCode(const char * arg_slug)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_checkGiftCode");
	int i;
	obj->id = 0x8e51b4c1;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_slug){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_slug, strlen(arg_slug));
		strcpy(obj->objs[0]->name, "slug");
	}

	return obj;
}

tlo_t * tl_payments_applyGiftCode(const char * arg_slug)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_applyGiftCode");
	int i;
	obj->id = 0xf6e26854;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_slug){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_slug, strlen(arg_slug));
		strcpy(obj->objs[0]->name, "slug");
	}

	return obj;
}

tlo_t * tl_payments_getGiveawayInfo(InputPeer arg_peer, int arg_msg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_getGiveawayInfo");
	int i;
	obj->id = 0xf4239425;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[1]->name, "msg_id");
	return obj;
}

tlo_t * tl_payments_launchPrepaidGiveaway(InputPeer arg_peer, long arg_giveaway_id, InputStorePaymentPurpose arg_purpose)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_launchPrepaidGiveaway");
	int i;
	obj->id = 0x5ff58f20;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_giveaway_id);
	strcpy(obj->objs[1]->name, "giveaway_id");

	//parse argument InputStorePaymentPurpose
	if (arg_purpose){
		obj->objs[2] = arg_purpose;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "purpose");
	}

	return obj;
}

tlo_t * tl_payments_getStarsTopupOptions()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_getStarsTopupOptions");
	int i;
	obj->id = 0xc00ec7d3;
	return obj;
}

tlo_t * tl_payments_getStarsStatus(InputPeer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_getStarsStatus");
	int i;
	obj->id = 0x104fcfa7;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}

	return obj;
}

tlo_t * tl_payments_getStarsTransactions(bool arg_inbound, bool arg_outbound, bool arg_ascending, const char * arg_subscription_id, InputPeer arg_peer, const char * arg_offset, int arg_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_getStarsTransactions");
	int i;
	obj->id = 0x69da4557;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_inbound);
	strcpy(obj->objs[1]->name, "inbound");
	if (arg_inbound)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_outbound);
	strcpy(obj->objs[2]->name, "outbound");
	if (arg_outbound)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 2;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_ascending);
	strcpy(obj->objs[3]->name, "ascending");
	if (arg_ascending)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument string
	if (arg_subscription_id){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 3;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_subscription_id, strlen(arg_subscription_id));
		strcpy(obj->objs[4]->name, "subscription_id");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument InputPeer
	if (arg_peer){
		obj->objs[5] = arg_peer;
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
	strcpy(obj->objs[5]->name, "peer");
	}


	//parse argument string
	if (arg_offset){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_offset, strlen(arg_offset));
		strcpy(obj->objs[6]->name, "offset");
	}


	//parse argument int
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 0;
	obj->objs[7]->flag_bit = 0;
	obj->objs[7]->type = TYPE_INT;
	obj->objs[7]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[7]->name, "limit");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_payments_sendStarsForm(long arg_form_id, InputInvoice arg_invoice)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_sendStarsForm");
	int i;
	obj->id = 0x7998c914;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument long
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_LONG;
	obj->objs[0]->value = 
		buf_add_ui64(arg_form_id);
	strcpy(obj->objs[0]->name, "form_id");

	//parse argument InputInvoice
	if (arg_invoice){
		obj->objs[1] = arg_invoice;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "invoice");
	}

	return obj;
}

tlo_t * tl_payments_refundStarsCharge(InputUser arg_user_id, const char * arg_charge_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_refundStarsCharge");
	int i;
	obj->id = 0x25ae8f4a;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputUser
	if (arg_user_id){
		obj->objs[0] = arg_user_id;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "user_id");
	}


	//parse argument string
	if (arg_charge_id){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_charge_id, strlen(arg_charge_id));
		strcpy(obj->objs[1]->name, "charge_id");
	}

	return obj;
}

tlo_t * tl_payments_getStarsRevenueStats(bool arg_dark, InputPeer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_getStarsRevenueStats");
	int i;
	obj->id = 0xd91ffad6;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_dark);
	strcpy(obj->objs[1]->name, "dark");
	if (arg_dark)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_payments_getStarsRevenueWithdrawalUrl(InputPeer arg_peer, long arg_stars, InputCheckPasswordSRP arg_password)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_getStarsRevenueWithdrawalUrl");
	int i;
	obj->id = 0x13bbe8b3;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument long
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_LONG;
	obj->objs[1]->value = 
		buf_add_ui64(arg_stars);
	strcpy(obj->objs[1]->name, "stars");

	//parse argument InputCheckPasswordSRP
	if (arg_password){
		obj->objs[2] = arg_password;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "password");
	}

	return obj;
}

tlo_t * tl_payments_getStarsRevenueAdsAccountUrl(InputPeer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_getStarsRevenueAdsAccountUrl");
	int i;
	obj->id = 0xd1d7efc5;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}

	return obj;
}

tlo_t * tl_payments_getStarsTransactionsByID(InputPeer arg_peer, InputStarsTransaction *arg_id, int len_arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_getStarsTransactionsByID");
	int i;
	obj->id = 0x27842d2e;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument Vector<InputStarsTransaction>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_id[i]->id);
			buf_cat(obj->objs[1]->value, arg_id[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_payments_getStarsGiftOptions(InputUser arg_user_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_getStarsGiftOptions");
	int i;
	obj->id = 0xd3c96bc8;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputUser
	if (arg_user_id){
		obj->objs[1] = arg_user_id;
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "user_id");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_payments_getStarsSubscriptions(bool arg_missing_balance, InputPeer arg_peer, const char * arg_offset)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_getStarsSubscriptions");
	int i;
	obj->id = 0x032512c5;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_missing_balance);
	strcpy(obj->objs[1]->name, "missing_balance");
	if (arg_missing_balance)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//parse argument string
	if (arg_offset){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_offset, strlen(arg_offset));
		strcpy(obj->objs[3]->name, "offset");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_payments_changeStarsSubscription(InputPeer arg_peer, const char * arg_subscription_id, Bool arg_canceled)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_changeStarsSubscription");
	int i;
	obj->id = 0xc7770878;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[1] = arg_peer;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "peer");
	}


	//parse argument string
	if (arg_subscription_id){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_subscription_id, strlen(arg_subscription_id));
		strcpy(obj->objs[2]->name, "subscription_id");
	}


	//parse argument Bool
	if (arg_canceled){
		obj->objs[3] = arg_canceled;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "canceled");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_payments_fulfillStarsSubscription(InputPeer arg_peer, const char * arg_subscription_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_fulfillStarsSubscription");
	int i;
	obj->id = 0xcc5bebb3;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument string
	if (arg_subscription_id){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_subscription_id, strlen(arg_subscription_id));
		strcpy(obj->objs[1]->name, "subscription_id");
	}

	return obj;
}

tlo_t * tl_payments_getStarsGiveawayOptions()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_getStarsGiveawayOptions");
	int i;
	obj->id = 0xbd1efd3e;
	return obj;
}

tlo_t * tl_payments_getStarGifts(int arg_hash)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_getStarGifts");
	int i;
	obj->id = 0xc4563590;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument int
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_INT;
	obj->objs[0]->value = 
		buf_add_ui32(arg_hash);
	strcpy(obj->objs[0]->name, "hash");
	return obj;
}

tlo_t * tl_payments_getUserStarGifts(InputUser arg_user_id, const char * arg_offset, int arg_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_getUserStarGifts");
	int i;
	obj->id = 0x5e72c7e1;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputUser
	if (arg_user_id){
		obj->objs[0] = arg_user_id;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "user_id");
	}


	//parse argument string
	if (arg_offset){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_offset, strlen(arg_offset));
		strcpy(obj->objs[1]->name, "offset");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[2]->name, "limit");
	return obj;
}

tlo_t * tl_payments_saveStarGift(bool arg_unsave, InputUser arg_user_id, int arg_msg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_saveStarGift");
	int i;
	obj->id = 0x87acf08e;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_unsave);
	strcpy(obj->objs[1]->name, "unsave");
	if (arg_unsave)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputUser
	if (arg_user_id){
		obj->objs[2] = arg_user_id;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "user_id");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[3]->name, "msg_id");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_payments_convertStarGift(InputUser arg_user_id, int arg_msg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "payments_convertStarGift");
	int i;
	obj->id = 0x0421e027;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputUser
	if (arg_user_id){
		obj->objs[0] = arg_user_id;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "user_id");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[1]->name, "msg_id");
	return obj;
}

tlo_t * tl_stickers_createStickerSet(bool arg_masks, bool arg_emojis, bool arg_text_color, InputUser arg_user_id, const char * arg_title, const char * arg_short_name, InputDocument arg_thumb, InputStickerSetItem *arg_stickers, int len_arg_stickers, const char * arg_software)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stickers_createStickerSet");
	int i;
	obj->id = 0x9021ab67;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 10;
	obj->objs = 
		(tlo_t **)MALLOC(10 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_masks);
	strcpy(obj->objs[1]->name, "masks");
	if (arg_masks)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 5;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_emojis);
	strcpy(obj->objs[2]->name, "emojis");
	if (arg_emojis)
		flagsv[nflags-1] |= (1 << 5);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 6;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_text_color);
	strcpy(obj->objs[3]->name, "text_color");
	if (arg_text_color)
		flagsv[nflags-1] |= (1 << 6);

	//parse argument InputUser
	if (arg_user_id){
		obj->objs[4] = arg_user_id;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "user_id");
	}


	//parse argument string
	if (arg_title){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[5]->name, "title");
	}


	//parse argument string
	if (arg_short_name){
		obj->objs[6] = NEW(tlo_t, return NULL);
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
		obj->objs[6]->type = TYPE_STRING;
		obj->objs[6]->value = 
			buf_add((ui8_t *)arg_short_name, strlen(arg_short_name));
		strcpy(obj->objs[6]->name, "short_name");
	}


	//parse argument InputDocument
	if (arg_thumb){
		obj->objs[7] = arg_thumb;
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 2;
	strcpy(obj->objs[7]->name, "thumb");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument Vector<InputStickerSetItem>
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 0;
	obj->objs[8]->flag_bit = 0;
	obj->objs[8]->type = TYPE_VECTOR;
	strcpy(obj->objs[8]->name, "stickers");
	if (arg_stickers){
		for(i=0; i<len_arg_stickers; ++i){
			obj->objs[8]->value = buf_add_ui32(arg_stickers[i]->id);
			buf_cat(obj->objs[8]->value, arg_stickers[i]->value);
		}
	}


	//parse argument string
	if (arg_software){
		obj->objs[9] = NEW(tlo_t, return NULL);
		obj->objs[9]->flag_num = 1;
		obj->objs[9]->flag_bit = 3;
		obj->objs[9]->type = TYPE_STRING;
		obj->objs[9]->value = 
			buf_add((ui8_t *)arg_software, strlen(arg_software));
		strcpy(obj->objs[9]->name, "software");
		flagsv[nflags-1] |= (1 << 3);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_stickers_removeStickerFromSet(InputDocument arg_sticker)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stickers_removeStickerFromSet");
	int i;
	obj->id = 0xf7760f51;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputDocument
	if (arg_sticker){
		obj->objs[0] = arg_sticker;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "sticker");
	}

	return obj;
}

tlo_t * tl_stickers_changeStickerPosition(InputDocument arg_sticker, int arg_position)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stickers_changeStickerPosition");
	int i;
	obj->id = 0xffb6d4ca;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputDocument
	if (arg_sticker){
		obj->objs[0] = arg_sticker;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "sticker");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_position);
	strcpy(obj->objs[1]->name, "position");
	return obj;
}

tlo_t * tl_stickers_addStickerToSet(InputStickerSet arg_stickerset, InputStickerSetItem arg_sticker)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stickers_addStickerToSet");
	int i;
	obj->id = 0x8653febe;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputStickerSet
	if (arg_stickerset){
		obj->objs[0] = arg_stickerset;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "stickerset");
	}


	//parse argument InputStickerSetItem
	if (arg_sticker){
		obj->objs[1] = arg_sticker;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "sticker");
	}

	return obj;
}

tlo_t * tl_stickers_setStickerSetThumb(InputStickerSet arg_stickerset, InputDocument arg_thumb, long arg_thumb_document_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stickers_setStickerSetThumb");
	int i;
	obj->id = 0xa76a5392;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputStickerSet
	if (arg_stickerset){
		obj->objs[1] = arg_stickerset;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "stickerset");
	}


	//parse argument InputDocument
	if (arg_thumb){
		obj->objs[2] = arg_thumb;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "thumb");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument long
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 1;
	obj->objs[3]->type = TYPE_LONG;
	obj->objs[3]->value = 
		buf_add_ui64(arg_thumb_document_id);
	strcpy(obj->objs[3]->name, "thumb_document_id");
	if (arg_thumb_document_id)
		flagsv[nflags-1] |= (1 << 1);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_stickers_checkShortName(const char * arg_short_name)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stickers_checkShortName");
	int i;
	obj->id = 0x284b3639;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_short_name){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_short_name, strlen(arg_short_name));
		strcpy(obj->objs[0]->name, "short_name");
	}

	return obj;
}

tlo_t * tl_stickers_suggestShortName(const char * arg_title)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stickers_suggestShortName");
	int i;
	obj->id = 0x4dafc503;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_title){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[0]->name, "title");
	}

	return obj;
}

tlo_t * tl_stickers_changeSticker(InputDocument arg_sticker, const char * arg_emoji, MaskCoords arg_mask_coords, const char * arg_keywords)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stickers_changeSticker");
	int i;
	obj->id = 0xf5537ebc;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputDocument
	if (arg_sticker){
		obj->objs[1] = arg_sticker;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "sticker");
	}


	//parse argument string
	if (arg_emoji){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_emoji, strlen(arg_emoji));
		strcpy(obj->objs[2]->name, "emoji");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument MaskCoords
	if (arg_mask_coords){
		obj->objs[3] = arg_mask_coords;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 1;
	strcpy(obj->objs[3]->name, "mask_coords");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument string
	if (arg_keywords){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 2;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_keywords, strlen(arg_keywords));
		strcpy(obj->objs[4]->name, "keywords");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_stickers_renameStickerSet(InputStickerSet arg_stickerset, const char * arg_title)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stickers_renameStickerSet");
	int i;
	obj->id = 0x124b1c00;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputStickerSet
	if (arg_stickerset){
		obj->objs[0] = arg_stickerset;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "stickerset");
	}


	//parse argument string
	if (arg_title){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[1]->name, "title");
	}

	return obj;
}

tlo_t * tl_stickers_deleteStickerSet(InputStickerSet arg_stickerset)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stickers_deleteStickerSet");
	int i;
	obj->id = 0x87704394;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputStickerSet
	if (arg_stickerset){
		obj->objs[0] = arg_stickerset;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "stickerset");
	}

	return obj;
}

tlo_t * tl_stickers_replaceSticker(InputDocument arg_sticker, InputStickerSetItem arg_new_sticker)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stickers_replaceSticker");
	int i;
	obj->id = 0x4696459a;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputDocument
	if (arg_sticker){
		obj->objs[0] = arg_sticker;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "sticker");
	}


	//parse argument InputStickerSetItem
	if (arg_new_sticker){
		obj->objs[1] = arg_new_sticker;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "new_sticker");
	}

	return obj;
}

tlo_t * tl_phone_getCallConfig()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_getCallConfig");
	int i;
	obj->id = 0x55451fa9;
	return obj;
}

tlo_t * tl_phone_requestCall(bool arg_video, InputUser arg_user_id, int arg_random_id, unsigned char * arg_g_a_hash, int len_arg_g_a_hash, PhoneCallProtocol arg_protocol)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_requestCall");
	int i;
	obj->id = 0x42ff96ed;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_video);
	strcpy(obj->objs[1]->name, "video");
	if (arg_video)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputUser
	if (arg_user_id){
		obj->objs[2] = arg_user_id;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "user_id");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_random_id);
	strcpy(obj->objs[3]->name, "random_id");

	//parse argument bytes
	if (arg_g_a_hash){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_BYTES;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_g_a_hash, len_arg_g_a_hash);
		strcpy(obj->objs[4]->name, "g_a_hash");
	}


	//parse argument PhoneCallProtocol
	if (arg_protocol){
		obj->objs[5] = arg_protocol;
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
	strcpy(obj->objs[5]->name, "protocol");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_phone_acceptCall(InputPhoneCall arg_peer, unsigned char * arg_g_b, int len_arg_g_b, PhoneCallProtocol arg_protocol)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_acceptCall");
	int i;
	obj->id = 0x3bd2b4a0;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputPhoneCall
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument bytes
	if (arg_g_b){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_g_b, len_arg_g_b);
		strcpy(obj->objs[1]->name, "g_b");
	}


	//parse argument PhoneCallProtocol
	if (arg_protocol){
		obj->objs[2] = arg_protocol;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "protocol");
	}

	return obj;
}

tlo_t * tl_phone_confirmCall(InputPhoneCall arg_peer, unsigned char * arg_g_a, int len_arg_g_a, long arg_key_fingerprint, PhoneCallProtocol arg_protocol)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_confirmCall");
	int i;
	obj->id = 0x2efe1722;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument InputPhoneCall
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument bytes
	if (arg_g_a){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_g_a, len_arg_g_a);
		strcpy(obj->objs[1]->name, "g_a");
	}


	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_key_fingerprint);
	strcpy(obj->objs[2]->name, "key_fingerprint");

	//parse argument PhoneCallProtocol
	if (arg_protocol){
		obj->objs[3] = arg_protocol;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "protocol");
	}

	return obj;
}

tlo_t * tl_phone_receivedCall(InputPhoneCall arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_receivedCall");
	int i;
	obj->id = 0x17d54f61;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputPhoneCall
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}

	return obj;
}

tlo_t * tl_phone_discardCall(bool arg_video, InputPhoneCall arg_peer, int arg_duration, PhoneCallDiscardReason arg_reason, long arg_connection_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_discardCall");
	int i;
	obj->id = 0xb2cbc1c0;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_video);
	strcpy(obj->objs[1]->name, "video");
	if (arg_video)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputPhoneCall
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_duration);
	strcpy(obj->objs[3]->name, "duration");

	//parse argument PhoneCallDiscardReason
	if (arg_reason){
		obj->objs[4] = arg_reason;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "reason");
	}


	//parse argument long
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 0;
	obj->objs[5]->flag_bit = 0;
	obj->objs[5]->type = TYPE_LONG;
	obj->objs[5]->value = 
		buf_add_ui64(arg_connection_id);
	strcpy(obj->objs[5]->name, "connection_id");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_phone_setCallRating(bool arg_user_initiative, InputPhoneCall arg_peer, int arg_rating, const char * arg_comment)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_setCallRating");
	int i;
	obj->id = 0x59ead627;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_user_initiative);
	strcpy(obj->objs[1]->name, "user_initiative");
	if (arg_user_initiative)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputPhoneCall
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_rating);
	strcpy(obj->objs[3]->name, "rating");

	//parse argument string
	if (arg_comment){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_comment, strlen(arg_comment));
		strcpy(obj->objs[4]->name, "comment");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_phone_saveCallDebug(InputPhoneCall arg_peer, DataJSON arg_debug)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_saveCallDebug");
	int i;
	obj->id = 0x277add7e;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPhoneCall
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument DataJSON
	if (arg_debug){
		obj->objs[1] = arg_debug;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "debug");
	}

	return obj;
}

tlo_t * tl_phone_sendSignalingData(InputPhoneCall arg_peer, unsigned char * arg_data, int len_arg_data)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_sendSignalingData");
	int i;
	obj->id = 0xff7a9383;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPhoneCall
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument bytes
	if (arg_data){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_BYTES;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_data, len_arg_data);
		strcpy(obj->objs[1]->name, "data");
	}

	return obj;
}

tlo_t * tl_phone_createGroupCall(bool arg_rtmp_stream, InputPeer arg_peer, int arg_random_id, const char * arg_title, int arg_schedule_date)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_createGroupCall");
	int i;
	obj->id = 0x48cdc6d8;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 2;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_rtmp_stream);
	strcpy(obj->objs[1]->name, "rtmp_stream");
	if (arg_rtmp_stream)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_random_id);
	strcpy(obj->objs[3]->name, "random_id");

	//parse argument string
	if (arg_title){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 0;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[4]->name, "title");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument int
	obj->objs[5] = NEW(tlo_t, return NULL);
	obj->objs[5]->flag_num = 1;
	obj->objs[5]->flag_bit = 1;
	obj->objs[5]->type = TYPE_INT;
	obj->objs[5]->value = 
		buf_add_ui32(arg_schedule_date);
	strcpy(obj->objs[5]->name, "schedule_date");
	if (arg_schedule_date)
		flagsv[nflags-1] |= (1 << 1);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_phone_joinGroupCall(bool arg_muted, bool arg_video_stopped, InputGroupCall arg_call, InputPeer arg_join_as, const char * arg_invite_hash, DataJSON arg_params)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_joinGroupCall");
	int i;
	obj->id = 0xb132ff7b;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_muted);
	strcpy(obj->objs[1]->name, "muted");
	if (arg_muted)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 2;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_video_stopped);
	strcpy(obj->objs[2]->name, "video_stopped");
	if (arg_video_stopped)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument InputGroupCall
	if (arg_call){
		obj->objs[3] = arg_call;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "call");
	}


	//parse argument InputPeer
	if (arg_join_as){
		obj->objs[4] = arg_join_as;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "join_as");
	}


	//parse argument string
	if (arg_invite_hash){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 1;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_invite_hash, strlen(arg_invite_hash));
		strcpy(obj->objs[5]->name, "invite_hash");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument DataJSON
	if (arg_params){
		obj->objs[6] = arg_params;
		obj->objs[6]->flag_num = 0;
		obj->objs[6]->flag_bit = 0;
	strcpy(obj->objs[6]->name, "params");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_phone_leaveGroupCall(InputGroupCall arg_call, int arg_source)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_leaveGroupCall");
	int i;
	obj->id = 0x500377f9;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputGroupCall
	if (arg_call){
		obj->objs[0] = arg_call;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "call");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_source);
	strcpy(obj->objs[1]->name, "source");
	return obj;
}

tlo_t * tl_phone_inviteToGroupCall(InputGroupCall arg_call, InputUser *arg_users, int len_arg_users)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_inviteToGroupCall");
	int i;
	obj->id = 0x7b393160;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputGroupCall
	if (arg_call){
		obj->objs[0] = arg_call;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "call");
	}


	//parse argument Vector<InputUser>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "users");
	if (arg_users){
		for(i=0; i<len_arg_users; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_users[i]->id);
			buf_cat(obj->objs[1]->value, arg_users[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_phone_discardGroupCall(InputGroupCall arg_call)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_discardGroupCall");
	int i;
	obj->id = 0x7a777135;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputGroupCall
	if (arg_call){
		obj->objs[0] = arg_call;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "call");
	}

	return obj;
}

tlo_t * tl_phone_toggleGroupCallSettings(bool arg_reset_invite_hash, InputGroupCall arg_call, Bool arg_join_muted)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_toggleGroupCallSettings");
	int i;
	obj->id = 0x74bbb43d;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_reset_invite_hash);
	strcpy(obj->objs[1]->name, "reset_invite_hash");
	if (arg_reset_invite_hash)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument InputGroupCall
	if (arg_call){
		obj->objs[2] = arg_call;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "call");
	}


	//parse argument Bool
	if (arg_join_muted){
		obj->objs[3] = arg_join_muted;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "join_muted");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_phone_getGroupCall(InputGroupCall arg_call, int arg_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_getGroupCall");
	int i;
	obj->id = 0x041845db;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputGroupCall
	if (arg_call){
		obj->objs[0] = arg_call;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "call");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[1]->name, "limit");
	return obj;
}

tlo_t * tl_phone_getGroupParticipants(InputGroupCall arg_call, InputPeer *arg_ids, int len_arg_ids, int *arg_sources, int len_arg_sources, const char * arg_offset, int arg_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_getGroupParticipants");
	int i;
	obj->id = 0xc558d8ab;
	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument InputGroupCall
	if (arg_call){
		obj->objs[0] = arg_call;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "call");
	}


	//parse argument Vector<InputPeer>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "ids");
	if (arg_ids){
		for(i=0; i<len_arg_ids; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_ids[i]->id);
			buf_cat(obj->objs[1]->value, arg_ids[i]->value);
		}
	}


	//parse argument Vector<int>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "sources");
	if (arg_sources){
		for(i=0; i<len_arg_sources; ++i){
			buf_t b = buf_add_ui32(arg_sources[i]);
			buf_cat(obj->objs[2]->value, b);
		}
	}


	//parse argument string
	if (arg_offset){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_offset, strlen(arg_offset));
		strcpy(obj->objs[3]->name, "offset");
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[4]->name, "limit");
	return obj;
}

tlo_t * tl_phone_checkGroupCall(InputGroupCall arg_call, int *arg_sources, int len_arg_sources)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_checkGroupCall");
	int i;
	obj->id = 0xb59cf977;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputGroupCall
	if (arg_call){
		obj->objs[0] = arg_call;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "call");
	}


	//parse argument Vector<int>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "sources");
	if (arg_sources){
		for(i=0; i<len_arg_sources; ++i){
			buf_t b = buf_add_ui32(arg_sources[i]);
			buf_cat(obj->objs[1]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_phone_toggleGroupCallRecord(bool arg_start, bool arg_video, InputGroupCall arg_call, const char * arg_title, Bool arg_video_portrait)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_toggleGroupCallRecord");
	int i;
	obj->id = 0xf128c708;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 6;
	obj->objs = 
		(tlo_t **)MALLOC(6 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_start);
	strcpy(obj->objs[1]->name, "start");
	if (arg_start)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 2;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_video);
	strcpy(obj->objs[2]->name, "video");
	if (arg_video)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument InputGroupCall
	if (arg_call){
		obj->objs[3] = arg_call;
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "call");
	}


	//parse argument string
	if (arg_title){
		obj->objs[4] = NEW(tlo_t, return NULL);
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 1;
		obj->objs[4]->type = TYPE_STRING;
		obj->objs[4]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[4]->name, "title");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument Bool
	if (arg_video_portrait){
		obj->objs[5] = arg_video_portrait;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 2;
	strcpy(obj->objs[5]->name, "video_portrait");
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_phone_editGroupCallParticipant(InputGroupCall arg_call, InputPeer arg_participant, Bool arg_muted, int arg_volume, Bool arg_raise_hand, Bool arg_video_stopped, Bool arg_video_paused, Bool arg_presentation_paused)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_editGroupCallParticipant");
	int i;
	obj->id = 0xa5273abf;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputGroupCall
	if (arg_call){
		obj->objs[1] = arg_call;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "call");
	}


	//parse argument InputPeer
	if (arg_participant){
		obj->objs[2] = arg_participant;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "participant");
	}


	//parse argument Bool
	if (arg_muted){
		obj->objs[3] = arg_muted;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "muted");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 1;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_volume);
	strcpy(obj->objs[4]->name, "volume");
	if (arg_volume)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument Bool
	if (arg_raise_hand){
		obj->objs[5] = arg_raise_hand;
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 2;
	strcpy(obj->objs[5]->name, "raise_hand");
		flagsv[nflags-1] |= (1 << 2);
	}


	//parse argument Bool
	if (arg_video_stopped){
		obj->objs[6] = arg_video_stopped;
		obj->objs[6]->flag_num = 1;
		obj->objs[6]->flag_bit = 3;
	strcpy(obj->objs[6]->name, "video_stopped");
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument Bool
	if (arg_video_paused){
		obj->objs[7] = arg_video_paused;
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 4;
	strcpy(obj->objs[7]->name, "video_paused");
		flagsv[nflags-1] |= (1 << 4);
	}


	//parse argument Bool
	if (arg_presentation_paused){
		obj->objs[8] = arg_presentation_paused;
		obj->objs[8]->flag_num = 1;
		obj->objs[8]->flag_bit = 5;
	strcpy(obj->objs[8]->name, "presentation_paused");
		flagsv[nflags-1] |= (1 << 5);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_phone_editGroupCallTitle(InputGroupCall arg_call, const char * arg_title)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_editGroupCallTitle");
	int i;
	obj->id = 0x1ca6ac0a;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputGroupCall
	if (arg_call){
		obj->objs[0] = arg_call;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "call");
	}


	//parse argument string
	if (arg_title){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[1]->name, "title");
	}

	return obj;
}

tlo_t * tl_phone_getGroupCallJoinAs(InputPeer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_getGroupCallJoinAs");
	int i;
	obj->id = 0xef7c213a;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}

	return obj;
}

tlo_t * tl_phone_exportGroupCallInvite(bool arg_can_self_unmute, InputGroupCall arg_call)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_exportGroupCallInvite");
	int i;
	obj->id = 0xe6aa647f;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_can_self_unmute);
	strcpy(obj->objs[1]->name, "can_self_unmute");
	if (arg_can_self_unmute)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputGroupCall
	if (arg_call){
		obj->objs[2] = arg_call;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "call");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_phone_toggleGroupCallStartSubscription(InputGroupCall arg_call, Bool arg_subscribed)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_toggleGroupCallStartSubscription");
	int i;
	obj->id = 0x219c34e6;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputGroupCall
	if (arg_call){
		obj->objs[0] = arg_call;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "call");
	}


	//parse argument Bool
	if (arg_subscribed){
		obj->objs[1] = arg_subscribed;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "subscribed");
	}

	return obj;
}

tlo_t * tl_phone_startScheduledGroupCall(InputGroupCall arg_call)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_startScheduledGroupCall");
	int i;
	obj->id = 0x5680e342;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputGroupCall
	if (arg_call){
		obj->objs[0] = arg_call;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "call");
	}

	return obj;
}

tlo_t * tl_phone_saveDefaultGroupCallJoinAs(InputPeer arg_peer, InputPeer arg_join_as)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_saveDefaultGroupCallJoinAs");
	int i;
	obj->id = 0x575e1f8c;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument InputPeer
	if (arg_join_as){
		obj->objs[1] = arg_join_as;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "join_as");
	}

	return obj;
}

tlo_t * tl_phone_joinGroupCallPresentation(InputGroupCall arg_call, DataJSON arg_params)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_joinGroupCallPresentation");
	int i;
	obj->id = 0xcbea6bc4;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputGroupCall
	if (arg_call){
		obj->objs[0] = arg_call;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "call");
	}


	//parse argument DataJSON
	if (arg_params){
		obj->objs[1] = arg_params;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "params");
	}

	return obj;
}

tlo_t * tl_phone_leaveGroupCallPresentation(InputGroupCall arg_call)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_leaveGroupCallPresentation");
	int i;
	obj->id = 0x1c50d144;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputGroupCall
	if (arg_call){
		obj->objs[0] = arg_call;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "call");
	}

	return obj;
}

tlo_t * tl_phone_getGroupCallStreamChannels(InputGroupCall arg_call)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_getGroupCallStreamChannels");
	int i;
	obj->id = 0x1ab21940;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputGroupCall
	if (arg_call){
		obj->objs[0] = arg_call;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "call");
	}

	return obj;
}

tlo_t * tl_phone_getGroupCallStreamRtmpUrl(InputPeer arg_peer, Bool arg_revoke)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_getGroupCallStreamRtmpUrl");
	int i;
	obj->id = 0xdeb3abbf;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument Bool
	if (arg_revoke){
		obj->objs[1] = arg_revoke;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "revoke");
	}

	return obj;
}

tlo_t * tl_phone_saveCallLog(InputPhoneCall arg_peer, InputFile arg_file)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "phone_saveCallLog");
	int i;
	obj->id = 0x41248786;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPhoneCall
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument InputFile
	if (arg_file){
		obj->objs[1] = arg_file;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "file");
	}

	return obj;
}

tlo_t * tl_langpack_getLangPack(const char * arg_lang_pack, const char * arg_lang_code)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "langpack_getLangPack");
	int i;
	obj->id = 0xf2f2330a;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_lang_pack){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_lang_pack, strlen(arg_lang_pack));
		strcpy(obj->objs[0]->name, "lang_pack");
	}


	//parse argument string
	if (arg_lang_code){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_lang_code, strlen(arg_lang_code));
		strcpy(obj->objs[1]->name, "lang_code");
	}

	return obj;
}

tlo_t * tl_langpack_getStrings(const char * arg_lang_pack, const char * arg_lang_code, const char * *arg_keys, int len_arg_keys)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "langpack_getStrings");
	int i;
	obj->id = 0xefea3803;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_lang_pack){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_lang_pack, strlen(arg_lang_pack));
		strcpy(obj->objs[0]->name, "lang_pack");
	}


	//parse argument string
	if (arg_lang_code){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_lang_code, strlen(arg_lang_code));
		strcpy(obj->objs[1]->name, "lang_code");
	}


	//parse argument Vector<string>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "keys");
	if (arg_keys){
		for(i=0; i<len_arg_keys; ++i){
			int len = strlen(arg_keys[i]);
			buf_t b = buf_add((ui8_t *)arg_keys[i], len);
			buf_cat(obj->objs[2]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_langpack_getDifference(const char * arg_lang_pack, const char * arg_lang_code, int arg_from_version)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "langpack_getDifference");
	int i;
	obj->id = 0xcd984aa5;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_lang_pack){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_lang_pack, strlen(arg_lang_pack));
		strcpy(obj->objs[0]->name, "lang_pack");
	}


	//parse argument string
	if (arg_lang_code){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_lang_code, strlen(arg_lang_code));
		strcpy(obj->objs[1]->name, "lang_code");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_from_version);
	strcpy(obj->objs[2]->name, "from_version");
	return obj;
}

tlo_t * tl_langpack_getLanguages(const char * arg_lang_pack)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "langpack_getLanguages");
	int i;
	obj->id = 0x42c6978f;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_lang_pack){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_lang_pack, strlen(arg_lang_pack));
		strcpy(obj->objs[0]->name, "lang_pack");
	}

	return obj;
}

tlo_t * tl_langpack_getLanguage(const char * arg_lang_pack, const char * arg_lang_code)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "langpack_getLanguage");
	int i;
	obj->id = 0x6a596502;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_lang_pack){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_lang_pack, strlen(arg_lang_pack));
		strcpy(obj->objs[0]->name, "lang_pack");
	}


	//parse argument string
	if (arg_lang_code){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_lang_code, strlen(arg_lang_code));
		strcpy(obj->objs[1]->name, "lang_code");
	}

	return obj;
}

tlo_t * tl_folders_editPeerFolders(InputFolderPeer *arg_folder_peers, int len_arg_folder_peers)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "folders_editPeerFolders");
	int i;
	obj->id = 0x6847d0ab;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<InputFolderPeer>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "folder_peers");
	if (arg_folder_peers){
		for(i=0; i<len_arg_folder_peers; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_folder_peers[i]->id);
			buf_cat(obj->objs[0]->value, arg_folder_peers[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_stats_getBroadcastStats(bool arg_dark, InputChannel arg_channel)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stats_getBroadcastStats");
	int i;
	obj->id = 0xab42441a;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_dark);
	strcpy(obj->objs[1]->name, "dark");
	if (arg_dark)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[2] = arg_channel;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "channel");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_stats_loadAsyncGraph(const char * arg_token, long arg_x)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stats_loadAsyncGraph");
	int i;
	obj->id = 0x621d5fa0;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_token){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_token, strlen(arg_token));
		strcpy(obj->objs[1]->name, "token");
	}


	//parse argument long
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_LONG;
	obj->objs[2]->value = 
		buf_add_ui64(arg_x);
	strcpy(obj->objs[2]->name, "x");
	if (arg_x)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_stats_getMegagroupStats(bool arg_dark, InputChannel arg_channel)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stats_getMegagroupStats");
	int i;
	obj->id = 0xdcdf8607;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_dark);
	strcpy(obj->objs[1]->name, "dark");
	if (arg_dark)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[2] = arg_channel;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "channel");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_stats_getMessagePublicForwards(InputChannel arg_channel, int arg_msg_id, const char * arg_offset, int arg_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stats_getMessagePublicForwards");
	int i;
	obj->id = 0x5f150144;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[1]->name, "msg_id");

	//parse argument string
	if (arg_offset){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_offset, strlen(arg_offset));
		strcpy(obj->objs[2]->name, "offset");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[3]->name, "limit");
	return obj;
}

tlo_t * tl_stats_getMessageStats(bool arg_dark, InputChannel arg_channel, int arg_msg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stats_getMessageStats");
	int i;
	obj->id = 0xb6e0a3f5;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_dark);
	strcpy(obj->objs[1]->name, "dark");
	if (arg_dark)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[2] = arg_channel;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "channel");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_msg_id);
	strcpy(obj->objs[3]->name, "msg_id");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_stats_getStoryStats(bool arg_dark, InputPeer arg_peer, int arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stats_getStoryStats");
	int i;
	obj->id = 0x374fef40;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_dark);
	strcpy(obj->objs[1]->name, "dark");
	if (arg_dark)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[3]->name, "id");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_stats_getStoryPublicForwards(InputPeer arg_peer, int arg_id, const char * arg_offset, int arg_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stats_getStoryPublicForwards");
	int i;
	obj->id = 0xa6437ef6;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[1]->name, "id");

	//parse argument string
	if (arg_offset){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_offset, strlen(arg_offset));
		strcpy(obj->objs[2]->name, "offset");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[3]->name, "limit");
	return obj;
}

tlo_t * tl_stats_getBroadcastRevenueStats(bool arg_dark, InputChannel arg_channel)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stats_getBroadcastRevenueStats");
	int i;
	obj->id = 0x75dfb671;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_dark);
	strcpy(obj->objs[1]->name, "dark");
	if (arg_dark)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[2] = arg_channel;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "channel");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_stats_getBroadcastRevenueWithdrawalUrl(InputChannel arg_channel, InputCheckPasswordSRP arg_password)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stats_getBroadcastRevenueWithdrawalUrl");
	int i;
	obj->id = 0x2a65ef73;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument InputCheckPasswordSRP
	if (arg_password){
		obj->objs[1] = arg_password;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "password");
	}

	return obj;
}

tlo_t * tl_stats_getBroadcastRevenueTransactions(InputChannel arg_channel, int arg_offset, int arg_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stats_getBroadcastRevenueTransactions");
	int i;
	obj->id = 0x0069280f;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputChannel
	if (arg_channel){
		obj->objs[0] = arg_channel;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "channel");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_offset);
	strcpy(obj->objs[1]->name, "offset");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[2]->name, "limit");
	return obj;
}

tlo_t * tl_chatlists_exportChatlistInvite(InputChatlist arg_chatlist, const char * arg_title, InputPeer *arg_peers, int len_arg_peers)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatlists_exportChatlistInvite");
	int i;
	obj->id = 0x8472478e;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputChatlist
	if (arg_chatlist){
		obj->objs[0] = arg_chatlist;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "chatlist");
	}


	//parse argument string
	if (arg_title){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[1]->name, "title");
	}


	//parse argument Vector<InputPeer>
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_VECTOR;
	strcpy(obj->objs[2]->name, "peers");
	if (arg_peers){
		for(i=0; i<len_arg_peers; ++i){
			obj->objs[2]->value = buf_add_ui32(arg_peers[i]->id);
			buf_cat(obj->objs[2]->value, arg_peers[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_chatlists_deleteExportedInvite(InputChatlist arg_chatlist, const char * arg_slug)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatlists_deleteExportedInvite");
	int i;
	obj->id = 0x719c5c5e;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputChatlist
	if (arg_chatlist){
		obj->objs[0] = arg_chatlist;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "chatlist");
	}


	//parse argument string
	if (arg_slug){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_slug, strlen(arg_slug));
		strcpy(obj->objs[1]->name, "slug");
	}

	return obj;
}

tlo_t * tl_chatlists_editExportedInvite(InputChatlist arg_chatlist, const char * arg_slug, const char * arg_title, InputPeer *arg_peers, int len_arg_peers)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatlists_editExportedInvite");
	int i;
	obj->id = 0x653db63d;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputChatlist
	if (arg_chatlist){
		obj->objs[1] = arg_chatlist;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "chatlist");
	}


	//parse argument string
	if (arg_slug){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_slug, strlen(arg_slug));
		strcpy(obj->objs[2]->name, "slug");
	}


	//parse argument string
	if (arg_title){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 1;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_title, strlen(arg_title));
		strcpy(obj->objs[3]->name, "title");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument Vector<InputPeer>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 2;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "peers");
	if (arg_peers){
		for(i=0; i<len_arg_peers; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_peers[i]->id);
			buf_cat(obj->objs[4]->value, arg_peers[i]->value);
		}
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_chatlists_getExportedInvites(InputChatlist arg_chatlist)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatlists_getExportedInvites");
	int i;
	obj->id = 0xce03da83;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputChatlist
	if (arg_chatlist){
		obj->objs[0] = arg_chatlist;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "chatlist");
	}

	return obj;
}

tlo_t * tl_chatlists_checkChatlistInvite(const char * arg_slug)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatlists_checkChatlistInvite");
	int i;
	obj->id = 0x41c10fff;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_slug){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_slug, strlen(arg_slug));
		strcpy(obj->objs[0]->name, "slug");
	}

	return obj;
}

tlo_t * tl_chatlists_joinChatlistInvite(const char * arg_slug, InputPeer *arg_peers, int len_arg_peers)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatlists_joinChatlistInvite");
	int i;
	obj->id = 0xa6b1e39a;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_slug){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_slug, strlen(arg_slug));
		strcpy(obj->objs[0]->name, "slug");
	}


	//parse argument Vector<InputPeer>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "peers");
	if (arg_peers){
		for(i=0; i<len_arg_peers; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_peers[i]->id);
			buf_cat(obj->objs[1]->value, arg_peers[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_chatlists_getChatlistUpdates(InputChatlist arg_chatlist)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatlists_getChatlistUpdates");
	int i;
	obj->id = 0x89419521;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputChatlist
	if (arg_chatlist){
		obj->objs[0] = arg_chatlist;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "chatlist");
	}

	return obj;
}

tlo_t * tl_chatlists_joinChatlistUpdates(InputChatlist arg_chatlist, InputPeer *arg_peers, int len_arg_peers)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatlists_joinChatlistUpdates");
	int i;
	obj->id = 0xe089f8f5;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputChatlist
	if (arg_chatlist){
		obj->objs[0] = arg_chatlist;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "chatlist");
	}


	//parse argument Vector<InputPeer>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "peers");
	if (arg_peers){
		for(i=0; i<len_arg_peers; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_peers[i]->id);
			buf_cat(obj->objs[1]->value, arg_peers[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_chatlists_hideChatlistUpdates(InputChatlist arg_chatlist)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatlists_hideChatlistUpdates");
	int i;
	obj->id = 0x66e486fb;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputChatlist
	if (arg_chatlist){
		obj->objs[0] = arg_chatlist;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "chatlist");
	}

	return obj;
}

tlo_t * tl_chatlists_getLeaveChatlistSuggestions(InputChatlist arg_chatlist)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatlists_getLeaveChatlistSuggestions");
	int i;
	obj->id = 0xfdbcd714;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputChatlist
	if (arg_chatlist){
		obj->objs[0] = arg_chatlist;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "chatlist");
	}

	return obj;
}

tlo_t * tl_chatlists_leaveChatlist(InputChatlist arg_chatlist, InputPeer *arg_peers, int len_arg_peers)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "chatlists_leaveChatlist");
	int i;
	obj->id = 0x74fae13a;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputChatlist
	if (arg_chatlist){
		obj->objs[0] = arg_chatlist;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "chatlist");
	}


	//parse argument Vector<InputPeer>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "peers");
	if (arg_peers){
		for(i=0; i<len_arg_peers; ++i){
			obj->objs[1]->value = buf_add_ui32(arg_peers[i]->id);
			buf_cat(obj->objs[1]->value, arg_peers[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_stories_canSendStory(InputPeer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stories_canSendStory");
	int i;
	obj->id = 0xc7dfdfdd;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}

	return obj;
}

tlo_t * tl_stories_sendStory(bool arg_pinned, bool arg_noforwards, bool arg_fwd_modified, InputPeer arg_peer, InputMedia arg_media, MediaArea *arg_media_areas, int len_arg_media_areas, const char * arg_caption, MessageEntity *arg_entities, int len_arg_entities, InputPrivacyRule *arg_privacy_rules, int len_arg_privacy_rules, long arg_random_id, int arg_period, InputPeer arg_fwd_from_id, int arg_fwd_from_story)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stories_sendStory");
	int i;
	obj->id = 0xe4e6694b;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 14;
	obj->objs = 
		(tlo_t **)MALLOC(14 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 2;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_pinned);
	strcpy(obj->objs[1]->name, "pinned");
	if (arg_pinned)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 4;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_noforwards);
	strcpy(obj->objs[2]->name, "noforwards");
	if (arg_noforwards)
		flagsv[nflags-1] |= (1 << 4);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 7;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_fwd_modified);
	strcpy(obj->objs[3]->name, "fwd_modified");
	if (arg_fwd_modified)
		flagsv[nflags-1] |= (1 << 7);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[4] = arg_peer;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "peer");
	}


	//parse argument InputMedia
	if (arg_media){
		obj->objs[5] = arg_media;
		obj->objs[5]->flag_num = 0;
		obj->objs[5]->flag_bit = 0;
	strcpy(obj->objs[5]->name, "media");
	}


	//parse argument Vector<MediaArea>
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 5;
	obj->objs[6]->type = TYPE_VECTOR;
	strcpy(obj->objs[6]->name, "media_areas");
	if (arg_media_areas){
		for(i=0; i<len_arg_media_areas; ++i){
			obj->objs[6]->value = buf_add_ui32(arg_media_areas[i]->id);
			buf_cat(obj->objs[6]->value, arg_media_areas[i]->value);
		}
		flagsv[nflags-1] |= (1 << 5);
	}


	//parse argument string
	if (arg_caption){
		obj->objs[7] = NEW(tlo_t, return NULL);
		obj->objs[7]->flag_num = 1;
		obj->objs[7]->flag_bit = 0;
		obj->objs[7]->type = TYPE_STRING;
		obj->objs[7]->value = 
			buf_add((ui8_t *)arg_caption, strlen(arg_caption));
		strcpy(obj->objs[7]->name, "caption");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument Vector<MessageEntity>
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 1;
	obj->objs[8]->flag_bit = 1;
	obj->objs[8]->type = TYPE_VECTOR;
	strcpy(obj->objs[8]->name, "entities");
	if (arg_entities){
		for(i=0; i<len_arg_entities; ++i){
			obj->objs[8]->value = buf_add_ui32(arg_entities[i]->id);
			buf_cat(obj->objs[8]->value, arg_entities[i]->value);
		}
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument Vector<InputPrivacyRule>
	obj->objs[9] = NEW(tlo_t, return NULL);
	obj->objs[9]->flag_num = 0;
	obj->objs[9]->flag_bit = 0;
	obj->objs[9]->type = TYPE_VECTOR;
	strcpy(obj->objs[9]->name, "privacy_rules");
	if (arg_privacy_rules){
		for(i=0; i<len_arg_privacy_rules; ++i){
			obj->objs[9]->value = buf_add_ui32(arg_privacy_rules[i]->id);
			buf_cat(obj->objs[9]->value, arg_privacy_rules[i]->value);
		}
	}


	//parse argument long
	obj->objs[10] = NEW(tlo_t, return NULL);
	obj->objs[10]->flag_num = 0;
	obj->objs[10]->flag_bit = 0;
	obj->objs[10]->type = TYPE_LONG;
	obj->objs[10]->value = 
		buf_add_ui64(arg_random_id);
	strcpy(obj->objs[10]->name, "random_id");

	//parse argument int
	obj->objs[11] = NEW(tlo_t, return NULL);
	obj->objs[11]->flag_num = 1;
	obj->objs[11]->flag_bit = 3;
	obj->objs[11]->type = TYPE_INT;
	obj->objs[11]->value = 
		buf_add_ui32(arg_period);
	strcpy(obj->objs[11]->name, "period");
	if (arg_period)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument InputPeer
	if (arg_fwd_from_id){
		obj->objs[12] = arg_fwd_from_id;
		obj->objs[12]->flag_num = 1;
		obj->objs[12]->flag_bit = 6;
	strcpy(obj->objs[12]->name, "fwd_from_id");
		flagsv[nflags-1] |= (1 << 6);
	}


	//parse argument int
	obj->objs[13] = NEW(tlo_t, return NULL);
	obj->objs[13]->flag_num = 1;
	obj->objs[13]->flag_bit = 6;
	obj->objs[13]->type = TYPE_INT;
	obj->objs[13]->value = 
		buf_add_ui32(arg_fwd_from_story);
	strcpy(obj->objs[13]->name, "fwd_from_story");
	if (arg_fwd_from_story)
		flagsv[nflags-1] |= (1 << 6);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_stories_editStory(InputPeer arg_peer, int arg_id, InputMedia arg_media, MediaArea *arg_media_areas, int len_arg_media_areas, const char * arg_caption, MessageEntity *arg_entities, int len_arg_entities, InputPrivacyRule *arg_privacy_rules, int len_arg_privacy_rules)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stories_editStory");
	int i;
	obj->id = 0xb583ba46;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 8;
	obj->objs = 
		(tlo_t **)MALLOC(8 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[1] = arg_peer;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "peer");
	}


	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[2]->name, "id");

	//parse argument InputMedia
	if (arg_media){
		obj->objs[3] = arg_media;
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
	strcpy(obj->objs[3]->name, "media");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument Vector<MediaArea>
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 1;
	obj->objs[4]->flag_bit = 3;
	obj->objs[4]->type = TYPE_VECTOR;
	strcpy(obj->objs[4]->name, "media_areas");
	if (arg_media_areas){
		for(i=0; i<len_arg_media_areas; ++i){
			obj->objs[4]->value = buf_add_ui32(arg_media_areas[i]->id);
			buf_cat(obj->objs[4]->value, arg_media_areas[i]->value);
		}
		flagsv[nflags-1] |= (1 << 3);
	}


	//parse argument string
	if (arg_caption){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 1;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_caption, strlen(arg_caption));
		strcpy(obj->objs[5]->name, "caption");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument Vector<MessageEntity>
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 1;
	obj->objs[6]->flag_bit = 1;
	obj->objs[6]->type = TYPE_VECTOR;
	strcpy(obj->objs[6]->name, "entities");
	if (arg_entities){
		for(i=0; i<len_arg_entities; ++i){
			obj->objs[6]->value = buf_add_ui32(arg_entities[i]->id);
			buf_cat(obj->objs[6]->value, arg_entities[i]->value);
		}
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument Vector<InputPrivacyRule>
	obj->objs[7] = NEW(tlo_t, return NULL);
	obj->objs[7]->flag_num = 1;
	obj->objs[7]->flag_bit = 2;
	obj->objs[7]->type = TYPE_VECTOR;
	strcpy(obj->objs[7]->name, "privacy_rules");
	if (arg_privacy_rules){
		for(i=0; i<len_arg_privacy_rules; ++i){
			obj->objs[7]->value = buf_add_ui32(arg_privacy_rules[i]->id);
			buf_cat(obj->objs[7]->value, arg_privacy_rules[i]->value);
		}
		flagsv[nflags-1] |= (1 << 2);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_stories_deleteStories(InputPeer arg_peer, int *arg_id, int len_arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stories_deleteStories");
	int i;
	obj->id = 0xae59db5f;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument Vector<int>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			buf_t b = buf_add_ui32(arg_id[i]);
			buf_cat(obj->objs[1]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_stories_togglePinned(InputPeer arg_peer, int *arg_id, int len_arg_id, Bool arg_pinned)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stories_togglePinned");
	int i;
	obj->id = 0x9a75a1ef;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument Vector<int>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			buf_t b = buf_add_ui32(arg_id[i]);
			buf_cat(obj->objs[1]->value, b);
		}
	}


	//parse argument Bool
	if (arg_pinned){
		obj->objs[2] = arg_pinned;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "pinned");
	}

	return obj;
}

tlo_t * tl_stories_getAllStories(bool arg_next, bool arg_hidden, const char * arg_state)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stories_getAllStories");
	int i;
	obj->id = 0xeeb0d625;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 1;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_next);
	strcpy(obj->objs[1]->name, "next");
	if (arg_next)
		flagsv[nflags-1] |= (1 << 1);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 2;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_hidden);
	strcpy(obj->objs[2]->name, "hidden");
	if (arg_hidden)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument string
	if (arg_state){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 1;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_state, strlen(arg_state));
		strcpy(obj->objs[3]->name, "state");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_stories_getPinnedStories(InputPeer arg_peer, int arg_offset_id, int arg_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stories_getPinnedStories");
	int i;
	obj->id = 0x5821a5dc;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_offset_id);
	strcpy(obj->objs[1]->name, "offset_id");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[2]->name, "limit");
	return obj;
}

tlo_t * tl_stories_getStoriesArchive(InputPeer arg_peer, int arg_offset_id, int arg_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stories_getStoriesArchive");
	int i;
	obj->id = 0xb4352016;
	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_offset_id);
	strcpy(obj->objs[1]->name, "offset_id");

	//parse argument int
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 0;
	obj->objs[2]->flag_bit = 0;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[2]->name, "limit");
	return obj;
}

tlo_t * tl_stories_getStoriesByID(InputPeer arg_peer, int *arg_id, int len_arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stories_getStoriesByID");
	int i;
	obj->id = 0x5774ca74;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument Vector<int>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			buf_t b = buf_add_ui32(arg_id[i]);
			buf_cat(obj->objs[1]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_stories_toggleAllStoriesHidden(Bool arg_hidden)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stories_toggleAllStoriesHidden");
	int i;
	obj->id = 0x7c2557c4;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Bool
	if (arg_hidden){
		obj->objs[0] = arg_hidden;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "hidden");
	}

	return obj;
}

tlo_t * tl_stories_readStories(InputPeer arg_peer, int arg_max_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stories_readStories");
	int i;
	obj->id = 0xa556dac8;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_max_id);
	strcpy(obj->objs[1]->name, "max_id");
	return obj;
}

tlo_t * tl_stories_incrementStoryViews(InputPeer arg_peer, int *arg_id, int len_arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stories_incrementStoryViews");
	int i;
	obj->id = 0xb2028afb;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument Vector<int>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			buf_t b = buf_add_ui32(arg_id[i]);
			buf_cat(obj->objs[1]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_stories_getStoryViewsList(bool arg_just_contacts, bool arg_reactions_first, bool arg_forwards_first, InputPeer arg_peer, const char * arg_q, int arg_id, const char * arg_offset, int arg_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stories_getStoryViewsList");
	int i;
	obj->id = 0x7ed23c57;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 9;
	obj->objs = 
		(tlo_t **)MALLOC(9 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_just_contacts);
	strcpy(obj->objs[1]->name, "just_contacts");
	if (arg_just_contacts)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 2;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_reactions_first);
	strcpy(obj->objs[2]->name, "reactions_first");
	if (arg_reactions_first)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument true
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 1;
	obj->objs[3]->flag_bit = 3;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_forwards_first);
	strcpy(obj->objs[3]->name, "forwards_first");
	if (arg_forwards_first)
		flagsv[nflags-1] |= (1 << 3);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[4] = arg_peer;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "peer");
	}


	//parse argument string
	if (arg_q){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 1;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_q, strlen(arg_q));
		strcpy(obj->objs[5]->name, "q");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[6]->name, "id");

	//parse argument string
	if (arg_offset){
		obj->objs[7] = NEW(tlo_t, return NULL);
		obj->objs[7]->flag_num = 0;
		obj->objs[7]->flag_bit = 0;
		obj->objs[7]->type = TYPE_STRING;
		obj->objs[7]->value = 
			buf_add((ui8_t *)arg_offset, strlen(arg_offset));
		strcpy(obj->objs[7]->name, "offset");
	}


	//parse argument int
	obj->objs[8] = NEW(tlo_t, return NULL);
	obj->objs[8]->flag_num = 0;
	obj->objs[8]->flag_bit = 0;
	obj->objs[8]->type = TYPE_INT;
	obj->objs[8]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[8]->name, "limit");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_stories_getStoriesViews(InputPeer arg_peer, int *arg_id, int len_arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stories_getStoriesViews");
	int i;
	obj->id = 0x28e16cc8;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument Vector<int>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			buf_t b = buf_add_ui32(arg_id[i]);
			buf_cat(obj->objs[1]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_stories_exportStoryLink(InputPeer arg_peer, int arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stories_exportStoryLink");
	int i;
	obj->id = 0x7b8def20;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument int
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[1]->name, "id");
	return obj;
}

tlo_t * tl_stories_report(InputPeer arg_peer, int *arg_id, int len_arg_id, unsigned char * arg_option, int len_arg_option, const char * arg_message)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stories_report");
	int i;
	obj->id = 0x19d8eb45;
	obj->nobjs = 4;
	obj->objs = 
		(tlo_t **)MALLOC(4 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument Vector<int>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			buf_t b = buf_add_ui32(arg_id[i]);
			buf_cat(obj->objs[1]->value, b);
		}
	}


	//parse argument bytes
	if (arg_option){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_BYTES;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_option, len_arg_option);
		strcpy(obj->objs[2]->name, "option");
	}


	//parse argument string
	if (arg_message){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_message, strlen(arg_message));
		strcpy(obj->objs[3]->name, "message");
	}

	return obj;
}

tlo_t * tl_stories_activateStealthMode(bool arg_past, bool arg_future)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stories_activateStealthMode");
	int i;
	obj->id = 0x57bbd166;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_past);
	strcpy(obj->objs[1]->name, "past");
	if (arg_past)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument true
	obj->objs[2] = NEW(tlo_t, return NULL);
	obj->objs[2]->flag_num = 1;
	obj->objs[2]->flag_bit = 1;
	obj->objs[2]->type = TYPE_INT;
	obj->objs[2]->value = 
		buf_add_ui32(arg_future);
	strcpy(obj->objs[2]->name, "future");
	if (arg_future)
		flagsv[nflags-1] |= (1 << 1);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_stories_sendReaction(bool arg_add_to_recent, InputPeer arg_peer, int arg_story_id, Reaction arg_reaction)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stories_sendReaction");
	int i;
	obj->id = 0x7fd736b2;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_add_to_recent);
	strcpy(obj->objs[1]->name, "add_to_recent");
	if (arg_add_to_recent)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_story_id);
	strcpy(obj->objs[3]->name, "story_id");

	//parse argument Reaction
	if (arg_reaction){
		obj->objs[4] = arg_reaction;
		obj->objs[4]->flag_num = 0;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "reaction");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_stories_getPeerStories(InputPeer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stories_getPeerStories");
	int i;
	obj->id = 0x2c4ada50;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}

	return obj;
}

tlo_t * tl_stories_getAllReadPeerStories()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stories_getAllReadPeerStories");
	int i;
	obj->id = 0x9b5ae7f9;
	return obj;
}

tlo_t * tl_stories_getPeerMaxIDs(InputPeer *arg_id, int len_arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stories_getPeerMaxIDs");
	int i;
	obj->id = 0x535983c3;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument Vector<InputPeer>
	obj->objs[0] = NEW(tlo_t, return NULL);
	obj->objs[0]->flag_num = 0;
	obj->objs[0]->flag_bit = 0;
	obj->objs[0]->type = TYPE_VECTOR;
	strcpy(obj->objs[0]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			obj->objs[0]->value = buf_add_ui32(arg_id[i]->id);
			buf_cat(obj->objs[0]->value, arg_id[i]->value);
		}
	}

	return obj;
}

tlo_t * tl_stories_getChatsToSend()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stories_getChatsToSend");
	int i;
	obj->id = 0xa56a8b60;
	return obj;
}

tlo_t * tl_stories_togglePeerStoriesHidden(InputPeer arg_peer, Bool arg_hidden)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stories_togglePeerStoriesHidden");
	int i;
	obj->id = 0xbd0415c4;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument Bool
	if (arg_hidden){
		obj->objs[1] = arg_hidden;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "hidden");
	}

	return obj;
}

tlo_t * tl_stories_getStoryReactionsList(bool arg_forwards_first, InputPeer arg_peer, int arg_id, Reaction arg_reaction, const char * arg_offset, int arg_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stories_getStoryReactionsList");
	int i;
	obj->id = 0xb9b2881f;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 7;
	obj->objs = 
		(tlo_t **)MALLOC(7 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 2;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_forwards_first);
	strcpy(obj->objs[1]->name, "forwards_first");
	if (arg_forwards_first)
		flagsv[nflags-1] |= (1 << 2);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//parse argument int
	obj->objs[3] = NEW(tlo_t, return NULL);
	obj->objs[3]->flag_num = 0;
	obj->objs[3]->flag_bit = 0;
	obj->objs[3]->type = TYPE_INT;
	obj->objs[3]->value = 
		buf_add_ui32(arg_id);
	strcpy(obj->objs[3]->name, "id");

	//parse argument Reaction
	if (arg_reaction){
		obj->objs[4] = arg_reaction;
		obj->objs[4]->flag_num = 1;
		obj->objs[4]->flag_bit = 0;
	strcpy(obj->objs[4]->name, "reaction");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument string
	if (arg_offset){
		obj->objs[5] = NEW(tlo_t, return NULL);
		obj->objs[5]->flag_num = 1;
		obj->objs[5]->flag_bit = 1;
		obj->objs[5]->type = TYPE_STRING;
		obj->objs[5]->value = 
			buf_add((ui8_t *)arg_offset, strlen(arg_offset));
		strcpy(obj->objs[5]->name, "offset");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument int
	obj->objs[6] = NEW(tlo_t, return NULL);
	obj->objs[6]->flag_num = 0;
	obj->objs[6]->flag_bit = 0;
	obj->objs[6]->type = TYPE_INT;
	obj->objs[6]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[6]->name, "limit");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_stories_togglePinnedToTop(InputPeer arg_peer, int *arg_id, int len_arg_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stories_togglePinnedToTop");
	int i;
	obj->id = 0x0b297e9b;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument Vector<int>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 0;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "id");
	if (arg_id){
		for(i=0; i<len_arg_id; ++i){
			buf_t b = buf_add_ui32(arg_id[i]);
			buf_cat(obj->objs[1]->value, b);
		}
	}

	return obj;
}

tlo_t * tl_stories_searchPosts(const char * arg_hashtag, MediaArea arg_area, const char * arg_offset, int arg_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "stories_searchPosts");
	int i;
	obj->id = 0x6cea116a;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_hashtag){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 1;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_hashtag, strlen(arg_hashtag));
		strcpy(obj->objs[1]->name, "hashtag");
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument MediaArea
	if (arg_area){
		obj->objs[2] = arg_area;
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 1;
	strcpy(obj->objs[2]->name, "area");
		flagsv[nflags-1] |= (1 << 1);
	}


	//parse argument string
	if (arg_offset){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_offset, strlen(arg_offset));
		strcpy(obj->objs[3]->name, "offset");
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[4]->name, "limit");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_premium_getBoostsList(bool arg_gifts, InputPeer arg_peer, const char * arg_offset, int arg_limit)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "premium_getBoostsList");
	int i;
	obj->id = 0x60f67660;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 5;
	obj->objs = 
		(tlo_t **)MALLOC(5 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_gifts);
	strcpy(obj->objs[1]->name, "gifts");
	if (arg_gifts)
		flagsv[nflags-1] |= (1 << 0);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//parse argument string
	if (arg_offset){
		obj->objs[3] = NEW(tlo_t, return NULL);
		obj->objs[3]->flag_num = 0;
		obj->objs[3]->flag_bit = 0;
		obj->objs[3]->type = TYPE_STRING;
		obj->objs[3]->value = 
			buf_add((ui8_t *)arg_offset, strlen(arg_offset));
		strcpy(obj->objs[3]->name, "offset");
	}


	//parse argument int
	obj->objs[4] = NEW(tlo_t, return NULL);
	obj->objs[4]->flag_num = 0;
	obj->objs[4]->flag_bit = 0;
	obj->objs[4]->type = TYPE_INT;
	obj->objs[4]->value = 
		buf_add_ui32(arg_limit);
	strcpy(obj->objs[4]->name, "limit");

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_premium_getMyBoosts()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "premium_getMyBoosts");
	int i;
	obj->id = 0x0be77b4a;
	return obj;
}

tlo_t * tl_premium_applyBoost(int *arg_slots, int len_arg_slots, InputPeer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "premium_applyBoost");
	int i;
	obj->id = 0x6b7da746;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument Vector<int>
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_VECTOR;
	strcpy(obj->objs[1]->name, "slots");
	if (arg_slots){
		for(i=0; i<len_arg_slots; ++i){
			buf_t b = buf_add_ui32(arg_slots[i]);
			buf_cat(obj->objs[1]->value, b);
		}
		flagsv[nflags-1] |= (1 << 0);
	}


	//parse argument InputPeer
	if (arg_peer){
		obj->objs[2] = arg_peer;
		obj->objs[2]->flag_num = 0;
		obj->objs[2]->flag_bit = 0;
	strcpy(obj->objs[2]->name, "peer");
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_premium_getBoostsStatus(InputPeer arg_peer)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "premium_getBoostsStatus");
	int i;
	obj->id = 0x042f1f61;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}

	return obj;
}

tlo_t * tl_premium_getUserBoosts(InputPeer arg_peer, InputUser arg_user_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "premium_getUserBoosts");
	int i;
	obj->id = 0x39854d1f;
	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument InputPeer
	if (arg_peer){
		obj->objs[0] = arg_peer;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "peer");
	}


	//parse argument InputUser
	if (arg_user_id){
		obj->objs[1] = arg_user_id;
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
	strcpy(obj->objs[1]->name, "user_id");
	}

	return obj;
}

tlo_t * tl_smsjobs_isEligibleToJoin()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "smsjobs_isEligibleToJoin");
	int i;
	obj->id = 0x0edc39d0;
	return obj;
}

tlo_t * tl_smsjobs_join()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "smsjobs_join");
	int i;
	obj->id = 0xa74ece2d;
	return obj;
}

tlo_t * tl_smsjobs_leave()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "smsjobs_leave");
	int i;
	obj->id = 0x9898ad73;
	return obj;
}

tlo_t * tl_smsjobs_updateSettings(bool arg_allow_international)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "smsjobs_updateSettings");
	int i;
	obj->id = 0x093fa0bf;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 2;
	obj->objs = 
		(tlo_t **)MALLOC(2 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument true
	obj->objs[1] = NEW(tlo_t, return NULL);
	obj->objs[1]->flag_num = 1;
	obj->objs[1]->flag_bit = 0;
	obj->objs[1]->type = TYPE_INT;
	obj->objs[1]->value = 
		buf_add_ui32(arg_allow_international);
	strcpy(obj->objs[1]->name, "allow_international");
	if (arg_allow_international)
		flagsv[nflags-1] |= (1 << 0);

	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_smsjobs_getStatus()
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "smsjobs_getStatus");
	int i;
	obj->id = 0x10a698e8;
	return obj;
}

tlo_t * tl_smsjobs_getSmsJob(const char * arg_job_id)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "smsjobs_getSmsJob");
	int i;
	obj->id = 0x778d902f;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument string
	if (arg_job_id){
		obj->objs[0] = NEW(tlo_t, return NULL);
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
		obj->objs[0]->type = TYPE_STRING;
		obj->objs[0]->value = 
			buf_add((ui8_t *)arg_job_id, strlen(arg_job_id));
		strcpy(obj->objs[0]->name, "job_id");
	}

	return obj;
}

tlo_t * tl_smsjobs_finishJob(const char * arg_job_id, const char * arg_error)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "smsjobs_finishJob");
	int i;
	obj->id = 0x4f1ebf24;
	int flags[1]; int nflags = 0; //flags position
 	int flagsv[1]; //flags values
	for (i=0;i<1;++i) flagsv[i]=0;
 	obj->nobjs = 3;
	obj->objs = 
		(tlo_t **)MALLOC(3 * sizeof(tlo_t*), return NULL);

	//parse argument (null)
	obj->objs[0] = NEW(tlo_t, return NULL);
	flags[nflags++] = 0;
	obj->objs[0]->type = TYPE_FLAG;
	strcpy(obj->objs[0]->name, "flags");

	//parse argument string
	if (arg_job_id){
		obj->objs[1] = NEW(tlo_t, return NULL);
		obj->objs[1]->flag_num = 0;
		obj->objs[1]->flag_bit = 0;
		obj->objs[1]->type = TYPE_STRING;
		obj->objs[1]->value = 
			buf_add((ui8_t *)arg_job_id, strlen(arg_job_id));
		strcpy(obj->objs[1]->name, "job_id");
	}


	//parse argument string
	if (arg_error){
		obj->objs[2] = NEW(tlo_t, return NULL);
		obj->objs[2]->flag_num = 1;
		obj->objs[2]->flag_bit = 0;
		obj->objs[2]->type = TYPE_STRING;
		obj->objs[2]->value = 
			buf_add((ui8_t *)arg_error, strlen(arg_error));
		strcpy(obj->objs[2]->name, "error");
		flagsv[nflags-1] |= (1 << 0);
	}


	//write flags
	int flag0 = flags[0];
	obj->objs[flag0]->value = buf_add_ui32(flagsv[0]);
	obj->objs[flag0]->type = TYPE_FLAG;
	return obj;
}

tlo_t * tl_fragment_getCollectibleInfo(InputCollectible arg_collectible)
{
	tlo_t * obj = NEW(tlo_t, return NULL);
	obj->type = TYPE_X;
	strcpy(obj->name, "fragment_getCollectibleInfo");
	int i;
	obj->id = 0xbe1e85ba;
	obj->nobjs = 1;
	obj->objs = 
		(tlo_t **)MALLOC(1 * sizeof(tlo_t*), return NULL);

	//parse argument InputCollectible
	if (arg_collectible){
		obj->objs[0] = arg_collectible;
		obj->objs[0]->flag_num = 0;
		obj->objs[0]->flag_bit = 0;
	strcpy(obj->objs[0]->name, "collectible");
	}

	return obj;
}

