#include "../config.h"
#include "../mtx/include/buf.h"
#include "../mtx/include/setup.h"
#include "tg.h"
#include "../tl/net.h"
#include <stdio.h>
#include <stdlib.h>
#include "strtok_foreach.h"
#include "../tl/serialize.h"
#include "../tl/cmn.h"
#include "../tl/hsh.h"
#include "../tl/cry.h"
#include "../tl/rsa.h"
#include "../mtx/include/net.h"

int _tg_new_auth_key(tg_t *tg, void *on_err_data,
		void (*on_err)(void *on_err_data, tl_t *tl, const char *err))
{
	reset_shared_rc();
	tl_net_open(_ip, _port);
	
 /* Client sends query to server
	* req_pq_multi#be7e8ef1 nonce:int128 = ResPQ;
	* The value of nonce is selected randomly by the client
	* (random number) and identifies the client within this
	* communication. Following this step, it is known to
	* all */

	tl_t *tl = NULL;
	buf_t nonce = buf_rand(16);
	buf_t req_pq = tl_req_pq_multi(nonce);
	tl = tl_send_query_(req_pq, false);
 /* Server sends response of the form
	* resPQ#05162463 nonce:int128 server_nonce:int128
	* pq:string server_public_key_fingerprints:Vector long =
	* ResPQ;
	* Here, string pq is a representation of a natural number
	* (in binary big endian format). This number is the
	* product of two different odd prime numbers. Normally,
	* pq is less than or equal to 2^63-1. The value of
	* server_nonce is selected randomly by the server;
	* following this step, it is known to all.
	*
	* server_public_key_fingerprints is a list of public RSA
	* key fingerprints (64 lower-order bits of SHA1
	* (server_public_key); the public key is represented as a
	* bare type rsa_public_key n:string e:string =
	* RSAPublicKey, where, as usual, n and e are numbers in
	* big endian format serialized as strings of bytes,
	* following
	* which SHA1 is computed) received by the server.
	*
	* All subsequent messages contain the pair (nonce,
	* server_nonce) both in the plain-text, and the encrypted
	* portions which makes it possible to identify a
	* “temporary session” — one run of the key generation
	* protocol described on this page that uses the same
	* (nonce, server_nonce) pair. An intruder could not create
	* a parallel session with the server with the same
	* parameters and reuse parts of server- or
	* client-encrypted messages for its own purposes in such a
	* parallel
	* session, because a different server_nonce would be
	* selected by the server for any new “temporary session”.
	*/
	if (tl && tl->_id == id_resPQ){
		tl_resPQ_t *resPQ = (tl_resPQ_t *)tl;
		printf("server fingerprints:\n");
		int i;
		for (i = 0; i < resPQ->server_public_key_fingerprints_len; ++i) {
			printf("%.16lx\n", resPQ->server_public_key_fingerprints_[i]);
		}

		ui64_t pq_ = buf_get_ui64(buf_swap(resPQ->pq_));
		printf("PQ: %ld\n", pq_);

	 /* Client decomposes pq into prime factors such that
		* p < q. */
		ui32_t p_, q_;
		tl_cmn_fact(pq_, &p_, &q_);
		if (!(p_ < q_)) {
			SWAP(p_, q_);
		}
		buf_t p  = buf_swap(buf_add_ui32(p_));
		buf_t q  = buf_swap(buf_add_ui32(q_));

	 /* encrypted_data payload generation */
	 /* new_nonce := another (good) random number generated by
		* the client; after this query, it is known to both
		* client and server */
		buf_t new_nonce = buf_rand(32);

	 /* data := a serialization of
		*
		* p_q_inner_data_dc#a9f55f95 pq:string p:string
		* q:string nonce:int128 server_nonce:int128
		* new_nonce:int256 dc:int = P_Q_inner_data;
		*
		* or of
		*
		* p_q_inner_data_temp_dc#56fddf88 pq:string
		* p:string q:string nonce:int128
		* server_nonce:int128 new_nonce:int256
		* dc:int expires_in:int = P_Q_inner_data;
		*
		* where dc is the ID of the DC we're
		* talking to; 10000 has to be added to
		* the DC ID when connecting to the test
		* servers; it has to be made negative if
		* the DC
		* we're connecting to is a media
		* (not CDN) DC.
		*/
		buf_t data = 
			tl_p_q_inner_data_dc(
					&resPQ->pq_, 
					&p, 
					&q, 
					nonce, 
					resPQ->server_nonce_, 
					new_nonce, 
					0002);

		printf("p_q_inner_data_dc:\n");
		buf_dump(data);

	 /* encrypted_data := RSA_PAD (data, server_public_key),
		* where RSA_PAD is a version of RSA with a variant of
		* OAEP+ padding explained below in 4.1) */
			
	 /* data_with_padding := data + random_padding_bytes; --
		* where random_padding_bytes are chosen so that the
		* resulting length of data_with_padding is precisely
		*     192 bytes, and data is the TL-serialized data to
		*     be encrypted as before. One has to check that
		*     data is not longer than 144 bytes. */
		if (data.size > 144*8){
			printf("error: data len: %d\n", data.size);
			return 1;
		}
		buf_t random_padding_bytes = 
			buf_rand(192*8 - data.size);
		buf_t data_with_padding = 
			buf_cat(data, random_padding_bytes);

		/* data_pad_reversed := BYTE_REVERSE(data_with_padding);
		 * -- is obtained from data_with_padding by reversing
		 *  the byte order.*/
		buf_t data_pad_reversed = buf_swap(data_with_padding);

generation_new_random_temp_key:;
		/* a random 32-byte temp_key is generated */
		buf_t temp_key = buf_rand(32*8);

		/* data_with_hash := data_pad_reversed + SHA256(temp_key
		 * + data_with_padding); -- after this assignment,
		 * data_with_hash is exactly 224 bytes long. */
		buf_t temp_key_data_with_padding =
			buf_cat(temp_key, data_with_padding);
		buf_t temp_key_data_with_padding_hash = 
			tl_hsh_sha256(temp_key_data_with_padding);
		buf_t data_with_hash = 
			buf_cat(data_pad_reversed, temp_key_data_with_padding_hash);
		if (data_with_hash.size != 224*8){
			 printf("Err: data_with_hash len: %d\n", 
					 data_with_hash.size);
			 return 1;
		 }

		/* aes_encrypted := AES256_IGE(data_with_hash, temp_key,
		 * 0); -- AES256-IGE encryption with zero IV. */
		buf_t aes_encrypted = 
			tl_cry_aes_e(data_with_hash, temp_key, buf_add_ui32(0));

		/* temp_key_xor := temp_key XOR SHA256(aes_encrypted);
		 * -- adjusted key, 32 bytes */
		buf_t aes_encrypted_hash = tl_hsh_sha256(aes_encrypted);
		buf_t temp_key_xor = buf_xor(temp_key, aes_encrypted_hash);
			
		/* key_aes_encrypted := temp_key_xor + aes_encrypted; --
		 * exactly 256 bytes (2048 bits) long */
		buf_t key_aes_encrypted = 
			buf_cat(temp_key_xor, aes_encrypted);
		 if (key_aes_encrypted.size != 256*8){
			 printf("Err: key_aes_encrypted len: %d\n", 
					 key_aes_encrypted.size);
			 return 1;
		 }

		 printf("key_aes_encrypted: \n");
		 buf_dump(key_aes_encrypted);

		/* The value of key_aes_encrypted is compared with the
		 * RSA-modulus of server_pubkey as a big-endian 2048-bit
		 * (256-byte) unsigned integer. If key_aes_encrypted
		 * turns out to be greater than or equal to the RSA
		 * modulus, the previous steps starting from the
		 * generation of new random temp_key are repeated.
		 * Otherwise the final step is performed: */
		 if (tl_rsa_cmp_to_pubkey_modulus(
					 key_aes_encrypted.data, 
					 key_aes_encrypted.size) >= 0)
		 {
			 printf("key_aes_encrypted: greater than or "
					 "equal to the RSA-modulus of server_pubkey\n");
			 goto generation_new_random_temp_key;
		 }

		/* encrypted_data := RSA(key_aes_encrypted,
		 * server_pubkey); -- 256-byte big-endian integer is
		 * elevated to the requisite power from the RSA public
		 * key modulo the RSA modulus, and the result is 
		 * stored as a big-endian integer consisting of 
		 * exactly 256 bytes (with leading zero bytes if 
		 * required). */
		 buf_t encrypted_data = tl_cry_rsa_e(key_aes_encrypted);
		 if (encrypted_data.size != 256*8){
			 printf("Err: encrypted_data len: %d\n", 
					 encrypted_data.size);
			 return 1;
		 }

		/* Send req_DH_params query with generated
		 * encrypted_data */
		buf_t req_DH_params = 
			tl_req_DH_params(
					resPQ->nonce_,
					 resPQ->server_nonce_, 
					&p, &q, 
					resPQ->server_public_key_fingerprints_[0], 
					&encrypted_data);

		tl = tl_send_query_(req_DH_params, false);
	 /* Server responds with
		* server_DH_params_ok#d0e8075c nonce:int128
		* server_nonce:int128 encrypted_answer:string =
		* Server_DH_Params
		* If the query is incorrect, the server returns a -404
		* error and the handshake must be restarted (any
		* subsequent request also returns -404, even if it is
		* correct).
		* A -444 error may also be returned if a test DC
		* ID is passed in p_q_inner_data_(_temp)dc when
		* handshaking with a production DC, and vice
		* versa. */

		if (tl && tl->_id == id_server_DH_params_ok){
			printf("DONE!\n");

		}
	}

	// throw error
	char *err = tg_strerr(tl); 
	if (on_err)
		on_err(on_err_data, tl, err);
	free(err);

	return 1;
}

static buf_t _init(tg_t *tg, buf_t query)
{
	buf_t initConnection = 
		tl_initConnection(
				tg->apiId,
				PACKAGE_NAME, 
				PACKAGE_VERSION, 
				PACKAGE_VERSION, 
				"ru", 
				"LibTg", 
				"ru", 
				NULL, 
				NULL, 
				&query);
	//printf("initConnection:\n");
	//buf_dump(initConnection);
	
	buf_t invokeWithLayer = 
		tl_invokeWithLayer(
				API_LAYER, &initConnection);
	//printf("invokeWithLayer:\n");
	//buf_dump(invokeWithLayer);
	
	return invokeWithLayer;
}

tl_user_t * 
tg_is_authorized(tg_t *tg, void *on_err_data,
		void (*on_err)(void *on_err_data, tl_t *tl, const char *err))
{
	// try to load auth_key_id from database
	buf_t auth_key = auth_key_from_database(tg);

	if (auth_key.size){
		//printf("Have auth_key with len: %d\n", auth_key.size);
		reset_shared_rc();
		//tl_net_open(_ip, _port);
		net_open(_ip, _port);
		shared_rc.salt = buf_rand_(8);
		shared_rc.key = buf_add_(auth_key.data, auth_key.size);
		shared_rc.seqnh = -1;
		api.log.info(".. new session");
		shared_rc.ssid = buf_rand_(8);
		
		// check if authorized
		InputUser iuser = tl_inputUserSelf();
		printf("iuser:\n");
		buf_dump(iuser);
		
		buf_t getUsers = 
			tl_users_getUsers(&iuser, 1);	
		printf("getUsers:\n");
		buf_dump(getUsers);
		
		tl_t *tl = 
			tl_send_query(_init(tg, getUsers)); 
		
		if (tl && tl->_id == id_vector){
			tl_t *user = tl_deserialize(&((tl_vector_t *)tl)->data_);
			if (user && user->_id == id_user){
				return (tl_user_t *)user;
			}
		}
		// throw error
		char *err = tg_strerr(tl); 
		if (on_err)
			on_err(on_err_data, tl, err);
		free(err);
		// free tl
		/* TODO:  <14-11-24, kuzmich> */
		return NULL;
	}

	if (on_err)
		on_err(on_err_data, NULL, "NEED_TO_AUTHORIZE");
	return NULL;
}

tl_auth_sentCode_t *
tg_auth_sendCode(tg_t *tg, const char *phone_number, 
		void *on_err_data,
		void (*on_err)(void *on_err_data, tl_t *tl, const char *err))
{
	// get tokens from database 
	buf_t t[20]; int tn = 0;
	char *auth_tokens = auth_tokens_from_database(tg);
	if (auth_tokens){
		strtok_foreach(auth_tokens, ";", token){
			t[tn++] = 
				buf_add((ui8_t*)token, strlen(token)); 
		}
	}
	
	// authorize with new key
	api.app.open();
	//api.net.close(shared_rc.net);

	// net
	//tl_net_open(_ip, _port);
	api.log.info(".. new session");
	shared_rc.ssid = buf_rand_(8);
	
	CodeSettings codeSettings = tl_codeSettings(
			false,
		 	false,
		 	false,
		 	false,
		 	false, 
			false,
		 	auth_tokens ? t : NULL,
		 	tn,
		 	NULL,
		 	NULL);

	//printf("codeSettings:\n");
	//buf_dump(codeSettings);

	buf_t sendCode = 
		tl_auth_sendCode(
				phone_number, 
				tg->apiId, 
				tg->apiHash, 
				&codeSettings);
	
	//printf("sendCode:\n");
	//buf_dump(sendCode);

	tl_t *tl = 
		tl_send_query(_init(tg, sendCode)); 

	if (tl && tl->_id == id_auth_sentCode){
		return (tl_auth_sentCode_t *)tl;
	}
	// throw error
	char *err = tg_strerr(tl); 
	if (on_err)
		on_err(on_err_data, tl, err);
	free(err);
	// free tl
	/* TODO:  <14-11-24, kuzmich> */

	return NULL;
}

tl_user_t *
tg_auth_signIn(tg_t *tg, tl_auth_sentCode_t *sentCode, 
		const char *phone_number, const char *phone_code, 
		void *on_err_data,
		void (*on_err)(void *on_err_data, tl_t *tl, const char *err))
{
	buf_t signIn = 
		tl_auth_signIn(
				phone_number, 
				(char *)sentCode->phone_code_hash_.data, 
				phone_code, 
				NULL);
	
	tl_t *tl = 
		tl_send_query(signIn);
	
	if (tl && tl->_id == id_auth_authorization){
		tl_auth_authorization_t *auth =
			(tl_auth_authorization_t *)tl;

		if (auth->setup_password_required_){
			// throw error
			if (on_err)
				on_err(on_err_data, tl, "SESSION_PASSWORD_NEEDED");
			return NULL;
		}
		
		if (auth->future_auth_token_.size > 0){
		// save auth token
			char auth_token[BUFSIZ];
			strncpy(
				auth_token,
				((char *)auth->future_auth_token_.data),
				auth->future_auth_token_.size);
			auth_token_to_database(tg, auth_token);
		}
		// save auth_key_id 
		auth_key_to_database(
				tg, buf_add(shared_rc.key.data, shared_rc.key.size),
				phone_number);

		// save settings
		tg->rc = shared_rc;

		return (tl_user_t *)auth->user_;
	}

	// throw error
	char *err = tg_strerr(tl); 
	if (on_err)
		on_err(on_err_data, tl, err);
	free(err);
	// free tl
	/* TODO:  <14-11-24, kuzmich> */

	return NULL;
}
