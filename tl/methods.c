/* generated by tl_generator */

#include "methods.h"
#include "serialize.h"
#include "alloc.h"

buf_t tl_resPQ(int128 nonce_, int128 server_nonce_, const char * pq_, long *server_public_key_fingerprints_, int server_public_key_fingerprints_len)
{
	buf_t buf = buf_add_ui32(0x05162463);
	//parse argument nonce (int128)
	{
		int i;
		for (i=0; i<4; ++i)
			buf = buf_cat(buf, buf_add_ui32(nonce_[i]));
	}
	//parse argument server_nonce (int128)
	{
		int i;
		for (i=0; i<4; ++i)
			buf = buf_cat(buf, buf_add_ui32(server_nonce_[i]));
	}
	//parse argument pq (string)
	{
		buf = buf_cat(buf, serialize_string(pq_));
	}
	//parse argument server_public_key_fingerprints (Vector<long>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(server_public_key_fingerprints_len));
		int i;
		for (i=0; i<server_public_key_fingerprints_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(server_public_key_fingerprints_[i]));
		}
	}
	return buf;
}

buf_t tl_p_q_inner_data_dc(const char * pq_, const char * p_, const char * q_, int128 nonce_, int128 server_nonce_, int256 new_nonce_, int dc_)
{
	buf_t buf = buf_add_ui32(0xa9f55f95);
	//parse argument pq (string)
	{
		buf = buf_cat(buf, serialize_string(pq_));
	}
	//parse argument p (string)
	{
		buf = buf_cat(buf, serialize_string(p_));
	}
	//parse argument q (string)
	{
		buf = buf_cat(buf, serialize_string(q_));
	}
	//parse argument nonce (int128)
	{
		int i;
		for (i=0; i<4; ++i)
			buf = buf_cat(buf, buf_add_ui32(nonce_[i]));
	}
	//parse argument server_nonce (int128)
	{
		int i;
		for (i=0; i<4; ++i)
			buf = buf_cat(buf, buf_add_ui32(server_nonce_[i]));
	}
	//parse argument new_nonce (int256)
	{
		int i;
		for (i=0; i<8; ++i)
			buf = buf_cat(buf, buf_add_ui32(new_nonce_[i]));
	}
	//parse argument dc (int)
	{
		buf = buf_cat(buf, buf_add_ui32(dc_));
	}
	return buf;
}

buf_t tl_p_q_inner_data_temp_dc(const char * pq_, const char * p_, const char * q_, int128 nonce_, int128 server_nonce_, int256 new_nonce_, int dc_, int expires_in_)
{
	buf_t buf = buf_add_ui32(0x56fddf88);
	//parse argument pq (string)
	{
		buf = buf_cat(buf, serialize_string(pq_));
	}
	//parse argument p (string)
	{
		buf = buf_cat(buf, serialize_string(p_));
	}
	//parse argument q (string)
	{
		buf = buf_cat(buf, serialize_string(q_));
	}
	//parse argument nonce (int128)
	{
		int i;
		for (i=0; i<4; ++i)
			buf = buf_cat(buf, buf_add_ui32(nonce_[i]));
	}
	//parse argument server_nonce (int128)
	{
		int i;
		for (i=0; i<4; ++i)
			buf = buf_cat(buf, buf_add_ui32(server_nonce_[i]));
	}
	//parse argument new_nonce (int256)
	{
		int i;
		for (i=0; i<8; ++i)
			buf = buf_cat(buf, buf_add_ui32(new_nonce_[i]));
	}
	//parse argument dc (int)
	{
		buf = buf_cat(buf, buf_add_ui32(dc_));
	}
	//parse argument expires_in (int)
	{
		buf = buf_cat(buf, buf_add_ui32(expires_in_));
	}
	return buf;
}

buf_t tl_server_DH_params_ok(int128 nonce_, int128 server_nonce_, const char * encrypted_answer_)
{
	buf_t buf = buf_add_ui32(0xd0e8075c);
	//parse argument nonce (int128)
	{
		int i;
		for (i=0; i<4; ++i)
			buf = buf_cat(buf, buf_add_ui32(nonce_[i]));
	}
	//parse argument server_nonce (int128)
	{
		int i;
		for (i=0; i<4; ++i)
			buf = buf_cat(buf, buf_add_ui32(server_nonce_[i]));
	}
	//parse argument encrypted_answer (string)
	{
		buf = buf_cat(buf, serialize_string(encrypted_answer_));
	}
	return buf;
}

buf_t tl_server_DH_inner_data(int128 nonce_, int128 server_nonce_, int g_, const char * dh_prime_, const char * g_a_, int server_time_)
{
	buf_t buf = buf_add_ui32(0xb5890dba);
	//parse argument nonce (int128)
	{
		int i;
		for (i=0; i<4; ++i)
			buf = buf_cat(buf, buf_add_ui32(nonce_[i]));
	}
	//parse argument server_nonce (int128)
	{
		int i;
		for (i=0; i<4; ++i)
			buf = buf_cat(buf, buf_add_ui32(server_nonce_[i]));
	}
	//parse argument g (int)
	{
		buf = buf_cat(buf, buf_add_ui32(g_));
	}
	//parse argument dh_prime (string)
	{
		buf = buf_cat(buf, serialize_string(dh_prime_));
	}
	//parse argument g_a (string)
	{
		buf = buf_cat(buf, serialize_string(g_a_));
	}
	//parse argument server_time (int)
	{
		buf = buf_cat(buf, buf_add_ui32(server_time_));
	}
	return buf;
}

buf_t tl_client_DH_inner_data(int128 nonce_, int128 server_nonce_, long retry_id_, const char * g_b_)
{
	buf_t buf = buf_add_ui32(0x6643b654);
	//parse argument nonce (int128)
	{
		int i;
		for (i=0; i<4; ++i)
			buf = buf_cat(buf, buf_add_ui32(nonce_[i]));
	}
	//parse argument server_nonce (int128)
	{
		int i;
		for (i=0; i<4; ++i)
			buf = buf_cat(buf, buf_add_ui32(server_nonce_[i]));
	}
	//parse argument retry_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(retry_id_));
	}
	//parse argument g_b (string)
	{
		buf = buf_cat(buf, serialize_string(g_b_));
	}
	return buf;
}

buf_t tl_dh_gen_ok(int128 nonce_, int128 server_nonce_, int128 new_nonce_hash1_)
{
	buf_t buf = buf_add_ui32(0x3bcbf734);
	//parse argument nonce (int128)
	{
		int i;
		for (i=0; i<4; ++i)
			buf = buf_cat(buf, buf_add_ui32(nonce_[i]));
	}
	//parse argument server_nonce (int128)
	{
		int i;
		for (i=0; i<4; ++i)
			buf = buf_cat(buf, buf_add_ui32(server_nonce_[i]));
	}
	//parse argument new_nonce_hash1 (int128)
	{
		int i;
		for (i=0; i<4; ++i)
			buf = buf_cat(buf, buf_add_ui32(new_nonce_hash1_[i]));
	}
	return buf;
}

buf_t tl_dh_gen_retry(int128 nonce_, int128 server_nonce_, int128 new_nonce_hash2_)
{
	buf_t buf = buf_add_ui32(0x46dc1fb9);
	//parse argument nonce (int128)
	{
		int i;
		for (i=0; i<4; ++i)
			buf = buf_cat(buf, buf_add_ui32(nonce_[i]));
	}
	//parse argument server_nonce (int128)
	{
		int i;
		for (i=0; i<4; ++i)
			buf = buf_cat(buf, buf_add_ui32(server_nonce_[i]));
	}
	//parse argument new_nonce_hash2 (int128)
	{
		int i;
		for (i=0; i<4; ++i)
			buf = buf_cat(buf, buf_add_ui32(new_nonce_hash2_[i]));
	}
	return buf;
}

buf_t tl_dh_gen_fail(int128 nonce_, int128 server_nonce_, int128 new_nonce_hash3_)
{
	buf_t buf = buf_add_ui32(0xa69dae02);
	//parse argument nonce (int128)
	{
		int i;
		for (i=0; i<4; ++i)
			buf = buf_cat(buf, buf_add_ui32(nonce_[i]));
	}
	//parse argument server_nonce (int128)
	{
		int i;
		for (i=0; i<4; ++i)
			buf = buf_cat(buf, buf_add_ui32(server_nonce_[i]));
	}
	//parse argument new_nonce_hash3 (int128)
	{
		int i;
		for (i=0; i<4; ++i)
			buf = buf_cat(buf, buf_add_ui32(new_nonce_hash3_[i]));
	}
	return buf;
}

buf_t tl_bind_auth_key_inner(long nonce_, long temp_auth_key_id_, long perm_auth_key_id_, long temp_session_id_, int expires_at_)
{
	buf_t buf = buf_add_ui32(0x75a3f765);
	//parse argument nonce (long)
	{
		buf = buf_cat(buf, buf_add_ui64(nonce_));
	}
	//parse argument temp_auth_key_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(temp_auth_key_id_));
	}
	//parse argument perm_auth_key_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(perm_auth_key_id_));
	}
	//parse argument temp_session_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(temp_session_id_));
	}
	//parse argument expires_at (int)
	{
		buf = buf_cat(buf, buf_add_ui32(expires_at_));
	}
	return buf;
}

buf_t tl_rpc_result(long req_msg_id_, const char * result_)
{
	buf_t buf = buf_add_ui32(0xf35c6d01);
	//parse argument req_msg_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(req_msg_id_));
	}
	//parse argument result (string)
	{
		buf = buf_cat(buf, serialize_string(result_));
	}
	return buf;
}

buf_t tl_rpc_error(int error_code_, const char * error_message_)
{
	buf_t buf = buf_add_ui32(0x2144ca19);
	//parse argument error_code (int)
	{
		buf = buf_cat(buf, buf_add_ui32(error_code_));
	}
	//parse argument error_message (string)
	{
		buf = buf_cat(buf, serialize_string(error_message_));
	}
	return buf;
}

buf_t tl_rpc_answer_unknown()
{
	buf_t buf = buf_add_ui32(0x5e2ad36e);
	return buf;
}

buf_t tl_rpc_answer_dropped_running()
{
	buf_t buf = buf_add_ui32(0xcd78e586);
	return buf;
}

buf_t tl_rpc_answer_dropped(long msg_id_, int seq_no_, int bytes_)
{
	buf_t buf = buf_add_ui32(0xa43ad8b7);
	//parse argument msg_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(msg_id_));
	}
	//parse argument seq_no (int)
	{
		buf = buf_cat(buf, buf_add_ui32(seq_no_));
	}
	//parse argument bytes (int)
	{
		buf = buf_cat(buf, buf_add_ui32(bytes_));
	}
	return buf;
}

buf_t tl_future_salt(int valid_since_, int valid_until_, long salt_)
{
	buf_t buf = buf_add_ui32(0x0949d9dc);
	//parse argument valid_since (int)
	{
		buf = buf_cat(buf, buf_add_ui32(valid_since_));
	}
	//parse argument valid_until (int)
	{
		buf = buf_cat(buf, buf_add_ui32(valid_until_));
	}
	//parse argument salt (long)
	{
		buf = buf_cat(buf, buf_add_ui64(salt_));
	}
	return buf;
}

buf_t tl_future_salts(long req_msg_id_, int now_, FutureSalt *salts_, int salts_len)
{
	buf_t buf = buf_add_ui32(0xae500895);
	//parse argument req_msg_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(req_msg_id_));
	}
	//parse argument now (int)
	{
		buf = buf_cat(buf, buf_add_ui32(now_));
	}
	//parse argument salts (vector<future_salt>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(salts_len));
		int i;
		for (i=0; i<salts_len; ++i){
			buf = buf_cat(buf, salts_[i]);
		}
	}
	return buf;
}

buf_t tl_pong(long msg_id_, long ping_id_)
{
	buf_t buf = buf_add_ui32(0x347773c5);
	//parse argument msg_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(msg_id_));
	}
	//parse argument ping_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(ping_id_));
	}
	return buf;
}

buf_t tl_destroy_session_ok(long session_id_)
{
	buf_t buf = buf_add_ui32(0xe22045fc);
	//parse argument session_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(session_id_));
	}
	return buf;
}

buf_t tl_destroy_session_none(long session_id_)
{
	buf_t buf = buf_add_ui32(0x62d350c9);
	//parse argument session_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(session_id_));
	}
	return buf;
}

buf_t tl_new_session_created(long first_msg_id_, long unique_id_, long server_salt_)
{
	buf_t buf = buf_add_ui32(0x9ec20908);
	//parse argument first_msg_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(first_msg_id_));
	}
	//parse argument unique_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(unique_id_));
	}
	//parse argument server_salt (long)
	{
		buf = buf_cat(buf, buf_add_ui64(server_salt_));
	}
	return buf;
}

buf_t tl_msg_container(buf_t *messages_, int messages_len)
{
	buf_t buf = buf_add_ui32(0x73f1f8dc);
	//parse argument messages (vector<%Message>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(messages_len));
		int i;
		for (i=0; i<messages_len; ++i){
			buf = buf_cat(buf, messages_[i]);
		}
	}
	return buf;
}

buf_t tl_msg_copy(Message *orig_message_)
{
	buf_t buf = buf_add_ui32(0xe06046b2);
	//parse argument orig_message (Message)
	{
		buf = buf_cat(buf, *orig_message_);
	}
	return buf;
}

buf_t tl_gzip_packed(const char * packed_data_)
{
	buf_t buf = buf_add_ui32(0x3072cfa1);
	//parse argument packed_data (string)
	{
		buf = buf_cat(buf, serialize_string(packed_data_));
	}
	return buf;
}

buf_t tl_msgs_ack(long *msg_ids_, int msg_ids_len)
{
	buf_t buf = buf_add_ui32(0x62d6b459);
	//parse argument msg_ids (Vector<long>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(msg_ids_len));
		int i;
		for (i=0; i<msg_ids_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(msg_ids_[i]));
		}
	}
	return buf;
}

buf_t tl_bad_msg_notification(long bad_msg_id_, int bad_msg_seqno_, int error_code_)
{
	buf_t buf = buf_add_ui32(0xa7eff811);
	//parse argument bad_msg_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(bad_msg_id_));
	}
	//parse argument bad_msg_seqno (int)
	{
		buf = buf_cat(buf, buf_add_ui32(bad_msg_seqno_));
	}
	//parse argument error_code (int)
	{
		buf = buf_cat(buf, buf_add_ui32(error_code_));
	}
	return buf;
}

buf_t tl_bad_server_salt(long bad_msg_id_, int bad_msg_seqno_, int error_code_, long new_server_salt_)
{
	buf_t buf = buf_add_ui32(0xedab447b);
	//parse argument bad_msg_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(bad_msg_id_));
	}
	//parse argument bad_msg_seqno (int)
	{
		buf = buf_cat(buf, buf_add_ui32(bad_msg_seqno_));
	}
	//parse argument error_code (int)
	{
		buf = buf_cat(buf, buf_add_ui32(error_code_));
	}
	//parse argument new_server_salt (long)
	{
		buf = buf_cat(buf, buf_add_ui64(new_server_salt_));
	}
	return buf;
}

buf_t tl_msg_resend_req(long *msg_ids_, int msg_ids_len)
{
	buf_t buf = buf_add_ui32(0x7d861a08);
	//parse argument msg_ids (Vector<long>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(msg_ids_len));
		int i;
		for (i=0; i<msg_ids_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(msg_ids_[i]));
		}
	}
	return buf;
}

buf_t tl_msgs_state_req(long *msg_ids_, int msg_ids_len)
{
	buf_t buf = buf_add_ui32(0xda69fb52);
	//parse argument msg_ids (Vector<long>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(msg_ids_len));
		int i;
		for (i=0; i<msg_ids_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(msg_ids_[i]));
		}
	}
	return buf;
}

buf_t tl_msgs_state_info(long req_msg_id_, const char * info_)
{
	buf_t buf = buf_add_ui32(0x04deb57d);
	//parse argument req_msg_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(req_msg_id_));
	}
	//parse argument info (string)
	{
		buf = buf_cat(buf, serialize_string(info_));
	}
	return buf;
}

buf_t tl_msgs_all_info(long *msg_ids_, int msg_ids_len, const char * info_)
{
	buf_t buf = buf_add_ui32(0x8cc0d131);
	//parse argument msg_ids (Vector<long>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(msg_ids_len));
		int i;
		for (i=0; i<msg_ids_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(msg_ids_[i]));
		}
	}
	//parse argument info (string)
	{
		buf = buf_cat(buf, serialize_string(info_));
	}
	return buf;
}

buf_t tl_msg_detailed_info(long msg_id_, long answer_msg_id_, int bytes_, int status_)
{
	buf_t buf = buf_add_ui32(0x276d3ec6);
	//parse argument msg_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(msg_id_));
	}
	//parse argument answer_msg_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(answer_msg_id_));
	}
	//parse argument bytes (int)
	{
		buf = buf_cat(buf, buf_add_ui32(bytes_));
	}
	//parse argument status (int)
	{
		buf = buf_cat(buf, buf_add_ui32(status_));
	}
	return buf;
}

buf_t tl_msg_new_detailed_info(long answer_msg_id_, int bytes_, int status_)
{
	buf_t buf = buf_add_ui32(0x809db6df);
	//parse argument answer_msg_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(answer_msg_id_));
	}
	//parse argument bytes (int)
	{
		buf = buf_cat(buf, buf_add_ui32(bytes_));
	}
	//parse argument status (int)
	{
		buf = buf_cat(buf, buf_add_ui32(status_));
	}
	return buf;
}

buf_t tl_destroy_auth_key_ok()
{
	buf_t buf = buf_add_ui32(0xf660e1d4);
	return buf;
}

buf_t tl_destroy_auth_key_none()
{
	buf_t buf = buf_add_ui32(0x0a9f2259);
	return buf;
}

buf_t tl_destroy_auth_key_fail()
{
	buf_t buf = buf_add_ui32(0xea109b13);
	return buf;
}

buf_t tl_req_pq_multi(int128 nonce_)
{
	buf_t buf = buf_add_ui32(0xbe7e8ef1);
	//parse argument nonce (int128)
	{
		int i;
		for (i=0; i<4; ++i)
			buf = buf_cat(buf, buf_add_ui32(nonce_[i]));
	}
	return buf;
}

buf_t tl_req_DH_params(int128 nonce_, int128 server_nonce_, const char * p_, const char * q_, long public_key_fingerprint_, const char * encrypted_data_)
{
	buf_t buf = buf_add_ui32(0xd712e4be);
	//parse argument nonce (int128)
	{
		int i;
		for (i=0; i<4; ++i)
			buf = buf_cat(buf, buf_add_ui32(nonce_[i]));
	}
	//parse argument server_nonce (int128)
	{
		int i;
		for (i=0; i<4; ++i)
			buf = buf_cat(buf, buf_add_ui32(server_nonce_[i]));
	}
	//parse argument p (string)
	{
		buf = buf_cat(buf, serialize_string(p_));
	}
	//parse argument q (string)
	{
		buf = buf_cat(buf, serialize_string(q_));
	}
	//parse argument public_key_fingerprint (long)
	{
		buf = buf_cat(buf, buf_add_ui64(public_key_fingerprint_));
	}
	//parse argument encrypted_data (string)
	{
		buf = buf_cat(buf, serialize_string(encrypted_data_));
	}
	return buf;
}

buf_t tl_set_client_DH_params(int128 nonce_, int128 server_nonce_, const char * encrypted_data_)
{
	buf_t buf = buf_add_ui32(0xf5045f1f);
	//parse argument nonce (int128)
	{
		int i;
		for (i=0; i<4; ++i)
			buf = buf_cat(buf, buf_add_ui32(nonce_[i]));
	}
	//parse argument server_nonce (int128)
	{
		int i;
		for (i=0; i<4; ++i)
			buf = buf_cat(buf, buf_add_ui32(server_nonce_[i]));
	}
	//parse argument encrypted_data (string)
	{
		buf = buf_cat(buf, serialize_string(encrypted_data_));
	}
	return buf;
}

buf_t tl_rpc_drop_answer(long req_msg_id_)
{
	buf_t buf = buf_add_ui32(0x58e4a740);
	//parse argument req_msg_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(req_msg_id_));
	}
	return buf;
}

buf_t tl_get_future_salts(int num_)
{
	buf_t buf = buf_add_ui32(0xb921bd04);
	//parse argument num (int)
	{
		buf = buf_cat(buf, buf_add_ui32(num_));
	}
	return buf;
}

buf_t tl_ping(long ping_id_)
{
	buf_t buf = buf_add_ui32(0x7abe77ec);
	//parse argument ping_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(ping_id_));
	}
	return buf;
}

buf_t tl_ping_delay_disconnect(long ping_id_, int disconnect_delay_)
{
	buf_t buf = buf_add_ui32(0xf3427b8c);
	//parse argument ping_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(ping_id_));
	}
	//parse argument disconnect_delay (int)
	{
		buf = buf_cat(buf, buf_add_ui32(disconnect_delay_));
	}
	return buf;
}

buf_t tl_destroy_session(long session_id_)
{
	buf_t buf = buf_add_ui32(0xe7512126);
	//parse argument session_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(session_id_));
	}
	return buf;
}

buf_t tl_http_wait(int max_delay_, int wait_after_, int max_wait_)
{
	buf_t buf = buf_add_ui32(0x9299359f);
	//parse argument max_delay (int)
	{
		buf = buf_cat(buf, buf_add_ui32(max_delay_));
	}
	//parse argument wait_after (int)
	{
		buf = buf_cat(buf, buf_add_ui32(wait_after_));
	}
	//parse argument max_wait (int)
	{
		buf = buf_cat(buf, buf_add_ui32(max_wait_));
	}
	return buf;
}

buf_t tl_destroy_auth_key()
{
	buf_t buf = buf_add_ui32(0xd1435160);
	return buf;
}

buf_t tl_true()
{
	buf_t buf = buf_add_ui32(0x3fedd339);
	return buf;
}

buf_t tl_boolFalse()
{
	buf_t buf = buf_add_ui32(0xbc799737);
	return buf;
}

buf_t tl_boolTrue()
{
	buf_t buf = buf_add_ui32(0x997275b5);
	return buf;
}

buf_t tl_vector()
{
	buf_t buf = buf_add_ui32(0x1cb5c415);
	return buf;
}

buf_t tl_error(int code_, const char * text_)
{
	buf_t buf = buf_add_ui32(0xc4b9f9bb);
	//parse argument code (int)
	{
		buf = buf_cat(buf, buf_add_ui32(code_));
	}
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	return buf;
}

buf_t tl_ipPort(int ipv4_, int port_)
{
	buf_t buf = buf_add_ui32(0xd433ad73);
	//parse argument ipv4 (int)
	{
		buf = buf_cat(buf, buf_add_ui32(ipv4_));
	}
	//parse argument port (int)
	{
		buf = buf_cat(buf, buf_add_ui32(port_));
	}
	return buf;
}

buf_t tl_ipPortSecret(int ipv4_, int port_, buf_t *secret_)
{
	buf_t buf = buf_add_ui32(0x37982646);
	//parse argument ipv4 (int)
	{
		buf = buf_cat(buf, buf_add_ui32(ipv4_));
	}
	//parse argument port (int)
	{
		buf = buf_cat(buf, buf_add_ui32(port_));
	}
	//parse argument secret (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(secret_->data, secret_->size));
	}
	return buf;
}

buf_t tl_accessPointRule(const char * phone_prefix_rules_, int dc_id_, IpPort *ips_, int ips_len)
{
	buf_t buf = buf_add_ui32(0x4679b65f);
	//parse argument phone_prefix_rules (string)
	{
		buf = buf_cat(buf, serialize_string(phone_prefix_rules_));
	}
	//parse argument dc_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(dc_id_));
	}
	//parse argument ips (vector<IpPort>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(ips_len));
		int i;
		for (i=0; i<ips_len; ++i){
			buf = buf_cat(buf, ips_[i]);
		}
	}
	return buf;
}

buf_t tl_help_configSimple(int date_, int expires_, AccessPointRule *rules_, int rules_len)
{
	buf_t buf = buf_add_ui32(0x5a592a6c);
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument expires (int)
	{
		buf = buf_cat(buf, buf_add_ui32(expires_));
	}
	//parse argument rules (vector<AccessPointRule>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(rules_len));
		int i;
		for (i=0; i<rules_len; ++i){
			buf = buf_cat(buf, rules_[i]);
		}
	}
	return buf;
}

buf_t tl_inputPeerPhotoFileLocationLegacy(bool big_, InputPeer *peer_, long volume_id_, int local_id_)
{
	buf_t buf = buf_add_ui32(0x27d69997);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument big (true)
	if (big_)
		*flag1 |= (1 << 0);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument volume_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(volume_id_));
	}
	//parse argument local_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(local_id_));
	}
	return buf;
}

buf_t tl_inputStickerSetThumbLegacy(InputStickerSet *stickerset_, long volume_id_, int local_id_)
{
	buf_t buf = buf_add_ui32(0x0dbaeae9);
	//parse argument stickerset (InputStickerSet)
	{
		buf = buf_cat(buf, *stickerset_);
	}
	//parse argument volume_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(volume_id_));
	}
	//parse argument local_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(local_id_));
	}
	return buf;
}

buf_t tl_invokeWithBusinessConnectionPrefix(const char * connection_id_)
{
	buf_t buf = buf_add_ui32(0xdd289f8e);
	//parse argument connection_id (string)
	{
		buf = buf_cat(buf, serialize_string(connection_id_));
	}
	return buf;
}

buf_t tl_invokeWithGooglePlayIntegrityPrefix(const char * nonce_, const char * token_)
{
	buf_t buf = buf_add_ui32(0x1df92984);
	//parse argument nonce (string)
	{
		buf = buf_cat(buf, serialize_string(nonce_));
	}
	//parse argument token (string)
	{
		buf = buf_cat(buf, serialize_string(token_));
	}
	return buf;
}

buf_t tl_invokeWithApnsSecretPrefix(const char * nonce_, const char * secret_)
{
	buf_t buf = buf_add_ui32(0x0dae54f8);
	//parse argument nonce (string)
	{
		buf = buf_cat(buf, serialize_string(nonce_));
	}
	//parse argument secret (string)
	{
		buf = buf_cat(buf, serialize_string(secret_));
	}
	return buf;
}

buf_t tl_inputPeerEmpty()
{
	buf_t buf = buf_add_ui32(0x7f3b18ea);
	return buf;
}

buf_t tl_inputPeerSelf()
{
	buf_t buf = buf_add_ui32(0x7da07ec9);
	return buf;
}

buf_t tl_inputPeerChat(long chat_id_)
{
	buf_t buf = buf_add_ui32(0x35a95cb9);
	//parse argument chat_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(chat_id_));
	}
	return buf;
}

buf_t tl_inputPeerUser(long user_id_, long access_hash_)
{
	buf_t buf = buf_add_ui32(0xdde8a54c);
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	return buf;
}

buf_t tl_inputPeerChannel(long channel_id_, long access_hash_)
{
	buf_t buf = buf_add_ui32(0x27bcbbfc);
	//parse argument channel_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(channel_id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	return buf;
}

buf_t tl_inputPeerUserFromMessage(InputPeer *peer_, int msg_id_, long user_id_)
{
	buf_t buf = buf_add_ui32(0xa87b0a1c);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	return buf;
}

buf_t tl_inputPeerChannelFromMessage(InputPeer *peer_, int msg_id_, long channel_id_)
{
	buf_t buf = buf_add_ui32(0xbd2a0840);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	//parse argument channel_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(channel_id_));
	}
	return buf;
}

buf_t tl_inputUserEmpty()
{
	buf_t buf = buf_add_ui32(0xb98886cf);
	return buf;
}

buf_t tl_inputUserSelf()
{
	buf_t buf = buf_add_ui32(0xf7c1b13f);
	return buf;
}

buf_t tl_inputUser(long user_id_, long access_hash_)
{
	buf_t buf = buf_add_ui32(0xf21158c6);
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	return buf;
}

buf_t tl_inputUserFromMessage(InputPeer *peer_, int msg_id_, long user_id_)
{
	buf_t buf = buf_add_ui32(0x1da448e2);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	return buf;
}

buf_t tl_inputPhoneContact(long client_id_, const char * phone_, const char * first_name_, const char * last_name_)
{
	buf_t buf = buf_add_ui32(0xf392b7f4);
	//parse argument client_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(client_id_));
	}
	//parse argument phone (string)
	{
		buf = buf_cat(buf, serialize_string(phone_));
	}
	//parse argument first_name (string)
	{
		buf = buf_cat(buf, serialize_string(first_name_));
	}
	//parse argument last_name (string)
	{
		buf = buf_cat(buf, serialize_string(last_name_));
	}
	return buf;
}

buf_t tl_inputFile(long id_, int parts_, const char * name_, const char * md5_checksum_)
{
	buf_t buf = buf_add_ui32(0xf52ff27f);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument parts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(parts_));
	}
	//parse argument name (string)
	{
		buf = buf_cat(buf, serialize_string(name_));
	}
	//parse argument md5_checksum (string)
	{
		buf = buf_cat(buf, serialize_string(md5_checksum_));
	}
	return buf;
}

buf_t tl_inputFileBig(long id_, int parts_, const char * name_)
{
	buf_t buf = buf_add_ui32(0xfa4f0bb5);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument parts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(parts_));
	}
	//parse argument name (string)
	{
		buf = buf_cat(buf, serialize_string(name_));
	}
	return buf;
}

buf_t tl_inputFileStoryDocument(InputDocument *id_)
{
	buf_t buf = buf_add_ui32(0x62dc8b48);
	//parse argument id (InputDocument)
	{
		buf = buf_cat(buf, *id_);
	}
	return buf;
}

buf_t tl_inputMediaEmpty()
{
	buf_t buf = buf_add_ui32(0x9664f57f);
	return buf;
}

buf_t tl_inputMediaUploadedPhoto(bool spoiler_, InputFile *file_, InputDocument *stickers_, int stickers_len, int ttl_seconds_)
{
	buf_t buf = buf_add_ui32(0x1e287d04);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument spoiler (true)
	if (spoiler_)
		*flag1 |= (1 << 2);
	//parse argument file (InputFile)
	{
		buf = buf_cat(buf, *file_);
	}
	//parse argument stickers (Vector<InputDocument>)
	if (stickers_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(stickers_len));
		int i;
		for (i=0; i<stickers_len; ++i){
			buf = buf_cat(buf, stickers_[i]);
		}
		*flag1 |= (1 << 0);
	}
	//parse argument ttl_seconds (int)
	if (ttl_seconds_)
	{
		buf = buf_cat(buf, buf_add_ui32(ttl_seconds_));
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_inputMediaPhoto(bool spoiler_, InputPhoto *id_, int ttl_seconds_)
{
	buf_t buf = buf_add_ui32(0xb3ba0635);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument spoiler (true)
	if (spoiler_)
		*flag1 |= (1 << 1);
	//parse argument id (InputPhoto)
	{
		buf = buf_cat(buf, *id_);
	}
	//parse argument ttl_seconds (int)
	if (ttl_seconds_)
	{
		buf = buf_cat(buf, buf_add_ui32(ttl_seconds_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_inputMediaGeoPoint(InputGeoPoint *geo_point_)
{
	buf_t buf = buf_add_ui32(0xf9c44144);
	//parse argument geo_point (InputGeoPoint)
	{
		buf = buf_cat(buf, *geo_point_);
	}
	return buf;
}

buf_t tl_inputMediaContact(const char * phone_number_, const char * first_name_, const char * last_name_, const char * vcard_)
{
	buf_t buf = buf_add_ui32(0xf8ab7dfb);
	//parse argument phone_number (string)
	{
		buf = buf_cat(buf, serialize_string(phone_number_));
	}
	//parse argument first_name (string)
	{
		buf = buf_cat(buf, serialize_string(first_name_));
	}
	//parse argument last_name (string)
	{
		buf = buf_cat(buf, serialize_string(last_name_));
	}
	//parse argument vcard (string)
	{
		buf = buf_cat(buf, serialize_string(vcard_));
	}
	return buf;
}

buf_t tl_inputMediaUploadedDocument(bool nosound_video_, bool force_file_, bool spoiler_, InputFile *file_, InputFile *thumb_, const char * mime_type_, DocumentAttribute *attributes_, int attributes_len, InputDocument *stickers_, int stickers_len, int ttl_seconds_)
{
	buf_t buf = buf_add_ui32(0x5b38c6c1);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument nosound_video (true)
	if (nosound_video_)
		*flag1 |= (1 << 3);
	//parse argument force_file (true)
	if (force_file_)
		*flag1 |= (1 << 4);
	//parse argument spoiler (true)
	if (spoiler_)
		*flag1 |= (1 << 5);
	//parse argument file (InputFile)
	{
		buf = buf_cat(buf, *file_);
	}
	//parse argument thumb (InputFile)
	if (thumb_)
	{
		buf = buf_cat(buf, *thumb_);
		*flag1 |= (1 << 2);
	}
	//parse argument mime_type (string)
	{
		buf = buf_cat(buf, serialize_string(mime_type_));
	}
	//parse argument attributes (Vector<DocumentAttribute>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(attributes_len));
		int i;
		for (i=0; i<attributes_len; ++i){
			buf = buf_cat(buf, attributes_[i]);
		}
	}
	//parse argument stickers (Vector<InputDocument>)
	if (stickers_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(stickers_len));
		int i;
		for (i=0; i<stickers_len; ++i){
			buf = buf_cat(buf, stickers_[i]);
		}
		*flag1 |= (1 << 0);
	}
	//parse argument ttl_seconds (int)
	if (ttl_seconds_)
	{
		buf = buf_cat(buf, buf_add_ui32(ttl_seconds_));
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_inputMediaDocument(bool spoiler_, InputDocument *id_, int ttl_seconds_, const char * query_)
{
	buf_t buf = buf_add_ui32(0x33473058);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument spoiler (true)
	if (spoiler_)
		*flag1 |= (1 << 2);
	//parse argument id (InputDocument)
	{
		buf = buf_cat(buf, *id_);
	}
	//parse argument ttl_seconds (int)
	if (ttl_seconds_)
	{
		buf = buf_cat(buf, buf_add_ui32(ttl_seconds_));
		*flag1 |= (1 << 0);
	}
	//parse argument query (string)
	if (query_)
	{
		buf = buf_cat(buf, serialize_string(query_));
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_inputMediaVenue(InputGeoPoint *geo_point_, const char * title_, const char * address_, const char * provider_, const char * venue_id_, const char * venue_type_)
{
	buf_t buf = buf_add_ui32(0xc13d1c11);
	//parse argument geo_point (InputGeoPoint)
	{
		buf = buf_cat(buf, *geo_point_);
	}
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument address (string)
	{
		buf = buf_cat(buf, serialize_string(address_));
	}
	//parse argument provider (string)
	{
		buf = buf_cat(buf, serialize_string(provider_));
	}
	//parse argument venue_id (string)
	{
		buf = buf_cat(buf, serialize_string(venue_id_));
	}
	//parse argument venue_type (string)
	{
		buf = buf_cat(buf, serialize_string(venue_type_));
	}
	return buf;
}

buf_t tl_inputMediaPhotoExternal(bool spoiler_, const char * url_, int ttl_seconds_)
{
	buf_t buf = buf_add_ui32(0xe5bbfe1a);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument spoiler (true)
	if (spoiler_)
		*flag1 |= (1 << 1);
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	//parse argument ttl_seconds (int)
	if (ttl_seconds_)
	{
		buf = buf_cat(buf, buf_add_ui32(ttl_seconds_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_inputMediaDocumentExternal(bool spoiler_, const char * url_, int ttl_seconds_)
{
	buf_t buf = buf_add_ui32(0xfb52dc99);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument spoiler (true)
	if (spoiler_)
		*flag1 |= (1 << 1);
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	//parse argument ttl_seconds (int)
	if (ttl_seconds_)
	{
		buf = buf_cat(buf, buf_add_ui32(ttl_seconds_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_inputMediaGame(InputGame *id_)
{
	buf_t buf = buf_add_ui32(0xd33f43f3);
	//parse argument id (InputGame)
	{
		buf = buf_cat(buf, *id_);
	}
	return buf;
}

buf_t tl_inputMediaInvoice(const char * title_, const char * description_, InputWebDocument *photo_, Invoice *invoice_, buf_t *payload_, const char * provider_, DataJSON *provider_data_, const char * start_param_, InputMedia *extended_media_)
{
	buf_t buf = buf_add_ui32(0x405fef0d);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument description (string)
	{
		buf = buf_cat(buf, serialize_string(description_));
	}
	//parse argument photo (InputWebDocument)
	if (photo_)
	{
		buf = buf_cat(buf, *photo_);
		*flag1 |= (1 << 0);
	}
	//parse argument invoice (Invoice)
	{
		buf = buf_cat(buf, *invoice_);
	}
	//parse argument payload (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(payload_->data, payload_->size));
	}
	//parse argument provider (string)
	if (provider_)
	{
		buf = buf_cat(buf, serialize_string(provider_));
		*flag1 |= (1 << 3);
	}
	//parse argument provider_data (DataJSON)
	{
		buf = buf_cat(buf, *provider_data_);
	}
	//parse argument start_param (string)
	if (start_param_)
	{
		buf = buf_cat(buf, serialize_string(start_param_));
		*flag1 |= (1 << 1);
	}
	//parse argument extended_media (InputMedia)
	if (extended_media_)
	{
		buf = buf_cat(buf, *extended_media_);
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_inputMediaGeoLive(bool stopped_, InputGeoPoint *geo_point_, int heading_, int period_, int proximity_notification_radius_)
{
	buf_t buf = buf_add_ui32(0x971fa843);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument stopped (true)
	if (stopped_)
		*flag1 |= (1 << 0);
	//parse argument geo_point (InputGeoPoint)
	{
		buf = buf_cat(buf, *geo_point_);
	}
	//parse argument heading (int)
	if (heading_)
	{
		buf = buf_cat(buf, buf_add_ui32(heading_));
		*flag1 |= (1 << 2);
	}
	//parse argument period (int)
	if (period_)
	{
		buf = buf_cat(buf, buf_add_ui32(period_));
		*flag1 |= (1 << 1);
	}
	//parse argument proximity_notification_radius (int)
	if (proximity_notification_radius_)
	{
		buf = buf_cat(buf, buf_add_ui32(proximity_notification_radius_));
		*flag1 |= (1 << 3);
	}
	return buf;
}

buf_t tl_inputMediaPoll(Poll *poll_, buf_t *correct_answers_, int correct_answers_len, const char * solution_, MessageEntity *solution_entities_, int solution_entities_len)
{
	buf_t buf = buf_add_ui32(0x0f94e5f1);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument poll (Poll)
	{
		buf = buf_cat(buf, *poll_);
	}
	//parse argument correct_answers (Vector<bytes>)
	if (correct_answers_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(correct_answers_len));
		int i;
		for (i=0; i<correct_answers_len; ++i){
			buf = buf_cat(buf, serialize_bytes(correct_answers_[i].data, correct_answers_[i].size));
		}
		*flag1 |= (1 << 0);
	}
	//parse argument solution (string)
	if (solution_)
	{
		buf = buf_cat(buf, serialize_string(solution_));
		*flag1 |= (1 << 1);
	}
	//parse argument solution_entities (Vector<MessageEntity>)
	if (solution_entities_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(solution_entities_len));
		int i;
		for (i=0; i<solution_entities_len; ++i){
			buf = buf_cat(buf, solution_entities_[i]);
		}
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_inputMediaDice(const char * emoticon_)
{
	buf_t buf = buf_add_ui32(0xe66fbf7b);
	//parse argument emoticon (string)
	{
		buf = buf_cat(buf, serialize_string(emoticon_));
	}
	return buf;
}

buf_t tl_inputMediaStory(InputPeer *peer_, int id_)
{
	buf_t buf = buf_add_ui32(0x89fdd778);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	return buf;
}

buf_t tl_inputMediaWebPage(bool force_large_media_, bool force_small_media_, bool optional_, const char * url_)
{
	buf_t buf = buf_add_ui32(0xc21b8849);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument force_large_media (true)
	if (force_large_media_)
		*flag1 |= (1 << 0);
	//parse argument force_small_media (true)
	if (force_small_media_)
		*flag1 |= (1 << 1);
	//parse argument optional (true)
	if (optional_)
		*flag1 |= (1 << 2);
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	return buf;
}

buf_t tl_inputMediaPaidMedia(long stars_amount_, InputMedia *extended_media_, int extended_media_len, const char * payload_)
{
	buf_t buf = buf_add_ui32(0xc4103386);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument stars_amount (long)
	{
		buf = buf_cat(buf, buf_add_ui64(stars_amount_));
	}
	//parse argument extended_media (Vector<InputMedia>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(extended_media_len));
		int i;
		for (i=0; i<extended_media_len; ++i){
			buf = buf_cat(buf, extended_media_[i]);
		}
	}
	//parse argument payload (string)
	if (payload_)
	{
		buf = buf_cat(buf, serialize_string(payload_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_inputChatPhotoEmpty()
{
	buf_t buf = buf_add_ui32(0x1ca48f57);
	return buf;
}

buf_t tl_inputChatUploadedPhoto(InputFile *file_, InputFile *video_, double video_start_ts_, VideoSize *video_emoji_markup_)
{
	buf_t buf = buf_add_ui32(0xbdcdaec0);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument file (InputFile)
	if (file_)
	{
		buf = buf_cat(buf, *file_);
		*flag1 |= (1 << 0);
	}
	//parse argument video (InputFile)
	if (video_)
	{
		buf = buf_cat(buf, *video_);
		*flag1 |= (1 << 1);
	}
	//parse argument video_start_ts (double)
	if (video_start_ts_)
	{
		buf = buf_cat(buf, buf_add_ui64(video_start_ts_));
		*flag1 |= (1 << 2);
	}
	//parse argument video_emoji_markup (VideoSize)
	if (video_emoji_markup_)
	{
		buf = buf_cat(buf, *video_emoji_markup_);
		*flag1 |= (1 << 3);
	}
	return buf;
}

buf_t tl_inputChatPhoto(InputPhoto *id_)
{
	buf_t buf = buf_add_ui32(0x8953ad37);
	//parse argument id (InputPhoto)
	{
		buf = buf_cat(buf, *id_);
	}
	return buf;
}

buf_t tl_inputGeoPointEmpty()
{
	buf_t buf = buf_add_ui32(0xe4c123d6);
	return buf;
}

buf_t tl_inputGeoPoint(double lat_, double long_, int accuracy_radius_)
{
	buf_t buf = buf_add_ui32(0x48222faf);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument lat (double)
	{
		buf = buf_cat(buf, buf_add_ui64(lat_));
	}
	//parse argument long (double)
	{
		buf = buf_cat(buf, buf_add_ui64(long_));
	}
	//parse argument accuracy_radius (int)
	if (accuracy_radius_)
	{
		buf = buf_cat(buf, buf_add_ui32(accuracy_radius_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_inputPhotoEmpty()
{
	buf_t buf = buf_add_ui32(0x1cd7bf0d);
	return buf;
}

buf_t tl_inputPhoto(long id_, long access_hash_, buf_t *file_reference_)
{
	buf_t buf = buf_add_ui32(0x3bb3b94a);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	//parse argument file_reference (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(file_reference_->data, file_reference_->size));
	}
	return buf;
}

buf_t tl_inputFileLocation(long volume_id_, int local_id_, long secret_, buf_t *file_reference_)
{
	buf_t buf = buf_add_ui32(0xdfdaabe1);
	//parse argument volume_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(volume_id_));
	}
	//parse argument local_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(local_id_));
	}
	//parse argument secret (long)
	{
		buf = buf_cat(buf, buf_add_ui64(secret_));
	}
	//parse argument file_reference (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(file_reference_->data, file_reference_->size));
	}
	return buf;
}

buf_t tl_inputEncryptedFileLocation(long id_, long access_hash_)
{
	buf_t buf = buf_add_ui32(0xf5235d55);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	return buf;
}

buf_t tl_inputDocumentFileLocation(long id_, long access_hash_, buf_t *file_reference_, const char * thumb_size_)
{
	buf_t buf = buf_add_ui32(0xbad07584);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	//parse argument file_reference (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(file_reference_->data, file_reference_->size));
	}
	//parse argument thumb_size (string)
	{
		buf = buf_cat(buf, serialize_string(thumb_size_));
	}
	return buf;
}

buf_t tl_inputSecureFileLocation(long id_, long access_hash_)
{
	buf_t buf = buf_add_ui32(0xcbc7ee28);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	return buf;
}

buf_t tl_inputTakeoutFileLocation()
{
	buf_t buf = buf_add_ui32(0x29be5899);
	return buf;
}

buf_t tl_inputPhotoFileLocation(long id_, long access_hash_, buf_t *file_reference_, const char * thumb_size_)
{
	buf_t buf = buf_add_ui32(0x40181ffe);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	//parse argument file_reference (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(file_reference_->data, file_reference_->size));
	}
	//parse argument thumb_size (string)
	{
		buf = buf_cat(buf, serialize_string(thumb_size_));
	}
	return buf;
}

buf_t tl_inputPhotoLegacyFileLocation(long id_, long access_hash_, buf_t *file_reference_, long volume_id_, int local_id_, long secret_)
{
	buf_t buf = buf_add_ui32(0xd83466f3);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	//parse argument file_reference (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(file_reference_->data, file_reference_->size));
	}
	//parse argument volume_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(volume_id_));
	}
	//parse argument local_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(local_id_));
	}
	//parse argument secret (long)
	{
		buf = buf_cat(buf, buf_add_ui64(secret_));
	}
	return buf;
}

buf_t tl_inputPeerPhotoFileLocation(bool big_, InputPeer *peer_, long photo_id_)
{
	buf_t buf = buf_add_ui32(0x37257e99);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument big (true)
	if (big_)
		*flag1 |= (1 << 0);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument photo_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(photo_id_));
	}
	return buf;
}

buf_t tl_inputStickerSetThumb(InputStickerSet *stickerset_, int thumb_version_)
{
	buf_t buf = buf_add_ui32(0x9d84f3db);
	//parse argument stickerset (InputStickerSet)
	{
		buf = buf_cat(buf, *stickerset_);
	}
	//parse argument thumb_version (int)
	{
		buf = buf_cat(buf, buf_add_ui32(thumb_version_));
	}
	return buf;
}

buf_t tl_inputGroupCallStream(InputGroupCall *call_, long time_ms_, int scale_, int video_channel_, int video_quality_)
{
	buf_t buf = buf_add_ui32(0x0598a92a);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument call (InputGroupCall)
	{
		buf = buf_cat(buf, *call_);
	}
	//parse argument time_ms (long)
	{
		buf = buf_cat(buf, buf_add_ui64(time_ms_));
	}
	//parse argument scale (int)
	{
		buf = buf_cat(buf, buf_add_ui32(scale_));
	}
	//parse argument video_channel (int)
	if (video_channel_)
	{
		buf = buf_cat(buf, buf_add_ui32(video_channel_));
		*flag1 |= (1 << 0);
	}
	//parse argument video_quality (int)
	if (video_quality_)
	{
		buf = buf_cat(buf, buf_add_ui32(video_quality_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_peerUser(long user_id_)
{
	buf_t buf = buf_add_ui32(0x59511722);
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	return buf;
}

buf_t tl_peerChat(long chat_id_)
{
	buf_t buf = buf_add_ui32(0x36c6019a);
	//parse argument chat_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(chat_id_));
	}
	return buf;
}

buf_t tl_peerChannel(long channel_id_)
{
	buf_t buf = buf_add_ui32(0xa2a5371e);
	//parse argument channel_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(channel_id_));
	}
	return buf;
}

buf_t tl_storage_fileUnknown()
{
	buf_t buf = buf_add_ui32(0xaa963b05);
	return buf;
}

buf_t tl_storage_filePartial()
{
	buf_t buf = buf_add_ui32(0x40bc6f52);
	return buf;
}

buf_t tl_storage_fileJpeg()
{
	buf_t buf = buf_add_ui32(0x007efe0e);
	return buf;
}

buf_t tl_storage_fileGif()
{
	buf_t buf = buf_add_ui32(0xcae1aadf);
	return buf;
}

buf_t tl_storage_filePng()
{
	buf_t buf = buf_add_ui32(0x0a4f63c0);
	return buf;
}

buf_t tl_storage_filePdf()
{
	buf_t buf = buf_add_ui32(0xae1e508d);
	return buf;
}

buf_t tl_storage_fileMp3()
{
	buf_t buf = buf_add_ui32(0x528a0677);
	return buf;
}

buf_t tl_storage_fileMov()
{
	buf_t buf = buf_add_ui32(0x4b09ebbc);
	return buf;
}

buf_t tl_storage_fileMp4()
{
	buf_t buf = buf_add_ui32(0xb3cea0e4);
	return buf;
}

buf_t tl_storage_fileWebp()
{
	buf_t buf = buf_add_ui32(0x1081464c);
	return buf;
}

buf_t tl_userEmpty(long id_)
{
	buf_t buf = buf_add_ui32(0xd3bc4b7a);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	return buf;
}

buf_t tl_user(bool self_, bool contact_, bool mutual_contact_, bool deleted_, bool bot_, bool bot_chat_history_, bool bot_nochats_, bool verified_, bool restricted_, bool min_, bool bot_inline_geo_, bool support_, bool scam_, bool apply_min_photo_, bool fake_, bool bot_attach_menu_, bool premium_, bool attach_menu_enabled_, bool bot_can_edit_, bool close_friend_, bool stories_hidden_, bool stories_unavailable_, bool contact_require_premium_, bool bot_business_, bool bot_has_main_app_, long id_, long access_hash_, const char * first_name_, const char * last_name_, const char * username_, const char * phone_, UserProfilePhoto *photo_, UserStatus *status_, int bot_info_version_, RestrictionReason *restriction_reason_, int restriction_reason_len, const char * bot_inline_placeholder_, const char * lang_code_, EmojiStatus *emoji_status_, Username *usernames_, int usernames_len, int stories_max_id_, PeerColor *color_, PeerColor *profile_color_, int bot_active_users_)
{
	buf_t buf = buf_add_ui32(0x83314fca);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument self (true)
	if (self_)
		*flag1 |= (1 << 10);
	//parse argument contact (true)
	if (contact_)
		*flag1 |= (1 << 11);
	//parse argument mutual_contact (true)
	if (mutual_contact_)
		*flag1 |= (1 << 12);
	//parse argument deleted (true)
	if (deleted_)
		*flag1 |= (1 << 13);
	//parse argument bot (true)
	if (bot_)
		*flag1 |= (1 << 14);
	//parse argument bot_chat_history (true)
	if (bot_chat_history_)
		*flag1 |= (1 << 15);
	//parse argument bot_nochats (true)
	if (bot_nochats_)
		*flag1 |= (1 << 16);
	//parse argument verified (true)
	if (verified_)
		*flag1 |= (1 << 17);
	//parse argument restricted (true)
	if (restricted_)
		*flag1 |= (1 << 18);
	//parse argument min (true)
	if (min_)
		*flag1 |= (1 << 20);
	//parse argument bot_inline_geo (true)
	if (bot_inline_geo_)
		*flag1 |= (1 << 21);
	//parse argument support (true)
	if (support_)
		*flag1 |= (1 << 23);
	//parse argument scam (true)
	if (scam_)
		*flag1 |= (1 << 24);
	//parse argument apply_min_photo (true)
	if (apply_min_photo_)
		*flag1 |= (1 << 25);
	//parse argument fake (true)
	if (fake_)
		*flag1 |= (1 << 26);
	//parse argument bot_attach_menu (true)
	if (bot_attach_menu_)
		*flag1 |= (1 << 27);
	//parse argument premium (true)
	if (premium_)
		*flag1 |= (1 << 28);
	//parse argument attach_menu_enabled (true)
	if (attach_menu_enabled_)
		*flag1 |= (1 << 29);
	//parse argument flags2 ((null))
	ui32_t *flag2 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument bot_can_edit (true)
	if (bot_can_edit_)
		*flag2 |= (1 << 1);
	//parse argument close_friend (true)
	if (close_friend_)
		*flag2 |= (1 << 2);
	//parse argument stories_hidden (true)
	if (stories_hidden_)
		*flag2 |= (1 << 3);
	//parse argument stories_unavailable (true)
	if (stories_unavailable_)
		*flag2 |= (1 << 4);
	//parse argument contact_require_premium (true)
	if (contact_require_premium_)
		*flag2 |= (1 << 10);
	//parse argument bot_business (true)
	if (bot_business_)
		*flag2 |= (1 << 11);
	//parse argument bot_has_main_app (true)
	if (bot_has_main_app_)
		*flag2 |= (1 << 13);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument access_hash (long)
	if (access_hash_)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
		*flag1 |= (1 << 0);
	}
	//parse argument first_name (string)
	if (first_name_)
	{
		buf = buf_cat(buf, serialize_string(first_name_));
		*flag1 |= (1 << 1);
	}
	//parse argument last_name (string)
	if (last_name_)
	{
		buf = buf_cat(buf, serialize_string(last_name_));
		*flag1 |= (1 << 2);
	}
	//parse argument username (string)
	if (username_)
	{
		buf = buf_cat(buf, serialize_string(username_));
		*flag1 |= (1 << 3);
	}
	//parse argument phone (string)
	if (phone_)
	{
		buf = buf_cat(buf, serialize_string(phone_));
		*flag1 |= (1 << 4);
	}
	//parse argument photo (UserProfilePhoto)
	if (photo_)
	{
		buf = buf_cat(buf, *photo_);
		*flag1 |= (1 << 5);
	}
	//parse argument status (UserStatus)
	if (status_)
	{
		buf = buf_cat(buf, *status_);
		*flag1 |= (1 << 6);
	}
	//parse argument bot_info_version (int)
	if (bot_info_version_)
	{
		buf = buf_cat(buf, buf_add_ui32(bot_info_version_));
		*flag1 |= (1 << 14);
	}
	//parse argument restriction_reason (Vector<RestrictionReason>)
	if (restriction_reason_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(restriction_reason_len));
		int i;
		for (i=0; i<restriction_reason_len; ++i){
			buf = buf_cat(buf, restriction_reason_[i]);
		}
		*flag1 |= (1 << 18);
	}
	//parse argument bot_inline_placeholder (string)
	if (bot_inline_placeholder_)
	{
		buf = buf_cat(buf, serialize_string(bot_inline_placeholder_));
		*flag1 |= (1 << 19);
	}
	//parse argument lang_code (string)
	if (lang_code_)
	{
		buf = buf_cat(buf, serialize_string(lang_code_));
		*flag1 |= (1 << 22);
	}
	//parse argument emoji_status (EmojiStatus)
	if (emoji_status_)
	{
		buf = buf_cat(buf, *emoji_status_);
		*flag1 |= (1 << 30);
	}
	//parse argument usernames (Vector<Username>)
	if (usernames_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(usernames_len));
		int i;
		for (i=0; i<usernames_len; ++i){
			buf = buf_cat(buf, usernames_[i]);
		}
		*flag2 |= (1 << 0);
	}
	//parse argument stories_max_id (int)
	if (stories_max_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(stories_max_id_));
		*flag2 |= (1 << 5);
	}
	//parse argument color (PeerColor)
	if (color_)
	{
		buf = buf_cat(buf, *color_);
		*flag2 |= (1 << 8);
	}
	//parse argument profile_color (PeerColor)
	if (profile_color_)
	{
		buf = buf_cat(buf, *profile_color_);
		*flag2 |= (1 << 9);
	}
	//parse argument bot_active_users (int)
	if (bot_active_users_)
	{
		buf = buf_cat(buf, buf_add_ui32(bot_active_users_));
		*flag2 |= (1 << 12);
	}
	return buf;
}

buf_t tl_userProfilePhotoEmpty()
{
	buf_t buf = buf_add_ui32(0x4f11bae1);
	return buf;
}

buf_t tl_userProfilePhoto(bool has_video_, bool personal_, long photo_id_, buf_t *stripped_thumb_, int dc_id_)
{
	buf_t buf = buf_add_ui32(0x82d1f706);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument has_video (true)
	if (has_video_)
		*flag1 |= (1 << 0);
	//parse argument personal (true)
	if (personal_)
		*flag1 |= (1 << 2);
	//parse argument photo_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(photo_id_));
	}
	//parse argument stripped_thumb (bytes)
	if (stripped_thumb_)
	{
		buf = buf_cat(buf, serialize_bytes(stripped_thumb_->data, stripped_thumb_->size));
		*flag1 |= (1 << 1);
	}
	//parse argument dc_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(dc_id_));
	}
	return buf;
}

buf_t tl_userStatusEmpty()
{
	buf_t buf = buf_add_ui32(0x09d05049);
	return buf;
}

buf_t tl_userStatusOnline(int expires_)
{
	buf_t buf = buf_add_ui32(0xedb93949);
	//parse argument expires (int)
	{
		buf = buf_cat(buf, buf_add_ui32(expires_));
	}
	return buf;
}

buf_t tl_userStatusOffline(int was_online_)
{
	buf_t buf = buf_add_ui32(0x008c703f);
	//parse argument was_online (int)
	{
		buf = buf_cat(buf, buf_add_ui32(was_online_));
	}
	return buf;
}

buf_t tl_userStatusRecently(bool by_me_)
{
	buf_t buf = buf_add_ui32(0x7b197dc8);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument by_me (true)
	if (by_me_)
		*flag1 |= (1 << 0);
	return buf;
}

buf_t tl_userStatusLastWeek(bool by_me_)
{
	buf_t buf = buf_add_ui32(0x541a1d1a);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument by_me (true)
	if (by_me_)
		*flag1 |= (1 << 0);
	return buf;
}

buf_t tl_userStatusLastMonth(bool by_me_)
{
	buf_t buf = buf_add_ui32(0x65899777);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument by_me (true)
	if (by_me_)
		*flag1 |= (1 << 0);
	return buf;
}

buf_t tl_chatEmpty(long id_)
{
	buf_t buf = buf_add_ui32(0x29562865);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	return buf;
}

buf_t tl_chat(bool creator_, bool left_, bool deactivated_, bool call_active_, bool call_not_empty_, bool noforwards_, long id_, const char * title_, ChatPhoto *photo_, int participants_count_, int date_, int version_, InputChannel *migrated_to_, ChatAdminRights *admin_rights_, ChatBannedRights *default_banned_rights_)
{
	buf_t buf = buf_add_ui32(0x41cbf256);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument creator (true)
	if (creator_)
		*flag1 |= (1 << 0);
	//parse argument left (true)
	if (left_)
		*flag1 |= (1 << 2);
	//parse argument deactivated (true)
	if (deactivated_)
		*flag1 |= (1 << 5);
	//parse argument call_active (true)
	if (call_active_)
		*flag1 |= (1 << 23);
	//parse argument call_not_empty (true)
	if (call_not_empty_)
		*flag1 |= (1 << 24);
	//parse argument noforwards (true)
	if (noforwards_)
		*flag1 |= (1 << 25);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument photo (ChatPhoto)
	{
		buf = buf_cat(buf, *photo_);
	}
	//parse argument participants_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(participants_count_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument version (int)
	{
		buf = buf_cat(buf, buf_add_ui32(version_));
	}
	//parse argument migrated_to (InputChannel)
	if (migrated_to_)
	{
		buf = buf_cat(buf, *migrated_to_);
		*flag1 |= (1 << 6);
	}
	//parse argument admin_rights (ChatAdminRights)
	if (admin_rights_)
	{
		buf = buf_cat(buf, *admin_rights_);
		*flag1 |= (1 << 14);
	}
	//parse argument default_banned_rights (ChatBannedRights)
	if (default_banned_rights_)
	{
		buf = buf_cat(buf, *default_banned_rights_);
		*flag1 |= (1 << 18);
	}
	return buf;
}

buf_t tl_chatForbidden(long id_, const char * title_)
{
	buf_t buf = buf_add_ui32(0x6592a1a7);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	return buf;
}

buf_t tl_channel(bool creator_, bool left_, bool broadcast_, bool verified_, bool megagroup_, bool restricted_, bool signatures_, bool min_, bool scam_, bool has_link_, bool has_geo_, bool slowmode_enabled_, bool call_active_, bool call_not_empty_, bool fake_, bool gigagroup_, bool noforwards_, bool join_to_send_, bool join_request_, bool forum_, bool stories_hidden_, bool stories_hidden_min_, bool stories_unavailable_, bool signature_profiles_, long id_, long access_hash_, const char * title_, const char * username_, ChatPhoto *photo_, int date_, RestrictionReason *restriction_reason_, int restriction_reason_len, ChatAdminRights *admin_rights_, ChatBannedRights *banned_rights_, ChatBannedRights *default_banned_rights_, int participants_count_, Username *usernames_, int usernames_len, int stories_max_id_, PeerColor *color_, PeerColor *profile_color_, EmojiStatus *emoji_status_, int level_, int subscription_until_date_)
{
	buf_t buf = buf_add_ui32(0xfe4478bd);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument creator (true)
	if (creator_)
		*flag1 |= (1 << 0);
	//parse argument left (true)
	if (left_)
		*flag1 |= (1 << 2);
	//parse argument broadcast (true)
	if (broadcast_)
		*flag1 |= (1 << 5);
	//parse argument verified (true)
	if (verified_)
		*flag1 |= (1 << 7);
	//parse argument megagroup (true)
	if (megagroup_)
		*flag1 |= (1 << 8);
	//parse argument restricted (true)
	if (restricted_)
		*flag1 |= (1 << 9);
	//parse argument signatures (true)
	if (signatures_)
		*flag1 |= (1 << 11);
	//parse argument min (true)
	if (min_)
		*flag1 |= (1 << 12);
	//parse argument scam (true)
	if (scam_)
		*flag1 |= (1 << 19);
	//parse argument has_link (true)
	if (has_link_)
		*flag1 |= (1 << 20);
	//parse argument has_geo (true)
	if (has_geo_)
		*flag1 |= (1 << 21);
	//parse argument slowmode_enabled (true)
	if (slowmode_enabled_)
		*flag1 |= (1 << 22);
	//parse argument call_active (true)
	if (call_active_)
		*flag1 |= (1 << 23);
	//parse argument call_not_empty (true)
	if (call_not_empty_)
		*flag1 |= (1 << 24);
	//parse argument fake (true)
	if (fake_)
		*flag1 |= (1 << 25);
	//parse argument gigagroup (true)
	if (gigagroup_)
		*flag1 |= (1 << 26);
	//parse argument noforwards (true)
	if (noforwards_)
		*flag1 |= (1 << 27);
	//parse argument join_to_send (true)
	if (join_to_send_)
		*flag1 |= (1 << 28);
	//parse argument join_request (true)
	if (join_request_)
		*flag1 |= (1 << 29);
	//parse argument forum (true)
	if (forum_)
		*flag1 |= (1 << 30);
	//parse argument flags2 ((null))
	ui32_t *flag2 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument stories_hidden (true)
	if (stories_hidden_)
		*flag2 |= (1 << 1);
	//parse argument stories_hidden_min (true)
	if (stories_hidden_min_)
		*flag2 |= (1 << 2);
	//parse argument stories_unavailable (true)
	if (stories_unavailable_)
		*flag2 |= (1 << 3);
	//parse argument signature_profiles (true)
	if (signature_profiles_)
		*flag2 |= (1 << 12);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument access_hash (long)
	if (access_hash_)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
		*flag1 |= (1 << 13);
	}
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument username (string)
	if (username_)
	{
		buf = buf_cat(buf, serialize_string(username_));
		*flag1 |= (1 << 6);
	}
	//parse argument photo (ChatPhoto)
	{
		buf = buf_cat(buf, *photo_);
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument restriction_reason (Vector<RestrictionReason>)
	if (restriction_reason_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(restriction_reason_len));
		int i;
		for (i=0; i<restriction_reason_len; ++i){
			buf = buf_cat(buf, restriction_reason_[i]);
		}
		*flag1 |= (1 << 9);
	}
	//parse argument admin_rights (ChatAdminRights)
	if (admin_rights_)
	{
		buf = buf_cat(buf, *admin_rights_);
		*flag1 |= (1 << 14);
	}
	//parse argument banned_rights (ChatBannedRights)
	if (banned_rights_)
	{
		buf = buf_cat(buf, *banned_rights_);
		*flag1 |= (1 << 15);
	}
	//parse argument default_banned_rights (ChatBannedRights)
	if (default_banned_rights_)
	{
		buf = buf_cat(buf, *default_banned_rights_);
		*flag1 |= (1 << 18);
	}
	//parse argument participants_count (int)
	if (participants_count_)
	{
		buf = buf_cat(buf, buf_add_ui32(participants_count_));
		*flag1 |= (1 << 17);
	}
	//parse argument usernames (Vector<Username>)
	if (usernames_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(usernames_len));
		int i;
		for (i=0; i<usernames_len; ++i){
			buf = buf_cat(buf, usernames_[i]);
		}
		*flag2 |= (1 << 0);
	}
	//parse argument stories_max_id (int)
	if (stories_max_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(stories_max_id_));
		*flag2 |= (1 << 4);
	}
	//parse argument color (PeerColor)
	if (color_)
	{
		buf = buf_cat(buf, *color_);
		*flag2 |= (1 << 7);
	}
	//parse argument profile_color (PeerColor)
	if (profile_color_)
	{
		buf = buf_cat(buf, *profile_color_);
		*flag2 |= (1 << 8);
	}
	//parse argument emoji_status (EmojiStatus)
	if (emoji_status_)
	{
		buf = buf_cat(buf, *emoji_status_);
		*flag2 |= (1 << 9);
	}
	//parse argument level (int)
	if (level_)
	{
		buf = buf_cat(buf, buf_add_ui32(level_));
		*flag2 |= (1 << 10);
	}
	//parse argument subscription_until_date (int)
	if (subscription_until_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(subscription_until_date_));
		*flag2 |= (1 << 11);
	}
	return buf;
}

buf_t tl_channelForbidden(bool broadcast_, bool megagroup_, long id_, long access_hash_, const char * title_, int until_date_)
{
	buf_t buf = buf_add_ui32(0x17d493d5);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument broadcast (true)
	if (broadcast_)
		*flag1 |= (1 << 5);
	//parse argument megagroup (true)
	if (megagroup_)
		*flag1 |= (1 << 8);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument until_date (int)
	if (until_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(until_date_));
		*flag1 |= (1 << 16);
	}
	return buf;
}

buf_t tl_chatFull(bool can_set_username_, bool has_scheduled_, bool translations_disabled_, long id_, const char * about_, ChatParticipants *participants_, Photo *chat_photo_, PeerNotifySettings *notify_settings_, ExportedChatInvite *exported_invite_, BotInfo *bot_info_, int bot_info_len, int pinned_msg_id_, int folder_id_, InputGroupCall *call_, int ttl_period_, Peer *groupcall_default_join_as_, const char * theme_emoticon_, int requests_pending_, long *recent_requesters_, int recent_requesters_len, ChatReactions *available_reactions_, int reactions_limit_)
{
	buf_t buf = buf_add_ui32(0x2633421b);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument can_set_username (true)
	if (can_set_username_)
		*flag1 |= (1 << 7);
	//parse argument has_scheduled (true)
	if (has_scheduled_)
		*flag1 |= (1 << 8);
	//parse argument translations_disabled (true)
	if (translations_disabled_)
		*flag1 |= (1 << 19);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument about (string)
	{
		buf = buf_cat(buf, serialize_string(about_));
	}
	//parse argument participants (ChatParticipants)
	{
		buf = buf_cat(buf, *participants_);
	}
	//parse argument chat_photo (Photo)
	if (chat_photo_)
	{
		buf = buf_cat(buf, *chat_photo_);
		*flag1 |= (1 << 2);
	}
	//parse argument notify_settings (PeerNotifySettings)
	{
		buf = buf_cat(buf, *notify_settings_);
	}
	//parse argument exported_invite (ExportedChatInvite)
	if (exported_invite_)
	{
		buf = buf_cat(buf, *exported_invite_);
		*flag1 |= (1 << 13);
	}
	//parse argument bot_info (Vector<BotInfo>)
	if (bot_info_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(bot_info_len));
		int i;
		for (i=0; i<bot_info_len; ++i){
			buf = buf_cat(buf, bot_info_[i]);
		}
		*flag1 |= (1 << 3);
	}
	//parse argument pinned_msg_id (int)
	if (pinned_msg_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(pinned_msg_id_));
		*flag1 |= (1 << 6);
	}
	//parse argument folder_id (int)
	if (folder_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(folder_id_));
		*flag1 |= (1 << 11);
	}
	//parse argument call (InputGroupCall)
	if (call_)
	{
		buf = buf_cat(buf, *call_);
		*flag1 |= (1 << 12);
	}
	//parse argument ttl_period (int)
	if (ttl_period_)
	{
		buf = buf_cat(buf, buf_add_ui32(ttl_period_));
		*flag1 |= (1 << 14);
	}
	//parse argument groupcall_default_join_as (Peer)
	if (groupcall_default_join_as_)
	{
		buf = buf_cat(buf, *groupcall_default_join_as_);
		*flag1 |= (1 << 15);
	}
	//parse argument theme_emoticon (string)
	if (theme_emoticon_)
	{
		buf = buf_cat(buf, serialize_string(theme_emoticon_));
		*flag1 |= (1 << 16);
	}
	//parse argument requests_pending (int)
	if (requests_pending_)
	{
		buf = buf_cat(buf, buf_add_ui32(requests_pending_));
		*flag1 |= (1 << 17);
	}
	//parse argument recent_requesters (Vector<long>)
	if (recent_requesters_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(recent_requesters_len));
		int i;
		for (i=0; i<recent_requesters_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(recent_requesters_[i]));
		}
		*flag1 |= (1 << 17);
	}
	//parse argument available_reactions (ChatReactions)
	if (available_reactions_)
	{
		buf = buf_cat(buf, *available_reactions_);
		*flag1 |= (1 << 18);
	}
	//parse argument reactions_limit (int)
	if (reactions_limit_)
	{
		buf = buf_cat(buf, buf_add_ui32(reactions_limit_));
		*flag1 |= (1 << 20);
	}
	return buf;
}

buf_t tl_channelFull(bool can_view_participants_, bool can_set_username_, bool can_set_stickers_, bool hidden_prehistory_, bool can_set_location_, bool has_scheduled_, bool can_view_stats_, bool blocked_, bool can_delete_channel_, bool antispam_, bool participants_hidden_, bool translations_disabled_, bool stories_pinned_available_, bool view_forum_as_messages_, bool restricted_sponsored_, bool can_view_revenue_, bool paid_media_allowed_, bool can_view_stars_revenue_, bool paid_reactions_available_, long id_, const char * about_, int participants_count_, int admins_count_, int kicked_count_, int banned_count_, int online_count_, int read_inbox_max_id_, int read_outbox_max_id_, int unread_count_, Photo *chat_photo_, PeerNotifySettings *notify_settings_, ExportedChatInvite *exported_invite_, BotInfo *bot_info_, int bot_info_len, long migrated_from_chat_id_, int migrated_from_max_id_, int pinned_msg_id_, StickerSet *stickerset_, int available_min_id_, int folder_id_, long linked_chat_id_, ChannelLocation *location_, int slowmode_seconds_, int slowmode_next_send_date_, int stats_dc_, int pts_, InputGroupCall *call_, int ttl_period_, const char * *pending_suggestions_, int pending_suggestions_len, Peer *groupcall_default_join_as_, const char * theme_emoticon_, int requests_pending_, long *recent_requesters_, int recent_requesters_len, Peer *default_send_as_, ChatReactions *available_reactions_, int reactions_limit_, PeerStories *stories_, WallPaper *wallpaper_, int boosts_applied_, int boosts_unrestrict_, StickerSet *emojiset_)
{
	buf_t buf = buf_add_ui32(0xbbab348d);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument can_view_participants (true)
	if (can_view_participants_)
		*flag1 |= (1 << 3);
	//parse argument can_set_username (true)
	if (can_set_username_)
		*flag1 |= (1 << 6);
	//parse argument can_set_stickers (true)
	if (can_set_stickers_)
		*flag1 |= (1 << 7);
	//parse argument hidden_prehistory (true)
	if (hidden_prehistory_)
		*flag1 |= (1 << 10);
	//parse argument can_set_location (true)
	if (can_set_location_)
		*flag1 |= (1 << 16);
	//parse argument has_scheduled (true)
	if (has_scheduled_)
		*flag1 |= (1 << 19);
	//parse argument can_view_stats (true)
	if (can_view_stats_)
		*flag1 |= (1 << 20);
	//parse argument blocked (true)
	if (blocked_)
		*flag1 |= (1 << 22);
	//parse argument flags2 ((null))
	ui32_t *flag2 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument can_delete_channel (true)
	if (can_delete_channel_)
		*flag2 |= (1 << 0);
	//parse argument antispam (true)
	if (antispam_)
		*flag2 |= (1 << 1);
	//parse argument participants_hidden (true)
	if (participants_hidden_)
		*flag2 |= (1 << 2);
	//parse argument translations_disabled (true)
	if (translations_disabled_)
		*flag2 |= (1 << 3);
	//parse argument stories_pinned_available (true)
	if (stories_pinned_available_)
		*flag2 |= (1 << 5);
	//parse argument view_forum_as_messages (true)
	if (view_forum_as_messages_)
		*flag2 |= (1 << 6);
	//parse argument restricted_sponsored (true)
	if (restricted_sponsored_)
		*flag2 |= (1 << 11);
	//parse argument can_view_revenue (true)
	if (can_view_revenue_)
		*flag2 |= (1 << 12);
	//parse argument paid_media_allowed (true)
	if (paid_media_allowed_)
		*flag2 |= (1 << 14);
	//parse argument can_view_stars_revenue (true)
	if (can_view_stars_revenue_)
		*flag2 |= (1 << 15);
	//parse argument paid_reactions_available (true)
	if (paid_reactions_available_)
		*flag2 |= (1 << 16);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument about (string)
	{
		buf = buf_cat(buf, serialize_string(about_));
	}
	//parse argument participants_count (int)
	if (participants_count_)
	{
		buf = buf_cat(buf, buf_add_ui32(participants_count_));
		*flag1 |= (1 << 0);
	}
	//parse argument admins_count (int)
	if (admins_count_)
	{
		buf = buf_cat(buf, buf_add_ui32(admins_count_));
		*flag1 |= (1 << 1);
	}
	//parse argument kicked_count (int)
	if (kicked_count_)
	{
		buf = buf_cat(buf, buf_add_ui32(kicked_count_));
		*flag1 |= (1 << 2);
	}
	//parse argument banned_count (int)
	if (banned_count_)
	{
		buf = buf_cat(buf, buf_add_ui32(banned_count_));
		*flag1 |= (1 << 2);
	}
	//parse argument online_count (int)
	if (online_count_)
	{
		buf = buf_cat(buf, buf_add_ui32(online_count_));
		*flag1 |= (1 << 13);
	}
	//parse argument read_inbox_max_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(read_inbox_max_id_));
	}
	//parse argument read_outbox_max_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(read_outbox_max_id_));
	}
	//parse argument unread_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(unread_count_));
	}
	//parse argument chat_photo (Photo)
	{
		buf = buf_cat(buf, *chat_photo_);
	}
	//parse argument notify_settings (PeerNotifySettings)
	{
		buf = buf_cat(buf, *notify_settings_);
	}
	//parse argument exported_invite (ExportedChatInvite)
	if (exported_invite_)
	{
		buf = buf_cat(buf, *exported_invite_);
		*flag1 |= (1 << 23);
	}
	//parse argument bot_info (Vector<BotInfo>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(bot_info_len));
		int i;
		for (i=0; i<bot_info_len; ++i){
			buf = buf_cat(buf, bot_info_[i]);
		}
	}
	//parse argument migrated_from_chat_id (long)
	if (migrated_from_chat_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(migrated_from_chat_id_));
		*flag1 |= (1 << 4);
	}
	//parse argument migrated_from_max_id (int)
	if (migrated_from_max_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(migrated_from_max_id_));
		*flag1 |= (1 << 4);
	}
	//parse argument pinned_msg_id (int)
	if (pinned_msg_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(pinned_msg_id_));
		*flag1 |= (1 << 5);
	}
	//parse argument stickerset (StickerSet)
	if (stickerset_)
	{
		buf = buf_cat(buf, *stickerset_);
		*flag1 |= (1 << 8);
	}
	//parse argument available_min_id (int)
	if (available_min_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(available_min_id_));
		*flag1 |= (1 << 9);
	}
	//parse argument folder_id (int)
	if (folder_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(folder_id_));
		*flag1 |= (1 << 11);
	}
	//parse argument linked_chat_id (long)
	if (linked_chat_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(linked_chat_id_));
		*flag1 |= (1 << 14);
	}
	//parse argument location (ChannelLocation)
	if (location_)
	{
		buf = buf_cat(buf, *location_);
		*flag1 |= (1 << 15);
	}
	//parse argument slowmode_seconds (int)
	if (slowmode_seconds_)
	{
		buf = buf_cat(buf, buf_add_ui32(slowmode_seconds_));
		*flag1 |= (1 << 17);
	}
	//parse argument slowmode_next_send_date (int)
	if (slowmode_next_send_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(slowmode_next_send_date_));
		*flag1 |= (1 << 18);
	}
	//parse argument stats_dc (int)
	if (stats_dc_)
	{
		buf = buf_cat(buf, buf_add_ui32(stats_dc_));
		*flag1 |= (1 << 12);
	}
	//parse argument pts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_));
	}
	//parse argument call (InputGroupCall)
	if (call_)
	{
		buf = buf_cat(buf, *call_);
		*flag1 |= (1 << 21);
	}
	//parse argument ttl_period (int)
	if (ttl_period_)
	{
		buf = buf_cat(buf, buf_add_ui32(ttl_period_));
		*flag1 |= (1 << 24);
	}
	//parse argument pending_suggestions (Vector<string>)
	if (pending_suggestions_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(pending_suggestions_len));
		int i;
		for (i=0; i<pending_suggestions_len; ++i){
			buf = buf_cat(buf, serialize_string(pending_suggestions_[i]));
		}
		*flag1 |= (1 << 25);
	}
	//parse argument groupcall_default_join_as (Peer)
	if (groupcall_default_join_as_)
	{
		buf = buf_cat(buf, *groupcall_default_join_as_);
		*flag1 |= (1 << 26);
	}
	//parse argument theme_emoticon (string)
	if (theme_emoticon_)
	{
		buf = buf_cat(buf, serialize_string(theme_emoticon_));
		*flag1 |= (1 << 27);
	}
	//parse argument requests_pending (int)
	if (requests_pending_)
	{
		buf = buf_cat(buf, buf_add_ui32(requests_pending_));
		*flag1 |= (1 << 28);
	}
	//parse argument recent_requesters (Vector<long>)
	if (recent_requesters_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(recent_requesters_len));
		int i;
		for (i=0; i<recent_requesters_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(recent_requesters_[i]));
		}
		*flag1 |= (1 << 28);
	}
	//parse argument default_send_as (Peer)
	if (default_send_as_)
	{
		buf = buf_cat(buf, *default_send_as_);
		*flag1 |= (1 << 29);
	}
	//parse argument available_reactions (ChatReactions)
	if (available_reactions_)
	{
		buf = buf_cat(buf, *available_reactions_);
		*flag1 |= (1 << 30);
	}
	//parse argument reactions_limit (int)
	if (reactions_limit_)
	{
		buf = buf_cat(buf, buf_add_ui32(reactions_limit_));
		*flag2 |= (1 << 13);
	}
	//parse argument stories (PeerStories)
	if (stories_)
	{
		buf = buf_cat(buf, *stories_);
		*flag2 |= (1 << 4);
	}
	//parse argument wallpaper (WallPaper)
	if (wallpaper_)
	{
		buf = buf_cat(buf, *wallpaper_);
		*flag2 |= (1 << 7);
	}
	//parse argument boosts_applied (int)
	if (boosts_applied_)
	{
		buf = buf_cat(buf, buf_add_ui32(boosts_applied_));
		*flag2 |= (1 << 8);
	}
	//parse argument boosts_unrestrict (int)
	if (boosts_unrestrict_)
	{
		buf = buf_cat(buf, buf_add_ui32(boosts_unrestrict_));
		*flag2 |= (1 << 9);
	}
	//parse argument emojiset (StickerSet)
	if (emojiset_)
	{
		buf = buf_cat(buf, *emojiset_);
		*flag2 |= (1 << 10);
	}
	return buf;
}

buf_t tl_chatParticipant(long user_id_, long inviter_id_, int date_)
{
	buf_t buf = buf_add_ui32(0xc02d4007);
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument inviter_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(inviter_id_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	return buf;
}

buf_t tl_chatParticipantCreator(long user_id_)
{
	buf_t buf = buf_add_ui32(0xe46bcee4);
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	return buf;
}

buf_t tl_chatParticipantAdmin(long user_id_, long inviter_id_, int date_)
{
	buf_t buf = buf_add_ui32(0xa0933f5b);
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument inviter_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(inviter_id_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	return buf;
}

buf_t tl_chatParticipantsForbidden(long chat_id_, ChatParticipant *self_participant_)
{
	buf_t buf = buf_add_ui32(0x8763d3e1);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument chat_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(chat_id_));
	}
	//parse argument self_participant (ChatParticipant)
	if (self_participant_)
	{
		buf = buf_cat(buf, *self_participant_);
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_chatParticipants(long chat_id_, ChatParticipant *participants_, int participants_len, int version_)
{
	buf_t buf = buf_add_ui32(0x3cbc93f8);
	//parse argument chat_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(chat_id_));
	}
	//parse argument participants (Vector<ChatParticipant>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(participants_len));
		int i;
		for (i=0; i<participants_len; ++i){
			buf = buf_cat(buf, participants_[i]);
		}
	}
	//parse argument version (int)
	{
		buf = buf_cat(buf, buf_add_ui32(version_));
	}
	return buf;
}

buf_t tl_chatPhotoEmpty()
{
	buf_t buf = buf_add_ui32(0x37c1011c);
	return buf;
}

buf_t tl_chatPhoto(bool has_video_, long photo_id_, buf_t *stripped_thumb_, int dc_id_)
{
	buf_t buf = buf_add_ui32(0x1c6e1c11);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument has_video (true)
	if (has_video_)
		*flag1 |= (1 << 0);
	//parse argument photo_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(photo_id_));
	}
	//parse argument stripped_thumb (bytes)
	if (stripped_thumb_)
	{
		buf = buf_cat(buf, serialize_bytes(stripped_thumb_->data, stripped_thumb_->size));
		*flag1 |= (1 << 1);
	}
	//parse argument dc_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(dc_id_));
	}
	return buf;
}

buf_t tl_messageEmpty(int id_, Peer *peer_id_)
{
	buf_t buf = buf_add_ui32(0x90a6ca84);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument peer_id (Peer)
	if (peer_id_)
	{
		buf = buf_cat(buf, *peer_id_);
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_message(bool out_, bool mentioned_, bool media_unread_, bool silent_, bool post_, bool from_scheduled_, bool legacy_, bool edit_hide_, bool pinned_, bool noforwards_, bool invert_media_, bool offline_, int id_, Peer *from_id_, int from_boosts_applied_, Peer *peer_id_, Peer *saved_peer_id_, MessageFwdHeader *fwd_from_, long via_bot_id_, long via_business_bot_id_, MessageReplyHeader *reply_to_, int date_, const char * message_, MessageMedia *media_, ReplyMarkup *reply_markup_, MessageEntity *entities_, int entities_len, int views_, int forwards_, MessageReplies *replies_, int edit_date_, const char * post_author_, long grouped_id_, MessageReactions *reactions_, RestrictionReason *restriction_reason_, int restriction_reason_len, int ttl_period_, int quick_reply_shortcut_id_, long effect_, FactCheck *factcheck_)
{
	buf_t buf = buf_add_ui32(0x94345242);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument out (true)
	if (out_)
		*flag1 |= (1 << 1);
	//parse argument mentioned (true)
	if (mentioned_)
		*flag1 |= (1 << 4);
	//parse argument media_unread (true)
	if (media_unread_)
		*flag1 |= (1 << 5);
	//parse argument silent (true)
	if (silent_)
		*flag1 |= (1 << 13);
	//parse argument post (true)
	if (post_)
		*flag1 |= (1 << 14);
	//parse argument from_scheduled (true)
	if (from_scheduled_)
		*flag1 |= (1 << 18);
	//parse argument legacy (true)
	if (legacy_)
		*flag1 |= (1 << 19);
	//parse argument edit_hide (true)
	if (edit_hide_)
		*flag1 |= (1 << 21);
	//parse argument pinned (true)
	if (pinned_)
		*flag1 |= (1 << 24);
	//parse argument noforwards (true)
	if (noforwards_)
		*flag1 |= (1 << 26);
	//parse argument invert_media (true)
	if (invert_media_)
		*flag1 |= (1 << 27);
	//parse argument flags2 ((null))
	ui32_t *flag2 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument offline (true)
	if (offline_)
		*flag2 |= (1 << 1);
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument from_id (Peer)
	if (from_id_)
	{
		buf = buf_cat(buf, *from_id_);
		*flag1 |= (1 << 8);
	}
	//parse argument from_boosts_applied (int)
	if (from_boosts_applied_)
	{
		buf = buf_cat(buf, buf_add_ui32(from_boosts_applied_));
		*flag1 |= (1 << 29);
	}
	//parse argument peer_id (Peer)
	{
		buf = buf_cat(buf, *peer_id_);
	}
	//parse argument saved_peer_id (Peer)
	if (saved_peer_id_)
	{
		buf = buf_cat(buf, *saved_peer_id_);
		*flag1 |= (1 << 28);
	}
	//parse argument fwd_from (MessageFwdHeader)
	if (fwd_from_)
	{
		buf = buf_cat(buf, *fwd_from_);
		*flag1 |= (1 << 2);
	}
	//parse argument via_bot_id (long)
	if (via_bot_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(via_bot_id_));
		*flag1 |= (1 << 11);
	}
	//parse argument via_business_bot_id (long)
	if (via_business_bot_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(via_business_bot_id_));
		*flag2 |= (1 << 0);
	}
	//parse argument reply_to (MessageReplyHeader)
	if (reply_to_)
	{
		buf = buf_cat(buf, *reply_to_);
		*flag1 |= (1 << 3);
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument message (string)
	{
		buf = buf_cat(buf, serialize_string(message_));
	}
	//parse argument media (MessageMedia)
	if (media_)
	{
		buf = buf_cat(buf, *media_);
		*flag1 |= (1 << 9);
	}
	//parse argument reply_markup (ReplyMarkup)
	if (reply_markup_)
	{
		buf = buf_cat(buf, *reply_markup_);
		*flag1 |= (1 << 6);
	}
	//parse argument entities (Vector<MessageEntity>)
	if (entities_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(entities_len));
		int i;
		for (i=0; i<entities_len; ++i){
			buf = buf_cat(buf, entities_[i]);
		}
		*flag1 |= (1 << 7);
	}
	//parse argument views (int)
	if (views_)
	{
		buf = buf_cat(buf, buf_add_ui32(views_));
		*flag1 |= (1 << 10);
	}
	//parse argument forwards (int)
	if (forwards_)
	{
		buf = buf_cat(buf, buf_add_ui32(forwards_));
		*flag1 |= (1 << 10);
	}
	//parse argument replies (MessageReplies)
	if (replies_)
	{
		buf = buf_cat(buf, *replies_);
		*flag1 |= (1 << 23);
	}
	//parse argument edit_date (int)
	if (edit_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(edit_date_));
		*flag1 |= (1 << 15);
	}
	//parse argument post_author (string)
	if (post_author_)
	{
		buf = buf_cat(buf, serialize_string(post_author_));
		*flag1 |= (1 << 16);
	}
	//parse argument grouped_id (long)
	if (grouped_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(grouped_id_));
		*flag1 |= (1 << 17);
	}
	//parse argument reactions (MessageReactions)
	if (reactions_)
	{
		buf = buf_cat(buf, *reactions_);
		*flag1 |= (1 << 20);
	}
	//parse argument restriction_reason (Vector<RestrictionReason>)
	if (restriction_reason_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(restriction_reason_len));
		int i;
		for (i=0; i<restriction_reason_len; ++i){
			buf = buf_cat(buf, restriction_reason_[i]);
		}
		*flag1 |= (1 << 22);
	}
	//parse argument ttl_period (int)
	if (ttl_period_)
	{
		buf = buf_cat(buf, buf_add_ui32(ttl_period_));
		*flag1 |= (1 << 25);
	}
	//parse argument quick_reply_shortcut_id (int)
	if (quick_reply_shortcut_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(quick_reply_shortcut_id_));
		*flag1 |= (1 << 30);
	}
	//parse argument effect (long)
	if (effect_)
	{
		buf = buf_cat(buf, buf_add_ui64(effect_));
		*flag2 |= (1 << 2);
	}
	//parse argument factcheck (FactCheck)
	if (factcheck_)
	{
		buf = buf_cat(buf, *factcheck_);
		*flag2 |= (1 << 3);
	}
	return buf;
}

buf_t tl_messageService(bool out_, bool mentioned_, bool media_unread_, bool silent_, bool post_, bool legacy_, int id_, Peer *from_id_, Peer *peer_id_, MessageReplyHeader *reply_to_, int date_, MessageAction *action_, int ttl_period_)
{
	buf_t buf = buf_add_ui32(0x2b085862);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument out (true)
	if (out_)
		*flag1 |= (1 << 1);
	//parse argument mentioned (true)
	if (mentioned_)
		*flag1 |= (1 << 4);
	//parse argument media_unread (true)
	if (media_unread_)
		*flag1 |= (1 << 5);
	//parse argument silent (true)
	if (silent_)
		*flag1 |= (1 << 13);
	//parse argument post (true)
	if (post_)
		*flag1 |= (1 << 14);
	//parse argument legacy (true)
	if (legacy_)
		*flag1 |= (1 << 19);
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument from_id (Peer)
	if (from_id_)
	{
		buf = buf_cat(buf, *from_id_);
		*flag1 |= (1 << 8);
	}
	//parse argument peer_id (Peer)
	{
		buf = buf_cat(buf, *peer_id_);
	}
	//parse argument reply_to (MessageReplyHeader)
	if (reply_to_)
	{
		buf = buf_cat(buf, *reply_to_);
		*flag1 |= (1 << 3);
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument action (MessageAction)
	{
		buf = buf_cat(buf, *action_);
	}
	//parse argument ttl_period (int)
	if (ttl_period_)
	{
		buf = buf_cat(buf, buf_add_ui32(ttl_period_));
		*flag1 |= (1 << 25);
	}
	return buf;
}

buf_t tl_messageMediaEmpty()
{
	buf_t buf = buf_add_ui32(0x3ded6320);
	return buf;
}

buf_t tl_messageMediaPhoto(bool spoiler_, Photo *photo_, int ttl_seconds_)
{
	buf_t buf = buf_add_ui32(0x695150d7);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument spoiler (true)
	if (spoiler_)
		*flag1 |= (1 << 3);
	//parse argument photo (Photo)
	if (photo_)
	{
		buf = buf_cat(buf, *photo_);
		*flag1 |= (1 << 0);
	}
	//parse argument ttl_seconds (int)
	if (ttl_seconds_)
	{
		buf = buf_cat(buf, buf_add_ui32(ttl_seconds_));
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_messageMediaGeo(GeoPoint *geo_)
{
	buf_t buf = buf_add_ui32(0x56e0d474);
	//parse argument geo (GeoPoint)
	{
		buf = buf_cat(buf, *geo_);
	}
	return buf;
}

buf_t tl_messageMediaContact(const char * phone_number_, const char * first_name_, const char * last_name_, const char * vcard_, long user_id_)
{
	buf_t buf = buf_add_ui32(0x70322949);
	//parse argument phone_number (string)
	{
		buf = buf_cat(buf, serialize_string(phone_number_));
	}
	//parse argument first_name (string)
	{
		buf = buf_cat(buf, serialize_string(first_name_));
	}
	//parse argument last_name (string)
	{
		buf = buf_cat(buf, serialize_string(last_name_));
	}
	//parse argument vcard (string)
	{
		buf = buf_cat(buf, serialize_string(vcard_));
	}
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	return buf;
}

buf_t tl_messageMediaUnsupported()
{
	buf_t buf = buf_add_ui32(0x9f84f49e);
	return buf;
}

buf_t tl_messageMediaDocument(bool nopremium_, bool spoiler_, bool video_, bool round_, bool voice_, Document *document_, Document *alt_documents_, int alt_documents_len, int ttl_seconds_)
{
	buf_t buf = buf_add_ui32(0xdd570bd5);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument nopremium (true)
	if (nopremium_)
		*flag1 |= (1 << 3);
	//parse argument spoiler (true)
	if (spoiler_)
		*flag1 |= (1 << 4);
	//parse argument video (true)
	if (video_)
		*flag1 |= (1 << 6);
	//parse argument round (true)
	if (round_)
		*flag1 |= (1 << 7);
	//parse argument voice (true)
	if (voice_)
		*flag1 |= (1 << 8);
	//parse argument document (Document)
	if (document_)
	{
		buf = buf_cat(buf, *document_);
		*flag1 |= (1 << 0);
	}
	//parse argument alt_documents (Vector<Document>)
	if (alt_documents_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(alt_documents_len));
		int i;
		for (i=0; i<alt_documents_len; ++i){
			buf = buf_cat(buf, alt_documents_[i]);
		}
		*flag1 |= (1 << 5);
	}
	//parse argument ttl_seconds (int)
	if (ttl_seconds_)
	{
		buf = buf_cat(buf, buf_add_ui32(ttl_seconds_));
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_messageMediaWebPage(bool force_large_media_, bool force_small_media_, bool manual_, bool safe_, WebPage *webpage_)
{
	buf_t buf = buf_add_ui32(0xddf10c3b);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument force_large_media (true)
	if (force_large_media_)
		*flag1 |= (1 << 0);
	//parse argument force_small_media (true)
	if (force_small_media_)
		*flag1 |= (1 << 1);
	//parse argument manual (true)
	if (manual_)
		*flag1 |= (1 << 3);
	//parse argument safe (true)
	if (safe_)
		*flag1 |= (1 << 4);
	//parse argument webpage (WebPage)
	{
		buf = buf_cat(buf, *webpage_);
	}
	return buf;
}

buf_t tl_messageMediaVenue(GeoPoint *geo_, const char * title_, const char * address_, const char * provider_, const char * venue_id_, const char * venue_type_)
{
	buf_t buf = buf_add_ui32(0x2ec0533f);
	//parse argument geo (GeoPoint)
	{
		buf = buf_cat(buf, *geo_);
	}
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument address (string)
	{
		buf = buf_cat(buf, serialize_string(address_));
	}
	//parse argument provider (string)
	{
		buf = buf_cat(buf, serialize_string(provider_));
	}
	//parse argument venue_id (string)
	{
		buf = buf_cat(buf, serialize_string(venue_id_));
	}
	//parse argument venue_type (string)
	{
		buf = buf_cat(buf, serialize_string(venue_type_));
	}
	return buf;
}

buf_t tl_messageMediaGame(Game *game_)
{
	buf_t buf = buf_add_ui32(0xfdb19008);
	//parse argument game (Game)
	{
		buf = buf_cat(buf, *game_);
	}
	return buf;
}

buf_t tl_messageMediaInvoice(bool shipping_address_requested_, bool test_, const char * title_, const char * description_, WebDocument *photo_, int receipt_msg_id_, const char * currency_, long total_amount_, const char * start_param_, MessageExtendedMedia *extended_media_)
{
	buf_t buf = buf_add_ui32(0xf6a548d3);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument shipping_address_requested (true)
	if (shipping_address_requested_)
		*flag1 |= (1 << 1);
	//parse argument test (true)
	if (test_)
		*flag1 |= (1 << 3);
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument description (string)
	{
		buf = buf_cat(buf, serialize_string(description_));
	}
	//parse argument photo (WebDocument)
	if (photo_)
	{
		buf = buf_cat(buf, *photo_);
		*flag1 |= (1 << 0);
	}
	//parse argument receipt_msg_id (int)
	if (receipt_msg_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(receipt_msg_id_));
		*flag1 |= (1 << 2);
	}
	//parse argument currency (string)
	{
		buf = buf_cat(buf, serialize_string(currency_));
	}
	//parse argument total_amount (long)
	{
		buf = buf_cat(buf, buf_add_ui64(total_amount_));
	}
	//parse argument start_param (string)
	{
		buf = buf_cat(buf, serialize_string(start_param_));
	}
	//parse argument extended_media (MessageExtendedMedia)
	if (extended_media_)
	{
		buf = buf_cat(buf, *extended_media_);
		*flag1 |= (1 << 4);
	}
	return buf;
}

buf_t tl_messageMediaGeoLive(GeoPoint *geo_, int heading_, int period_, int proximity_notification_radius_)
{
	buf_t buf = buf_add_ui32(0xb940c666);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument geo (GeoPoint)
	{
		buf = buf_cat(buf, *geo_);
	}
	//parse argument heading (int)
	if (heading_)
	{
		buf = buf_cat(buf, buf_add_ui32(heading_));
		*flag1 |= (1 << 0);
	}
	//parse argument period (int)
	{
		buf = buf_cat(buf, buf_add_ui32(period_));
	}
	//parse argument proximity_notification_radius (int)
	if (proximity_notification_radius_)
	{
		buf = buf_cat(buf, buf_add_ui32(proximity_notification_radius_));
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_messageMediaPoll(Poll *poll_, PollResults *results_)
{
	buf_t buf = buf_add_ui32(0x4bd6e798);
	//parse argument poll (Poll)
	{
		buf = buf_cat(buf, *poll_);
	}
	//parse argument results (PollResults)
	{
		buf = buf_cat(buf, *results_);
	}
	return buf;
}

buf_t tl_messageMediaDice(int value_, const char * emoticon_)
{
	buf_t buf = buf_add_ui32(0x3f7ee58b);
	//parse argument value (int)
	{
		buf = buf_cat(buf, buf_add_ui32(value_));
	}
	//parse argument emoticon (string)
	{
		buf = buf_cat(buf, serialize_string(emoticon_));
	}
	return buf;
}

buf_t tl_messageMediaStory(bool via_mention_, Peer *peer_, int id_, StoryItem *story_)
{
	buf_t buf = buf_add_ui32(0x68cb6283);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument via_mention (true)
	if (via_mention_)
		*flag1 |= (1 << 1);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument story (StoryItem)
	if (story_)
	{
		buf = buf_cat(buf, *story_);
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_messageMediaGiveaway(bool only_new_subscribers_, bool winners_are_visible_, long *channels_, int channels_len, const char * *countries_iso2_, int countries_iso2_len, const char * prize_description_, int quantity_, int months_, long stars_, int until_date_)
{
	buf_t buf = buf_add_ui32(0xaa073beb);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument only_new_subscribers (true)
	if (only_new_subscribers_)
		*flag1 |= (1 << 0);
	//parse argument winners_are_visible (true)
	if (winners_are_visible_)
		*flag1 |= (1 << 2);
	//parse argument channels (Vector<long>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(channels_len));
		int i;
		for (i=0; i<channels_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(channels_[i]));
		}
	}
	//parse argument countries_iso2 (Vector<string>)
	if (countries_iso2_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(countries_iso2_len));
		int i;
		for (i=0; i<countries_iso2_len; ++i){
			buf = buf_cat(buf, serialize_string(countries_iso2_[i]));
		}
		*flag1 |= (1 << 1);
	}
	//parse argument prize_description (string)
	if (prize_description_)
	{
		buf = buf_cat(buf, serialize_string(prize_description_));
		*flag1 |= (1 << 3);
	}
	//parse argument quantity (int)
	{
		buf = buf_cat(buf, buf_add_ui32(quantity_));
	}
	//parse argument months (int)
	if (months_)
	{
		buf = buf_cat(buf, buf_add_ui32(months_));
		*flag1 |= (1 << 4);
	}
	//parse argument stars (long)
	if (stars_)
	{
		buf = buf_cat(buf, buf_add_ui64(stars_));
		*flag1 |= (1 << 5);
	}
	//parse argument until_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(until_date_));
	}
	return buf;
}

buf_t tl_messageMediaGiveawayResults(bool only_new_subscribers_, bool refunded_, long channel_id_, int additional_peers_count_, int launch_msg_id_, int winners_count_, int unclaimed_count_, long *winners_, int winners_len, int months_, long stars_, const char * prize_description_, int until_date_)
{
	buf_t buf = buf_add_ui32(0xceaa3ea1);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument only_new_subscribers (true)
	if (only_new_subscribers_)
		*flag1 |= (1 << 0);
	//parse argument refunded (true)
	if (refunded_)
		*flag1 |= (1 << 2);
	//parse argument channel_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(channel_id_));
	}
	//parse argument additional_peers_count (int)
	if (additional_peers_count_)
	{
		buf = buf_cat(buf, buf_add_ui32(additional_peers_count_));
		*flag1 |= (1 << 3);
	}
	//parse argument launch_msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(launch_msg_id_));
	}
	//parse argument winners_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(winners_count_));
	}
	//parse argument unclaimed_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(unclaimed_count_));
	}
	//parse argument winners (Vector<long>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(winners_len));
		int i;
		for (i=0; i<winners_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(winners_[i]));
		}
	}
	//parse argument months (int)
	if (months_)
	{
		buf = buf_cat(buf, buf_add_ui32(months_));
		*flag1 |= (1 << 4);
	}
	//parse argument stars (long)
	if (stars_)
	{
		buf = buf_cat(buf, buf_add_ui64(stars_));
		*flag1 |= (1 << 5);
	}
	//parse argument prize_description (string)
	if (prize_description_)
	{
		buf = buf_cat(buf, serialize_string(prize_description_));
		*flag1 |= (1 << 1);
	}
	//parse argument until_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(until_date_));
	}
	return buf;
}

buf_t tl_messageMediaPaidMedia(long stars_amount_, MessageExtendedMedia *extended_media_, int extended_media_len)
{
	buf_t buf = buf_add_ui32(0xa8852491);
	//parse argument stars_amount (long)
	{
		buf = buf_cat(buf, buf_add_ui64(stars_amount_));
	}
	//parse argument extended_media (Vector<MessageExtendedMedia>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(extended_media_len));
		int i;
		for (i=0; i<extended_media_len; ++i){
			buf = buf_cat(buf, extended_media_[i]);
		}
	}
	return buf;
}

buf_t tl_messageActionEmpty()
{
	buf_t buf = buf_add_ui32(0xb6aef7b0);
	return buf;
}

buf_t tl_messageActionChatCreate(const char * title_, long *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0xbd47cbad);
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument users (Vector<long>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(users_[i]));
		}
	}
	return buf;
}

buf_t tl_messageActionChatEditTitle(const char * title_)
{
	buf_t buf = buf_add_ui32(0xb5a1ce5a);
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	return buf;
}

buf_t tl_messageActionChatEditPhoto(Photo *photo_)
{
	buf_t buf = buf_add_ui32(0x7fcb13a8);
	//parse argument photo (Photo)
	{
		buf = buf_cat(buf, *photo_);
	}
	return buf;
}

buf_t tl_messageActionChatDeletePhoto()
{
	buf_t buf = buf_add_ui32(0x95e3fbef);
	return buf;
}

buf_t tl_messageActionChatAddUser(long *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x15cefd00);
	//parse argument users (Vector<long>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(users_[i]));
		}
	}
	return buf;
}

buf_t tl_messageActionChatDeleteUser(long user_id_)
{
	buf_t buf = buf_add_ui32(0xa43f30cc);
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	return buf;
}

buf_t tl_messageActionChatJoinedByLink(long inviter_id_)
{
	buf_t buf = buf_add_ui32(0x031224c3);
	//parse argument inviter_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(inviter_id_));
	}
	return buf;
}

buf_t tl_messageActionChannelCreate(const char * title_)
{
	buf_t buf = buf_add_ui32(0x95d2ac92);
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	return buf;
}

buf_t tl_messageActionChatMigrateTo(long channel_id_)
{
	buf_t buf = buf_add_ui32(0xe1037f92);
	//parse argument channel_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(channel_id_));
	}
	return buf;
}

buf_t tl_messageActionChannelMigrateFrom(const char * title_, long chat_id_)
{
	buf_t buf = buf_add_ui32(0xea3948e9);
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument chat_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(chat_id_));
	}
	return buf;
}

buf_t tl_messageActionPinMessage()
{
	buf_t buf = buf_add_ui32(0x94bd38ed);
	return buf;
}

buf_t tl_messageActionHistoryClear()
{
	buf_t buf = buf_add_ui32(0x9fbab604);
	return buf;
}

buf_t tl_messageActionGameScore(long game_id_, int score_)
{
	buf_t buf = buf_add_ui32(0x92a72876);
	//parse argument game_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(game_id_));
	}
	//parse argument score (int)
	{
		buf = buf_cat(buf, buf_add_ui32(score_));
	}
	return buf;
}

buf_t tl_messageActionPaymentSentMe(bool recurring_init_, bool recurring_used_, const char * currency_, long total_amount_, buf_t *payload_, PaymentRequestedInfo *info_, const char * shipping_option_id_, PaymentCharge *charge_)
{
	buf_t buf = buf_add_ui32(0x8f31b327);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument recurring_init (true)
	if (recurring_init_)
		*flag1 |= (1 << 2);
	//parse argument recurring_used (true)
	if (recurring_used_)
		*flag1 |= (1 << 3);
	//parse argument currency (string)
	{
		buf = buf_cat(buf, serialize_string(currency_));
	}
	//parse argument total_amount (long)
	{
		buf = buf_cat(buf, buf_add_ui64(total_amount_));
	}
	//parse argument payload (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(payload_->data, payload_->size));
	}
	//parse argument info (PaymentRequestedInfo)
	if (info_)
	{
		buf = buf_cat(buf, *info_);
		*flag1 |= (1 << 0);
	}
	//parse argument shipping_option_id (string)
	if (shipping_option_id_)
	{
		buf = buf_cat(buf, serialize_string(shipping_option_id_));
		*flag1 |= (1 << 1);
	}
	//parse argument charge (PaymentCharge)
	{
		buf = buf_cat(buf, *charge_);
	}
	return buf;
}

buf_t tl_messageActionPaymentSent(bool recurring_init_, bool recurring_used_, const char * currency_, long total_amount_, const char * invoice_slug_)
{
	buf_t buf = buf_add_ui32(0x96163f56);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument recurring_init (true)
	if (recurring_init_)
		*flag1 |= (1 << 2);
	//parse argument recurring_used (true)
	if (recurring_used_)
		*flag1 |= (1 << 3);
	//parse argument currency (string)
	{
		buf = buf_cat(buf, serialize_string(currency_));
	}
	//parse argument total_amount (long)
	{
		buf = buf_cat(buf, buf_add_ui64(total_amount_));
	}
	//parse argument invoice_slug (string)
	if (invoice_slug_)
	{
		buf = buf_cat(buf, serialize_string(invoice_slug_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_messageActionPhoneCall(bool video_, long call_id_, PhoneCallDiscardReason *reason_, int duration_)
{
	buf_t buf = buf_add_ui32(0x80e11a7f);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument video (true)
	if (video_)
		*flag1 |= (1 << 2);
	//parse argument call_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(call_id_));
	}
	//parse argument reason (PhoneCallDiscardReason)
	if (reason_)
	{
		buf = buf_cat(buf, *reason_);
		*flag1 |= (1 << 0);
	}
	//parse argument duration (int)
	if (duration_)
	{
		buf = buf_cat(buf, buf_add_ui32(duration_));
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_messageActionScreenshotTaken()
{
	buf_t buf = buf_add_ui32(0x4792929b);
	return buf;
}

buf_t tl_messageActionCustomAction(const char * message_)
{
	buf_t buf = buf_add_ui32(0xfae69f56);
	//parse argument message (string)
	{
		buf = buf_cat(buf, serialize_string(message_));
	}
	return buf;
}

buf_t tl_messageActionBotAllowed(bool attach_menu_, bool from_request_, const char * domain_, BotApp *app_)
{
	buf_t buf = buf_add_ui32(0xc516d679);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument attach_menu (true)
	if (attach_menu_)
		*flag1 |= (1 << 1);
	//parse argument from_request (true)
	if (from_request_)
		*flag1 |= (1 << 3);
	//parse argument domain (string)
	if (domain_)
	{
		buf = buf_cat(buf, serialize_string(domain_));
		*flag1 |= (1 << 0);
	}
	//parse argument app (BotApp)
	if (app_)
	{
		buf = buf_cat(buf, *app_);
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_messageActionSecureValuesSentMe(SecureValue *values_, int values_len, SecureCredentialsEncrypted *credentials_)
{
	buf_t buf = buf_add_ui32(0x1b287353);
	//parse argument values (Vector<SecureValue>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(values_len));
		int i;
		for (i=0; i<values_len; ++i){
			buf = buf_cat(buf, values_[i]);
		}
	}
	//parse argument credentials (SecureCredentialsEncrypted)
	{
		buf = buf_cat(buf, *credentials_);
	}
	return buf;
}

buf_t tl_messageActionSecureValuesSent(SecureValueType *types_, int types_len)
{
	buf_t buf = buf_add_ui32(0xd95c6154);
	//parse argument types (Vector<SecureValueType>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(types_len));
		int i;
		for (i=0; i<types_len; ++i){
			buf = buf_cat(buf, types_[i]);
		}
	}
	return buf;
}

buf_t tl_messageActionContactSignUp()
{
	buf_t buf = buf_add_ui32(0xf3f25f76);
	return buf;
}

buf_t tl_messageActionGeoProximityReached(Peer *from_id_, Peer *to_id_, int distance_)
{
	buf_t buf = buf_add_ui32(0x98e0d697);
	//parse argument from_id (Peer)
	{
		buf = buf_cat(buf, *from_id_);
	}
	//parse argument to_id (Peer)
	{
		buf = buf_cat(buf, *to_id_);
	}
	//parse argument distance (int)
	{
		buf = buf_cat(buf, buf_add_ui32(distance_));
	}
	return buf;
}

buf_t tl_messageActionGroupCall(InputGroupCall *call_, int duration_)
{
	buf_t buf = buf_add_ui32(0x7a0d7f42);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument call (InputGroupCall)
	{
		buf = buf_cat(buf, *call_);
	}
	//parse argument duration (int)
	if (duration_)
	{
		buf = buf_cat(buf, buf_add_ui32(duration_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_messageActionInviteToGroupCall(InputGroupCall *call_, long *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x502f92f7);
	//parse argument call (InputGroupCall)
	{
		buf = buf_cat(buf, *call_);
	}
	//parse argument users (Vector<long>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(users_[i]));
		}
	}
	return buf;
}

buf_t tl_messageActionSetMessagesTTL(int period_, long auto_setting_from_)
{
	buf_t buf = buf_add_ui32(0x3c134d7b);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument period (int)
	{
		buf = buf_cat(buf, buf_add_ui32(period_));
	}
	//parse argument auto_setting_from (long)
	if (auto_setting_from_)
	{
		buf = buf_cat(buf, buf_add_ui64(auto_setting_from_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_messageActionGroupCallScheduled(InputGroupCall *call_, int schedule_date_)
{
	buf_t buf = buf_add_ui32(0xb3a07661);
	//parse argument call (InputGroupCall)
	{
		buf = buf_cat(buf, *call_);
	}
	//parse argument schedule_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(schedule_date_));
	}
	return buf;
}

buf_t tl_messageActionSetChatTheme(const char * emoticon_)
{
	buf_t buf = buf_add_ui32(0xaa786345);
	//parse argument emoticon (string)
	{
		buf = buf_cat(buf, serialize_string(emoticon_));
	}
	return buf;
}

buf_t tl_messageActionChatJoinedByRequest()
{
	buf_t buf = buf_add_ui32(0xebbca3cb);
	return buf;
}

buf_t tl_messageActionWebViewDataSentMe(const char * text_, const char * data_)
{
	buf_t buf = buf_add_ui32(0x47dd8079);
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	//parse argument data (string)
	{
		buf = buf_cat(buf, serialize_string(data_));
	}
	return buf;
}

buf_t tl_messageActionWebViewDataSent(const char * text_)
{
	buf_t buf = buf_add_ui32(0xb4c38cb5);
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	return buf;
}

buf_t tl_messageActionGiftPremium(const char * currency_, long amount_, int months_, const char * crypto_currency_, long crypto_amount_)
{
	buf_t buf = buf_add_ui32(0xc83d6aec);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument currency (string)
	{
		buf = buf_cat(buf, serialize_string(currency_));
	}
	//parse argument amount (long)
	{
		buf = buf_cat(buf, buf_add_ui64(amount_));
	}
	//parse argument months (int)
	{
		buf = buf_cat(buf, buf_add_ui32(months_));
	}
	//parse argument crypto_currency (string)
	if (crypto_currency_)
	{
		buf = buf_cat(buf, serialize_string(crypto_currency_));
		*flag1 |= (1 << 0);
	}
	//parse argument crypto_amount (long)
	if (crypto_amount_)
	{
		buf = buf_cat(buf, buf_add_ui64(crypto_amount_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_messageActionTopicCreate(const char * title_, int icon_color_, long icon_emoji_id_)
{
	buf_t buf = buf_add_ui32(0x0d999256);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument icon_color (int)
	{
		buf = buf_cat(buf, buf_add_ui32(icon_color_));
	}
	//parse argument icon_emoji_id (long)
	if (icon_emoji_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(icon_emoji_id_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_messageActionTopicEdit(const char * title_, long icon_emoji_id_, Bool *closed_, Bool *hidden_)
{
	buf_t buf = buf_add_ui32(0xc0944820);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument title (string)
	if (title_)
	{
		buf = buf_cat(buf, serialize_string(title_));
		*flag1 |= (1 << 0);
	}
	//parse argument icon_emoji_id (long)
	if (icon_emoji_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(icon_emoji_id_));
		*flag1 |= (1 << 1);
	}
	//parse argument closed (Bool)
	if (closed_)
	{
		buf = buf_cat(buf, *closed_);
		*flag1 |= (1 << 2);
	}
	//parse argument hidden (Bool)
	if (hidden_)
	{
		buf = buf_cat(buf, *hidden_);
		*flag1 |= (1 << 3);
	}
	return buf;
}

buf_t tl_messageActionSuggestProfilePhoto(Photo *photo_)
{
	buf_t buf = buf_add_ui32(0x57de635e);
	//parse argument photo (Photo)
	{
		buf = buf_cat(buf, *photo_);
	}
	return buf;
}

buf_t tl_messageActionRequestedPeer(int button_id_, Peer *peers_, int peers_len)
{
	buf_t buf = buf_add_ui32(0x31518e9b);
	//parse argument button_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(button_id_));
	}
	//parse argument peers (Vector<Peer>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(peers_len));
		int i;
		for (i=0; i<peers_len; ++i){
			buf = buf_cat(buf, peers_[i]);
		}
	}
	return buf;
}

buf_t tl_messageActionSetChatWallPaper(bool same_, bool for_both_, WallPaper *wallpaper_)
{
	buf_t buf = buf_add_ui32(0x5060a3f4);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument same (true)
	if (same_)
		*flag1 |= (1 << 0);
	//parse argument for_both (true)
	if (for_both_)
		*flag1 |= (1 << 1);
	//parse argument wallpaper (WallPaper)
	{
		buf = buf_cat(buf, *wallpaper_);
	}
	return buf;
}

buf_t tl_messageActionGiftCode(bool via_giveaway_, bool unclaimed_, Peer *boost_peer_, int months_, const char * slug_, const char * currency_, long amount_, const char * crypto_currency_, long crypto_amount_)
{
	buf_t buf = buf_add_ui32(0x678c2e09);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument via_giveaway (true)
	if (via_giveaway_)
		*flag1 |= (1 << 0);
	//parse argument unclaimed (true)
	if (unclaimed_)
		*flag1 |= (1 << 2);
	//parse argument boost_peer (Peer)
	if (boost_peer_)
	{
		buf = buf_cat(buf, *boost_peer_);
		*flag1 |= (1 << 1);
	}
	//parse argument months (int)
	{
		buf = buf_cat(buf, buf_add_ui32(months_));
	}
	//parse argument slug (string)
	{
		buf = buf_cat(buf, serialize_string(slug_));
	}
	//parse argument currency (string)
	if (currency_)
	{
		buf = buf_cat(buf, serialize_string(currency_));
		*flag1 |= (1 << 2);
	}
	//parse argument amount (long)
	if (amount_)
	{
		buf = buf_cat(buf, buf_add_ui64(amount_));
		*flag1 |= (1 << 2);
	}
	//parse argument crypto_currency (string)
	if (crypto_currency_)
	{
		buf = buf_cat(buf, serialize_string(crypto_currency_));
		*flag1 |= (1 << 3);
	}
	//parse argument crypto_amount (long)
	if (crypto_amount_)
	{
		buf = buf_cat(buf, buf_add_ui64(crypto_amount_));
		*flag1 |= (1 << 3);
	}
	return buf;
}

buf_t tl_messageActionGiveawayLaunch(long stars_)
{
	buf_t buf = buf_add_ui32(0xa80f51e4);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument stars (long)
	if (stars_)
	{
		buf = buf_cat(buf, buf_add_ui64(stars_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_messageActionGiveawayResults(bool stars_, int winners_count_, int unclaimed_count_)
{
	buf_t buf = buf_add_ui32(0x87e2f155);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument stars (true)
	if (stars_)
		*flag1 |= (1 << 0);
	//parse argument winners_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(winners_count_));
	}
	//parse argument unclaimed_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(unclaimed_count_));
	}
	return buf;
}

buf_t tl_messageActionBoostApply(int boosts_)
{
	buf_t buf = buf_add_ui32(0xcc02aa6d);
	//parse argument boosts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(boosts_));
	}
	return buf;
}

buf_t tl_messageActionRequestedPeerSentMe(int button_id_, RequestedPeer *peers_, int peers_len)
{
	buf_t buf = buf_add_ui32(0x93b31848);
	//parse argument button_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(button_id_));
	}
	//parse argument peers (Vector<RequestedPeer>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(peers_len));
		int i;
		for (i=0; i<peers_len; ++i){
			buf = buf_cat(buf, peers_[i]);
		}
	}
	return buf;
}

buf_t tl_messageActionPaymentRefunded(Peer *peer_, const char * currency_, long total_amount_, buf_t *payload_, PaymentCharge *charge_)
{
	buf_t buf = buf_add_ui32(0x41b3e202);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument currency (string)
	{
		buf = buf_cat(buf, serialize_string(currency_));
	}
	//parse argument total_amount (long)
	{
		buf = buf_cat(buf, buf_add_ui64(total_amount_));
	}
	//parse argument payload (bytes)
	if (payload_)
	{
		buf = buf_cat(buf, serialize_bytes(payload_->data, payload_->size));
		*flag1 |= (1 << 0);
	}
	//parse argument charge (PaymentCharge)
	{
		buf = buf_cat(buf, *charge_);
	}
	return buf;
}

buf_t tl_messageActionGiftStars(const char * currency_, long amount_, long stars_, const char * crypto_currency_, long crypto_amount_, const char * transaction_id_)
{
	buf_t buf = buf_add_ui32(0x45d5b021);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument currency (string)
	{
		buf = buf_cat(buf, serialize_string(currency_));
	}
	//parse argument amount (long)
	{
		buf = buf_cat(buf, buf_add_ui64(amount_));
	}
	//parse argument stars (long)
	{
		buf = buf_cat(buf, buf_add_ui64(stars_));
	}
	//parse argument crypto_currency (string)
	if (crypto_currency_)
	{
		buf = buf_cat(buf, serialize_string(crypto_currency_));
		*flag1 |= (1 << 0);
	}
	//parse argument crypto_amount (long)
	if (crypto_amount_)
	{
		buf = buf_cat(buf, buf_add_ui64(crypto_amount_));
		*flag1 |= (1 << 0);
	}
	//parse argument transaction_id (string)
	if (transaction_id_)
	{
		buf = buf_cat(buf, serialize_string(transaction_id_));
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_messageActionPrizeStars(bool unclaimed_, long stars_, const char * transaction_id_, Peer *boost_peer_, int giveaway_msg_id_)
{
	buf_t buf = buf_add_ui32(0xb00c47a2);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument unclaimed (true)
	if (unclaimed_)
		*flag1 |= (1 << 0);
	//parse argument stars (long)
	{
		buf = buf_cat(buf, buf_add_ui64(stars_));
	}
	//parse argument transaction_id (string)
	{
		buf = buf_cat(buf, serialize_string(transaction_id_));
	}
	//parse argument boost_peer (Peer)
	{
		buf = buf_cat(buf, *boost_peer_);
	}
	//parse argument giveaway_msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(giveaway_msg_id_));
	}
	return buf;
}

buf_t tl_messageActionStarGift(bool name_hidden_, bool saved_, bool converted_, StarGift *gift_, TextWithEntities *message_, long convert_stars_)
{
	buf_t buf = buf_add_ui32(0x9bb3ef44);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument name_hidden (true)
	if (name_hidden_)
		*flag1 |= (1 << 0);
	//parse argument saved (true)
	if (saved_)
		*flag1 |= (1 << 2);
	//parse argument converted (true)
	if (converted_)
		*flag1 |= (1 << 3);
	//parse argument gift (StarGift)
	{
		buf = buf_cat(buf, *gift_);
	}
	//parse argument message (TextWithEntities)
	if (message_)
	{
		buf = buf_cat(buf, *message_);
		*flag1 |= (1 << 1);
	}
	//parse argument convert_stars (long)
	{
		buf = buf_cat(buf, buf_add_ui64(convert_stars_));
	}
	return buf;
}

buf_t tl_dialog(bool pinned_, bool unread_mark_, bool view_forum_as_messages_, Peer *peer_, int top_message_, int read_inbox_max_id_, int read_outbox_max_id_, int unread_count_, int unread_mentions_count_, int unread_reactions_count_, PeerNotifySettings *notify_settings_, int pts_, DraftMessage *draft_, int folder_id_, int ttl_period_)
{
	buf_t buf = buf_add_ui32(0xd58a08c6);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument pinned (true)
	if (pinned_)
		*flag1 |= (1 << 2);
	//parse argument unread_mark (true)
	if (unread_mark_)
		*flag1 |= (1 << 3);
	//parse argument view_forum_as_messages (true)
	if (view_forum_as_messages_)
		*flag1 |= (1 << 6);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument top_message (int)
	{
		buf = buf_cat(buf, buf_add_ui32(top_message_));
	}
	//parse argument read_inbox_max_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(read_inbox_max_id_));
	}
	//parse argument read_outbox_max_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(read_outbox_max_id_));
	}
	//parse argument unread_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(unread_count_));
	}
	//parse argument unread_mentions_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(unread_mentions_count_));
	}
	//parse argument unread_reactions_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(unread_reactions_count_));
	}
	//parse argument notify_settings (PeerNotifySettings)
	{
		buf = buf_cat(buf, *notify_settings_);
	}
	//parse argument pts (int)
	if (pts_)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_));
		*flag1 |= (1 << 0);
	}
	//parse argument draft (DraftMessage)
	if (draft_)
	{
		buf = buf_cat(buf, *draft_);
		*flag1 |= (1 << 1);
	}
	//parse argument folder_id (int)
	if (folder_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(folder_id_));
		*flag1 |= (1 << 4);
	}
	//parse argument ttl_period (int)
	if (ttl_period_)
	{
		buf = buf_cat(buf, buf_add_ui32(ttl_period_));
		*flag1 |= (1 << 5);
	}
	return buf;
}

buf_t tl_dialogFolder(bool pinned_, Folder *folder_, Peer *peer_, int top_message_, int unread_muted_peers_count_, int unread_unmuted_peers_count_, int unread_muted_messages_count_, int unread_unmuted_messages_count_)
{
	buf_t buf = buf_add_ui32(0x71bd134c);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument pinned (true)
	if (pinned_)
		*flag1 |= (1 << 2);
	//parse argument folder (Folder)
	{
		buf = buf_cat(buf, *folder_);
	}
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument top_message (int)
	{
		buf = buf_cat(buf, buf_add_ui32(top_message_));
	}
	//parse argument unread_muted_peers_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(unread_muted_peers_count_));
	}
	//parse argument unread_unmuted_peers_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(unread_unmuted_peers_count_));
	}
	//parse argument unread_muted_messages_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(unread_muted_messages_count_));
	}
	//parse argument unread_unmuted_messages_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(unread_unmuted_messages_count_));
	}
	return buf;
}

buf_t tl_photoEmpty(long id_)
{
	buf_t buf = buf_add_ui32(0x2331b22d);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	return buf;
}

buf_t tl_photo(bool has_stickers_, long id_, long access_hash_, buf_t *file_reference_, int date_, PhotoSize *sizes_, int sizes_len, VideoSize *video_sizes_, int video_sizes_len, int dc_id_)
{
	buf_t buf = buf_add_ui32(0xfb197a65);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument has_stickers (true)
	if (has_stickers_)
		*flag1 |= (1 << 0);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	//parse argument file_reference (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(file_reference_->data, file_reference_->size));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument sizes (Vector<PhotoSize>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(sizes_len));
		int i;
		for (i=0; i<sizes_len; ++i){
			buf = buf_cat(buf, sizes_[i]);
		}
	}
	//parse argument video_sizes (Vector<VideoSize>)
	if (video_sizes_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(video_sizes_len));
		int i;
		for (i=0; i<video_sizes_len; ++i){
			buf = buf_cat(buf, video_sizes_[i]);
		}
		*flag1 |= (1 << 1);
	}
	//parse argument dc_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(dc_id_));
	}
	return buf;
}

buf_t tl_photoSizeEmpty(const char * type_)
{
	buf_t buf = buf_add_ui32(0x0e17e23c);
	//parse argument type (string)
	{
		buf = buf_cat(buf, serialize_string(type_));
	}
	return buf;
}

buf_t tl_photoSize(const char * type_, int w_, int h_, int size_)
{
	buf_t buf = buf_add_ui32(0x75c78e60);
	//parse argument type (string)
	{
		buf = buf_cat(buf, serialize_string(type_));
	}
	//parse argument w (int)
	{
		buf = buf_cat(buf, buf_add_ui32(w_));
	}
	//parse argument h (int)
	{
		buf = buf_cat(buf, buf_add_ui32(h_));
	}
	//parse argument size (int)
	{
		buf = buf_cat(buf, buf_add_ui32(size_));
	}
	return buf;
}

buf_t tl_photoCachedSize(const char * type_, int w_, int h_, buf_t *bytes_)
{
	buf_t buf = buf_add_ui32(0x021e1ad6);
	//parse argument type (string)
	{
		buf = buf_cat(buf, serialize_string(type_));
	}
	//parse argument w (int)
	{
		buf = buf_cat(buf, buf_add_ui32(w_));
	}
	//parse argument h (int)
	{
		buf = buf_cat(buf, buf_add_ui32(h_));
	}
	//parse argument bytes (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(bytes_->data, bytes_->size));
	}
	return buf;
}

buf_t tl_photoStrippedSize(const char * type_, buf_t *bytes_)
{
	buf_t buf = buf_add_ui32(0xe0b0bc2e);
	//parse argument type (string)
	{
		buf = buf_cat(buf, serialize_string(type_));
	}
	//parse argument bytes (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(bytes_->data, bytes_->size));
	}
	return buf;
}

buf_t tl_photoSizeProgressive(const char * type_, int w_, int h_, int *sizes_, int sizes_len)
{
	buf_t buf = buf_add_ui32(0xfa3efb95);
	//parse argument type (string)
	{
		buf = buf_cat(buf, serialize_string(type_));
	}
	//parse argument w (int)
	{
		buf = buf_cat(buf, buf_add_ui32(w_));
	}
	//parse argument h (int)
	{
		buf = buf_cat(buf, buf_add_ui32(h_));
	}
	//parse argument sizes (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(sizes_len));
		int i;
		for (i=0; i<sizes_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(sizes_[i]));
		}
	}
	return buf;
}

buf_t tl_photoPathSize(const char * type_, buf_t *bytes_)
{
	buf_t buf = buf_add_ui32(0xd8214d41);
	//parse argument type (string)
	{
		buf = buf_cat(buf, serialize_string(type_));
	}
	//parse argument bytes (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(bytes_->data, bytes_->size));
	}
	return buf;
}

buf_t tl_geoPointEmpty()
{
	buf_t buf = buf_add_ui32(0x1117dd5f);
	return buf;
}

buf_t tl_geoPoint(double long_, double lat_, long access_hash_, int accuracy_radius_)
{
	buf_t buf = buf_add_ui32(0xb2a2f663);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument long (double)
	{
		buf = buf_cat(buf, buf_add_ui64(long_));
	}
	//parse argument lat (double)
	{
		buf = buf_cat(buf, buf_add_ui64(lat_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	//parse argument accuracy_radius (int)
	if (accuracy_radius_)
	{
		buf = buf_cat(buf, buf_add_ui32(accuracy_radius_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_auth_sentCode(auth_SentCodeType *type_, const char * phone_code_hash_, auth_CodeType *next_type_, int timeout_)
{
	buf_t buf = buf_add_ui32(0x5e002502);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument type (auth_SentCodeType)
	{
		buf = buf_cat(buf, *type_);
	}
	//parse argument phone_code_hash (string)
	{
		buf = buf_cat(buf, serialize_string(phone_code_hash_));
	}
	//parse argument next_type (auth_CodeType)
	if (next_type_)
	{
		buf = buf_cat(buf, *next_type_);
		*flag1 |= (1 << 1);
	}
	//parse argument timeout (int)
	if (timeout_)
	{
		buf = buf_cat(buf, buf_add_ui32(timeout_));
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_auth_sentCodeSuccess(auth_Authorization *authorization_)
{
	buf_t buf = buf_add_ui32(0x2390fe44);
	//parse argument authorization (auth_Authorization)
	{
		buf = buf_cat(buf, *authorization_);
	}
	return buf;
}

buf_t tl_auth_authorization(bool setup_password_required_, int otherwise_relogin_days_, int tmp_sessions_, buf_t *future_auth_token_, User *user_)
{
	buf_t buf = buf_add_ui32(0x2ea2c0d4);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument setup_password_required (true)
	if (setup_password_required_)
		*flag1 |= (1 << 1);
	//parse argument otherwise_relogin_days (int)
	if (otherwise_relogin_days_)
	{
		buf = buf_cat(buf, buf_add_ui32(otherwise_relogin_days_));
		*flag1 |= (1 << 1);
	}
	//parse argument tmp_sessions (int)
	if (tmp_sessions_)
	{
		buf = buf_cat(buf, buf_add_ui32(tmp_sessions_));
		*flag1 |= (1 << 0);
	}
	//parse argument future_auth_token (bytes)
	if (future_auth_token_)
	{
		buf = buf_cat(buf, serialize_bytes(future_auth_token_->data, future_auth_token_->size));
		*flag1 |= (1 << 2);
	}
	//parse argument user (User)
	{
		buf = buf_cat(buf, *user_);
	}
	return buf;
}

buf_t tl_auth_authorizationSignUpRequired(help_TermsOfService *terms_of_service_)
{
	buf_t buf = buf_add_ui32(0x44747e9a);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument terms_of_service (help_TermsOfService)
	if (terms_of_service_)
	{
		buf = buf_cat(buf, *terms_of_service_);
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_auth_exportedAuthorization(long id_, buf_t *bytes_)
{
	buf_t buf = buf_add_ui32(0xb434e2b8);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument bytes (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(bytes_->data, bytes_->size));
	}
	return buf;
}

buf_t tl_inputNotifyPeer(InputPeer *peer_)
{
	buf_t buf = buf_add_ui32(0xb8bc5b0c);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_inputNotifyUsers()
{
	buf_t buf = buf_add_ui32(0x193b4417);
	return buf;
}

buf_t tl_inputNotifyChats()
{
	buf_t buf = buf_add_ui32(0x4a95e84e);
	return buf;
}

buf_t tl_inputNotifyBroadcasts()
{
	buf_t buf = buf_add_ui32(0xb1db7c7e);
	return buf;
}

buf_t tl_inputNotifyForumTopic(InputPeer *peer_, int top_msg_id_)
{
	buf_t buf = buf_add_ui32(0x5c467992);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument top_msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(top_msg_id_));
	}
	return buf;
}

buf_t tl_inputPeerNotifySettings(Bool *show_previews_, Bool *silent_, int mute_until_, NotificationSound *sound_, Bool *stories_muted_, Bool *stories_hide_sender_, NotificationSound *stories_sound_)
{
	buf_t buf = buf_add_ui32(0xcacb6ae2);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument show_previews (Bool)
	if (show_previews_)
	{
		buf = buf_cat(buf, *show_previews_);
		*flag1 |= (1 << 0);
	}
	//parse argument silent (Bool)
	if (silent_)
	{
		buf = buf_cat(buf, *silent_);
		*flag1 |= (1 << 1);
	}
	//parse argument mute_until (int)
	if (mute_until_)
	{
		buf = buf_cat(buf, buf_add_ui32(mute_until_));
		*flag1 |= (1 << 2);
	}
	//parse argument sound (NotificationSound)
	if (sound_)
	{
		buf = buf_cat(buf, *sound_);
		*flag1 |= (1 << 3);
	}
	//parse argument stories_muted (Bool)
	if (stories_muted_)
	{
		buf = buf_cat(buf, *stories_muted_);
		*flag1 |= (1 << 6);
	}
	//parse argument stories_hide_sender (Bool)
	if (stories_hide_sender_)
	{
		buf = buf_cat(buf, *stories_hide_sender_);
		*flag1 |= (1 << 7);
	}
	//parse argument stories_sound (NotificationSound)
	if (stories_sound_)
	{
		buf = buf_cat(buf, *stories_sound_);
		*flag1 |= (1 << 8);
	}
	return buf;
}

buf_t tl_peerNotifySettings(Bool *show_previews_, Bool *silent_, int mute_until_, NotificationSound *ios_sound_, NotificationSound *android_sound_, NotificationSound *other_sound_, Bool *stories_muted_, Bool *stories_hide_sender_, NotificationSound *stories_ios_sound_, NotificationSound *stories_android_sound_, NotificationSound *stories_other_sound_)
{
	buf_t buf = buf_add_ui32(0x99622c0c);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument show_previews (Bool)
	if (show_previews_)
	{
		buf = buf_cat(buf, *show_previews_);
		*flag1 |= (1 << 0);
	}
	//parse argument silent (Bool)
	if (silent_)
	{
		buf = buf_cat(buf, *silent_);
		*flag1 |= (1 << 1);
	}
	//parse argument mute_until (int)
	if (mute_until_)
	{
		buf = buf_cat(buf, buf_add_ui32(mute_until_));
		*flag1 |= (1 << 2);
	}
	//parse argument ios_sound (NotificationSound)
	if (ios_sound_)
	{
		buf = buf_cat(buf, *ios_sound_);
		*flag1 |= (1 << 3);
	}
	//parse argument android_sound (NotificationSound)
	if (android_sound_)
	{
		buf = buf_cat(buf, *android_sound_);
		*flag1 |= (1 << 4);
	}
	//parse argument other_sound (NotificationSound)
	if (other_sound_)
	{
		buf = buf_cat(buf, *other_sound_);
		*flag1 |= (1 << 5);
	}
	//parse argument stories_muted (Bool)
	if (stories_muted_)
	{
		buf = buf_cat(buf, *stories_muted_);
		*flag1 |= (1 << 6);
	}
	//parse argument stories_hide_sender (Bool)
	if (stories_hide_sender_)
	{
		buf = buf_cat(buf, *stories_hide_sender_);
		*flag1 |= (1 << 7);
	}
	//parse argument stories_ios_sound (NotificationSound)
	if (stories_ios_sound_)
	{
		buf = buf_cat(buf, *stories_ios_sound_);
		*flag1 |= (1 << 8);
	}
	//parse argument stories_android_sound (NotificationSound)
	if (stories_android_sound_)
	{
		buf = buf_cat(buf, *stories_android_sound_);
		*flag1 |= (1 << 9);
	}
	//parse argument stories_other_sound (NotificationSound)
	if (stories_other_sound_)
	{
		buf = buf_cat(buf, *stories_other_sound_);
		*flag1 |= (1 << 10);
	}
	return buf;
}

buf_t tl_peerSettings(bool report_spam_, bool add_contact_, bool block_contact_, bool share_contact_, bool need_contacts_exception_, bool report_geo_, bool autoarchived_, bool invite_members_, bool request_chat_broadcast_, bool business_bot_paused_, bool business_bot_can_reply_, int geo_distance_, const char * request_chat_title_, int request_chat_date_, long business_bot_id_, const char * business_bot_manage_url_)
{
	buf_t buf = buf_add_ui32(0xacd66c5e);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument report_spam (true)
	if (report_spam_)
		*flag1 |= (1 << 0);
	//parse argument add_contact (true)
	if (add_contact_)
		*flag1 |= (1 << 1);
	//parse argument block_contact (true)
	if (block_contact_)
		*flag1 |= (1 << 2);
	//parse argument share_contact (true)
	if (share_contact_)
		*flag1 |= (1 << 3);
	//parse argument need_contacts_exception (true)
	if (need_contacts_exception_)
		*flag1 |= (1 << 4);
	//parse argument report_geo (true)
	if (report_geo_)
		*flag1 |= (1 << 5);
	//parse argument autoarchived (true)
	if (autoarchived_)
		*flag1 |= (1 << 7);
	//parse argument invite_members (true)
	if (invite_members_)
		*flag1 |= (1 << 8);
	//parse argument request_chat_broadcast (true)
	if (request_chat_broadcast_)
		*flag1 |= (1 << 10);
	//parse argument business_bot_paused (true)
	if (business_bot_paused_)
		*flag1 |= (1 << 11);
	//parse argument business_bot_can_reply (true)
	if (business_bot_can_reply_)
		*flag1 |= (1 << 12);
	//parse argument geo_distance (int)
	if (geo_distance_)
	{
		buf = buf_cat(buf, buf_add_ui32(geo_distance_));
		*flag1 |= (1 << 6);
	}
	//parse argument request_chat_title (string)
	if (request_chat_title_)
	{
		buf = buf_cat(buf, serialize_string(request_chat_title_));
		*flag1 |= (1 << 9);
	}
	//parse argument request_chat_date (int)
	if (request_chat_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(request_chat_date_));
		*flag1 |= (1 << 9);
	}
	//parse argument business_bot_id (long)
	if (business_bot_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(business_bot_id_));
		*flag1 |= (1 << 13);
	}
	//parse argument business_bot_manage_url (string)
	if (business_bot_manage_url_)
	{
		buf = buf_cat(buf, serialize_string(business_bot_manage_url_));
		*flag1 |= (1 << 13);
	}
	return buf;
}

buf_t tl_wallPaper(long id_, bool creator_, bool default_, bool pattern_, bool dark_, long access_hash_, const char * slug_, Document *document_, WallPaperSettings *settings_)
{
	buf_t buf = buf_add_ui32(0xa437c3ed);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument creator (true)
	if (creator_)
		*flag1 |= (1 << 0);
	//parse argument default (true)
	if (default_)
		*flag1 |= (1 << 1);
	//parse argument pattern (true)
	if (pattern_)
		*flag1 |= (1 << 3);
	//parse argument dark (true)
	if (dark_)
		*flag1 |= (1 << 4);
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	//parse argument slug (string)
	{
		buf = buf_cat(buf, serialize_string(slug_));
	}
	//parse argument document (Document)
	{
		buf = buf_cat(buf, *document_);
	}
	//parse argument settings (WallPaperSettings)
	if (settings_)
	{
		buf = buf_cat(buf, *settings_);
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_wallPaperNoFile(long id_, bool default_, bool dark_, WallPaperSettings *settings_)
{
	buf_t buf = buf_add_ui32(0xe0804116);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument default (true)
	if (default_)
		*flag1 |= (1 << 1);
	//parse argument dark (true)
	if (dark_)
		*flag1 |= (1 << 4);
	//parse argument settings (WallPaperSettings)
	if (settings_)
	{
		buf = buf_cat(buf, *settings_);
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_inputReportReasonSpam()
{
	buf_t buf = buf_add_ui32(0x58dbcab8);
	return buf;
}

buf_t tl_inputReportReasonViolence()
{
	buf_t buf = buf_add_ui32(0x1e22c78d);
	return buf;
}

buf_t tl_inputReportReasonPornography()
{
	buf_t buf = buf_add_ui32(0x2e59d922);
	return buf;
}

buf_t tl_inputReportReasonChildAbuse()
{
	buf_t buf = buf_add_ui32(0xadf44ee3);
	return buf;
}

buf_t tl_inputReportReasonOther()
{
	buf_t buf = buf_add_ui32(0xc1e4a2b1);
	return buf;
}

buf_t tl_inputReportReasonCopyright()
{
	buf_t buf = buf_add_ui32(0x9b89f93a);
	return buf;
}

buf_t tl_inputReportReasonGeoIrrelevant()
{
	buf_t buf = buf_add_ui32(0xdbd4feed);
	return buf;
}

buf_t tl_inputReportReasonFake()
{
	buf_t buf = buf_add_ui32(0xf5ddd6e7);
	return buf;
}

buf_t tl_inputReportReasonIllegalDrugs()
{
	buf_t buf = buf_add_ui32(0x0a8eb2be);
	return buf;
}

buf_t tl_inputReportReasonPersonalDetails()
{
	buf_t buf = buf_add_ui32(0x9ec7863d);
	return buf;
}

buf_t tl_userFull(bool blocked_, bool phone_calls_available_, bool phone_calls_private_, bool can_pin_message_, bool has_scheduled_, bool video_calls_available_, bool voice_messages_forbidden_, bool translations_disabled_, bool stories_pinned_available_, bool blocked_my_stories_from_, bool wallpaper_overridden_, bool contact_require_premium_, bool read_dates_private_, bool sponsored_enabled_, long id_, const char * about_, PeerSettings *settings_, Photo *personal_photo_, Photo *profile_photo_, Photo *fallback_photo_, PeerNotifySettings *notify_settings_, BotInfo *bot_info_, int pinned_msg_id_, int common_chats_count_, int folder_id_, int ttl_period_, const char * theme_emoticon_, const char * private_forward_name_, ChatAdminRights *bot_group_admin_rights_, ChatAdminRights *bot_broadcast_admin_rights_, PremiumGiftOption *premium_gifts_, int premium_gifts_len, WallPaper *wallpaper_, PeerStories *stories_, BusinessWorkHours *business_work_hours_, BusinessLocation *business_location_, BusinessGreetingMessage *business_greeting_message_, BusinessAwayMessage *business_away_message_, BusinessIntro *business_intro_, Birthday *birthday_, long personal_channel_id_, int personal_channel_message_, int stargifts_count_)
{
	buf_t buf = buf_add_ui32(0x1f58e369);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument blocked (true)
	if (blocked_)
		*flag1 |= (1 << 0);
	//parse argument phone_calls_available (true)
	if (phone_calls_available_)
		*flag1 |= (1 << 4);
	//parse argument phone_calls_private (true)
	if (phone_calls_private_)
		*flag1 |= (1 << 5);
	//parse argument can_pin_message (true)
	if (can_pin_message_)
		*flag1 |= (1 << 7);
	//parse argument has_scheduled (true)
	if (has_scheduled_)
		*flag1 |= (1 << 12);
	//parse argument video_calls_available (true)
	if (video_calls_available_)
		*flag1 |= (1 << 13);
	//parse argument voice_messages_forbidden (true)
	if (voice_messages_forbidden_)
		*flag1 |= (1 << 20);
	//parse argument translations_disabled (true)
	if (translations_disabled_)
		*flag1 |= (1 << 23);
	//parse argument stories_pinned_available (true)
	if (stories_pinned_available_)
		*flag1 |= (1 << 26);
	//parse argument blocked_my_stories_from (true)
	if (blocked_my_stories_from_)
		*flag1 |= (1 << 27);
	//parse argument wallpaper_overridden (true)
	if (wallpaper_overridden_)
		*flag1 |= (1 << 28);
	//parse argument contact_require_premium (true)
	if (contact_require_premium_)
		*flag1 |= (1 << 29);
	//parse argument read_dates_private (true)
	if (read_dates_private_)
		*flag1 |= (1 << 30);
	//parse argument flags2 ((null))
	ui32_t *flag2 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument sponsored_enabled (true)
	if (sponsored_enabled_)
		*flag2 |= (1 << 7);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument about (string)
	if (about_)
	{
		buf = buf_cat(buf, serialize_string(about_));
		*flag1 |= (1 << 1);
	}
	//parse argument settings (PeerSettings)
	{
		buf = buf_cat(buf, *settings_);
	}
	//parse argument personal_photo (Photo)
	if (personal_photo_)
	{
		buf = buf_cat(buf, *personal_photo_);
		*flag1 |= (1 << 21);
	}
	//parse argument profile_photo (Photo)
	if (profile_photo_)
	{
		buf = buf_cat(buf, *profile_photo_);
		*flag1 |= (1 << 2);
	}
	//parse argument fallback_photo (Photo)
	if (fallback_photo_)
	{
		buf = buf_cat(buf, *fallback_photo_);
		*flag1 |= (1 << 22);
	}
	//parse argument notify_settings (PeerNotifySettings)
	{
		buf = buf_cat(buf, *notify_settings_);
	}
	//parse argument bot_info (BotInfo)
	if (bot_info_)
	{
		buf = buf_cat(buf, *bot_info_);
		*flag1 |= (1 << 3);
	}
	//parse argument pinned_msg_id (int)
	if (pinned_msg_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(pinned_msg_id_));
		*flag1 |= (1 << 6);
	}
	//parse argument common_chats_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(common_chats_count_));
	}
	//parse argument folder_id (int)
	if (folder_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(folder_id_));
		*flag1 |= (1 << 11);
	}
	//parse argument ttl_period (int)
	if (ttl_period_)
	{
		buf = buf_cat(buf, buf_add_ui32(ttl_period_));
		*flag1 |= (1 << 14);
	}
	//parse argument theme_emoticon (string)
	if (theme_emoticon_)
	{
		buf = buf_cat(buf, serialize_string(theme_emoticon_));
		*flag1 |= (1 << 15);
	}
	//parse argument private_forward_name (string)
	if (private_forward_name_)
	{
		buf = buf_cat(buf, serialize_string(private_forward_name_));
		*flag1 |= (1 << 16);
	}
	//parse argument bot_group_admin_rights (ChatAdminRights)
	if (bot_group_admin_rights_)
	{
		buf = buf_cat(buf, *bot_group_admin_rights_);
		*flag1 |= (1 << 17);
	}
	//parse argument bot_broadcast_admin_rights (ChatAdminRights)
	if (bot_broadcast_admin_rights_)
	{
		buf = buf_cat(buf, *bot_broadcast_admin_rights_);
		*flag1 |= (1 << 18);
	}
	//parse argument premium_gifts (Vector<PremiumGiftOption>)
	if (premium_gifts_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(premium_gifts_len));
		int i;
		for (i=0; i<premium_gifts_len; ++i){
			buf = buf_cat(buf, premium_gifts_[i]);
		}
		*flag1 |= (1 << 19);
	}
	//parse argument wallpaper (WallPaper)
	if (wallpaper_)
	{
		buf = buf_cat(buf, *wallpaper_);
		*flag1 |= (1 << 24);
	}
	//parse argument stories (PeerStories)
	if (stories_)
	{
		buf = buf_cat(buf, *stories_);
		*flag1 |= (1 << 25);
	}
	//parse argument business_work_hours (BusinessWorkHours)
	if (business_work_hours_)
	{
		buf = buf_cat(buf, *business_work_hours_);
		*flag2 |= (1 << 0);
	}
	//parse argument business_location (BusinessLocation)
	if (business_location_)
	{
		buf = buf_cat(buf, *business_location_);
		*flag2 |= (1 << 1);
	}
	//parse argument business_greeting_message (BusinessGreetingMessage)
	if (business_greeting_message_)
	{
		buf = buf_cat(buf, *business_greeting_message_);
		*flag2 |= (1 << 2);
	}
	//parse argument business_away_message (BusinessAwayMessage)
	if (business_away_message_)
	{
		buf = buf_cat(buf, *business_away_message_);
		*flag2 |= (1 << 3);
	}
	//parse argument business_intro (BusinessIntro)
	if (business_intro_)
	{
		buf = buf_cat(buf, *business_intro_);
		*flag2 |= (1 << 4);
	}
	//parse argument birthday (Birthday)
	if (birthday_)
	{
		buf = buf_cat(buf, *birthday_);
		*flag2 |= (1 << 5);
	}
	//parse argument personal_channel_id (long)
	if (personal_channel_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(personal_channel_id_));
		*flag2 |= (1 << 6);
	}
	//parse argument personal_channel_message (int)
	if (personal_channel_message_)
	{
		buf = buf_cat(buf, buf_add_ui32(personal_channel_message_));
		*flag2 |= (1 << 6);
	}
	//parse argument stargifts_count (int)
	if (stargifts_count_)
	{
		buf = buf_cat(buf, buf_add_ui32(stargifts_count_));
		*flag2 |= (1 << 8);
	}
	return buf;
}

buf_t tl_contact(long user_id_, Bool *mutual_)
{
	buf_t buf = buf_add_ui32(0x145ade0b);
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument mutual (Bool)
	{
		buf = buf_cat(buf, *mutual_);
	}
	return buf;
}

buf_t tl_importedContact(long user_id_, long client_id_)
{
	buf_t buf = buf_add_ui32(0xc13e3c50);
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument client_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(client_id_));
	}
	return buf;
}

buf_t tl_contactStatus(long user_id_, UserStatus *status_)
{
	buf_t buf = buf_add_ui32(0x16d9703b);
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument status (UserStatus)
	{
		buf = buf_cat(buf, *status_);
	}
	return buf;
}

buf_t tl_contacts_contactsNotModified()
{
	buf_t buf = buf_add_ui32(0xb74ba9d2);
	return buf;
}

buf_t tl_contacts_contacts(Contact *contacts_, int contacts_len, int saved_count_, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0xeae87e42);
	//parse argument contacts (Vector<Contact>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(contacts_len));
		int i;
		for (i=0; i<contacts_len; ++i){
			buf = buf_cat(buf, contacts_[i]);
		}
	}
	//parse argument saved_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(saved_count_));
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_contacts_importedContacts(ImportedContact *imported_, int imported_len, PopularContact *popular_invites_, int popular_invites_len, long *retry_contacts_, int retry_contacts_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x77d01c3b);
	//parse argument imported (Vector<ImportedContact>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(imported_len));
		int i;
		for (i=0; i<imported_len; ++i){
			buf = buf_cat(buf, imported_[i]);
		}
	}
	//parse argument popular_invites (Vector<PopularContact>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(popular_invites_len));
		int i;
		for (i=0; i<popular_invites_len; ++i){
			buf = buf_cat(buf, popular_invites_[i]);
		}
	}
	//parse argument retry_contacts (Vector<long>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(retry_contacts_len));
		int i;
		for (i=0; i<retry_contacts_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(retry_contacts_[i]));
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_contacts_blocked(PeerBlocked *blocked_, int blocked_len, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x0ade1591);
	//parse argument blocked (Vector<PeerBlocked>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(blocked_len));
		int i;
		for (i=0; i<blocked_len; ++i){
			buf = buf_cat(buf, blocked_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_contacts_blockedSlice(int count_, PeerBlocked *blocked_, int blocked_len, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0xe1664194);
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	//parse argument blocked (Vector<PeerBlocked>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(blocked_len));
		int i;
		for (i=0; i<blocked_len; ++i){
			buf = buf_cat(buf, blocked_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_messages_dialogs(Dialog *dialogs_, int dialogs_len, Message *messages_, int messages_len, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x15ba6c40);
	//parse argument dialogs (Vector<Dialog>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(dialogs_len));
		int i;
		for (i=0; i<dialogs_len; ++i){
			buf = buf_cat(buf, dialogs_[i]);
		}
	}
	//parse argument messages (Vector<Message>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(messages_len));
		int i;
		for (i=0; i<messages_len; ++i){
			buf = buf_cat(buf, messages_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_messages_dialogsSlice(int count_, Dialog *dialogs_, int dialogs_len, Message *messages_, int messages_len, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x71e094f3);
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	//parse argument dialogs (Vector<Dialog>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(dialogs_len));
		int i;
		for (i=0; i<dialogs_len; ++i){
			buf = buf_cat(buf, dialogs_[i]);
		}
	}
	//parse argument messages (Vector<Message>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(messages_len));
		int i;
		for (i=0; i<messages_len; ++i){
			buf = buf_cat(buf, messages_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_messages_dialogsNotModified(int count_)
{
	buf_t buf = buf_add_ui32(0xf0e3e596);
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	return buf;
}

buf_t tl_messages_messages(Message *messages_, int messages_len, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x8c718e87);
	//parse argument messages (Vector<Message>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(messages_len));
		int i;
		for (i=0; i<messages_len; ++i){
			buf = buf_cat(buf, messages_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_messages_messagesSlice(bool inexact_, int count_, int next_rate_, int offset_id_offset_, Message *messages_, int messages_len, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x3a54685e);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument inexact (true)
	if (inexact_)
		*flag1 |= (1 << 1);
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	//parse argument next_rate (int)
	if (next_rate_)
	{
		buf = buf_cat(buf, buf_add_ui32(next_rate_));
		*flag1 |= (1 << 0);
	}
	//parse argument offset_id_offset (int)
	if (offset_id_offset_)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_id_offset_));
		*flag1 |= (1 << 2);
	}
	//parse argument messages (Vector<Message>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(messages_len));
		int i;
		for (i=0; i<messages_len; ++i){
			buf = buf_cat(buf, messages_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_messages_channelMessages(bool inexact_, int pts_, int count_, int offset_id_offset_, Message *messages_, int messages_len, ForumTopic *topics_, int topics_len, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0xc776ba4e);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument inexact (true)
	if (inexact_)
		*flag1 |= (1 << 1);
	//parse argument pts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_));
	}
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	//parse argument offset_id_offset (int)
	if (offset_id_offset_)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_id_offset_));
		*flag1 |= (1 << 2);
	}
	//parse argument messages (Vector<Message>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(messages_len));
		int i;
		for (i=0; i<messages_len; ++i){
			buf = buf_cat(buf, messages_[i]);
		}
	}
	//parse argument topics (Vector<ForumTopic>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(topics_len));
		int i;
		for (i=0; i<topics_len; ++i){
			buf = buf_cat(buf, topics_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_messages_messagesNotModified(int count_)
{
	buf_t buf = buf_add_ui32(0x74535f21);
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	return buf;
}

buf_t tl_messages_chats(Chat *chats_, int chats_len)
{
	buf_t buf = buf_add_ui32(0x64ff9fd5);
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	return buf;
}

buf_t tl_messages_chatsSlice(int count_, Chat *chats_, int chats_len)
{
	buf_t buf = buf_add_ui32(0x9cd81144);
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	return buf;
}

buf_t tl_messages_chatFull(ChatFull *full_chat_, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0xe5d7d19c);
	//parse argument full_chat (ChatFull)
	{
		buf = buf_cat(buf, *full_chat_);
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_messages_affectedHistory(int pts_, int pts_count_, int offset_)
{
	buf_t buf = buf_add_ui32(0xb45c69d1);
	//parse argument pts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_));
	}
	//parse argument pts_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_count_));
	}
	//parse argument offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_));
	}
	return buf;
}

buf_t tl_inputMessagesFilterEmpty()
{
	buf_t buf = buf_add_ui32(0x57e2f66c);
	return buf;
}

buf_t tl_inputMessagesFilterPhotos()
{
	buf_t buf = buf_add_ui32(0x9609a51c);
	return buf;
}

buf_t tl_inputMessagesFilterVideo()
{
	buf_t buf = buf_add_ui32(0x9fc00e65);
	return buf;
}

buf_t tl_inputMessagesFilterPhotoVideo()
{
	buf_t buf = buf_add_ui32(0x56e9f0e4);
	return buf;
}

buf_t tl_inputMessagesFilterDocument()
{
	buf_t buf = buf_add_ui32(0x9eddf188);
	return buf;
}

buf_t tl_inputMessagesFilterUrl()
{
	buf_t buf = buf_add_ui32(0x7ef0dd87);
	return buf;
}

buf_t tl_inputMessagesFilterGif()
{
	buf_t buf = buf_add_ui32(0xffc86587);
	return buf;
}

buf_t tl_inputMessagesFilterVoice()
{
	buf_t buf = buf_add_ui32(0x50f5c392);
	return buf;
}

buf_t tl_inputMessagesFilterMusic()
{
	buf_t buf = buf_add_ui32(0x3751b49e);
	return buf;
}

buf_t tl_inputMessagesFilterChatPhotos()
{
	buf_t buf = buf_add_ui32(0x3a20ecb8);
	return buf;
}

buf_t tl_inputMessagesFilterPhoneCalls(bool missed_)
{
	buf_t buf = buf_add_ui32(0x80c99768);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument missed (true)
	if (missed_)
		*flag1 |= (1 << 0);
	return buf;
}

buf_t tl_inputMessagesFilterRoundVoice()
{
	buf_t buf = buf_add_ui32(0x7a7c17a4);
	return buf;
}

buf_t tl_inputMessagesFilterRoundVideo()
{
	buf_t buf = buf_add_ui32(0xb549da53);
	return buf;
}

buf_t tl_inputMessagesFilterMyMentions()
{
	buf_t buf = buf_add_ui32(0xc1f8e69a);
	return buf;
}

buf_t tl_inputMessagesFilterGeo()
{
	buf_t buf = buf_add_ui32(0xe7026d0d);
	return buf;
}

buf_t tl_inputMessagesFilterContacts()
{
	buf_t buf = buf_add_ui32(0xe062db83);
	return buf;
}

buf_t tl_inputMessagesFilterPinned()
{
	buf_t buf = buf_add_ui32(0x1bb00451);
	return buf;
}

buf_t tl_updateNewMessage(Message *message_, int pts_, int pts_count_)
{
	buf_t buf = buf_add_ui32(0x1f2b0afd);
	//parse argument message (Message)
	{
		buf = buf_cat(buf, *message_);
	}
	//parse argument pts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_));
	}
	//parse argument pts_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_count_));
	}
	return buf;
}

buf_t tl_updateMessageID(int id_, long random_id_)
{
	buf_t buf = buf_add_ui32(0x4e90bfd6);
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument random_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(random_id_));
	}
	return buf;
}

buf_t tl_updateDeleteMessages(int *messages_, int messages_len, int pts_, int pts_count_)
{
	buf_t buf = buf_add_ui32(0xa20db0e5);
	//parse argument messages (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(messages_len));
		int i;
		for (i=0; i<messages_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(messages_[i]));
		}
	}
	//parse argument pts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_));
	}
	//parse argument pts_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_count_));
	}
	return buf;
}

buf_t tl_updateUserTyping(long user_id_, SendMessageAction *action_)
{
	buf_t buf = buf_add_ui32(0xc01e857f);
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument action (SendMessageAction)
	{
		buf = buf_cat(buf, *action_);
	}
	return buf;
}

buf_t tl_updateChatUserTyping(long chat_id_, Peer *from_id_, SendMessageAction *action_)
{
	buf_t buf = buf_add_ui32(0x83487af0);
	//parse argument chat_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(chat_id_));
	}
	//parse argument from_id (Peer)
	{
		buf = buf_cat(buf, *from_id_);
	}
	//parse argument action (SendMessageAction)
	{
		buf = buf_cat(buf, *action_);
	}
	return buf;
}

buf_t tl_updateChatParticipants(ChatParticipants *participants_)
{
	buf_t buf = buf_add_ui32(0x07761198);
	//parse argument participants (ChatParticipants)
	{
		buf = buf_cat(buf, *participants_);
	}
	return buf;
}

buf_t tl_updateUserStatus(long user_id_, UserStatus *status_)
{
	buf_t buf = buf_add_ui32(0xe5bdf8de);
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument status (UserStatus)
	{
		buf = buf_cat(buf, *status_);
	}
	return buf;
}

buf_t tl_updateUserName(long user_id_, const char * first_name_, const char * last_name_, Username *usernames_, int usernames_len)
{
	buf_t buf = buf_add_ui32(0xa7848924);
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument first_name (string)
	{
		buf = buf_cat(buf, serialize_string(first_name_));
	}
	//parse argument last_name (string)
	{
		buf = buf_cat(buf, serialize_string(last_name_));
	}
	//parse argument usernames (Vector<Username>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(usernames_len));
		int i;
		for (i=0; i<usernames_len; ++i){
			buf = buf_cat(buf, usernames_[i]);
		}
	}
	return buf;
}

buf_t tl_updateNewAuthorization(bool unconfirmed_, long hash_, int date_, const char * device_, const char * location_)
{
	buf_t buf = buf_add_ui32(0x8951abef);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument unconfirmed (true)
	if (unconfirmed_)
		*flag1 |= (1 << 0);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	//parse argument date (int)
	if (date_)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
		*flag1 |= (1 << 0);
	}
	//parse argument device (string)
	if (device_)
	{
		buf = buf_cat(buf, serialize_string(device_));
		*flag1 |= (1 << 0);
	}
	//parse argument location (string)
	if (location_)
	{
		buf = buf_cat(buf, serialize_string(location_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_updateNewEncryptedMessage(EncryptedMessage *message_, int qts_)
{
	buf_t buf = buf_add_ui32(0x12bcbd9a);
	//parse argument message (EncryptedMessage)
	{
		buf = buf_cat(buf, *message_);
	}
	//parse argument qts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(qts_));
	}
	return buf;
}

buf_t tl_updateEncryptedChatTyping(int chat_id_)
{
	buf_t buf = buf_add_ui32(0x1710f156);
	//parse argument chat_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(chat_id_));
	}
	return buf;
}

buf_t tl_updateEncryption(EncryptedChat *chat_, int date_)
{
	buf_t buf = buf_add_ui32(0xb4a2e88d);
	//parse argument chat (EncryptedChat)
	{
		buf = buf_cat(buf, *chat_);
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	return buf;
}

buf_t tl_updateEncryptedMessagesRead(int chat_id_, int max_date_, int date_)
{
	buf_t buf = buf_add_ui32(0x38fe25b7);
	//parse argument chat_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(chat_id_));
	}
	//parse argument max_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(max_date_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	return buf;
}

buf_t tl_updateChatParticipantAdd(long chat_id_, long user_id_, long inviter_id_, int date_, int version_)
{
	buf_t buf = buf_add_ui32(0x3dda5451);
	//parse argument chat_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(chat_id_));
	}
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument inviter_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(inviter_id_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument version (int)
	{
		buf = buf_cat(buf, buf_add_ui32(version_));
	}
	return buf;
}

buf_t tl_updateChatParticipantDelete(long chat_id_, long user_id_, int version_)
{
	buf_t buf = buf_add_ui32(0xe32f3d77);
	//parse argument chat_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(chat_id_));
	}
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument version (int)
	{
		buf = buf_cat(buf, buf_add_ui32(version_));
	}
	return buf;
}

buf_t tl_updateDcOptions(DcOption *dc_options_, int dc_options_len)
{
	buf_t buf = buf_add_ui32(0x8e5e9873);
	//parse argument dc_options (Vector<DcOption>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(dc_options_len));
		int i;
		for (i=0; i<dc_options_len; ++i){
			buf = buf_cat(buf, dc_options_[i]);
		}
	}
	return buf;
}

buf_t tl_updateNotifySettings(NotifyPeer *peer_, PeerNotifySettings *notify_settings_)
{
	buf_t buf = buf_add_ui32(0xbec268ef);
	//parse argument peer (NotifyPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument notify_settings (PeerNotifySettings)
	{
		buf = buf_cat(buf, *notify_settings_);
	}
	return buf;
}

buf_t tl_updateServiceNotification(bool popup_, bool invert_media_, int inbox_date_, const char * type_, const char * message_, MessageMedia *media_, MessageEntity *entities_, int entities_len)
{
	buf_t buf = buf_add_ui32(0xebe46819);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument popup (true)
	if (popup_)
		*flag1 |= (1 << 0);
	//parse argument invert_media (true)
	if (invert_media_)
		*flag1 |= (1 << 2);
	//parse argument inbox_date (int)
	if (inbox_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(inbox_date_));
		*flag1 |= (1 << 1);
	}
	//parse argument type (string)
	{
		buf = buf_cat(buf, serialize_string(type_));
	}
	//parse argument message (string)
	{
		buf = buf_cat(buf, serialize_string(message_));
	}
	//parse argument media (MessageMedia)
	{
		buf = buf_cat(buf, *media_);
	}
	//parse argument entities (Vector<MessageEntity>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(entities_len));
		int i;
		for (i=0; i<entities_len; ++i){
			buf = buf_cat(buf, entities_[i]);
		}
	}
	return buf;
}

buf_t tl_updatePrivacy(PrivacyKey *key_, PrivacyRule *rules_, int rules_len)
{
	buf_t buf = buf_add_ui32(0xee3b272a);
	//parse argument key (PrivacyKey)
	{
		buf = buf_cat(buf, *key_);
	}
	//parse argument rules (Vector<PrivacyRule>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(rules_len));
		int i;
		for (i=0; i<rules_len; ++i){
			buf = buf_cat(buf, rules_[i]);
		}
	}
	return buf;
}

buf_t tl_updateUserPhone(long user_id_, const char * phone_)
{
	buf_t buf = buf_add_ui32(0x05492a13);
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument phone (string)
	{
		buf = buf_cat(buf, serialize_string(phone_));
	}
	return buf;
}

buf_t tl_updateReadHistoryInbox(int folder_id_, Peer *peer_, int max_id_, int still_unread_count_, int pts_, int pts_count_)
{
	buf_t buf = buf_add_ui32(0x9c974fdf);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument folder_id (int)
	if (folder_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(folder_id_));
		*flag1 |= (1 << 0);
	}
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument max_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(max_id_));
	}
	//parse argument still_unread_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(still_unread_count_));
	}
	//parse argument pts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_));
	}
	//parse argument pts_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_count_));
	}
	return buf;
}

buf_t tl_updateReadHistoryOutbox(Peer *peer_, int max_id_, int pts_, int pts_count_)
{
	buf_t buf = buf_add_ui32(0x2f2f21bf);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument max_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(max_id_));
	}
	//parse argument pts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_));
	}
	//parse argument pts_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_count_));
	}
	return buf;
}

buf_t tl_updateWebPage(WebPage *webpage_, int pts_, int pts_count_)
{
	buf_t buf = buf_add_ui32(0x7f891213);
	//parse argument webpage (WebPage)
	{
		buf = buf_cat(buf, *webpage_);
	}
	//parse argument pts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_));
	}
	//parse argument pts_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_count_));
	}
	return buf;
}

buf_t tl_updateReadMessagesContents(int *messages_, int messages_len, int pts_, int pts_count_, int date_)
{
	buf_t buf = buf_add_ui32(0xf8227181);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument messages (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(messages_len));
		int i;
		for (i=0; i<messages_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(messages_[i]));
		}
	}
	//parse argument pts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_));
	}
	//parse argument pts_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_count_));
	}
	//parse argument date (int)
	if (date_)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_updateChannelTooLong(long channel_id_, int pts_)
{
	buf_t buf = buf_add_ui32(0x108d941f);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument channel_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(channel_id_));
	}
	//parse argument pts (int)
	if (pts_)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_updateChannel(long channel_id_)
{
	buf_t buf = buf_add_ui32(0x635b4c09);
	//parse argument channel_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(channel_id_));
	}
	return buf;
}

buf_t tl_updateNewChannelMessage(Message *message_, int pts_, int pts_count_)
{
	buf_t buf = buf_add_ui32(0x62ba04d9);
	//parse argument message (Message)
	{
		buf = buf_cat(buf, *message_);
	}
	//parse argument pts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_));
	}
	//parse argument pts_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_count_));
	}
	return buf;
}

buf_t tl_updateReadChannelInbox(int folder_id_, long channel_id_, int max_id_, int still_unread_count_, int pts_)
{
	buf_t buf = buf_add_ui32(0x922e6e10);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument folder_id (int)
	if (folder_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(folder_id_));
		*flag1 |= (1 << 0);
	}
	//parse argument channel_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(channel_id_));
	}
	//parse argument max_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(max_id_));
	}
	//parse argument still_unread_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(still_unread_count_));
	}
	//parse argument pts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_));
	}
	return buf;
}

buf_t tl_updateDeleteChannelMessages(long channel_id_, int *messages_, int messages_len, int pts_, int pts_count_)
{
	buf_t buf = buf_add_ui32(0xc32d5b12);
	//parse argument channel_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(channel_id_));
	}
	//parse argument messages (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(messages_len));
		int i;
		for (i=0; i<messages_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(messages_[i]));
		}
	}
	//parse argument pts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_));
	}
	//parse argument pts_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_count_));
	}
	return buf;
}

buf_t tl_updateChannelMessageViews(long channel_id_, int id_, int views_)
{
	buf_t buf = buf_add_ui32(0xf226ac08);
	//parse argument channel_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(channel_id_));
	}
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument views (int)
	{
		buf = buf_cat(buf, buf_add_ui32(views_));
	}
	return buf;
}

buf_t tl_updateChatParticipantAdmin(long chat_id_, long user_id_, Bool *is_admin_, int version_)
{
	buf_t buf = buf_add_ui32(0xd7ca61a2);
	//parse argument chat_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(chat_id_));
	}
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument is_admin (Bool)
	{
		buf = buf_cat(buf, *is_admin_);
	}
	//parse argument version (int)
	{
		buf = buf_cat(buf, buf_add_ui32(version_));
	}
	return buf;
}

buf_t tl_updateNewStickerSet(messages_StickerSet *stickerset_)
{
	buf_t buf = buf_add_ui32(0x688a30aa);
	//parse argument stickerset (messages_StickerSet)
	{
		buf = buf_cat(buf, *stickerset_);
	}
	return buf;
}

buf_t tl_updateStickerSetsOrder(bool masks_, bool emojis_, long *order_, int order_len)
{
	buf_t buf = buf_add_ui32(0x0bb2d201);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument masks (true)
	if (masks_)
		*flag1 |= (1 << 0);
	//parse argument emojis (true)
	if (emojis_)
		*flag1 |= (1 << 1);
	//parse argument order (Vector<long>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(order_len));
		int i;
		for (i=0; i<order_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(order_[i]));
		}
	}
	return buf;
}

buf_t tl_updateStickerSets(bool masks_, bool emojis_)
{
	buf_t buf = buf_add_ui32(0x31c24808);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument masks (true)
	if (masks_)
		*flag1 |= (1 << 0);
	//parse argument emojis (true)
	if (emojis_)
		*flag1 |= (1 << 1);
	return buf;
}

buf_t tl_updateSavedGifs()
{
	buf_t buf = buf_add_ui32(0x9375341e);
	return buf;
}

buf_t tl_updateBotInlineQuery(long query_id_, long user_id_, const char * query_, GeoPoint *geo_, InlineQueryPeerType *peer_type_, const char * offset_)
{
	buf_t buf = buf_add_ui32(0x496f379c);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument query_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(query_id_));
	}
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument query (string)
	{
		buf = buf_cat(buf, serialize_string(query_));
	}
	//parse argument geo (GeoPoint)
	if (geo_)
	{
		buf = buf_cat(buf, *geo_);
		*flag1 |= (1 << 0);
	}
	//parse argument peer_type (InlineQueryPeerType)
	if (peer_type_)
	{
		buf = buf_cat(buf, *peer_type_);
		*flag1 |= (1 << 1);
	}
	//parse argument offset (string)
	{
		buf = buf_cat(buf, serialize_string(offset_));
	}
	return buf;
}

buf_t tl_updateBotInlineSend(long user_id_, const char * query_, GeoPoint *geo_, const char * id_, InputBotInlineMessageID *msg_id_)
{
	buf_t buf = buf_add_ui32(0x12f12a07);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument query (string)
	{
		buf = buf_cat(buf, serialize_string(query_));
	}
	//parse argument geo (GeoPoint)
	if (geo_)
	{
		buf = buf_cat(buf, *geo_);
		*flag1 |= (1 << 0);
	}
	//parse argument id (string)
	{
		buf = buf_cat(buf, serialize_string(id_));
	}
	//parse argument msg_id (InputBotInlineMessageID)
	if (msg_id_)
	{
		buf = buf_cat(buf, *msg_id_);
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_updateEditChannelMessage(Message *message_, int pts_, int pts_count_)
{
	buf_t buf = buf_add_ui32(0x1b3f4df7);
	//parse argument message (Message)
	{
		buf = buf_cat(buf, *message_);
	}
	//parse argument pts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_));
	}
	//parse argument pts_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_count_));
	}
	return buf;
}

buf_t tl_updateBotCallbackQuery(long query_id_, long user_id_, Peer *peer_, int msg_id_, long chat_instance_, buf_t *data_, const char * game_short_name_)
{
	buf_t buf = buf_add_ui32(0xb9cfc48d);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument query_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(query_id_));
	}
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	//parse argument chat_instance (long)
	{
		buf = buf_cat(buf, buf_add_ui64(chat_instance_));
	}
	//parse argument data (bytes)
	if (data_)
	{
		buf = buf_cat(buf, serialize_bytes(data_->data, data_->size));
		*flag1 |= (1 << 0);
	}
	//parse argument game_short_name (string)
	if (game_short_name_)
	{
		buf = buf_cat(buf, serialize_string(game_short_name_));
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_updateEditMessage(Message *message_, int pts_, int pts_count_)
{
	buf_t buf = buf_add_ui32(0xe40370a3);
	//parse argument message (Message)
	{
		buf = buf_cat(buf, *message_);
	}
	//parse argument pts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_));
	}
	//parse argument pts_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_count_));
	}
	return buf;
}

buf_t tl_updateInlineBotCallbackQuery(long query_id_, long user_id_, InputBotInlineMessageID *msg_id_, long chat_instance_, buf_t *data_, const char * game_short_name_)
{
	buf_t buf = buf_add_ui32(0x691e9052);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument query_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(query_id_));
	}
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument msg_id (InputBotInlineMessageID)
	{
		buf = buf_cat(buf, *msg_id_);
	}
	//parse argument chat_instance (long)
	{
		buf = buf_cat(buf, buf_add_ui64(chat_instance_));
	}
	//parse argument data (bytes)
	if (data_)
	{
		buf = buf_cat(buf, serialize_bytes(data_->data, data_->size));
		*flag1 |= (1 << 0);
	}
	//parse argument game_short_name (string)
	if (game_short_name_)
	{
		buf = buf_cat(buf, serialize_string(game_short_name_));
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_updateReadChannelOutbox(long channel_id_, int max_id_)
{
	buf_t buf = buf_add_ui32(0xb75f99a9);
	//parse argument channel_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(channel_id_));
	}
	//parse argument max_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(max_id_));
	}
	return buf;
}

buf_t tl_updateDraftMessage(Peer *peer_, int top_msg_id_, DraftMessage *draft_)
{
	buf_t buf = buf_add_ui32(0x1b49ec6d);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument top_msg_id (int)
	if (top_msg_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(top_msg_id_));
		*flag1 |= (1 << 0);
	}
	//parse argument draft (DraftMessage)
	{
		buf = buf_cat(buf, *draft_);
	}
	return buf;
}

buf_t tl_updateReadFeaturedStickers()
{
	buf_t buf = buf_add_ui32(0x571d2742);
	return buf;
}

buf_t tl_updateRecentStickers()
{
	buf_t buf = buf_add_ui32(0x9a422c20);
	return buf;
}

buf_t tl_updateConfig()
{
	buf_t buf = buf_add_ui32(0xa229dd06);
	return buf;
}

buf_t tl_updatePtsChanged()
{
	buf_t buf = buf_add_ui32(0x3354678f);
	return buf;
}

buf_t tl_updateChannelWebPage(long channel_id_, WebPage *webpage_, int pts_, int pts_count_)
{
	buf_t buf = buf_add_ui32(0x2f2ba99f);
	//parse argument channel_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(channel_id_));
	}
	//parse argument webpage (WebPage)
	{
		buf = buf_cat(buf, *webpage_);
	}
	//parse argument pts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_));
	}
	//parse argument pts_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_count_));
	}
	return buf;
}

buf_t tl_updateDialogPinned(bool pinned_, int folder_id_, DialogPeer *peer_)
{
	buf_t buf = buf_add_ui32(0x6e6fe51c);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument pinned (true)
	if (pinned_)
		*flag1 |= (1 << 0);
	//parse argument folder_id (int)
	if (folder_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(folder_id_));
		*flag1 |= (1 << 1);
	}
	//parse argument peer (DialogPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_updatePinnedDialogs(int folder_id_, DialogPeer *order_, int order_len)
{
	buf_t buf = buf_add_ui32(0xfa0f3ca2);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument folder_id (int)
	if (folder_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(folder_id_));
		*flag1 |= (1 << 1);
	}
	//parse argument order (Vector<DialogPeer>)
	if (order_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(order_len));
		int i;
		for (i=0; i<order_len; ++i){
			buf = buf_cat(buf, order_[i]);
		}
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_updateBotWebhookJSON(DataJSON *data_)
{
	buf_t buf = buf_add_ui32(0x8317c0c3);
	//parse argument data (DataJSON)
	{
		buf = buf_cat(buf, *data_);
	}
	return buf;
}

buf_t tl_updateBotWebhookJSONQuery(long query_id_, DataJSON *data_, int timeout_)
{
	buf_t buf = buf_add_ui32(0x9b9240a6);
	//parse argument query_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(query_id_));
	}
	//parse argument data (DataJSON)
	{
		buf = buf_cat(buf, *data_);
	}
	//parse argument timeout (int)
	{
		buf = buf_cat(buf, buf_add_ui32(timeout_));
	}
	return buf;
}

buf_t tl_updateBotShippingQuery(long query_id_, long user_id_, buf_t *payload_, PostAddress *shipping_address_)
{
	buf_t buf = buf_add_ui32(0xb5aefd7d);
	//parse argument query_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(query_id_));
	}
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument payload (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(payload_->data, payload_->size));
	}
	//parse argument shipping_address (PostAddress)
	{
		buf = buf_cat(buf, *shipping_address_);
	}
	return buf;
}

buf_t tl_updateBotPrecheckoutQuery(long query_id_, long user_id_, buf_t *payload_, PaymentRequestedInfo *info_, const char * shipping_option_id_, const char * currency_, long total_amount_)
{
	buf_t buf = buf_add_ui32(0x8caa9a96);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument query_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(query_id_));
	}
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument payload (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(payload_->data, payload_->size));
	}
	//parse argument info (PaymentRequestedInfo)
	if (info_)
	{
		buf = buf_cat(buf, *info_);
		*flag1 |= (1 << 0);
	}
	//parse argument shipping_option_id (string)
	if (shipping_option_id_)
	{
		buf = buf_cat(buf, serialize_string(shipping_option_id_));
		*flag1 |= (1 << 1);
	}
	//parse argument currency (string)
	{
		buf = buf_cat(buf, serialize_string(currency_));
	}
	//parse argument total_amount (long)
	{
		buf = buf_cat(buf, buf_add_ui64(total_amount_));
	}
	return buf;
}

buf_t tl_updatePhoneCall(PhoneCall *phone_call_)
{
	buf_t buf = buf_add_ui32(0xab0f6b1e);
	//parse argument phone_call (PhoneCall)
	{
		buf = buf_cat(buf, *phone_call_);
	}
	return buf;
}

buf_t tl_updateLangPackTooLong(const char * lang_code_)
{
	buf_t buf = buf_add_ui32(0x46560264);
	//parse argument lang_code (string)
	{
		buf = buf_cat(buf, serialize_string(lang_code_));
	}
	return buf;
}

buf_t tl_updateLangPack(LangPackDifference *difference_)
{
	buf_t buf = buf_add_ui32(0x56022f4d);
	//parse argument difference (LangPackDifference)
	{
		buf = buf_cat(buf, *difference_);
	}
	return buf;
}

buf_t tl_updateFavedStickers()
{
	buf_t buf = buf_add_ui32(0xe511996d);
	return buf;
}

buf_t tl_updateChannelReadMessagesContents(long channel_id_, int top_msg_id_, int *messages_, int messages_len)
{
	buf_t buf = buf_add_ui32(0xea29055d);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument channel_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(channel_id_));
	}
	//parse argument top_msg_id (int)
	if (top_msg_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(top_msg_id_));
		*flag1 |= (1 << 0);
	}
	//parse argument messages (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(messages_len));
		int i;
		for (i=0; i<messages_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(messages_[i]));
		}
	}
	return buf;
}

buf_t tl_updateContactsReset()
{
	buf_t buf = buf_add_ui32(0x7084a7be);
	return buf;
}

buf_t tl_updateChannelAvailableMessages(long channel_id_, int available_min_id_)
{
	buf_t buf = buf_add_ui32(0xb23fc698);
	//parse argument channel_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(channel_id_));
	}
	//parse argument available_min_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(available_min_id_));
	}
	return buf;
}

buf_t tl_updateDialogUnreadMark(bool unread_, DialogPeer *peer_)
{
	buf_t buf = buf_add_ui32(0xe16459c3);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument unread (true)
	if (unread_)
		*flag1 |= (1 << 0);
	//parse argument peer (DialogPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_updateMessagePoll(long poll_id_, Poll *poll_, PollResults *results_)
{
	buf_t buf = buf_add_ui32(0xaca1657b);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument poll_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(poll_id_));
	}
	//parse argument poll (Poll)
	if (poll_)
	{
		buf = buf_cat(buf, *poll_);
		*flag1 |= (1 << 0);
	}
	//parse argument results (PollResults)
	{
		buf = buf_cat(buf, *results_);
	}
	return buf;
}

buf_t tl_updateChatDefaultBannedRights(Peer *peer_, ChatBannedRights *default_banned_rights_, int version_)
{
	buf_t buf = buf_add_ui32(0x54c01850);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument default_banned_rights (ChatBannedRights)
	{
		buf = buf_cat(buf, *default_banned_rights_);
	}
	//parse argument version (int)
	{
		buf = buf_cat(buf, buf_add_ui32(version_));
	}
	return buf;
}

buf_t tl_updateFolderPeers(FolderPeer *folder_peers_, int folder_peers_len, int pts_, int pts_count_)
{
	buf_t buf = buf_add_ui32(0x19360dc0);
	//parse argument folder_peers (Vector<FolderPeer>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(folder_peers_len));
		int i;
		for (i=0; i<folder_peers_len; ++i){
			buf = buf_cat(buf, folder_peers_[i]);
		}
	}
	//parse argument pts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_));
	}
	//parse argument pts_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_count_));
	}
	return buf;
}

buf_t tl_updatePeerSettings(Peer *peer_, PeerSettings *settings_)
{
	buf_t buf = buf_add_ui32(0x6a7e7366);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument settings (PeerSettings)
	{
		buf = buf_cat(buf, *settings_);
	}
	return buf;
}

buf_t tl_updatePeerLocated(PeerLocated *peers_, int peers_len)
{
	buf_t buf = buf_add_ui32(0xb4afcfb0);
	//parse argument peers (Vector<PeerLocated>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(peers_len));
		int i;
		for (i=0; i<peers_len; ++i){
			buf = buf_cat(buf, peers_[i]);
		}
	}
	return buf;
}

buf_t tl_updateNewScheduledMessage(Message *message_)
{
	buf_t buf = buf_add_ui32(0x39a51dfb);
	//parse argument message (Message)
	{
		buf = buf_cat(buf, *message_);
	}
	return buf;
}

buf_t tl_updateDeleteScheduledMessages(Peer *peer_, int *messages_, int messages_len)
{
	buf_t buf = buf_add_ui32(0x90866cee);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument messages (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(messages_len));
		int i;
		for (i=0; i<messages_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(messages_[i]));
		}
	}
	return buf;
}

buf_t tl_updateTheme(Theme *theme_)
{
	buf_t buf = buf_add_ui32(0x8216fba3);
	//parse argument theme (Theme)
	{
		buf = buf_cat(buf, *theme_);
	}
	return buf;
}

buf_t tl_updateGeoLiveViewed(Peer *peer_, int msg_id_)
{
	buf_t buf = buf_add_ui32(0x871fb939);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	return buf;
}

buf_t tl_updateLoginToken()
{
	buf_t buf = buf_add_ui32(0x564fe691);
	return buf;
}

buf_t tl_updateMessagePollVote(long poll_id_, Peer *peer_, buf_t *options_, int options_len, int qts_)
{
	buf_t buf = buf_add_ui32(0x24f40e77);
	//parse argument poll_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(poll_id_));
	}
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument options (Vector<bytes>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(options_len));
		int i;
		for (i=0; i<options_len; ++i){
			buf = buf_cat(buf, serialize_bytes(options_[i].data, options_[i].size));
		}
	}
	//parse argument qts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(qts_));
	}
	return buf;
}

buf_t tl_updateDialogFilter(int id_, DialogFilter *filter_)
{
	buf_t buf = buf_add_ui32(0x26ffde7d);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument filter (DialogFilter)
	if (filter_)
	{
		buf = buf_cat(buf, *filter_);
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_updateDialogFilterOrder(int *order_, int order_len)
{
	buf_t buf = buf_add_ui32(0xa5d72105);
	//parse argument order (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(order_len));
		int i;
		for (i=0; i<order_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(order_[i]));
		}
	}
	return buf;
}

buf_t tl_updateDialogFilters()
{
	buf_t buf = buf_add_ui32(0x3504914f);
	return buf;
}

buf_t tl_updatePhoneCallSignalingData(long phone_call_id_, buf_t *data_)
{
	buf_t buf = buf_add_ui32(0x2661bf09);
	//parse argument phone_call_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(phone_call_id_));
	}
	//parse argument data (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(data_->data, data_->size));
	}
	return buf;
}

buf_t tl_updateChannelMessageForwards(long channel_id_, int id_, int forwards_)
{
	buf_t buf = buf_add_ui32(0xd29a27f4);
	//parse argument channel_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(channel_id_));
	}
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument forwards (int)
	{
		buf = buf_cat(buf, buf_add_ui32(forwards_));
	}
	return buf;
}

buf_t tl_updateReadChannelDiscussionInbox(long channel_id_, int top_msg_id_, int read_max_id_, long broadcast_id_, int broadcast_post_)
{
	buf_t buf = buf_add_ui32(0xd6b19546);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument channel_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(channel_id_));
	}
	//parse argument top_msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(top_msg_id_));
	}
	//parse argument read_max_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(read_max_id_));
	}
	//parse argument broadcast_id (long)
	if (broadcast_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(broadcast_id_));
		*flag1 |= (1 << 0);
	}
	//parse argument broadcast_post (int)
	if (broadcast_post_)
	{
		buf = buf_cat(buf, buf_add_ui32(broadcast_post_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_updateReadChannelDiscussionOutbox(long channel_id_, int top_msg_id_, int read_max_id_)
{
	buf_t buf = buf_add_ui32(0x695c9e7c);
	//parse argument channel_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(channel_id_));
	}
	//parse argument top_msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(top_msg_id_));
	}
	//parse argument read_max_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(read_max_id_));
	}
	return buf;
}

buf_t tl_updatePeerBlocked(bool blocked_, bool blocked_my_stories_from_, Peer *peer_id_)
{
	buf_t buf = buf_add_ui32(0xebe07752);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument blocked (true)
	if (blocked_)
		*flag1 |= (1 << 0);
	//parse argument blocked_my_stories_from (true)
	if (blocked_my_stories_from_)
		*flag1 |= (1 << 1);
	//parse argument peer_id (Peer)
	{
		buf = buf_cat(buf, *peer_id_);
	}
	return buf;
}

buf_t tl_updateChannelUserTyping(long channel_id_, int top_msg_id_, Peer *from_id_, SendMessageAction *action_)
{
	buf_t buf = buf_add_ui32(0x8c88c923);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument channel_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(channel_id_));
	}
	//parse argument top_msg_id (int)
	if (top_msg_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(top_msg_id_));
		*flag1 |= (1 << 0);
	}
	//parse argument from_id (Peer)
	{
		buf = buf_cat(buf, *from_id_);
	}
	//parse argument action (SendMessageAction)
	{
		buf = buf_cat(buf, *action_);
	}
	return buf;
}

buf_t tl_updatePinnedMessages(bool pinned_, Peer *peer_, int *messages_, int messages_len, int pts_, int pts_count_)
{
	buf_t buf = buf_add_ui32(0xed85eab5);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument pinned (true)
	if (pinned_)
		*flag1 |= (1 << 0);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument messages (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(messages_len));
		int i;
		for (i=0; i<messages_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(messages_[i]));
		}
	}
	//parse argument pts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_));
	}
	//parse argument pts_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_count_));
	}
	return buf;
}

buf_t tl_updatePinnedChannelMessages(bool pinned_, long channel_id_, int *messages_, int messages_len, int pts_, int pts_count_)
{
	buf_t buf = buf_add_ui32(0x5bb98608);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument pinned (true)
	if (pinned_)
		*flag1 |= (1 << 0);
	//parse argument channel_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(channel_id_));
	}
	//parse argument messages (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(messages_len));
		int i;
		for (i=0; i<messages_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(messages_[i]));
		}
	}
	//parse argument pts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_));
	}
	//parse argument pts_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_count_));
	}
	return buf;
}

buf_t tl_updateChat(long chat_id_)
{
	buf_t buf = buf_add_ui32(0xf89a6a4e);
	//parse argument chat_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(chat_id_));
	}
	return buf;
}

buf_t tl_updateGroupCallParticipants(InputGroupCall *call_, GroupCallParticipant *participants_, int participants_len, int version_)
{
	buf_t buf = buf_add_ui32(0xf2ebdb4e);
	//parse argument call (InputGroupCall)
	{
		buf = buf_cat(buf, *call_);
	}
	//parse argument participants (Vector<GroupCallParticipant>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(participants_len));
		int i;
		for (i=0; i<participants_len; ++i){
			buf = buf_cat(buf, participants_[i]);
		}
	}
	//parse argument version (int)
	{
		buf = buf_cat(buf, buf_add_ui32(version_));
	}
	return buf;
}

buf_t tl_updateGroupCall(long chat_id_, GroupCall *call_)
{
	buf_t buf = buf_add_ui32(0x14b24500);
	//parse argument chat_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(chat_id_));
	}
	//parse argument call (GroupCall)
	{
		buf = buf_cat(buf, *call_);
	}
	return buf;
}

buf_t tl_updatePeerHistoryTTL(Peer *peer_, int ttl_period_)
{
	buf_t buf = buf_add_ui32(0xbb9bb9a5);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument ttl_period (int)
	if (ttl_period_)
	{
		buf = buf_cat(buf, buf_add_ui32(ttl_period_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_updateChatParticipant(long chat_id_, int date_, long actor_id_, long user_id_, ChatParticipant *prev_participant_, ChatParticipant *new_participant_, ExportedChatInvite *invite_, int qts_)
{
	buf_t buf = buf_add_ui32(0xd087663a);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument chat_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(chat_id_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument actor_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(actor_id_));
	}
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument prev_participant (ChatParticipant)
	if (prev_participant_)
	{
		buf = buf_cat(buf, *prev_participant_);
		*flag1 |= (1 << 0);
	}
	//parse argument new_participant (ChatParticipant)
	if (new_participant_)
	{
		buf = buf_cat(buf, *new_participant_);
		*flag1 |= (1 << 1);
	}
	//parse argument invite (ExportedChatInvite)
	if (invite_)
	{
		buf = buf_cat(buf, *invite_);
		*flag1 |= (1 << 2);
	}
	//parse argument qts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(qts_));
	}
	return buf;
}

buf_t tl_updateChannelParticipant(bool via_chatlist_, long channel_id_, int date_, long actor_id_, long user_id_, ChannelParticipant *prev_participant_, ChannelParticipant *new_participant_, ExportedChatInvite *invite_, int qts_)
{
	buf_t buf = buf_add_ui32(0x985d3abb);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument via_chatlist (true)
	if (via_chatlist_)
		*flag1 |= (1 << 3);
	//parse argument channel_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(channel_id_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument actor_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(actor_id_));
	}
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument prev_participant (ChannelParticipant)
	if (prev_participant_)
	{
		buf = buf_cat(buf, *prev_participant_);
		*flag1 |= (1 << 0);
	}
	//parse argument new_participant (ChannelParticipant)
	if (new_participant_)
	{
		buf = buf_cat(buf, *new_participant_);
		*flag1 |= (1 << 1);
	}
	//parse argument invite (ExportedChatInvite)
	if (invite_)
	{
		buf = buf_cat(buf, *invite_);
		*flag1 |= (1 << 2);
	}
	//parse argument qts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(qts_));
	}
	return buf;
}

buf_t tl_updateBotStopped(long user_id_, int date_, Bool *stopped_, int qts_)
{
	buf_t buf = buf_add_ui32(0xc4870a49);
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument stopped (Bool)
	{
		buf = buf_cat(buf, *stopped_);
	}
	//parse argument qts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(qts_));
	}
	return buf;
}

buf_t tl_updateGroupCallConnection(bool presentation_, DataJSON *params_)
{
	buf_t buf = buf_add_ui32(0x0b783982);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument presentation (true)
	if (presentation_)
		*flag1 |= (1 << 0);
	//parse argument params (DataJSON)
	{
		buf = buf_cat(buf, *params_);
	}
	return buf;
}

buf_t tl_updateBotCommands(Peer *peer_, long bot_id_, BotCommand *commands_, int commands_len)
{
	buf_t buf = buf_add_ui32(0x4d712f2e);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument bot_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(bot_id_));
	}
	//parse argument commands (Vector<BotCommand>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(commands_len));
		int i;
		for (i=0; i<commands_len; ++i){
			buf = buf_cat(buf, commands_[i]);
		}
	}
	return buf;
}

buf_t tl_updatePendingJoinRequests(Peer *peer_, int requests_pending_, long *recent_requesters_, int recent_requesters_len)
{
	buf_t buf = buf_add_ui32(0x7063c3db);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument requests_pending (int)
	{
		buf = buf_cat(buf, buf_add_ui32(requests_pending_));
	}
	//parse argument recent_requesters (Vector<long>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(recent_requesters_len));
		int i;
		for (i=0; i<recent_requesters_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(recent_requesters_[i]));
		}
	}
	return buf;
}

buf_t tl_updateBotChatInviteRequester(Peer *peer_, int date_, long user_id_, const char * about_, ExportedChatInvite *invite_, int qts_)
{
	buf_t buf = buf_add_ui32(0x11dfa986);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument about (string)
	{
		buf = buf_cat(buf, serialize_string(about_));
	}
	//parse argument invite (ExportedChatInvite)
	{
		buf = buf_cat(buf, *invite_);
	}
	//parse argument qts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(qts_));
	}
	return buf;
}

buf_t tl_updateMessageReactions(Peer *peer_, int msg_id_, int top_msg_id_, MessageReactions *reactions_)
{
	buf_t buf = buf_add_ui32(0x5e1b3cb8);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	//parse argument top_msg_id (int)
	if (top_msg_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(top_msg_id_));
		*flag1 |= (1 << 0);
	}
	//parse argument reactions (MessageReactions)
	{
		buf = buf_cat(buf, *reactions_);
	}
	return buf;
}

buf_t tl_updateAttachMenuBots()
{
	buf_t buf = buf_add_ui32(0x17b7a20b);
	return buf;
}

buf_t tl_updateWebViewResultSent(long query_id_)
{
	buf_t buf = buf_add_ui32(0x1592b79d);
	//parse argument query_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(query_id_));
	}
	return buf;
}

buf_t tl_updateBotMenuButton(long bot_id_, BotMenuButton *button_)
{
	buf_t buf = buf_add_ui32(0x14b85813);
	//parse argument bot_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(bot_id_));
	}
	//parse argument button (BotMenuButton)
	{
		buf = buf_cat(buf, *button_);
	}
	return buf;
}

buf_t tl_updateSavedRingtones()
{
	buf_t buf = buf_add_ui32(0x74d8be99);
	return buf;
}

buf_t tl_updateTranscribedAudio(bool pending_, Peer *peer_, int msg_id_, long transcription_id_, const char * text_)
{
	buf_t buf = buf_add_ui32(0x0084cd5a);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument pending (true)
	if (pending_)
		*flag1 |= (1 << 0);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	//parse argument transcription_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(transcription_id_));
	}
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	return buf;
}

buf_t tl_updateReadFeaturedEmojiStickers()
{
	buf_t buf = buf_add_ui32(0xfb4c496c);
	return buf;
}

buf_t tl_updateUserEmojiStatus(long user_id_, EmojiStatus *emoji_status_)
{
	buf_t buf = buf_add_ui32(0x28373599);
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument emoji_status (EmojiStatus)
	{
		buf = buf_cat(buf, *emoji_status_);
	}
	return buf;
}

buf_t tl_updateRecentEmojiStatuses()
{
	buf_t buf = buf_add_ui32(0x30f443db);
	return buf;
}

buf_t tl_updateRecentReactions()
{
	buf_t buf = buf_add_ui32(0x6f7863f4);
	return buf;
}

buf_t tl_updateMoveStickerSetToTop(bool masks_, bool emojis_, long stickerset_)
{
	buf_t buf = buf_add_ui32(0x86fccf85);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument masks (true)
	if (masks_)
		*flag1 |= (1 << 0);
	//parse argument emojis (true)
	if (emojis_)
		*flag1 |= (1 << 1);
	//parse argument stickerset (long)
	{
		buf = buf_cat(buf, buf_add_ui64(stickerset_));
	}
	return buf;
}

buf_t tl_updateMessageExtendedMedia(Peer *peer_, int msg_id_, MessageExtendedMedia *extended_media_, int extended_media_len)
{
	buf_t buf = buf_add_ui32(0xd5a41724);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	//parse argument extended_media (Vector<MessageExtendedMedia>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(extended_media_len));
		int i;
		for (i=0; i<extended_media_len; ++i){
			buf = buf_cat(buf, extended_media_[i]);
		}
	}
	return buf;
}

buf_t tl_updateChannelPinnedTopic(bool pinned_, long channel_id_, int topic_id_)
{
	buf_t buf = buf_add_ui32(0x192efbe3);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument pinned (true)
	if (pinned_)
		*flag1 |= (1 << 0);
	//parse argument channel_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(channel_id_));
	}
	//parse argument topic_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(topic_id_));
	}
	return buf;
}

buf_t tl_updateChannelPinnedTopics(long channel_id_, int *order_, int order_len)
{
	buf_t buf = buf_add_ui32(0xfe198602);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument channel_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(channel_id_));
	}
	//parse argument order (Vector<int>)
	if (order_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(order_len));
		int i;
		for (i=0; i<order_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(order_[i]));
		}
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_updateUser(long user_id_)
{
	buf_t buf = buf_add_ui32(0x20529438);
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	return buf;
}

buf_t tl_updateAutoSaveSettings()
{
	buf_t buf = buf_add_ui32(0xec05b097);
	return buf;
}

buf_t tl_updateStory(Peer *peer_, StoryItem *story_)
{
	buf_t buf = buf_add_ui32(0x75b3b798);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument story (StoryItem)
	{
		buf = buf_cat(buf, *story_);
	}
	return buf;
}

buf_t tl_updateReadStories(Peer *peer_, int max_id_)
{
	buf_t buf = buf_add_ui32(0xf74e932b);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument max_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(max_id_));
	}
	return buf;
}

buf_t tl_updateStoryID(int id_, long random_id_)
{
	buf_t buf = buf_add_ui32(0x1bf335b9);
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument random_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(random_id_));
	}
	return buf;
}

buf_t tl_updateStoriesStealthMode(StoriesStealthMode *stealth_mode_)
{
	buf_t buf = buf_add_ui32(0x2c084dc1);
	//parse argument stealth_mode (StoriesStealthMode)
	{
		buf = buf_cat(buf, *stealth_mode_);
	}
	return buf;
}

buf_t tl_updateSentStoryReaction(Peer *peer_, int story_id_, Reaction *reaction_)
{
	buf_t buf = buf_add_ui32(0x7d627683);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument story_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(story_id_));
	}
	//parse argument reaction (Reaction)
	{
		buf = buf_cat(buf, *reaction_);
	}
	return buf;
}

buf_t tl_updateBotChatBoost(Peer *peer_, Boost *boost_, int qts_)
{
	buf_t buf = buf_add_ui32(0x904dd49c);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument boost (Boost)
	{
		buf = buf_cat(buf, *boost_);
	}
	//parse argument qts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(qts_));
	}
	return buf;
}

buf_t tl_updateChannelViewForumAsMessages(long channel_id_, Bool *enabled_)
{
	buf_t buf = buf_add_ui32(0x07b68920);
	//parse argument channel_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(channel_id_));
	}
	//parse argument enabled (Bool)
	{
		buf = buf_cat(buf, *enabled_);
	}
	return buf;
}

buf_t tl_updatePeerWallpaper(bool wallpaper_overridden_, Peer *peer_, WallPaper *wallpaper_)
{
	buf_t buf = buf_add_ui32(0xae3f101d);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument wallpaper_overridden (true)
	if (wallpaper_overridden_)
		*flag1 |= (1 << 1);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument wallpaper (WallPaper)
	if (wallpaper_)
	{
		buf = buf_cat(buf, *wallpaper_);
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_updateBotMessageReaction(Peer *peer_, int msg_id_, int date_, Peer *actor_, Reaction *old_reactions_, int old_reactions_len, Reaction *new_reactions_, int new_reactions_len, int qts_)
{
	buf_t buf = buf_add_ui32(0xac21d3ce);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument actor (Peer)
	{
		buf = buf_cat(buf, *actor_);
	}
	//parse argument old_reactions (Vector<Reaction>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(old_reactions_len));
		int i;
		for (i=0; i<old_reactions_len; ++i){
			buf = buf_cat(buf, old_reactions_[i]);
		}
	}
	//parse argument new_reactions (Vector<Reaction>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(new_reactions_len));
		int i;
		for (i=0; i<new_reactions_len; ++i){
			buf = buf_cat(buf, new_reactions_[i]);
		}
	}
	//parse argument qts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(qts_));
	}
	return buf;
}

buf_t tl_updateBotMessageReactions(Peer *peer_, int msg_id_, int date_, ReactionCount *reactions_, int reactions_len, int qts_)
{
	buf_t buf = buf_add_ui32(0x09cb7759);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument reactions (Vector<ReactionCount>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(reactions_len));
		int i;
		for (i=0; i<reactions_len; ++i){
			buf = buf_cat(buf, reactions_[i]);
		}
	}
	//parse argument qts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(qts_));
	}
	return buf;
}

buf_t tl_updateSavedDialogPinned(bool pinned_, DialogPeer *peer_)
{
	buf_t buf = buf_add_ui32(0xaeaf9e74);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument pinned (true)
	if (pinned_)
		*flag1 |= (1 << 0);
	//parse argument peer (DialogPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_updatePinnedSavedDialogs(DialogPeer *order_, int order_len)
{
	buf_t buf = buf_add_ui32(0x686c85a6);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument order (Vector<DialogPeer>)
	if (order_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(order_len));
		int i;
		for (i=0; i<order_len; ++i){
			buf = buf_cat(buf, order_[i]);
		}
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_updateSavedReactionTags()
{
	buf_t buf = buf_add_ui32(0x39c67432);
	return buf;
}

buf_t tl_updateSmsJob(const char * job_id_)
{
	buf_t buf = buf_add_ui32(0xf16269d4);
	//parse argument job_id (string)
	{
		buf = buf_cat(buf, serialize_string(job_id_));
	}
	return buf;
}

buf_t tl_updateQuickReplies(QuickReply *quick_replies_, int quick_replies_len)
{
	buf_t buf = buf_add_ui32(0xf9470ab2);
	//parse argument quick_replies (Vector<QuickReply>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(quick_replies_len));
		int i;
		for (i=0; i<quick_replies_len; ++i){
			buf = buf_cat(buf, quick_replies_[i]);
		}
	}
	return buf;
}

buf_t tl_updateNewQuickReply(QuickReply *quick_reply_)
{
	buf_t buf = buf_add_ui32(0xf53da717);
	//parse argument quick_reply (QuickReply)
	{
		buf = buf_cat(buf, *quick_reply_);
	}
	return buf;
}

buf_t tl_updateDeleteQuickReply(int shortcut_id_)
{
	buf_t buf = buf_add_ui32(0x53e6f1ec);
	//parse argument shortcut_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(shortcut_id_));
	}
	return buf;
}

buf_t tl_updateQuickReplyMessage(Message *message_)
{
	buf_t buf = buf_add_ui32(0x3e050d0f);
	//parse argument message (Message)
	{
		buf = buf_cat(buf, *message_);
	}
	return buf;
}

buf_t tl_updateDeleteQuickReplyMessages(int shortcut_id_, int *messages_, int messages_len)
{
	buf_t buf = buf_add_ui32(0x566fe7cd);
	//parse argument shortcut_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(shortcut_id_));
	}
	//parse argument messages (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(messages_len));
		int i;
		for (i=0; i<messages_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(messages_[i]));
		}
	}
	return buf;
}

buf_t tl_updateBotBusinessConnect(BotBusinessConnection *connection_, int qts_)
{
	buf_t buf = buf_add_ui32(0x8ae5c97a);
	//parse argument connection (BotBusinessConnection)
	{
		buf = buf_cat(buf, *connection_);
	}
	//parse argument qts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(qts_));
	}
	return buf;
}

buf_t tl_updateBotNewBusinessMessage(const char * connection_id_, Message *message_, Message *reply_to_message_, int qts_)
{
	buf_t buf = buf_add_ui32(0x9ddb347c);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument connection_id (string)
	{
		buf = buf_cat(buf, serialize_string(connection_id_));
	}
	//parse argument message (Message)
	{
		buf = buf_cat(buf, *message_);
	}
	//parse argument reply_to_message (Message)
	if (reply_to_message_)
	{
		buf = buf_cat(buf, *reply_to_message_);
		*flag1 |= (1 << 0);
	}
	//parse argument qts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(qts_));
	}
	return buf;
}

buf_t tl_updateBotEditBusinessMessage(const char * connection_id_, Message *message_, Message *reply_to_message_, int qts_)
{
	buf_t buf = buf_add_ui32(0x07df587c);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument connection_id (string)
	{
		buf = buf_cat(buf, serialize_string(connection_id_));
	}
	//parse argument message (Message)
	{
		buf = buf_cat(buf, *message_);
	}
	//parse argument reply_to_message (Message)
	if (reply_to_message_)
	{
		buf = buf_cat(buf, *reply_to_message_);
		*flag1 |= (1 << 0);
	}
	//parse argument qts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(qts_));
	}
	return buf;
}

buf_t tl_updateBotDeleteBusinessMessage(const char * connection_id_, Peer *peer_, int *messages_, int messages_len, int qts_)
{
	buf_t buf = buf_add_ui32(0xa02a982e);
	//parse argument connection_id (string)
	{
		buf = buf_cat(buf, serialize_string(connection_id_));
	}
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument messages (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(messages_len));
		int i;
		for (i=0; i<messages_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(messages_[i]));
		}
	}
	//parse argument qts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(qts_));
	}
	return buf;
}

buf_t tl_updateNewStoryReaction(int story_id_, Peer *peer_, Reaction *reaction_)
{
	buf_t buf = buf_add_ui32(0x1824e40b);
	//parse argument story_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(story_id_));
	}
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument reaction (Reaction)
	{
		buf = buf_cat(buf, *reaction_);
	}
	return buf;
}

buf_t tl_updateBroadcastRevenueTransactions(Peer *peer_, BroadcastRevenueBalances *balances_)
{
	buf_t buf = buf_add_ui32(0xdfd961f5);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument balances (BroadcastRevenueBalances)
	{
		buf = buf_cat(buf, *balances_);
	}
	return buf;
}

buf_t tl_updateStarsBalance(long balance_)
{
	buf_t buf = buf_add_ui32(0x0fb85198);
	//parse argument balance (long)
	{
		buf = buf_cat(buf, buf_add_ui64(balance_));
	}
	return buf;
}

buf_t tl_updateBusinessBotCallbackQuery(long query_id_, long user_id_, const char * connection_id_, Message *message_, Message *reply_to_message_, long chat_instance_, buf_t *data_)
{
	buf_t buf = buf_add_ui32(0x1ea2fda7);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument query_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(query_id_));
	}
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument connection_id (string)
	{
		buf = buf_cat(buf, serialize_string(connection_id_));
	}
	//parse argument message (Message)
	{
		buf = buf_cat(buf, *message_);
	}
	//parse argument reply_to_message (Message)
	if (reply_to_message_)
	{
		buf = buf_cat(buf, *reply_to_message_);
		*flag1 |= (1 << 2);
	}
	//parse argument chat_instance (long)
	{
		buf = buf_cat(buf, buf_add_ui64(chat_instance_));
	}
	//parse argument data (bytes)
	if (data_)
	{
		buf = buf_cat(buf, serialize_bytes(data_->data, data_->size));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_updateStarsRevenueStatus(Peer *peer_, StarsRevenueStatus *status_)
{
	buf_t buf = buf_add_ui32(0xa584b019);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument status (StarsRevenueStatus)
	{
		buf = buf_cat(buf, *status_);
	}
	return buf;
}

buf_t tl_updateBotPurchasedPaidMedia(long user_id_, const char * payload_, int qts_)
{
	buf_t buf = buf_add_ui32(0x283bd312);
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument payload (string)
	{
		buf = buf_cat(buf, serialize_string(payload_));
	}
	//parse argument qts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(qts_));
	}
	return buf;
}

buf_t tl_updatePaidReactionPrivacy(Bool *private_)
{
	buf_t buf = buf_add_ui32(0x51ca7aec);
	//parse argument private (Bool)
	{
		buf = buf_cat(buf, *private_);
	}
	return buf;
}

buf_t tl_updates_state(int pts_, int qts_, int date_, int seq_, int unread_count_)
{
	buf_t buf = buf_add_ui32(0xa56c2a3e);
	//parse argument pts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_));
	}
	//parse argument qts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(qts_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument seq (int)
	{
		buf = buf_cat(buf, buf_add_ui32(seq_));
	}
	//parse argument unread_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(unread_count_));
	}
	return buf;
}

buf_t tl_updates_differenceEmpty(int date_, int seq_)
{
	buf_t buf = buf_add_ui32(0x5d75a138);
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument seq (int)
	{
		buf = buf_cat(buf, buf_add_ui32(seq_));
	}
	return buf;
}

buf_t tl_updates_difference(Message *new_messages_, int new_messages_len, EncryptedMessage *new_encrypted_messages_, int new_encrypted_messages_len, Update *other_updates_, int other_updates_len, Chat *chats_, int chats_len, User *users_, int users_len, updates_State *state_)
{
	buf_t buf = buf_add_ui32(0x00f49ca0);
	//parse argument new_messages (Vector<Message>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(new_messages_len));
		int i;
		for (i=0; i<new_messages_len; ++i){
			buf = buf_cat(buf, new_messages_[i]);
		}
	}
	//parse argument new_encrypted_messages (Vector<EncryptedMessage>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(new_encrypted_messages_len));
		int i;
		for (i=0; i<new_encrypted_messages_len; ++i){
			buf = buf_cat(buf, new_encrypted_messages_[i]);
		}
	}
	//parse argument other_updates (Vector<Update>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(other_updates_len));
		int i;
		for (i=0; i<other_updates_len; ++i){
			buf = buf_cat(buf, other_updates_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	//parse argument state (updates_State)
	{
		buf = buf_cat(buf, *state_);
	}
	return buf;
}

buf_t tl_updates_differenceSlice(Message *new_messages_, int new_messages_len, EncryptedMessage *new_encrypted_messages_, int new_encrypted_messages_len, Update *other_updates_, int other_updates_len, Chat *chats_, int chats_len, User *users_, int users_len, updates_State *intermediate_state_)
{
	buf_t buf = buf_add_ui32(0xa8fb1981);
	//parse argument new_messages (Vector<Message>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(new_messages_len));
		int i;
		for (i=0; i<new_messages_len; ++i){
			buf = buf_cat(buf, new_messages_[i]);
		}
	}
	//parse argument new_encrypted_messages (Vector<EncryptedMessage>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(new_encrypted_messages_len));
		int i;
		for (i=0; i<new_encrypted_messages_len; ++i){
			buf = buf_cat(buf, new_encrypted_messages_[i]);
		}
	}
	//parse argument other_updates (Vector<Update>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(other_updates_len));
		int i;
		for (i=0; i<other_updates_len; ++i){
			buf = buf_cat(buf, other_updates_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	//parse argument intermediate_state (updates_State)
	{
		buf = buf_cat(buf, *intermediate_state_);
	}
	return buf;
}

buf_t tl_updates_differenceTooLong(int pts_)
{
	buf_t buf = buf_add_ui32(0x4afe8f6d);
	//parse argument pts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_));
	}
	return buf;
}

buf_t tl_updatesTooLong()
{
	buf_t buf = buf_add_ui32(0xe317af7e);
	return buf;
}

buf_t tl_updateShortMessage(bool out_, bool mentioned_, bool media_unread_, bool silent_, int id_, long user_id_, const char * message_, int pts_, int pts_count_, int date_, MessageFwdHeader *fwd_from_, long via_bot_id_, MessageReplyHeader *reply_to_, MessageEntity *entities_, int entities_len, int ttl_period_)
{
	buf_t buf = buf_add_ui32(0x313bc7f8);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument out (true)
	if (out_)
		*flag1 |= (1 << 1);
	//parse argument mentioned (true)
	if (mentioned_)
		*flag1 |= (1 << 4);
	//parse argument media_unread (true)
	if (media_unread_)
		*flag1 |= (1 << 5);
	//parse argument silent (true)
	if (silent_)
		*flag1 |= (1 << 13);
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument message (string)
	{
		buf = buf_cat(buf, serialize_string(message_));
	}
	//parse argument pts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_));
	}
	//parse argument pts_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_count_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument fwd_from (MessageFwdHeader)
	if (fwd_from_)
	{
		buf = buf_cat(buf, *fwd_from_);
		*flag1 |= (1 << 2);
	}
	//parse argument via_bot_id (long)
	if (via_bot_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(via_bot_id_));
		*flag1 |= (1 << 11);
	}
	//parse argument reply_to (MessageReplyHeader)
	if (reply_to_)
	{
		buf = buf_cat(buf, *reply_to_);
		*flag1 |= (1 << 3);
	}
	//parse argument entities (Vector<MessageEntity>)
	if (entities_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(entities_len));
		int i;
		for (i=0; i<entities_len; ++i){
			buf = buf_cat(buf, entities_[i]);
		}
		*flag1 |= (1 << 7);
	}
	//parse argument ttl_period (int)
	if (ttl_period_)
	{
		buf = buf_cat(buf, buf_add_ui32(ttl_period_));
		*flag1 |= (1 << 25);
	}
	return buf;
}

buf_t tl_updateShortChatMessage(bool out_, bool mentioned_, bool media_unread_, bool silent_, int id_, long from_id_, long chat_id_, const char * message_, int pts_, int pts_count_, int date_, MessageFwdHeader *fwd_from_, long via_bot_id_, MessageReplyHeader *reply_to_, MessageEntity *entities_, int entities_len, int ttl_period_)
{
	buf_t buf = buf_add_ui32(0x4d6deea5);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument out (true)
	if (out_)
		*flag1 |= (1 << 1);
	//parse argument mentioned (true)
	if (mentioned_)
		*flag1 |= (1 << 4);
	//parse argument media_unread (true)
	if (media_unread_)
		*flag1 |= (1 << 5);
	//parse argument silent (true)
	if (silent_)
		*flag1 |= (1 << 13);
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument from_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(from_id_));
	}
	//parse argument chat_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(chat_id_));
	}
	//parse argument message (string)
	{
		buf = buf_cat(buf, serialize_string(message_));
	}
	//parse argument pts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_));
	}
	//parse argument pts_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_count_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument fwd_from (MessageFwdHeader)
	if (fwd_from_)
	{
		buf = buf_cat(buf, *fwd_from_);
		*flag1 |= (1 << 2);
	}
	//parse argument via_bot_id (long)
	if (via_bot_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(via_bot_id_));
		*flag1 |= (1 << 11);
	}
	//parse argument reply_to (MessageReplyHeader)
	if (reply_to_)
	{
		buf = buf_cat(buf, *reply_to_);
		*flag1 |= (1 << 3);
	}
	//parse argument entities (Vector<MessageEntity>)
	if (entities_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(entities_len));
		int i;
		for (i=0; i<entities_len; ++i){
			buf = buf_cat(buf, entities_[i]);
		}
		*flag1 |= (1 << 7);
	}
	//parse argument ttl_period (int)
	if (ttl_period_)
	{
		buf = buf_cat(buf, buf_add_ui32(ttl_period_));
		*flag1 |= (1 << 25);
	}
	return buf;
}

buf_t tl_updateShort(Update *update_, int date_)
{
	buf_t buf = buf_add_ui32(0x78d4dec1);
	//parse argument update (Update)
	{
		buf = buf_cat(buf, *update_);
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	return buf;
}

buf_t tl_updatesCombined(Update *updates_, int updates_len, User *users_, int users_len, Chat *chats_, int chats_len, int date_, int seq_start_, int seq_)
{
	buf_t buf = buf_add_ui32(0x725b04c3);
	//parse argument updates (Vector<Update>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(updates_len));
		int i;
		for (i=0; i<updates_len; ++i){
			buf = buf_cat(buf, updates_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument seq_start (int)
	{
		buf = buf_cat(buf, buf_add_ui32(seq_start_));
	}
	//parse argument seq (int)
	{
		buf = buf_cat(buf, buf_add_ui32(seq_));
	}
	return buf;
}

buf_t tl_updates(Update *updates_, int updates_len, User *users_, int users_len, Chat *chats_, int chats_len, int date_, int seq_)
{
	buf_t buf = buf_add_ui32(0x74ae4240);
	//parse argument updates (Vector<Update>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(updates_len));
		int i;
		for (i=0; i<updates_len; ++i){
			buf = buf_cat(buf, updates_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument seq (int)
	{
		buf = buf_cat(buf, buf_add_ui32(seq_));
	}
	return buf;
}

buf_t tl_updateShortSentMessage(bool out_, int id_, int pts_, int pts_count_, int date_, MessageMedia *media_, MessageEntity *entities_, int entities_len, int ttl_period_)
{
	buf_t buf = buf_add_ui32(0x9015e101);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument out (true)
	if (out_)
		*flag1 |= (1 << 1);
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument pts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_));
	}
	//parse argument pts_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_count_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument media (MessageMedia)
	if (media_)
	{
		buf = buf_cat(buf, *media_);
		*flag1 |= (1 << 9);
	}
	//parse argument entities (Vector<MessageEntity>)
	if (entities_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(entities_len));
		int i;
		for (i=0; i<entities_len; ++i){
			buf = buf_cat(buf, entities_[i]);
		}
		*flag1 |= (1 << 7);
	}
	//parse argument ttl_period (int)
	if (ttl_period_)
	{
		buf = buf_cat(buf, buf_add_ui32(ttl_period_));
		*flag1 |= (1 << 25);
	}
	return buf;
}

buf_t tl_photos_photos(Photo *photos_, int photos_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x8dca6aa5);
	//parse argument photos (Vector<Photo>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(photos_len));
		int i;
		for (i=0; i<photos_len; ++i){
			buf = buf_cat(buf, photos_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_photos_photosSlice(int count_, Photo *photos_, int photos_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x15051f54);
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	//parse argument photos (Vector<Photo>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(photos_len));
		int i;
		for (i=0; i<photos_len; ++i){
			buf = buf_cat(buf, photos_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_photos_photo(Photo *photo_, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x20212ca8);
	//parse argument photo (Photo)
	{
		buf = buf_cat(buf, *photo_);
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_upload_file(storage_FileType *type_, int mtime_, buf_t *bytes_)
{
	buf_t buf = buf_add_ui32(0x096a18d5);
	//parse argument type (storage_FileType)
	{
		buf = buf_cat(buf, *type_);
	}
	//parse argument mtime (int)
	{
		buf = buf_cat(buf, buf_add_ui32(mtime_));
	}
	//parse argument bytes (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(bytes_->data, bytes_->size));
	}
	return buf;
}

buf_t tl_upload_fileCdnRedirect(int dc_id_, buf_t *file_token_, buf_t *encryption_key_, buf_t *encryption_iv_, FileHash *file_hashes_, int file_hashes_len)
{
	buf_t buf = buf_add_ui32(0xf18cda44);
	//parse argument dc_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(dc_id_));
	}
	//parse argument file_token (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(file_token_->data, file_token_->size));
	}
	//parse argument encryption_key (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(encryption_key_->data, encryption_key_->size));
	}
	//parse argument encryption_iv (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(encryption_iv_->data, encryption_iv_->size));
	}
	//parse argument file_hashes (Vector<FileHash>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(file_hashes_len));
		int i;
		for (i=0; i<file_hashes_len; ++i){
			buf = buf_cat(buf, file_hashes_[i]);
		}
	}
	return buf;
}

buf_t tl_dcOption(bool ipv6_, bool media_only_, bool tcpo_only_, bool cdn_, bool static_, bool this_port_only_, int id_, const char * ip_address_, int port_, buf_t *secret_)
{
	buf_t buf = buf_add_ui32(0x18b7a10d);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument ipv6 (true)
	if (ipv6_)
		*flag1 |= (1 << 0);
	//parse argument media_only (true)
	if (media_only_)
		*flag1 |= (1 << 1);
	//parse argument tcpo_only (true)
	if (tcpo_only_)
		*flag1 |= (1 << 2);
	//parse argument cdn (true)
	if (cdn_)
		*flag1 |= (1 << 3);
	//parse argument static (true)
	if (static_)
		*flag1 |= (1 << 4);
	//parse argument this_port_only (true)
	if (this_port_only_)
		*flag1 |= (1 << 5);
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument ip_address (string)
	{
		buf = buf_cat(buf, serialize_string(ip_address_));
	}
	//parse argument port (int)
	{
		buf = buf_cat(buf, buf_add_ui32(port_));
	}
	//parse argument secret (bytes)
	if (secret_)
	{
		buf = buf_cat(buf, serialize_bytes(secret_->data, secret_->size));
		*flag1 |= (1 << 10);
	}
	return buf;
}

buf_t tl_config(bool default_p2p_contacts_, bool preload_featured_stickers_, bool revoke_pm_inbox_, bool blocked_mode_, bool force_try_ipv6_, int date_, int expires_, Bool *test_mode_, int this_dc_, DcOption *dc_options_, int dc_options_len, const char * dc_txt_domain_name_, int chat_size_max_, int megagroup_size_max_, int forwarded_count_max_, int online_update_period_ms_, int offline_blur_timeout_ms_, int offline_idle_timeout_ms_, int online_cloud_timeout_ms_, int notify_cloud_delay_ms_, int notify_default_delay_ms_, int push_chat_period_ms_, int push_chat_limit_, int edit_time_limit_, int revoke_time_limit_, int revoke_pm_time_limit_, int rating_e_decay_, int stickers_recent_limit_, int channels_read_media_period_, int tmp_sessions_, int call_receive_timeout_ms_, int call_ring_timeout_ms_, int call_connect_timeout_ms_, int call_packet_timeout_ms_, const char * me_url_prefix_, const char * autoupdate_url_prefix_, const char * gif_search_username_, const char * venue_search_username_, const char * img_search_username_, const char * static_maps_provider_, int caption_length_max_, int message_length_max_, int webfile_dc_id_, const char * suggested_lang_code_, int lang_pack_version_, int base_lang_pack_version_, Reaction *reactions_default_, const char * autologin_token_)
{
	buf_t buf = buf_add_ui32(0xcc1a241e);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument default_p2p_contacts (true)
	if (default_p2p_contacts_)
		*flag1 |= (1 << 3);
	//parse argument preload_featured_stickers (true)
	if (preload_featured_stickers_)
		*flag1 |= (1 << 4);
	//parse argument revoke_pm_inbox (true)
	if (revoke_pm_inbox_)
		*flag1 |= (1 << 6);
	//parse argument blocked_mode (true)
	if (blocked_mode_)
		*flag1 |= (1 << 8);
	//parse argument force_try_ipv6 (true)
	if (force_try_ipv6_)
		*flag1 |= (1 << 14);
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument expires (int)
	{
		buf = buf_cat(buf, buf_add_ui32(expires_));
	}
	//parse argument test_mode (Bool)
	{
		buf = buf_cat(buf, *test_mode_);
	}
	//parse argument this_dc (int)
	{
		buf = buf_cat(buf, buf_add_ui32(this_dc_));
	}
	//parse argument dc_options (Vector<DcOption>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(dc_options_len));
		int i;
		for (i=0; i<dc_options_len; ++i){
			buf = buf_cat(buf, dc_options_[i]);
		}
	}
	//parse argument dc_txt_domain_name (string)
	{
		buf = buf_cat(buf, serialize_string(dc_txt_domain_name_));
	}
	//parse argument chat_size_max (int)
	{
		buf = buf_cat(buf, buf_add_ui32(chat_size_max_));
	}
	//parse argument megagroup_size_max (int)
	{
		buf = buf_cat(buf, buf_add_ui32(megagroup_size_max_));
	}
	//parse argument forwarded_count_max (int)
	{
		buf = buf_cat(buf, buf_add_ui32(forwarded_count_max_));
	}
	//parse argument online_update_period_ms (int)
	{
		buf = buf_cat(buf, buf_add_ui32(online_update_period_ms_));
	}
	//parse argument offline_blur_timeout_ms (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offline_blur_timeout_ms_));
	}
	//parse argument offline_idle_timeout_ms (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offline_idle_timeout_ms_));
	}
	//parse argument online_cloud_timeout_ms (int)
	{
		buf = buf_cat(buf, buf_add_ui32(online_cloud_timeout_ms_));
	}
	//parse argument notify_cloud_delay_ms (int)
	{
		buf = buf_cat(buf, buf_add_ui32(notify_cloud_delay_ms_));
	}
	//parse argument notify_default_delay_ms (int)
	{
		buf = buf_cat(buf, buf_add_ui32(notify_default_delay_ms_));
	}
	//parse argument push_chat_period_ms (int)
	{
		buf = buf_cat(buf, buf_add_ui32(push_chat_period_ms_));
	}
	//parse argument push_chat_limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(push_chat_limit_));
	}
	//parse argument edit_time_limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(edit_time_limit_));
	}
	//parse argument revoke_time_limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(revoke_time_limit_));
	}
	//parse argument revoke_pm_time_limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(revoke_pm_time_limit_));
	}
	//parse argument rating_e_decay (int)
	{
		buf = buf_cat(buf, buf_add_ui32(rating_e_decay_));
	}
	//parse argument stickers_recent_limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(stickers_recent_limit_));
	}
	//parse argument channels_read_media_period (int)
	{
		buf = buf_cat(buf, buf_add_ui32(channels_read_media_period_));
	}
	//parse argument tmp_sessions (int)
	if (tmp_sessions_)
	{
		buf = buf_cat(buf, buf_add_ui32(tmp_sessions_));
		*flag1 |= (1 << 0);
	}
	//parse argument call_receive_timeout_ms (int)
	{
		buf = buf_cat(buf, buf_add_ui32(call_receive_timeout_ms_));
	}
	//parse argument call_ring_timeout_ms (int)
	{
		buf = buf_cat(buf, buf_add_ui32(call_ring_timeout_ms_));
	}
	//parse argument call_connect_timeout_ms (int)
	{
		buf = buf_cat(buf, buf_add_ui32(call_connect_timeout_ms_));
	}
	//parse argument call_packet_timeout_ms (int)
	{
		buf = buf_cat(buf, buf_add_ui32(call_packet_timeout_ms_));
	}
	//parse argument me_url_prefix (string)
	{
		buf = buf_cat(buf, serialize_string(me_url_prefix_));
	}
	//parse argument autoupdate_url_prefix (string)
	if (autoupdate_url_prefix_)
	{
		buf = buf_cat(buf, serialize_string(autoupdate_url_prefix_));
		*flag1 |= (1 << 7);
	}
	//parse argument gif_search_username (string)
	if (gif_search_username_)
	{
		buf = buf_cat(buf, serialize_string(gif_search_username_));
		*flag1 |= (1 << 9);
	}
	//parse argument venue_search_username (string)
	if (venue_search_username_)
	{
		buf = buf_cat(buf, serialize_string(venue_search_username_));
		*flag1 |= (1 << 10);
	}
	//parse argument img_search_username (string)
	if (img_search_username_)
	{
		buf = buf_cat(buf, serialize_string(img_search_username_));
		*flag1 |= (1 << 11);
	}
	//parse argument static_maps_provider (string)
	if (static_maps_provider_)
	{
		buf = buf_cat(buf, serialize_string(static_maps_provider_));
		*flag1 |= (1 << 12);
	}
	//parse argument caption_length_max (int)
	{
		buf = buf_cat(buf, buf_add_ui32(caption_length_max_));
	}
	//parse argument message_length_max (int)
	{
		buf = buf_cat(buf, buf_add_ui32(message_length_max_));
	}
	//parse argument webfile_dc_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(webfile_dc_id_));
	}
	//parse argument suggested_lang_code (string)
	if (suggested_lang_code_)
	{
		buf = buf_cat(buf, serialize_string(suggested_lang_code_));
		*flag1 |= (1 << 2);
	}
	//parse argument lang_pack_version (int)
	if (lang_pack_version_)
	{
		buf = buf_cat(buf, buf_add_ui32(lang_pack_version_));
		*flag1 |= (1 << 2);
	}
	//parse argument base_lang_pack_version (int)
	if (base_lang_pack_version_)
	{
		buf = buf_cat(buf, buf_add_ui32(base_lang_pack_version_));
		*flag1 |= (1 << 2);
	}
	//parse argument reactions_default (Reaction)
	if (reactions_default_)
	{
		buf = buf_cat(buf, *reactions_default_);
		*flag1 |= (1 << 15);
	}
	//parse argument autologin_token (string)
	if (autologin_token_)
	{
		buf = buf_cat(buf, serialize_string(autologin_token_));
		*flag1 |= (1 << 16);
	}
	return buf;
}

buf_t tl_nearestDc(const char * country_, int this_dc_, int nearest_dc_)
{
	buf_t buf = buf_add_ui32(0x8e1a1775);
	//parse argument country (string)
	{
		buf = buf_cat(buf, serialize_string(country_));
	}
	//parse argument this_dc (int)
	{
		buf = buf_cat(buf, buf_add_ui32(this_dc_));
	}
	//parse argument nearest_dc (int)
	{
		buf = buf_cat(buf, buf_add_ui32(nearest_dc_));
	}
	return buf;
}

buf_t tl_help_appUpdate(bool can_not_skip_, int id_, const char * version_, const char * text_, MessageEntity *entities_, int entities_len, Document *document_, const char * url_, Document *sticker_)
{
	buf_t buf = buf_add_ui32(0xccbbce30);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument can_not_skip (true)
	if (can_not_skip_)
		*flag1 |= (1 << 0);
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument version (string)
	{
		buf = buf_cat(buf, serialize_string(version_));
	}
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	//parse argument entities (Vector<MessageEntity>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(entities_len));
		int i;
		for (i=0; i<entities_len; ++i){
			buf = buf_cat(buf, entities_[i]);
		}
	}
	//parse argument document (Document)
	if (document_)
	{
		buf = buf_cat(buf, *document_);
		*flag1 |= (1 << 1);
	}
	//parse argument url (string)
	if (url_)
	{
		buf = buf_cat(buf, serialize_string(url_));
		*flag1 |= (1 << 2);
	}
	//parse argument sticker (Document)
	if (sticker_)
	{
		buf = buf_cat(buf, *sticker_);
		*flag1 |= (1 << 3);
	}
	return buf;
}

buf_t tl_help_noAppUpdate()
{
	buf_t buf = buf_add_ui32(0xc45a6536);
	return buf;
}

buf_t tl_help_inviteText(const char * message_)
{
	buf_t buf = buf_add_ui32(0x18cb9f78);
	//parse argument message (string)
	{
		buf = buf_cat(buf, serialize_string(message_));
	}
	return buf;
}

buf_t tl_encryptedChatEmpty(int id_)
{
	buf_t buf = buf_add_ui32(0xab7ec0a0);
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	return buf;
}

buf_t tl_encryptedChatWaiting(int id_, long access_hash_, int date_, long admin_id_, long participant_id_)
{
	buf_t buf = buf_add_ui32(0x66b25953);
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument admin_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(admin_id_));
	}
	//parse argument participant_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(participant_id_));
	}
	return buf;
}

buf_t tl_encryptedChatRequested(int folder_id_, int id_, long access_hash_, int date_, long admin_id_, long participant_id_, buf_t *g_a_)
{
	buf_t buf = buf_add_ui32(0x48f1d94c);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument folder_id (int)
	if (folder_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(folder_id_));
		*flag1 |= (1 << 0);
	}
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument admin_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(admin_id_));
	}
	//parse argument participant_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(participant_id_));
	}
	//parse argument g_a (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(g_a_->data, g_a_->size));
	}
	return buf;
}

buf_t tl_encryptedChat(int id_, long access_hash_, int date_, long admin_id_, long participant_id_, buf_t *g_a_or_b_, long key_fingerprint_)
{
	buf_t buf = buf_add_ui32(0x61f0d4c7);
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument admin_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(admin_id_));
	}
	//parse argument participant_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(participant_id_));
	}
	//parse argument g_a_or_b (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(g_a_or_b_->data, g_a_or_b_->size));
	}
	//parse argument key_fingerprint (long)
	{
		buf = buf_cat(buf, buf_add_ui64(key_fingerprint_));
	}
	return buf;
}

buf_t tl_encryptedChatDiscarded(bool history_deleted_, int id_)
{
	buf_t buf = buf_add_ui32(0x1e1c7c45);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument history_deleted (true)
	if (history_deleted_)
		*flag1 |= (1 << 0);
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	return buf;
}

buf_t tl_inputEncryptedChat(int chat_id_, long access_hash_)
{
	buf_t buf = buf_add_ui32(0xf141b5e1);
	//parse argument chat_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(chat_id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	return buf;
}

buf_t tl_encryptedFileEmpty()
{
	buf_t buf = buf_add_ui32(0xc21f497e);
	return buf;
}

buf_t tl_encryptedFile(long id_, long access_hash_, long size_, int dc_id_, int key_fingerprint_)
{
	buf_t buf = buf_add_ui32(0xa8008cd8);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	//parse argument size (long)
	{
		buf = buf_cat(buf, buf_add_ui64(size_));
	}
	//parse argument dc_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(dc_id_));
	}
	//parse argument key_fingerprint (int)
	{
		buf = buf_cat(buf, buf_add_ui32(key_fingerprint_));
	}
	return buf;
}

buf_t tl_inputEncryptedFileEmpty()
{
	buf_t buf = buf_add_ui32(0x1837c364);
	return buf;
}

buf_t tl_inputEncryptedFileUploaded(long id_, int parts_, const char * md5_checksum_, int key_fingerprint_)
{
	buf_t buf = buf_add_ui32(0x64bd0306);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument parts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(parts_));
	}
	//parse argument md5_checksum (string)
	{
		buf = buf_cat(buf, serialize_string(md5_checksum_));
	}
	//parse argument key_fingerprint (int)
	{
		buf = buf_cat(buf, buf_add_ui32(key_fingerprint_));
	}
	return buf;
}

buf_t tl_inputEncryptedFile(long id_, long access_hash_)
{
	buf_t buf = buf_add_ui32(0x5a17b5e5);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	return buf;
}

buf_t tl_inputEncryptedFileBigUploaded(long id_, int parts_, int key_fingerprint_)
{
	buf_t buf = buf_add_ui32(0x2dc173c8);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument parts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(parts_));
	}
	//parse argument key_fingerprint (int)
	{
		buf = buf_cat(buf, buf_add_ui32(key_fingerprint_));
	}
	return buf;
}

buf_t tl_encryptedMessage(long random_id_, int chat_id_, int date_, buf_t *bytes_, EncryptedFile *file_)
{
	buf_t buf = buf_add_ui32(0xed18c118);
	//parse argument random_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(random_id_));
	}
	//parse argument chat_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(chat_id_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument bytes (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(bytes_->data, bytes_->size));
	}
	//parse argument file (EncryptedFile)
	{
		buf = buf_cat(buf, *file_);
	}
	return buf;
}

buf_t tl_encryptedMessageService(long random_id_, int chat_id_, int date_, buf_t *bytes_)
{
	buf_t buf = buf_add_ui32(0x23734b06);
	//parse argument random_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(random_id_));
	}
	//parse argument chat_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(chat_id_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument bytes (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(bytes_->data, bytes_->size));
	}
	return buf;
}

buf_t tl_messages_dhConfigNotModified(buf_t *random_)
{
	buf_t buf = buf_add_ui32(0xc0e24635);
	//parse argument random (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(random_->data, random_->size));
	}
	return buf;
}

buf_t tl_messages_dhConfig(int g_, buf_t *p_, int version_, buf_t *random_)
{
	buf_t buf = buf_add_ui32(0x2c221edd);
	//parse argument g (int)
	{
		buf = buf_cat(buf, buf_add_ui32(g_));
	}
	//parse argument p (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(p_->data, p_->size));
	}
	//parse argument version (int)
	{
		buf = buf_cat(buf, buf_add_ui32(version_));
	}
	//parse argument random (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(random_->data, random_->size));
	}
	return buf;
}

buf_t tl_messages_sentEncryptedMessage(int date_)
{
	buf_t buf = buf_add_ui32(0x560f8935);
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	return buf;
}

buf_t tl_messages_sentEncryptedFile(int date_, EncryptedFile *file_)
{
	buf_t buf = buf_add_ui32(0x9493ff32);
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument file (EncryptedFile)
	{
		buf = buf_cat(buf, *file_);
	}
	return buf;
}

buf_t tl_inputDocumentEmpty()
{
	buf_t buf = buf_add_ui32(0x72f0eaae);
	return buf;
}

buf_t tl_inputDocument(long id_, long access_hash_, buf_t *file_reference_)
{
	buf_t buf = buf_add_ui32(0x1abfb575);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	//parse argument file_reference (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(file_reference_->data, file_reference_->size));
	}
	return buf;
}

buf_t tl_documentEmpty(long id_)
{
	buf_t buf = buf_add_ui32(0x36f8c871);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	return buf;
}

buf_t tl_document(long id_, long access_hash_, buf_t *file_reference_, int date_, const char * mime_type_, long size_, PhotoSize *thumbs_, int thumbs_len, VideoSize *video_thumbs_, int video_thumbs_len, int dc_id_, DocumentAttribute *attributes_, int attributes_len)
{
	buf_t buf = buf_add_ui32(0x8fd4c4d8);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	//parse argument file_reference (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(file_reference_->data, file_reference_->size));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument mime_type (string)
	{
		buf = buf_cat(buf, serialize_string(mime_type_));
	}
	//parse argument size (long)
	{
		buf = buf_cat(buf, buf_add_ui64(size_));
	}
	//parse argument thumbs (Vector<PhotoSize>)
	if (thumbs_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(thumbs_len));
		int i;
		for (i=0; i<thumbs_len; ++i){
			buf = buf_cat(buf, thumbs_[i]);
		}
		*flag1 |= (1 << 0);
	}
	//parse argument video_thumbs (Vector<VideoSize>)
	if (video_thumbs_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(video_thumbs_len));
		int i;
		for (i=0; i<video_thumbs_len; ++i){
			buf = buf_cat(buf, video_thumbs_[i]);
		}
		*flag1 |= (1 << 1);
	}
	//parse argument dc_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(dc_id_));
	}
	//parse argument attributes (Vector<DocumentAttribute>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(attributes_len));
		int i;
		for (i=0; i<attributes_len; ++i){
			buf = buf_cat(buf, attributes_[i]);
		}
	}
	return buf;
}

buf_t tl_help_support(const char * phone_number_, User *user_)
{
	buf_t buf = buf_add_ui32(0x17c6b5f6);
	//parse argument phone_number (string)
	{
		buf = buf_cat(buf, serialize_string(phone_number_));
	}
	//parse argument user (User)
	{
		buf = buf_cat(buf, *user_);
	}
	return buf;
}

buf_t tl_notifyPeer(Peer *peer_)
{
	buf_t buf = buf_add_ui32(0x9fd40bd8);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_notifyUsers()
{
	buf_t buf = buf_add_ui32(0xb4c83b4c);
	return buf;
}

buf_t tl_notifyChats()
{
	buf_t buf = buf_add_ui32(0xc007cec3);
	return buf;
}

buf_t tl_notifyBroadcasts()
{
	buf_t buf = buf_add_ui32(0xd612e8ef);
	return buf;
}

buf_t tl_notifyForumTopic(Peer *peer_, int top_msg_id_)
{
	buf_t buf = buf_add_ui32(0x226e6308);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument top_msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(top_msg_id_));
	}
	return buf;
}

buf_t tl_sendMessageTypingAction()
{
	buf_t buf = buf_add_ui32(0x16bf744e);
	return buf;
}

buf_t tl_sendMessageCancelAction()
{
	buf_t buf = buf_add_ui32(0xfd5ec8f5);
	return buf;
}

buf_t tl_sendMessageRecordVideoAction()
{
	buf_t buf = buf_add_ui32(0xa187d66f);
	return buf;
}

buf_t tl_sendMessageUploadVideoAction(int progress_)
{
	buf_t buf = buf_add_ui32(0xe9763aec);
	//parse argument progress (int)
	{
		buf = buf_cat(buf, buf_add_ui32(progress_));
	}
	return buf;
}

buf_t tl_sendMessageRecordAudioAction()
{
	buf_t buf = buf_add_ui32(0xd52f73f7);
	return buf;
}

buf_t tl_sendMessageUploadAudioAction(int progress_)
{
	buf_t buf = buf_add_ui32(0xf351d7ab);
	//parse argument progress (int)
	{
		buf = buf_cat(buf, buf_add_ui32(progress_));
	}
	return buf;
}

buf_t tl_sendMessageUploadPhotoAction(int progress_)
{
	buf_t buf = buf_add_ui32(0xd1d34a26);
	//parse argument progress (int)
	{
		buf = buf_cat(buf, buf_add_ui32(progress_));
	}
	return buf;
}

buf_t tl_sendMessageUploadDocumentAction(int progress_)
{
	buf_t buf = buf_add_ui32(0xaa0cd9e4);
	//parse argument progress (int)
	{
		buf = buf_cat(buf, buf_add_ui32(progress_));
	}
	return buf;
}

buf_t tl_sendMessageGeoLocationAction()
{
	buf_t buf = buf_add_ui32(0x176f8ba1);
	return buf;
}

buf_t tl_sendMessageChooseContactAction()
{
	buf_t buf = buf_add_ui32(0x628cbc6f);
	return buf;
}

buf_t tl_sendMessageGamePlayAction()
{
	buf_t buf = buf_add_ui32(0xdd6a8f48);
	return buf;
}

buf_t tl_sendMessageRecordRoundAction()
{
	buf_t buf = buf_add_ui32(0x88f27fbc);
	return buf;
}

buf_t tl_sendMessageUploadRoundAction(int progress_)
{
	buf_t buf = buf_add_ui32(0x243e1c66);
	//parse argument progress (int)
	{
		buf = buf_cat(buf, buf_add_ui32(progress_));
	}
	return buf;
}

buf_t tl_speakingInGroupCallAction()
{
	buf_t buf = buf_add_ui32(0xd92c2285);
	return buf;
}

buf_t tl_sendMessageHistoryImportAction(int progress_)
{
	buf_t buf = buf_add_ui32(0xdbda9246);
	//parse argument progress (int)
	{
		buf = buf_cat(buf, buf_add_ui32(progress_));
	}
	return buf;
}

buf_t tl_sendMessageChooseStickerAction()
{
	buf_t buf = buf_add_ui32(0xb05ac6b1);
	return buf;
}

buf_t tl_sendMessageEmojiInteraction(const char * emoticon_, int msg_id_, DataJSON *interaction_)
{
	buf_t buf = buf_add_ui32(0x25972bcb);
	//parse argument emoticon (string)
	{
		buf = buf_cat(buf, serialize_string(emoticon_));
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	//parse argument interaction (DataJSON)
	{
		buf = buf_cat(buf, *interaction_);
	}
	return buf;
}

buf_t tl_sendMessageEmojiInteractionSeen(const char * emoticon_)
{
	buf_t buf = buf_add_ui32(0xb665902e);
	//parse argument emoticon (string)
	{
		buf = buf_cat(buf, serialize_string(emoticon_));
	}
	return buf;
}

buf_t tl_contacts_found(Peer *my_results_, int my_results_len, Peer *results_, int results_len, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0xb3134d9d);
	//parse argument my_results (Vector<Peer>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(my_results_len));
		int i;
		for (i=0; i<my_results_len; ++i){
			buf = buf_cat(buf, my_results_[i]);
		}
	}
	//parse argument results (Vector<Peer>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(results_len));
		int i;
		for (i=0; i<results_len; ++i){
			buf = buf_cat(buf, results_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_inputPrivacyKeyStatusTimestamp()
{
	buf_t buf = buf_add_ui32(0x4f96cb18);
	return buf;
}

buf_t tl_inputPrivacyKeyChatInvite()
{
	buf_t buf = buf_add_ui32(0xbdfb0426);
	return buf;
}

buf_t tl_inputPrivacyKeyPhoneCall()
{
	buf_t buf = buf_add_ui32(0xfabadc5f);
	return buf;
}

buf_t tl_inputPrivacyKeyPhoneP2P()
{
	buf_t buf = buf_add_ui32(0xdb9e70d2);
	return buf;
}

buf_t tl_inputPrivacyKeyForwards()
{
	buf_t buf = buf_add_ui32(0xa4dd4c08);
	return buf;
}

buf_t tl_inputPrivacyKeyProfilePhoto()
{
	buf_t buf = buf_add_ui32(0x5719bacc);
	return buf;
}

buf_t tl_inputPrivacyKeyPhoneNumber()
{
	buf_t buf = buf_add_ui32(0x0352dafa);
	return buf;
}

buf_t tl_inputPrivacyKeyAddedByPhone()
{
	buf_t buf = buf_add_ui32(0xd1219bdd);
	return buf;
}

buf_t tl_inputPrivacyKeyVoiceMessages()
{
	buf_t buf = buf_add_ui32(0xaee69d68);
	return buf;
}

buf_t tl_inputPrivacyKeyAbout()
{
	buf_t buf = buf_add_ui32(0x3823cc40);
	return buf;
}

buf_t tl_inputPrivacyKeyBirthday()
{
	buf_t buf = buf_add_ui32(0xd65a11cc);
	return buf;
}

buf_t tl_privacyKeyStatusTimestamp()
{
	buf_t buf = buf_add_ui32(0xbc2eab30);
	return buf;
}

buf_t tl_privacyKeyChatInvite()
{
	buf_t buf = buf_add_ui32(0x500e6dfa);
	return buf;
}

buf_t tl_privacyKeyPhoneCall()
{
	buf_t buf = buf_add_ui32(0x3d662b7b);
	return buf;
}

buf_t tl_privacyKeyPhoneP2P()
{
	buf_t buf = buf_add_ui32(0x39491cc8);
	return buf;
}

buf_t tl_privacyKeyForwards()
{
	buf_t buf = buf_add_ui32(0x69ec56a3);
	return buf;
}

buf_t tl_privacyKeyProfilePhoto()
{
	buf_t buf = buf_add_ui32(0x96151fed);
	return buf;
}

buf_t tl_privacyKeyPhoneNumber()
{
	buf_t buf = buf_add_ui32(0xd19ae46d);
	return buf;
}

buf_t tl_privacyKeyAddedByPhone()
{
	buf_t buf = buf_add_ui32(0x42ffd42b);
	return buf;
}

buf_t tl_privacyKeyVoiceMessages()
{
	buf_t buf = buf_add_ui32(0x0697f414);
	return buf;
}

buf_t tl_privacyKeyAbout()
{
	buf_t buf = buf_add_ui32(0xa486b761);
	return buf;
}

buf_t tl_privacyKeyBirthday()
{
	buf_t buf = buf_add_ui32(0x2000a518);
	return buf;
}

buf_t tl_inputPrivacyValueAllowContacts()
{
	buf_t buf = buf_add_ui32(0x0d09e07b);
	return buf;
}

buf_t tl_inputPrivacyValueAllowAll()
{
	buf_t buf = buf_add_ui32(0x184b35ce);
	return buf;
}

buf_t tl_inputPrivacyValueAllowUsers(InputUser *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x131cc67f);
	//parse argument users (Vector<InputUser>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_inputPrivacyValueDisallowContacts()
{
	buf_t buf = buf_add_ui32(0x0ba52007);
	return buf;
}

buf_t tl_inputPrivacyValueDisallowAll()
{
	buf_t buf = buf_add_ui32(0xd66b66c9);
	return buf;
}

buf_t tl_inputPrivacyValueDisallowUsers(InputUser *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x90110467);
	//parse argument users (Vector<InputUser>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_inputPrivacyValueAllowChatParticipants(long *chats_, int chats_len)
{
	buf_t buf = buf_add_ui32(0x840649cf);
	//parse argument chats (Vector<long>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(chats_[i]));
		}
	}
	return buf;
}

buf_t tl_inputPrivacyValueDisallowChatParticipants(long *chats_, int chats_len)
{
	buf_t buf = buf_add_ui32(0xe94f0f86);
	//parse argument chats (Vector<long>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(chats_[i]));
		}
	}
	return buf;
}

buf_t tl_inputPrivacyValueAllowCloseFriends()
{
	buf_t buf = buf_add_ui32(0x2f453e49);
	return buf;
}

buf_t tl_inputPrivacyValueAllowPremium()
{
	buf_t buf = buf_add_ui32(0x77cdc9f1);
	return buf;
}

buf_t tl_privacyValueAllowContacts()
{
	buf_t buf = buf_add_ui32(0xfffe1bac);
	return buf;
}

buf_t tl_privacyValueAllowAll()
{
	buf_t buf = buf_add_ui32(0x65427b82);
	return buf;
}

buf_t tl_privacyValueAllowUsers(long *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0xb8905fb2);
	//parse argument users (Vector<long>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(users_[i]));
		}
	}
	return buf;
}

buf_t tl_privacyValueDisallowContacts()
{
	buf_t buf = buf_add_ui32(0xf888fa1a);
	return buf;
}

buf_t tl_privacyValueDisallowAll()
{
	buf_t buf = buf_add_ui32(0x8b73e763);
	return buf;
}

buf_t tl_privacyValueDisallowUsers(long *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0xe4621141);
	//parse argument users (Vector<long>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(users_[i]));
		}
	}
	return buf;
}

buf_t tl_privacyValueAllowChatParticipants(long *chats_, int chats_len)
{
	buf_t buf = buf_add_ui32(0x6b134e8e);
	//parse argument chats (Vector<long>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(chats_[i]));
		}
	}
	return buf;
}

buf_t tl_privacyValueDisallowChatParticipants(long *chats_, int chats_len)
{
	buf_t buf = buf_add_ui32(0x41c87565);
	//parse argument chats (Vector<long>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(chats_[i]));
		}
	}
	return buf;
}

buf_t tl_privacyValueAllowCloseFriends()
{
	buf_t buf = buf_add_ui32(0xf7e8d89b);
	return buf;
}

buf_t tl_privacyValueAllowPremium()
{
	buf_t buf = buf_add_ui32(0xece9814b);
	return buf;
}

buf_t tl_account_privacyRules(PrivacyRule *rules_, int rules_len, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x50a04e45);
	//parse argument rules (Vector<PrivacyRule>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(rules_len));
		int i;
		for (i=0; i<rules_len; ++i){
			buf = buf_cat(buf, rules_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_accountDaysTTL(int days_)
{
	buf_t buf = buf_add_ui32(0xb8d0afdf);
	//parse argument days (int)
	{
		buf = buf_cat(buf, buf_add_ui32(days_));
	}
	return buf;
}

buf_t tl_documentAttributeImageSize(int w_, int h_)
{
	buf_t buf = buf_add_ui32(0x6c37c15c);
	//parse argument w (int)
	{
		buf = buf_cat(buf, buf_add_ui32(w_));
	}
	//parse argument h (int)
	{
		buf = buf_cat(buf, buf_add_ui32(h_));
	}
	return buf;
}

buf_t tl_documentAttributeAnimated()
{
	buf_t buf = buf_add_ui32(0x11b58939);
	return buf;
}

buf_t tl_documentAttributeSticker(bool mask_, const char * alt_, InputStickerSet *stickerset_, MaskCoords *mask_coords_)
{
	buf_t buf = buf_add_ui32(0x6319d612);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument mask (true)
	if (mask_)
		*flag1 |= (1 << 1);
	//parse argument alt (string)
	{
		buf = buf_cat(buf, serialize_string(alt_));
	}
	//parse argument stickerset (InputStickerSet)
	{
		buf = buf_cat(buf, *stickerset_);
	}
	//parse argument mask_coords (MaskCoords)
	if (mask_coords_)
	{
		buf = buf_cat(buf, *mask_coords_);
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_documentAttributeVideo(bool round_message_, bool supports_streaming_, bool nosound_, double duration_, int w_, int h_, int preload_prefix_size_, double video_start_ts_, const char * video_codec_)
{
	buf_t buf = buf_add_ui32(0x43c57c48);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument round_message (true)
	if (round_message_)
		*flag1 |= (1 << 0);
	//parse argument supports_streaming (true)
	if (supports_streaming_)
		*flag1 |= (1 << 1);
	//parse argument nosound (true)
	if (nosound_)
		*flag1 |= (1 << 3);
	//parse argument duration (double)
	{
		buf = buf_cat(buf, buf_add_ui64(duration_));
	}
	//parse argument w (int)
	{
		buf = buf_cat(buf, buf_add_ui32(w_));
	}
	//parse argument h (int)
	{
		buf = buf_cat(buf, buf_add_ui32(h_));
	}
	//parse argument preload_prefix_size (int)
	if (preload_prefix_size_)
	{
		buf = buf_cat(buf, buf_add_ui32(preload_prefix_size_));
		*flag1 |= (1 << 2);
	}
	//parse argument video_start_ts (double)
	if (video_start_ts_)
	{
		buf = buf_cat(buf, buf_add_ui64(video_start_ts_));
		*flag1 |= (1 << 4);
	}
	//parse argument video_codec (string)
	if (video_codec_)
	{
		buf = buf_cat(buf, serialize_string(video_codec_));
		*flag1 |= (1 << 5);
	}
	return buf;
}

buf_t tl_documentAttributeAudio(bool voice_, int duration_, const char * title_, const char * performer_, buf_t *waveform_)
{
	buf_t buf = buf_add_ui32(0x9852f9c6);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument voice (true)
	if (voice_)
		*flag1 |= (1 << 10);
	//parse argument duration (int)
	{
		buf = buf_cat(buf, buf_add_ui32(duration_));
	}
	//parse argument title (string)
	if (title_)
	{
		buf = buf_cat(buf, serialize_string(title_));
		*flag1 |= (1 << 0);
	}
	//parse argument performer (string)
	if (performer_)
	{
		buf = buf_cat(buf, serialize_string(performer_));
		*flag1 |= (1 << 1);
	}
	//parse argument waveform (bytes)
	if (waveform_)
	{
		buf = buf_cat(buf, serialize_bytes(waveform_->data, waveform_->size));
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_documentAttributeFilename(const char * file_name_)
{
	buf_t buf = buf_add_ui32(0x15590068);
	//parse argument file_name (string)
	{
		buf = buf_cat(buf, serialize_string(file_name_));
	}
	return buf;
}

buf_t tl_documentAttributeHasStickers()
{
	buf_t buf = buf_add_ui32(0x9801d2f7);
	return buf;
}

buf_t tl_documentAttributeCustomEmoji(bool free_, bool text_color_, const char * alt_, InputStickerSet *stickerset_)
{
	buf_t buf = buf_add_ui32(0xfd149899);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument free (true)
	if (free_)
		*flag1 |= (1 << 0);
	//parse argument text_color (true)
	if (text_color_)
		*flag1 |= (1 << 1);
	//parse argument alt (string)
	{
		buf = buf_cat(buf, serialize_string(alt_));
	}
	//parse argument stickerset (InputStickerSet)
	{
		buf = buf_cat(buf, *stickerset_);
	}
	return buf;
}

buf_t tl_messages_stickersNotModified()
{
	buf_t buf = buf_add_ui32(0xf1749a22);
	return buf;
}

buf_t tl_messages_stickers(long hash_, Document *stickers_, int stickers_len)
{
	buf_t buf = buf_add_ui32(0x30a6ec7e);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	//parse argument stickers (Vector<Document>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(stickers_len));
		int i;
		for (i=0; i<stickers_len; ++i){
			buf = buf_cat(buf, stickers_[i]);
		}
	}
	return buf;
}

buf_t tl_stickerPack(const char * emoticon_, long *documents_, int documents_len)
{
	buf_t buf = buf_add_ui32(0x12b299d4);
	//parse argument emoticon (string)
	{
		buf = buf_cat(buf, serialize_string(emoticon_));
	}
	//parse argument documents (Vector<long>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(documents_len));
		int i;
		for (i=0; i<documents_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(documents_[i]));
		}
	}
	return buf;
}

buf_t tl_messages_allStickersNotModified()
{
	buf_t buf = buf_add_ui32(0xe86602c3);
	return buf;
}

buf_t tl_messages_allStickers(long hash_, StickerSet *sets_, int sets_len)
{
	buf_t buf = buf_add_ui32(0xcdbbcebb);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	//parse argument sets (Vector<StickerSet>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(sets_len));
		int i;
		for (i=0; i<sets_len; ++i){
			buf = buf_cat(buf, sets_[i]);
		}
	}
	return buf;
}

buf_t tl_messages_affectedMessages(int pts_, int pts_count_)
{
	buf_t buf = buf_add_ui32(0x84d19185);
	//parse argument pts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_));
	}
	//parse argument pts_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_count_));
	}
	return buf;
}

buf_t tl_webPageEmpty(long id_, const char * url_)
{
	buf_t buf = buf_add_ui32(0x211a1788);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument url (string)
	if (url_)
	{
		buf = buf_cat(buf, serialize_string(url_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_webPagePending(long id_, const char * url_, int date_)
{
	buf_t buf = buf_add_ui32(0xb0d13e47);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument url (string)
	if (url_)
	{
		buf = buf_cat(buf, serialize_string(url_));
		*flag1 |= (1 << 0);
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	return buf;
}

buf_t tl_webPage(bool has_large_media_, long id_, const char * url_, const char * display_url_, int hash_, const char * type_, const char * site_name_, const char * title_, const char * description_, Photo *photo_, const char * embed_url_, const char * embed_type_, int embed_width_, int embed_height_, int duration_, const char * author_, Document *document_, Page *cached_page_, WebPageAttribute *attributes_, int attributes_len)
{
	buf_t buf = buf_add_ui32(0xe89c45b2);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument has_large_media (true)
	if (has_large_media_)
		*flag1 |= (1 << 13);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	//parse argument display_url (string)
	{
		buf = buf_cat(buf, serialize_string(display_url_));
	}
	//parse argument hash (int)
	{
		buf = buf_cat(buf, buf_add_ui32(hash_));
	}
	//parse argument type (string)
	if (type_)
	{
		buf = buf_cat(buf, serialize_string(type_));
		*flag1 |= (1 << 0);
	}
	//parse argument site_name (string)
	if (site_name_)
	{
		buf = buf_cat(buf, serialize_string(site_name_));
		*flag1 |= (1 << 1);
	}
	//parse argument title (string)
	if (title_)
	{
		buf = buf_cat(buf, serialize_string(title_));
		*flag1 |= (1 << 2);
	}
	//parse argument description (string)
	if (description_)
	{
		buf = buf_cat(buf, serialize_string(description_));
		*flag1 |= (1 << 3);
	}
	//parse argument photo (Photo)
	if (photo_)
	{
		buf = buf_cat(buf, *photo_);
		*flag1 |= (1 << 4);
	}
	//parse argument embed_url (string)
	if (embed_url_)
	{
		buf = buf_cat(buf, serialize_string(embed_url_));
		*flag1 |= (1 << 5);
	}
	//parse argument embed_type (string)
	if (embed_type_)
	{
		buf = buf_cat(buf, serialize_string(embed_type_));
		*flag1 |= (1 << 5);
	}
	//parse argument embed_width (int)
	if (embed_width_)
	{
		buf = buf_cat(buf, buf_add_ui32(embed_width_));
		*flag1 |= (1 << 6);
	}
	//parse argument embed_height (int)
	if (embed_height_)
	{
		buf = buf_cat(buf, buf_add_ui32(embed_height_));
		*flag1 |= (1 << 6);
	}
	//parse argument duration (int)
	if (duration_)
	{
		buf = buf_cat(buf, buf_add_ui32(duration_));
		*flag1 |= (1 << 7);
	}
	//parse argument author (string)
	if (author_)
	{
		buf = buf_cat(buf, serialize_string(author_));
		*flag1 |= (1 << 8);
	}
	//parse argument document (Document)
	if (document_)
	{
		buf = buf_cat(buf, *document_);
		*flag1 |= (1 << 9);
	}
	//parse argument cached_page (Page)
	if (cached_page_)
	{
		buf = buf_cat(buf, *cached_page_);
		*flag1 |= (1 << 10);
	}
	//parse argument attributes (Vector<WebPageAttribute>)
	if (attributes_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(attributes_len));
		int i;
		for (i=0; i<attributes_len; ++i){
			buf = buf_cat(buf, attributes_[i]);
		}
		*flag1 |= (1 << 12);
	}
	return buf;
}

buf_t tl_webPageNotModified(int cached_page_views_)
{
	buf_t buf = buf_add_ui32(0x7311ca11);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument cached_page_views (int)
	if (cached_page_views_)
	{
		buf = buf_cat(buf, buf_add_ui32(cached_page_views_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_authorization(bool current_, bool official_app_, bool password_pending_, bool encrypted_requests_disabled_, bool call_requests_disabled_, bool unconfirmed_, long hash_, const char * device_model_, const char * platform_, const char * system_version_, int api_id_, const char * app_name_, const char * app_version_, int date_created_, int date_active_, const char * ip_, const char * country_, const char * region_)
{
	buf_t buf = buf_add_ui32(0xad01d61d);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument current (true)
	if (current_)
		*flag1 |= (1 << 0);
	//parse argument official_app (true)
	if (official_app_)
		*flag1 |= (1 << 1);
	//parse argument password_pending (true)
	if (password_pending_)
		*flag1 |= (1 << 2);
	//parse argument encrypted_requests_disabled (true)
	if (encrypted_requests_disabled_)
		*flag1 |= (1 << 3);
	//parse argument call_requests_disabled (true)
	if (call_requests_disabled_)
		*flag1 |= (1 << 4);
	//parse argument unconfirmed (true)
	if (unconfirmed_)
		*flag1 |= (1 << 5);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	//parse argument device_model (string)
	{
		buf = buf_cat(buf, serialize_string(device_model_));
	}
	//parse argument platform (string)
	{
		buf = buf_cat(buf, serialize_string(platform_));
	}
	//parse argument system_version (string)
	{
		buf = buf_cat(buf, serialize_string(system_version_));
	}
	//parse argument api_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(api_id_));
	}
	//parse argument app_name (string)
	{
		buf = buf_cat(buf, serialize_string(app_name_));
	}
	//parse argument app_version (string)
	{
		buf = buf_cat(buf, serialize_string(app_version_));
	}
	//parse argument date_created (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_created_));
	}
	//parse argument date_active (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_active_));
	}
	//parse argument ip (string)
	{
		buf = buf_cat(buf, serialize_string(ip_));
	}
	//parse argument country (string)
	{
		buf = buf_cat(buf, serialize_string(country_));
	}
	//parse argument region (string)
	{
		buf = buf_cat(buf, serialize_string(region_));
	}
	return buf;
}

buf_t tl_account_authorizations(int authorization_ttl_days_, Authorization *authorizations_, int authorizations_len)
{
	buf_t buf = buf_add_ui32(0x4bff8ea0);
	//parse argument authorization_ttl_days (int)
	{
		buf = buf_cat(buf, buf_add_ui32(authorization_ttl_days_));
	}
	//parse argument authorizations (Vector<Authorization>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(authorizations_len));
		int i;
		for (i=0; i<authorizations_len; ++i){
			buf = buf_cat(buf, authorizations_[i]);
		}
	}
	return buf;
}

buf_t tl_account_password(bool has_recovery_, bool has_secure_values_, bool has_password_, PasswordKdfAlgo *current_algo_, buf_t *srp_B_, long srp_id_, const char * hint_, const char * email_unconfirmed_pattern_, PasswordKdfAlgo *new_algo_, SecurePasswordKdfAlgo *new_secure_algo_, buf_t *secure_random_, int pending_reset_date_, const char * login_email_pattern_)
{
	buf_t buf = buf_add_ui32(0x957b50fb);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument has_recovery (true)
	if (has_recovery_)
		*flag1 |= (1 << 0);
	//parse argument has_secure_values (true)
	if (has_secure_values_)
		*flag1 |= (1 << 1);
	//parse argument has_password (true)
	if (has_password_)
		*flag1 |= (1 << 2);
	//parse argument current_algo (PasswordKdfAlgo)
	if (current_algo_)
	{
		buf = buf_cat(buf, *current_algo_);
		*flag1 |= (1 << 2);
	}
	//parse argument srp_B (bytes)
	if (srp_B_)
	{
		buf = buf_cat(buf, serialize_bytes(srp_B_->data, srp_B_->size));
		*flag1 |= (1 << 2);
	}
	//parse argument srp_id (long)
	if (srp_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(srp_id_));
		*flag1 |= (1 << 2);
	}
	//parse argument hint (string)
	if (hint_)
	{
		buf = buf_cat(buf, serialize_string(hint_));
		*flag1 |= (1 << 3);
	}
	//parse argument email_unconfirmed_pattern (string)
	if (email_unconfirmed_pattern_)
	{
		buf = buf_cat(buf, serialize_string(email_unconfirmed_pattern_));
		*flag1 |= (1 << 4);
	}
	//parse argument new_algo (PasswordKdfAlgo)
	{
		buf = buf_cat(buf, *new_algo_);
	}
	//parse argument new_secure_algo (SecurePasswordKdfAlgo)
	{
		buf = buf_cat(buf, *new_secure_algo_);
	}
	//parse argument secure_random (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(secure_random_->data, secure_random_->size));
	}
	//parse argument pending_reset_date (int)
	if (pending_reset_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(pending_reset_date_));
		*flag1 |= (1 << 5);
	}
	//parse argument login_email_pattern (string)
	if (login_email_pattern_)
	{
		buf = buf_cat(buf, serialize_string(login_email_pattern_));
		*flag1 |= (1 << 6);
	}
	return buf;
}

buf_t tl_account_passwordSettings(const char * email_, SecureSecretSettings *secure_settings_)
{
	buf_t buf = buf_add_ui32(0x9a5c33e5);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument email (string)
	if (email_)
	{
		buf = buf_cat(buf, serialize_string(email_));
		*flag1 |= (1 << 0);
	}
	//parse argument secure_settings (SecureSecretSettings)
	if (secure_settings_)
	{
		buf = buf_cat(buf, *secure_settings_);
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_account_passwordInputSettings(PasswordKdfAlgo *new_algo_, buf_t *new_password_hash_, const char * hint_, const char * email_, SecureSecretSettings *new_secure_settings_)
{
	buf_t buf = buf_add_ui32(0xc23727c9);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument new_algo (PasswordKdfAlgo)
	if (new_algo_)
	{
		buf = buf_cat(buf, *new_algo_);
		*flag1 |= (1 << 0);
	}
	//parse argument new_password_hash (bytes)
	if (new_password_hash_)
	{
		buf = buf_cat(buf, serialize_bytes(new_password_hash_->data, new_password_hash_->size));
		*flag1 |= (1 << 0);
	}
	//parse argument hint (string)
	if (hint_)
	{
		buf = buf_cat(buf, serialize_string(hint_));
		*flag1 |= (1 << 0);
	}
	//parse argument email (string)
	if (email_)
	{
		buf = buf_cat(buf, serialize_string(email_));
		*flag1 |= (1 << 1);
	}
	//parse argument new_secure_settings (SecureSecretSettings)
	if (new_secure_settings_)
	{
		buf = buf_cat(buf, *new_secure_settings_);
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_auth_passwordRecovery(const char * email_pattern_)
{
	buf_t buf = buf_add_ui32(0x137948a5);
	//parse argument email_pattern (string)
	{
		buf = buf_cat(buf, serialize_string(email_pattern_));
	}
	return buf;
}

buf_t tl_receivedNotifyMessage(int id_, int flags_)
{
	buf_t buf = buf_add_ui32(0xa384b779);
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument flags (int)
	{
		buf = buf_cat(buf, buf_add_ui32(flags_));
	}
	return buf;
}

buf_t tl_chatInviteExported(bool revoked_, bool permanent_, bool request_needed_, const char * link_, long admin_id_, int date_, int start_date_, int expire_date_, int usage_limit_, int usage_, int requested_, int subscription_expired_, const char * title_, StarsSubscriptionPricing *subscription_pricing_)
{
	buf_t buf = buf_add_ui32(0xa22cbd96);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument revoked (true)
	if (revoked_)
		*flag1 |= (1 << 0);
	//parse argument permanent (true)
	if (permanent_)
		*flag1 |= (1 << 5);
	//parse argument request_needed (true)
	if (request_needed_)
		*flag1 |= (1 << 6);
	//parse argument link (string)
	{
		buf = buf_cat(buf, serialize_string(link_));
	}
	//parse argument admin_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(admin_id_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument start_date (int)
	if (start_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(start_date_));
		*flag1 |= (1 << 4);
	}
	//parse argument expire_date (int)
	if (expire_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(expire_date_));
		*flag1 |= (1 << 1);
	}
	//parse argument usage_limit (int)
	if (usage_limit_)
	{
		buf = buf_cat(buf, buf_add_ui32(usage_limit_));
		*flag1 |= (1 << 2);
	}
	//parse argument usage (int)
	if (usage_)
	{
		buf = buf_cat(buf, buf_add_ui32(usage_));
		*flag1 |= (1 << 3);
	}
	//parse argument requested (int)
	if (requested_)
	{
		buf = buf_cat(buf, buf_add_ui32(requested_));
		*flag1 |= (1 << 7);
	}
	//parse argument subscription_expired (int)
	if (subscription_expired_)
	{
		buf = buf_cat(buf, buf_add_ui32(subscription_expired_));
		*flag1 |= (1 << 10);
	}
	//parse argument title (string)
	if (title_)
	{
		buf = buf_cat(buf, serialize_string(title_));
		*flag1 |= (1 << 8);
	}
	//parse argument subscription_pricing (StarsSubscriptionPricing)
	if (subscription_pricing_)
	{
		buf = buf_cat(buf, *subscription_pricing_);
		*flag1 |= (1 << 9);
	}
	return buf;
}

buf_t tl_chatInvitePublicJoinRequests()
{
	buf_t buf = buf_add_ui32(0xed107ab7);
	return buf;
}

buf_t tl_chatInviteAlready(Chat *chat_)
{
	buf_t buf = buf_add_ui32(0x5a686d7c);
	//parse argument chat (Chat)
	{
		buf = buf_cat(buf, *chat_);
	}
	return buf;
}

buf_t tl_chatInvite(bool channel_, bool broadcast_, bool public_, bool megagroup_, bool request_needed_, bool verified_, bool scam_, bool fake_, bool can_refulfill_subscription_, const char * title_, const char * about_, Photo *photo_, int participants_count_, User *participants_, int participants_len, int color_, StarsSubscriptionPricing *subscription_pricing_, long subscription_form_id_)
{
	buf_t buf = buf_add_ui32(0xfe65389d);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument channel (true)
	if (channel_)
		*flag1 |= (1 << 0);
	//parse argument broadcast (true)
	if (broadcast_)
		*flag1 |= (1 << 1);
	//parse argument public (true)
	if (public_)
		*flag1 |= (1 << 2);
	//parse argument megagroup (true)
	if (megagroup_)
		*flag1 |= (1 << 3);
	//parse argument request_needed (true)
	if (request_needed_)
		*flag1 |= (1 << 6);
	//parse argument verified (true)
	if (verified_)
		*flag1 |= (1 << 7);
	//parse argument scam (true)
	if (scam_)
		*flag1 |= (1 << 8);
	//parse argument fake (true)
	if (fake_)
		*flag1 |= (1 << 9);
	//parse argument can_refulfill_subscription (true)
	if (can_refulfill_subscription_)
		*flag1 |= (1 << 11);
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument about (string)
	if (about_)
	{
		buf = buf_cat(buf, serialize_string(about_));
		*flag1 |= (1 << 5);
	}
	//parse argument photo (Photo)
	{
		buf = buf_cat(buf, *photo_);
	}
	//parse argument participants_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(participants_count_));
	}
	//parse argument participants (Vector<User>)
	if (participants_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(participants_len));
		int i;
		for (i=0; i<participants_len; ++i){
			buf = buf_cat(buf, participants_[i]);
		}
		*flag1 |= (1 << 4);
	}
	//parse argument color (int)
	{
		buf = buf_cat(buf, buf_add_ui32(color_));
	}
	//parse argument subscription_pricing (StarsSubscriptionPricing)
	if (subscription_pricing_)
	{
		buf = buf_cat(buf, *subscription_pricing_);
		*flag1 |= (1 << 10);
	}
	//parse argument subscription_form_id (long)
	if (subscription_form_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(subscription_form_id_));
		*flag1 |= (1 << 12);
	}
	return buf;
}

buf_t tl_chatInvitePeek(Chat *chat_, int expires_)
{
	buf_t buf = buf_add_ui32(0x61695cb0);
	//parse argument chat (Chat)
	{
		buf = buf_cat(buf, *chat_);
	}
	//parse argument expires (int)
	{
		buf = buf_cat(buf, buf_add_ui32(expires_));
	}
	return buf;
}

buf_t tl_inputStickerSetEmpty()
{
	buf_t buf = buf_add_ui32(0xffb62b95);
	return buf;
}

buf_t tl_inputStickerSetID(long id_, long access_hash_)
{
	buf_t buf = buf_add_ui32(0x9de7a269);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	return buf;
}

buf_t tl_inputStickerSetShortName(const char * short_name_)
{
	buf_t buf = buf_add_ui32(0x861cc8a0);
	//parse argument short_name (string)
	{
		buf = buf_cat(buf, serialize_string(short_name_));
	}
	return buf;
}

buf_t tl_inputStickerSetAnimatedEmoji()
{
	buf_t buf = buf_add_ui32(0x028703c8);
	return buf;
}

buf_t tl_inputStickerSetDice(const char * emoticon_)
{
	buf_t buf = buf_add_ui32(0xe67f520e);
	//parse argument emoticon (string)
	{
		buf = buf_cat(buf, serialize_string(emoticon_));
	}
	return buf;
}

buf_t tl_inputStickerSetAnimatedEmojiAnimations()
{
	buf_t buf = buf_add_ui32(0x0cde3739);
	return buf;
}

buf_t tl_inputStickerSetPremiumGifts()
{
	buf_t buf = buf_add_ui32(0xc88b3b02);
	return buf;
}

buf_t tl_inputStickerSetEmojiGenericAnimations()
{
	buf_t buf = buf_add_ui32(0x04c4d4ce);
	return buf;
}

buf_t tl_inputStickerSetEmojiDefaultStatuses()
{
	buf_t buf = buf_add_ui32(0x29d0f5ee);
	return buf;
}

buf_t tl_inputStickerSetEmojiDefaultTopicIcons()
{
	buf_t buf = buf_add_ui32(0x44c1f8e9);
	return buf;
}

buf_t tl_inputStickerSetEmojiChannelDefaultStatuses()
{
	buf_t buf = buf_add_ui32(0x49748553);
	return buf;
}

buf_t tl_stickerSet(bool archived_, bool official_, bool masks_, bool emojis_, bool text_color_, bool channel_emoji_status_, bool creator_, int installed_date_, long id_, long access_hash_, const char * title_, const char * short_name_, PhotoSize *thumbs_, int thumbs_len, int thumb_dc_id_, int thumb_version_, long thumb_document_id_, int count_, int hash_)
{
	buf_t buf = buf_add_ui32(0x2dd14edc);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument archived (true)
	if (archived_)
		*flag1 |= (1 << 1);
	//parse argument official (true)
	if (official_)
		*flag1 |= (1 << 2);
	//parse argument masks (true)
	if (masks_)
		*flag1 |= (1 << 3);
	//parse argument emojis (true)
	if (emojis_)
		*flag1 |= (1 << 7);
	//parse argument text_color (true)
	if (text_color_)
		*flag1 |= (1 << 9);
	//parse argument channel_emoji_status (true)
	if (channel_emoji_status_)
		*flag1 |= (1 << 10);
	//parse argument creator (true)
	if (creator_)
		*flag1 |= (1 << 11);
	//parse argument installed_date (int)
	if (installed_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(installed_date_));
		*flag1 |= (1 << 0);
	}
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument short_name (string)
	{
		buf = buf_cat(buf, serialize_string(short_name_));
	}
	//parse argument thumbs (Vector<PhotoSize>)
	if (thumbs_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(thumbs_len));
		int i;
		for (i=0; i<thumbs_len; ++i){
			buf = buf_cat(buf, thumbs_[i]);
		}
		*flag1 |= (1 << 4);
	}
	//parse argument thumb_dc_id (int)
	if (thumb_dc_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(thumb_dc_id_));
		*flag1 |= (1 << 4);
	}
	//parse argument thumb_version (int)
	if (thumb_version_)
	{
		buf = buf_cat(buf, buf_add_ui32(thumb_version_));
		*flag1 |= (1 << 4);
	}
	//parse argument thumb_document_id (long)
	if (thumb_document_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(thumb_document_id_));
		*flag1 |= (1 << 8);
	}
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	//parse argument hash (int)
	{
		buf = buf_cat(buf, buf_add_ui32(hash_));
	}
	return buf;
}

buf_t tl_messages_stickerSet(StickerSet *set_, StickerPack *packs_, int packs_len, StickerKeyword *keywords_, int keywords_len, Document *documents_, int documents_len)
{
	buf_t buf = buf_add_ui32(0x6e153f16);
	//parse argument set (StickerSet)
	{
		buf = buf_cat(buf, *set_);
	}
	//parse argument packs (Vector<StickerPack>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(packs_len));
		int i;
		for (i=0; i<packs_len; ++i){
			buf = buf_cat(buf, packs_[i]);
		}
	}
	//parse argument keywords (Vector<StickerKeyword>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(keywords_len));
		int i;
		for (i=0; i<keywords_len; ++i){
			buf = buf_cat(buf, keywords_[i]);
		}
	}
	//parse argument documents (Vector<Document>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(documents_len));
		int i;
		for (i=0; i<documents_len; ++i){
			buf = buf_cat(buf, documents_[i]);
		}
	}
	return buf;
}

buf_t tl_messages_stickerSetNotModified()
{
	buf_t buf = buf_add_ui32(0xd3f924eb);
	return buf;
}

buf_t tl_botCommand(const char * command_, const char * description_)
{
	buf_t buf = buf_add_ui32(0xc27ac8c7);
	//parse argument command (string)
	{
		buf = buf_cat(buf, serialize_string(command_));
	}
	//parse argument description (string)
	{
		buf = buf_cat(buf, serialize_string(description_));
	}
	return buf;
}

buf_t tl_botInfo(bool has_preview_medias_, long user_id_, const char * description_, Photo *description_photo_, Document *description_document_, BotCommand *commands_, int commands_len, BotMenuButton *menu_button_, const char * privacy_policy_url_)
{
	buf_t buf = buf_add_ui32(0x82437e74);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument has_preview_medias (true)
	if (has_preview_medias_)
		*flag1 |= (1 << 6);
	//parse argument user_id (long)
	if (user_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
		*flag1 |= (1 << 0);
	}
	//parse argument description (string)
	if (description_)
	{
		buf = buf_cat(buf, serialize_string(description_));
		*flag1 |= (1 << 1);
	}
	//parse argument description_photo (Photo)
	if (description_photo_)
	{
		buf = buf_cat(buf, *description_photo_);
		*flag1 |= (1 << 4);
	}
	//parse argument description_document (Document)
	if (description_document_)
	{
		buf = buf_cat(buf, *description_document_);
		*flag1 |= (1 << 5);
	}
	//parse argument commands (Vector<BotCommand>)
	if (commands_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(commands_len));
		int i;
		for (i=0; i<commands_len; ++i){
			buf = buf_cat(buf, commands_[i]);
		}
		*flag1 |= (1 << 2);
	}
	//parse argument menu_button (BotMenuButton)
	if (menu_button_)
	{
		buf = buf_cat(buf, *menu_button_);
		*flag1 |= (1 << 3);
	}
	//parse argument privacy_policy_url (string)
	if (privacy_policy_url_)
	{
		buf = buf_cat(buf, serialize_string(privacy_policy_url_));
		*flag1 |= (1 << 7);
	}
	return buf;
}

buf_t tl_keyboardButton(const char * text_)
{
	buf_t buf = buf_add_ui32(0xa2fa4880);
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	return buf;
}

buf_t tl_keyboardButtonUrl(const char * text_, const char * url_)
{
	buf_t buf = buf_add_ui32(0x258aff05);
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	return buf;
}

buf_t tl_keyboardButtonCallback(bool requires_password_, const char * text_, buf_t *data_)
{
	buf_t buf = buf_add_ui32(0x35bbdb6b);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument requires_password (true)
	if (requires_password_)
		*flag1 |= (1 << 0);
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	//parse argument data (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(data_->data, data_->size));
	}
	return buf;
}

buf_t tl_keyboardButtonRequestPhone(const char * text_)
{
	buf_t buf = buf_add_ui32(0xb16a6c29);
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	return buf;
}

buf_t tl_keyboardButtonRequestGeoLocation(const char * text_)
{
	buf_t buf = buf_add_ui32(0xfc796b3f);
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	return buf;
}

buf_t tl_keyboardButtonSwitchInline(bool same_peer_, const char * text_, const char * query_, InlineQueryPeerType *peer_types_, int peer_types_len)
{
	buf_t buf = buf_add_ui32(0x93b9fbb5);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument same_peer (true)
	if (same_peer_)
		*flag1 |= (1 << 0);
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	//parse argument query (string)
	{
		buf = buf_cat(buf, serialize_string(query_));
	}
	//parse argument peer_types (Vector<InlineQueryPeerType>)
	if (peer_types_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(peer_types_len));
		int i;
		for (i=0; i<peer_types_len; ++i){
			buf = buf_cat(buf, peer_types_[i]);
		}
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_keyboardButtonGame(const char * text_)
{
	buf_t buf = buf_add_ui32(0x50f41ccf);
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	return buf;
}

buf_t tl_keyboardButtonBuy(const char * text_)
{
	buf_t buf = buf_add_ui32(0xafd93fbb);
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	return buf;
}

buf_t tl_keyboardButtonUrlAuth(const char * text_, const char * fwd_text_, const char * url_, int button_id_)
{
	buf_t buf = buf_add_ui32(0x10b78d29);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	//parse argument fwd_text (string)
	if (fwd_text_)
	{
		buf = buf_cat(buf, serialize_string(fwd_text_));
		*flag1 |= (1 << 0);
	}
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	//parse argument button_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(button_id_));
	}
	return buf;
}

buf_t tl_inputKeyboardButtonUrlAuth(bool request_write_access_, const char * text_, const char * fwd_text_, const char * url_, InputUser *bot_)
{
	buf_t buf = buf_add_ui32(0xd02e7fd4);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument request_write_access (true)
	if (request_write_access_)
		*flag1 |= (1 << 0);
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	//parse argument fwd_text (string)
	if (fwd_text_)
	{
		buf = buf_cat(buf, serialize_string(fwd_text_));
		*flag1 |= (1 << 1);
	}
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	//parse argument bot (InputUser)
	{
		buf = buf_cat(buf, *bot_);
	}
	return buf;
}

buf_t tl_keyboardButtonRequestPoll(Bool *quiz_, const char * text_)
{
	buf_t buf = buf_add_ui32(0xbbc7515d);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument quiz (Bool)
	if (quiz_)
	{
		buf = buf_cat(buf, *quiz_);
		*flag1 |= (1 << 0);
	}
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	return buf;
}

buf_t tl_inputKeyboardButtonUserProfile(const char * text_, InputUser *user_id_)
{
	buf_t buf = buf_add_ui32(0xe988037b);
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	//parse argument user_id (InputUser)
	{
		buf = buf_cat(buf, *user_id_);
	}
	return buf;
}

buf_t tl_keyboardButtonUserProfile(const char * text_, long user_id_)
{
	buf_t buf = buf_add_ui32(0x308660c1);
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	return buf;
}

buf_t tl_keyboardButtonWebView(const char * text_, const char * url_)
{
	buf_t buf = buf_add_ui32(0x13767230);
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	return buf;
}

buf_t tl_keyboardButtonSimpleWebView(const char * text_, const char * url_)
{
	buf_t buf = buf_add_ui32(0xa0c0505c);
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	return buf;
}

buf_t tl_keyboardButtonRequestPeer(const char * text_, int button_id_, RequestPeerType *peer_type_, int max_quantity_)
{
	buf_t buf = buf_add_ui32(0x53d7bfd8);
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	//parse argument button_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(button_id_));
	}
	//parse argument peer_type (RequestPeerType)
	{
		buf = buf_cat(buf, *peer_type_);
	}
	//parse argument max_quantity (int)
	{
		buf = buf_cat(buf, buf_add_ui32(max_quantity_));
	}
	return buf;
}

buf_t tl_inputKeyboardButtonRequestPeer(bool name_requested_, bool username_requested_, bool photo_requested_, const char * text_, int button_id_, RequestPeerType *peer_type_, int max_quantity_)
{
	buf_t buf = buf_add_ui32(0xc9662d05);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument name_requested (true)
	if (name_requested_)
		*flag1 |= (1 << 0);
	//parse argument username_requested (true)
	if (username_requested_)
		*flag1 |= (1 << 1);
	//parse argument photo_requested (true)
	if (photo_requested_)
		*flag1 |= (1 << 2);
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	//parse argument button_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(button_id_));
	}
	//parse argument peer_type (RequestPeerType)
	{
		buf = buf_cat(buf, *peer_type_);
	}
	//parse argument max_quantity (int)
	{
		buf = buf_cat(buf, buf_add_ui32(max_quantity_));
	}
	return buf;
}

buf_t tl_keyboardButtonCopy(const char * text_, const char * copy_text_)
{
	buf_t buf = buf_add_ui32(0x75d2698e);
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	//parse argument copy_text (string)
	{
		buf = buf_cat(buf, serialize_string(copy_text_));
	}
	return buf;
}

buf_t tl_keyboardButtonRow(KeyboardButton *buttons_, int buttons_len)
{
	buf_t buf = buf_add_ui32(0x77608b83);
	//parse argument buttons (Vector<KeyboardButton>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(buttons_len));
		int i;
		for (i=0; i<buttons_len; ++i){
			buf = buf_cat(buf, buttons_[i]);
		}
	}
	return buf;
}

buf_t tl_replyKeyboardHide(bool selective_)
{
	buf_t buf = buf_add_ui32(0xa03e5b85);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument selective (true)
	if (selective_)
		*flag1 |= (1 << 2);
	return buf;
}

buf_t tl_replyKeyboardForceReply(bool single_use_, bool selective_, const char * placeholder_)
{
	buf_t buf = buf_add_ui32(0x86b40b08);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument single_use (true)
	if (single_use_)
		*flag1 |= (1 << 1);
	//parse argument selective (true)
	if (selective_)
		*flag1 |= (1 << 2);
	//parse argument placeholder (string)
	if (placeholder_)
	{
		buf = buf_cat(buf, serialize_string(placeholder_));
		*flag1 |= (1 << 3);
	}
	return buf;
}

buf_t tl_replyKeyboardMarkup(bool resize_, bool single_use_, bool selective_, bool persistent_, KeyboardButtonRow *rows_, int rows_len, const char * placeholder_)
{
	buf_t buf = buf_add_ui32(0x85dd99d1);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument resize (true)
	if (resize_)
		*flag1 |= (1 << 0);
	//parse argument single_use (true)
	if (single_use_)
		*flag1 |= (1 << 1);
	//parse argument selective (true)
	if (selective_)
		*flag1 |= (1 << 2);
	//parse argument persistent (true)
	if (persistent_)
		*flag1 |= (1 << 4);
	//parse argument rows (Vector<KeyboardButtonRow>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(rows_len));
		int i;
		for (i=0; i<rows_len; ++i){
			buf = buf_cat(buf, rows_[i]);
		}
	}
	//parse argument placeholder (string)
	if (placeholder_)
	{
		buf = buf_cat(buf, serialize_string(placeholder_));
		*flag1 |= (1 << 3);
	}
	return buf;
}

buf_t tl_replyInlineMarkup(KeyboardButtonRow *rows_, int rows_len)
{
	buf_t buf = buf_add_ui32(0x48a30254);
	//parse argument rows (Vector<KeyboardButtonRow>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(rows_len));
		int i;
		for (i=0; i<rows_len; ++i){
			buf = buf_cat(buf, rows_[i]);
		}
	}
	return buf;
}

buf_t tl_messageEntityUnknown(int offset_, int length_)
{
	buf_t buf = buf_add_ui32(0xbb92ba95);
	//parse argument offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_));
	}
	//parse argument length (int)
	{
		buf = buf_cat(buf, buf_add_ui32(length_));
	}
	return buf;
}

buf_t tl_messageEntityMention(int offset_, int length_)
{
	buf_t buf = buf_add_ui32(0xfa04579d);
	//parse argument offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_));
	}
	//parse argument length (int)
	{
		buf = buf_cat(buf, buf_add_ui32(length_));
	}
	return buf;
}

buf_t tl_messageEntityHashtag(int offset_, int length_)
{
	buf_t buf = buf_add_ui32(0x6f635b0d);
	//parse argument offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_));
	}
	//parse argument length (int)
	{
		buf = buf_cat(buf, buf_add_ui32(length_));
	}
	return buf;
}

buf_t tl_messageEntityBotCommand(int offset_, int length_)
{
	buf_t buf = buf_add_ui32(0x6cef8ac7);
	//parse argument offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_));
	}
	//parse argument length (int)
	{
		buf = buf_cat(buf, buf_add_ui32(length_));
	}
	return buf;
}

buf_t tl_messageEntityUrl(int offset_, int length_)
{
	buf_t buf = buf_add_ui32(0x6ed02538);
	//parse argument offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_));
	}
	//parse argument length (int)
	{
		buf = buf_cat(buf, buf_add_ui32(length_));
	}
	return buf;
}

buf_t tl_messageEntityEmail(int offset_, int length_)
{
	buf_t buf = buf_add_ui32(0x64e475c2);
	//parse argument offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_));
	}
	//parse argument length (int)
	{
		buf = buf_cat(buf, buf_add_ui32(length_));
	}
	return buf;
}

buf_t tl_messageEntityBold(int offset_, int length_)
{
	buf_t buf = buf_add_ui32(0xbd610bc9);
	//parse argument offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_));
	}
	//parse argument length (int)
	{
		buf = buf_cat(buf, buf_add_ui32(length_));
	}
	return buf;
}

buf_t tl_messageEntityItalic(int offset_, int length_)
{
	buf_t buf = buf_add_ui32(0x826f8b60);
	//parse argument offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_));
	}
	//parse argument length (int)
	{
		buf = buf_cat(buf, buf_add_ui32(length_));
	}
	return buf;
}

buf_t tl_messageEntityCode(int offset_, int length_)
{
	buf_t buf = buf_add_ui32(0x28a20571);
	//parse argument offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_));
	}
	//parse argument length (int)
	{
		buf = buf_cat(buf, buf_add_ui32(length_));
	}
	return buf;
}

buf_t tl_messageEntityPre(int offset_, int length_, const char * language_)
{
	buf_t buf = buf_add_ui32(0x73924be0);
	//parse argument offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_));
	}
	//parse argument length (int)
	{
		buf = buf_cat(buf, buf_add_ui32(length_));
	}
	//parse argument language (string)
	{
		buf = buf_cat(buf, serialize_string(language_));
	}
	return buf;
}

buf_t tl_messageEntityTextUrl(int offset_, int length_, const char * url_)
{
	buf_t buf = buf_add_ui32(0x76a6d327);
	//parse argument offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_));
	}
	//parse argument length (int)
	{
		buf = buf_cat(buf, buf_add_ui32(length_));
	}
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	return buf;
}

buf_t tl_messageEntityMentionName(int offset_, int length_, long user_id_)
{
	buf_t buf = buf_add_ui32(0xdc7b1140);
	//parse argument offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_));
	}
	//parse argument length (int)
	{
		buf = buf_cat(buf, buf_add_ui32(length_));
	}
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	return buf;
}

buf_t tl_inputMessageEntityMentionName(int offset_, int length_, InputUser *user_id_)
{
	buf_t buf = buf_add_ui32(0x208e68c9);
	//parse argument offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_));
	}
	//parse argument length (int)
	{
		buf = buf_cat(buf, buf_add_ui32(length_));
	}
	//parse argument user_id (InputUser)
	{
		buf = buf_cat(buf, *user_id_);
	}
	return buf;
}

buf_t tl_messageEntityPhone(int offset_, int length_)
{
	buf_t buf = buf_add_ui32(0x9b69e34b);
	//parse argument offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_));
	}
	//parse argument length (int)
	{
		buf = buf_cat(buf, buf_add_ui32(length_));
	}
	return buf;
}

buf_t tl_messageEntityCashtag(int offset_, int length_)
{
	buf_t buf = buf_add_ui32(0x4c4e743f);
	//parse argument offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_));
	}
	//parse argument length (int)
	{
		buf = buf_cat(buf, buf_add_ui32(length_));
	}
	return buf;
}

buf_t tl_messageEntityUnderline(int offset_, int length_)
{
	buf_t buf = buf_add_ui32(0x9c4e7e8b);
	//parse argument offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_));
	}
	//parse argument length (int)
	{
		buf = buf_cat(buf, buf_add_ui32(length_));
	}
	return buf;
}

buf_t tl_messageEntityStrike(int offset_, int length_)
{
	buf_t buf = buf_add_ui32(0xbf0693d4);
	//parse argument offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_));
	}
	//parse argument length (int)
	{
		buf = buf_cat(buf, buf_add_ui32(length_));
	}
	return buf;
}

buf_t tl_messageEntityBankCard(int offset_, int length_)
{
	buf_t buf = buf_add_ui32(0x761e6af4);
	//parse argument offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_));
	}
	//parse argument length (int)
	{
		buf = buf_cat(buf, buf_add_ui32(length_));
	}
	return buf;
}

buf_t tl_messageEntitySpoiler(int offset_, int length_)
{
	buf_t buf = buf_add_ui32(0x32ca960f);
	//parse argument offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_));
	}
	//parse argument length (int)
	{
		buf = buf_cat(buf, buf_add_ui32(length_));
	}
	return buf;
}

buf_t tl_messageEntityCustomEmoji(int offset_, int length_, long document_id_)
{
	buf_t buf = buf_add_ui32(0xc8cf05f8);
	//parse argument offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_));
	}
	//parse argument length (int)
	{
		buf = buf_cat(buf, buf_add_ui32(length_));
	}
	//parse argument document_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(document_id_));
	}
	return buf;
}

buf_t tl_messageEntityBlockquote(bool collapsed_, int offset_, int length_)
{
	buf_t buf = buf_add_ui32(0xf1ccaaac);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument collapsed (true)
	if (collapsed_)
		*flag1 |= (1 << 0);
	//parse argument offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_));
	}
	//parse argument length (int)
	{
		buf = buf_cat(buf, buf_add_ui32(length_));
	}
	return buf;
}

buf_t tl_inputChannelEmpty()
{
	buf_t buf = buf_add_ui32(0xee8c1e86);
	return buf;
}

buf_t tl_inputChannel(long channel_id_, long access_hash_)
{
	buf_t buf = buf_add_ui32(0xf35aec28);
	//parse argument channel_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(channel_id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	return buf;
}

buf_t tl_inputChannelFromMessage(InputPeer *peer_, int msg_id_, long channel_id_)
{
	buf_t buf = buf_add_ui32(0x5b934f9d);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	//parse argument channel_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(channel_id_));
	}
	return buf;
}

buf_t tl_contacts_resolvedPeer(Peer *peer_, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x7f077ad9);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_messageRange(int min_id_, int max_id_)
{
	buf_t buf = buf_add_ui32(0x0ae30253);
	//parse argument min_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(min_id_));
	}
	//parse argument max_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(max_id_));
	}
	return buf;
}

buf_t tl_updates_channelDifferenceEmpty(bool final_, int pts_, int timeout_)
{
	buf_t buf = buf_add_ui32(0x3e11affb);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument final (true)
	if (final_)
		*flag1 |= (1 << 0);
	//parse argument pts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_));
	}
	//parse argument timeout (int)
	if (timeout_)
	{
		buf = buf_cat(buf, buf_add_ui32(timeout_));
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_updates_channelDifferenceTooLong(bool final_, int timeout_, Dialog *dialog_, Message *messages_, int messages_len, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0xa4bcc6fe);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument final (true)
	if (final_)
		*flag1 |= (1 << 0);
	//parse argument timeout (int)
	if (timeout_)
	{
		buf = buf_cat(buf, buf_add_ui32(timeout_));
		*flag1 |= (1 << 1);
	}
	//parse argument dialog (Dialog)
	{
		buf = buf_cat(buf, *dialog_);
	}
	//parse argument messages (Vector<Message>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(messages_len));
		int i;
		for (i=0; i<messages_len; ++i){
			buf = buf_cat(buf, messages_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_updates_channelDifference(bool final_, int pts_, int timeout_, Message *new_messages_, int new_messages_len, Update *other_updates_, int other_updates_len, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x2064674e);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument final (true)
	if (final_)
		*flag1 |= (1 << 0);
	//parse argument pts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_));
	}
	//parse argument timeout (int)
	if (timeout_)
	{
		buf = buf_cat(buf, buf_add_ui32(timeout_));
		*flag1 |= (1 << 1);
	}
	//parse argument new_messages (Vector<Message>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(new_messages_len));
		int i;
		for (i=0; i<new_messages_len; ++i){
			buf = buf_cat(buf, new_messages_[i]);
		}
	}
	//parse argument other_updates (Vector<Update>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(other_updates_len));
		int i;
		for (i=0; i<other_updates_len; ++i){
			buf = buf_cat(buf, other_updates_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_channelMessagesFilterEmpty()
{
	buf_t buf = buf_add_ui32(0x94d42ee7);
	return buf;
}

buf_t tl_channelMessagesFilter(bool exclude_new_messages_, MessageRange *ranges_, int ranges_len)
{
	buf_t buf = buf_add_ui32(0xcd77d957);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument exclude_new_messages (true)
	if (exclude_new_messages_)
		*flag1 |= (1 << 1);
	//parse argument ranges (Vector<MessageRange>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(ranges_len));
		int i;
		for (i=0; i<ranges_len; ++i){
			buf = buf_cat(buf, ranges_[i]);
		}
	}
	return buf;
}

buf_t tl_channelParticipant(long user_id_, int date_, int subscription_until_date_)
{
	buf_t buf = buf_add_ui32(0xcb397619);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument subscription_until_date (int)
	if (subscription_until_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(subscription_until_date_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_channelParticipantSelf(bool via_request_, long user_id_, long inviter_id_, int date_, int subscription_until_date_)
{
	buf_t buf = buf_add_ui32(0x4f607bef);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument via_request (true)
	if (via_request_)
		*flag1 |= (1 << 0);
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument inviter_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(inviter_id_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument subscription_until_date (int)
	if (subscription_until_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(subscription_until_date_));
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_channelParticipantCreator(long user_id_, ChatAdminRights *admin_rights_, const char * rank_)
{
	buf_t buf = buf_add_ui32(0x2fe601d3);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument admin_rights (ChatAdminRights)
	{
		buf = buf_cat(buf, *admin_rights_);
	}
	//parse argument rank (string)
	if (rank_)
	{
		buf = buf_cat(buf, serialize_string(rank_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_channelParticipantAdmin(bool can_edit_, bool self_, long user_id_, long inviter_id_, long promoted_by_, int date_, ChatAdminRights *admin_rights_, const char * rank_)
{
	buf_t buf = buf_add_ui32(0x34c3bb53);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument can_edit (true)
	if (can_edit_)
		*flag1 |= (1 << 0);
	//parse argument self (true)
	if (self_)
		*flag1 |= (1 << 1);
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument inviter_id (long)
	if (inviter_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(inviter_id_));
		*flag1 |= (1 << 1);
	}
	//parse argument promoted_by (long)
	{
		buf = buf_cat(buf, buf_add_ui64(promoted_by_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument admin_rights (ChatAdminRights)
	{
		buf = buf_cat(buf, *admin_rights_);
	}
	//parse argument rank (string)
	if (rank_)
	{
		buf = buf_cat(buf, serialize_string(rank_));
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_channelParticipantBanned(bool left_, Peer *peer_, long kicked_by_, int date_, ChatBannedRights *banned_rights_)
{
	buf_t buf = buf_add_ui32(0x6df8014e);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument left (true)
	if (left_)
		*flag1 |= (1 << 0);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument kicked_by (long)
	{
		buf = buf_cat(buf, buf_add_ui64(kicked_by_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument banned_rights (ChatBannedRights)
	{
		buf = buf_cat(buf, *banned_rights_);
	}
	return buf;
}

buf_t tl_channelParticipantLeft(Peer *peer_)
{
	buf_t buf = buf_add_ui32(0x1b03f006);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_channelParticipantsRecent()
{
	buf_t buf = buf_add_ui32(0xde3f3c79);
	return buf;
}

buf_t tl_channelParticipantsAdmins()
{
	buf_t buf = buf_add_ui32(0xb4608969);
	return buf;
}

buf_t tl_channelParticipantsKicked(const char * q_)
{
	buf_t buf = buf_add_ui32(0xa3b54985);
	//parse argument q (string)
	{
		buf = buf_cat(buf, serialize_string(q_));
	}
	return buf;
}

buf_t tl_channelParticipantsBots()
{
	buf_t buf = buf_add_ui32(0xb0d1865b);
	return buf;
}

buf_t tl_channelParticipantsBanned(const char * q_)
{
	buf_t buf = buf_add_ui32(0x1427a5e1);
	//parse argument q (string)
	{
		buf = buf_cat(buf, serialize_string(q_));
	}
	return buf;
}

buf_t tl_channelParticipantsSearch(const char * q_)
{
	buf_t buf = buf_add_ui32(0x0656ac4b);
	//parse argument q (string)
	{
		buf = buf_cat(buf, serialize_string(q_));
	}
	return buf;
}

buf_t tl_channelParticipantsContacts(const char * q_)
{
	buf_t buf = buf_add_ui32(0xbb6ae88d);
	//parse argument q (string)
	{
		buf = buf_cat(buf, serialize_string(q_));
	}
	return buf;
}

buf_t tl_channelParticipantsMentions(const char * q_, int top_msg_id_)
{
	buf_t buf = buf_add_ui32(0xe04b5ceb);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument q (string)
	if (q_)
	{
		buf = buf_cat(buf, serialize_string(q_));
		*flag1 |= (1 << 0);
	}
	//parse argument top_msg_id (int)
	if (top_msg_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(top_msg_id_));
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_channels_channelParticipants(int count_, ChannelParticipant *participants_, int participants_len, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x9ab0feaf);
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	//parse argument participants (Vector<ChannelParticipant>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(participants_len));
		int i;
		for (i=0; i<participants_len; ++i){
			buf = buf_cat(buf, participants_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_channels_channelParticipantsNotModified()
{
	buf_t buf = buf_add_ui32(0xf0173fe9);
	return buf;
}

buf_t tl_channels_channelParticipant(ChannelParticipant *participant_, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0xdfb80317);
	//parse argument participant (ChannelParticipant)
	{
		buf = buf_cat(buf, *participant_);
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_help_termsOfService(bool popup_, DataJSON *id_, const char * text_, MessageEntity *entities_, int entities_len, int min_age_confirm_)
{
	buf_t buf = buf_add_ui32(0x780a0310);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument popup (true)
	if (popup_)
		*flag1 |= (1 << 0);
	//parse argument id (DataJSON)
	{
		buf = buf_cat(buf, *id_);
	}
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	//parse argument entities (Vector<MessageEntity>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(entities_len));
		int i;
		for (i=0; i<entities_len; ++i){
			buf = buf_cat(buf, entities_[i]);
		}
	}
	//parse argument min_age_confirm (int)
	if (min_age_confirm_)
	{
		buf = buf_cat(buf, buf_add_ui32(min_age_confirm_));
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_messages_savedGifsNotModified()
{
	buf_t buf = buf_add_ui32(0xe8025ca2);
	return buf;
}

buf_t tl_messages_savedGifs(long hash_, Document *gifs_, int gifs_len)
{
	buf_t buf = buf_add_ui32(0x84a02a0d);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	//parse argument gifs (Vector<Document>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(gifs_len));
		int i;
		for (i=0; i<gifs_len; ++i){
			buf = buf_cat(buf, gifs_[i]);
		}
	}
	return buf;
}

buf_t tl_inputBotInlineMessageMediaAuto(bool invert_media_, const char * message_, MessageEntity *entities_, int entities_len, ReplyMarkup *reply_markup_)
{
	buf_t buf = buf_add_ui32(0x3380c786);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument invert_media (true)
	if (invert_media_)
		*flag1 |= (1 << 3);
	//parse argument message (string)
	{
		buf = buf_cat(buf, serialize_string(message_));
	}
	//parse argument entities (Vector<MessageEntity>)
	if (entities_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(entities_len));
		int i;
		for (i=0; i<entities_len; ++i){
			buf = buf_cat(buf, entities_[i]);
		}
		*flag1 |= (1 << 1);
	}
	//parse argument reply_markup (ReplyMarkup)
	if (reply_markup_)
	{
		buf = buf_cat(buf, *reply_markup_);
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_inputBotInlineMessageText(bool no_webpage_, bool invert_media_, const char * message_, MessageEntity *entities_, int entities_len, ReplyMarkup *reply_markup_)
{
	buf_t buf = buf_add_ui32(0x3dcd7a87);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument no_webpage (true)
	if (no_webpage_)
		*flag1 |= (1 << 0);
	//parse argument invert_media (true)
	if (invert_media_)
		*flag1 |= (1 << 3);
	//parse argument message (string)
	{
		buf = buf_cat(buf, serialize_string(message_));
	}
	//parse argument entities (Vector<MessageEntity>)
	if (entities_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(entities_len));
		int i;
		for (i=0; i<entities_len; ++i){
			buf = buf_cat(buf, entities_[i]);
		}
		*flag1 |= (1 << 1);
	}
	//parse argument reply_markup (ReplyMarkup)
	if (reply_markup_)
	{
		buf = buf_cat(buf, *reply_markup_);
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_inputBotInlineMessageMediaGeo(InputGeoPoint *geo_point_, int heading_, int period_, int proximity_notification_radius_, ReplyMarkup *reply_markup_)
{
	buf_t buf = buf_add_ui32(0x96929a85);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument geo_point (InputGeoPoint)
	{
		buf = buf_cat(buf, *geo_point_);
	}
	//parse argument heading (int)
	if (heading_)
	{
		buf = buf_cat(buf, buf_add_ui32(heading_));
		*flag1 |= (1 << 0);
	}
	//parse argument period (int)
	if (period_)
	{
		buf = buf_cat(buf, buf_add_ui32(period_));
		*flag1 |= (1 << 1);
	}
	//parse argument proximity_notification_radius (int)
	if (proximity_notification_radius_)
	{
		buf = buf_cat(buf, buf_add_ui32(proximity_notification_radius_));
		*flag1 |= (1 << 3);
	}
	//parse argument reply_markup (ReplyMarkup)
	if (reply_markup_)
	{
		buf = buf_cat(buf, *reply_markup_);
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_inputBotInlineMessageMediaVenue(InputGeoPoint *geo_point_, const char * title_, const char * address_, const char * provider_, const char * venue_id_, const char * venue_type_, ReplyMarkup *reply_markup_)
{
	buf_t buf = buf_add_ui32(0x417bbf11);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument geo_point (InputGeoPoint)
	{
		buf = buf_cat(buf, *geo_point_);
	}
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument address (string)
	{
		buf = buf_cat(buf, serialize_string(address_));
	}
	//parse argument provider (string)
	{
		buf = buf_cat(buf, serialize_string(provider_));
	}
	//parse argument venue_id (string)
	{
		buf = buf_cat(buf, serialize_string(venue_id_));
	}
	//parse argument venue_type (string)
	{
		buf = buf_cat(buf, serialize_string(venue_type_));
	}
	//parse argument reply_markup (ReplyMarkup)
	if (reply_markup_)
	{
		buf = buf_cat(buf, *reply_markup_);
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_inputBotInlineMessageMediaContact(const char * phone_number_, const char * first_name_, const char * last_name_, const char * vcard_, ReplyMarkup *reply_markup_)
{
	buf_t buf = buf_add_ui32(0xa6edbffd);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument phone_number (string)
	{
		buf = buf_cat(buf, serialize_string(phone_number_));
	}
	//parse argument first_name (string)
	{
		buf = buf_cat(buf, serialize_string(first_name_));
	}
	//parse argument last_name (string)
	{
		buf = buf_cat(buf, serialize_string(last_name_));
	}
	//parse argument vcard (string)
	{
		buf = buf_cat(buf, serialize_string(vcard_));
	}
	//parse argument reply_markup (ReplyMarkup)
	if (reply_markup_)
	{
		buf = buf_cat(buf, *reply_markup_);
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_inputBotInlineMessageGame(ReplyMarkup *reply_markup_)
{
	buf_t buf = buf_add_ui32(0x4b425864);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument reply_markup (ReplyMarkup)
	if (reply_markup_)
	{
		buf = buf_cat(buf, *reply_markup_);
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_inputBotInlineMessageMediaInvoice(const char * title_, const char * description_, InputWebDocument *photo_, Invoice *invoice_, buf_t *payload_, const char * provider_, DataJSON *provider_data_, ReplyMarkup *reply_markup_)
{
	buf_t buf = buf_add_ui32(0xd7e78225);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument description (string)
	{
		buf = buf_cat(buf, serialize_string(description_));
	}
	//parse argument photo (InputWebDocument)
	if (photo_)
	{
		buf = buf_cat(buf, *photo_);
		*flag1 |= (1 << 0);
	}
	//parse argument invoice (Invoice)
	{
		buf = buf_cat(buf, *invoice_);
	}
	//parse argument payload (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(payload_->data, payload_->size));
	}
	//parse argument provider (string)
	{
		buf = buf_cat(buf, serialize_string(provider_));
	}
	//parse argument provider_data (DataJSON)
	{
		buf = buf_cat(buf, *provider_data_);
	}
	//parse argument reply_markup (ReplyMarkup)
	if (reply_markup_)
	{
		buf = buf_cat(buf, *reply_markup_);
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_inputBotInlineMessageMediaWebPage(bool invert_media_, bool force_large_media_, bool force_small_media_, bool optional_, const char * message_, MessageEntity *entities_, int entities_len, const char * url_, ReplyMarkup *reply_markup_)
{
	buf_t buf = buf_add_ui32(0xbddcc510);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument invert_media (true)
	if (invert_media_)
		*flag1 |= (1 << 3);
	//parse argument force_large_media (true)
	if (force_large_media_)
		*flag1 |= (1 << 4);
	//parse argument force_small_media (true)
	if (force_small_media_)
		*flag1 |= (1 << 5);
	//parse argument optional (true)
	if (optional_)
		*flag1 |= (1 << 6);
	//parse argument message (string)
	{
		buf = buf_cat(buf, serialize_string(message_));
	}
	//parse argument entities (Vector<MessageEntity>)
	if (entities_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(entities_len));
		int i;
		for (i=0; i<entities_len; ++i){
			buf = buf_cat(buf, entities_[i]);
		}
		*flag1 |= (1 << 1);
	}
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	//parse argument reply_markup (ReplyMarkup)
	if (reply_markup_)
	{
		buf = buf_cat(buf, *reply_markup_);
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_inputBotInlineResult(const char * id_, const char * type_, const char * title_, const char * description_, const char * url_, InputWebDocument *thumb_, InputWebDocument *content_, InputBotInlineMessage *send_message_)
{
	buf_t buf = buf_add_ui32(0x88bf9319);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument id (string)
	{
		buf = buf_cat(buf, serialize_string(id_));
	}
	//parse argument type (string)
	{
		buf = buf_cat(buf, serialize_string(type_));
	}
	//parse argument title (string)
	if (title_)
	{
		buf = buf_cat(buf, serialize_string(title_));
		*flag1 |= (1 << 1);
	}
	//parse argument description (string)
	if (description_)
	{
		buf = buf_cat(buf, serialize_string(description_));
		*flag1 |= (1 << 2);
	}
	//parse argument url (string)
	if (url_)
	{
		buf = buf_cat(buf, serialize_string(url_));
		*flag1 |= (1 << 3);
	}
	//parse argument thumb (InputWebDocument)
	if (thumb_)
	{
		buf = buf_cat(buf, *thumb_);
		*flag1 |= (1 << 4);
	}
	//parse argument content (InputWebDocument)
	if (content_)
	{
		buf = buf_cat(buf, *content_);
		*flag1 |= (1 << 5);
	}
	//parse argument send_message (InputBotInlineMessage)
	{
		buf = buf_cat(buf, *send_message_);
	}
	return buf;
}

buf_t tl_inputBotInlineResultPhoto(const char * id_, const char * type_, InputPhoto *photo_, InputBotInlineMessage *send_message_)
{
	buf_t buf = buf_add_ui32(0xa8d864a7);
	//parse argument id (string)
	{
		buf = buf_cat(buf, serialize_string(id_));
	}
	//parse argument type (string)
	{
		buf = buf_cat(buf, serialize_string(type_));
	}
	//parse argument photo (InputPhoto)
	{
		buf = buf_cat(buf, *photo_);
	}
	//parse argument send_message (InputBotInlineMessage)
	{
		buf = buf_cat(buf, *send_message_);
	}
	return buf;
}

buf_t tl_inputBotInlineResultDocument(const char * id_, const char * type_, const char * title_, const char * description_, InputDocument *document_, InputBotInlineMessage *send_message_)
{
	buf_t buf = buf_add_ui32(0xfff8fdc4);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument id (string)
	{
		buf = buf_cat(buf, serialize_string(id_));
	}
	//parse argument type (string)
	{
		buf = buf_cat(buf, serialize_string(type_));
	}
	//parse argument title (string)
	if (title_)
	{
		buf = buf_cat(buf, serialize_string(title_));
		*flag1 |= (1 << 1);
	}
	//parse argument description (string)
	if (description_)
	{
		buf = buf_cat(buf, serialize_string(description_));
		*flag1 |= (1 << 2);
	}
	//parse argument document (InputDocument)
	{
		buf = buf_cat(buf, *document_);
	}
	//parse argument send_message (InputBotInlineMessage)
	{
		buf = buf_cat(buf, *send_message_);
	}
	return buf;
}

buf_t tl_inputBotInlineResultGame(const char * id_, const char * short_name_, InputBotInlineMessage *send_message_)
{
	buf_t buf = buf_add_ui32(0x4fa417f2);
	//parse argument id (string)
	{
		buf = buf_cat(buf, serialize_string(id_));
	}
	//parse argument short_name (string)
	{
		buf = buf_cat(buf, serialize_string(short_name_));
	}
	//parse argument send_message (InputBotInlineMessage)
	{
		buf = buf_cat(buf, *send_message_);
	}
	return buf;
}

buf_t tl_botInlineMessageMediaAuto(bool invert_media_, const char * message_, MessageEntity *entities_, int entities_len, ReplyMarkup *reply_markup_)
{
	buf_t buf = buf_add_ui32(0x764cf810);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument invert_media (true)
	if (invert_media_)
		*flag1 |= (1 << 3);
	//parse argument message (string)
	{
		buf = buf_cat(buf, serialize_string(message_));
	}
	//parse argument entities (Vector<MessageEntity>)
	if (entities_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(entities_len));
		int i;
		for (i=0; i<entities_len; ++i){
			buf = buf_cat(buf, entities_[i]);
		}
		*flag1 |= (1 << 1);
	}
	//parse argument reply_markup (ReplyMarkup)
	if (reply_markup_)
	{
		buf = buf_cat(buf, *reply_markup_);
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_botInlineMessageText(bool no_webpage_, bool invert_media_, const char * message_, MessageEntity *entities_, int entities_len, ReplyMarkup *reply_markup_)
{
	buf_t buf = buf_add_ui32(0x8c7f65e2);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument no_webpage (true)
	if (no_webpage_)
		*flag1 |= (1 << 0);
	//parse argument invert_media (true)
	if (invert_media_)
		*flag1 |= (1 << 3);
	//parse argument message (string)
	{
		buf = buf_cat(buf, serialize_string(message_));
	}
	//parse argument entities (Vector<MessageEntity>)
	if (entities_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(entities_len));
		int i;
		for (i=0; i<entities_len; ++i){
			buf = buf_cat(buf, entities_[i]);
		}
		*flag1 |= (1 << 1);
	}
	//parse argument reply_markup (ReplyMarkup)
	if (reply_markup_)
	{
		buf = buf_cat(buf, *reply_markup_);
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_botInlineMessageMediaGeo(GeoPoint *geo_, int heading_, int period_, int proximity_notification_radius_, ReplyMarkup *reply_markup_)
{
	buf_t buf = buf_add_ui32(0x051846fd);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument geo (GeoPoint)
	{
		buf = buf_cat(buf, *geo_);
	}
	//parse argument heading (int)
	if (heading_)
	{
		buf = buf_cat(buf, buf_add_ui32(heading_));
		*flag1 |= (1 << 0);
	}
	//parse argument period (int)
	if (period_)
	{
		buf = buf_cat(buf, buf_add_ui32(period_));
		*flag1 |= (1 << 1);
	}
	//parse argument proximity_notification_radius (int)
	if (proximity_notification_radius_)
	{
		buf = buf_cat(buf, buf_add_ui32(proximity_notification_radius_));
		*flag1 |= (1 << 3);
	}
	//parse argument reply_markup (ReplyMarkup)
	if (reply_markup_)
	{
		buf = buf_cat(buf, *reply_markup_);
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_botInlineMessageMediaVenue(GeoPoint *geo_, const char * title_, const char * address_, const char * provider_, const char * venue_id_, const char * venue_type_, ReplyMarkup *reply_markup_)
{
	buf_t buf = buf_add_ui32(0x8a86659c);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument geo (GeoPoint)
	{
		buf = buf_cat(buf, *geo_);
	}
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument address (string)
	{
		buf = buf_cat(buf, serialize_string(address_));
	}
	//parse argument provider (string)
	{
		buf = buf_cat(buf, serialize_string(provider_));
	}
	//parse argument venue_id (string)
	{
		buf = buf_cat(buf, serialize_string(venue_id_));
	}
	//parse argument venue_type (string)
	{
		buf = buf_cat(buf, serialize_string(venue_type_));
	}
	//parse argument reply_markup (ReplyMarkup)
	if (reply_markup_)
	{
		buf = buf_cat(buf, *reply_markup_);
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_botInlineMessageMediaContact(const char * phone_number_, const char * first_name_, const char * last_name_, const char * vcard_, ReplyMarkup *reply_markup_)
{
	buf_t buf = buf_add_ui32(0x18d1cdc2);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument phone_number (string)
	{
		buf = buf_cat(buf, serialize_string(phone_number_));
	}
	//parse argument first_name (string)
	{
		buf = buf_cat(buf, serialize_string(first_name_));
	}
	//parse argument last_name (string)
	{
		buf = buf_cat(buf, serialize_string(last_name_));
	}
	//parse argument vcard (string)
	{
		buf = buf_cat(buf, serialize_string(vcard_));
	}
	//parse argument reply_markup (ReplyMarkup)
	if (reply_markup_)
	{
		buf = buf_cat(buf, *reply_markup_);
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_botInlineMessageMediaInvoice(bool shipping_address_requested_, bool test_, const char * title_, const char * description_, WebDocument *photo_, const char * currency_, long total_amount_, ReplyMarkup *reply_markup_)
{
	buf_t buf = buf_add_ui32(0x354a9b09);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument shipping_address_requested (true)
	if (shipping_address_requested_)
		*flag1 |= (1 << 1);
	//parse argument test (true)
	if (test_)
		*flag1 |= (1 << 3);
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument description (string)
	{
		buf = buf_cat(buf, serialize_string(description_));
	}
	//parse argument photo (WebDocument)
	if (photo_)
	{
		buf = buf_cat(buf, *photo_);
		*flag1 |= (1 << 0);
	}
	//parse argument currency (string)
	{
		buf = buf_cat(buf, serialize_string(currency_));
	}
	//parse argument total_amount (long)
	{
		buf = buf_cat(buf, buf_add_ui64(total_amount_));
	}
	//parse argument reply_markup (ReplyMarkup)
	if (reply_markup_)
	{
		buf = buf_cat(buf, *reply_markup_);
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_botInlineMessageMediaWebPage(bool invert_media_, bool force_large_media_, bool force_small_media_, bool manual_, bool safe_, const char * message_, MessageEntity *entities_, int entities_len, const char * url_, ReplyMarkup *reply_markup_)
{
	buf_t buf = buf_add_ui32(0x809ad9a6);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument invert_media (true)
	if (invert_media_)
		*flag1 |= (1 << 3);
	//parse argument force_large_media (true)
	if (force_large_media_)
		*flag1 |= (1 << 4);
	//parse argument force_small_media (true)
	if (force_small_media_)
		*flag1 |= (1 << 5);
	//parse argument manual (true)
	if (manual_)
		*flag1 |= (1 << 7);
	//parse argument safe (true)
	if (safe_)
		*flag1 |= (1 << 8);
	//parse argument message (string)
	{
		buf = buf_cat(buf, serialize_string(message_));
	}
	//parse argument entities (Vector<MessageEntity>)
	if (entities_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(entities_len));
		int i;
		for (i=0; i<entities_len; ++i){
			buf = buf_cat(buf, entities_[i]);
		}
		*flag1 |= (1 << 1);
	}
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	//parse argument reply_markup (ReplyMarkup)
	if (reply_markup_)
	{
		buf = buf_cat(buf, *reply_markup_);
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_botInlineResult(const char * id_, const char * type_, const char * title_, const char * description_, const char * url_, WebDocument *thumb_, WebDocument *content_, BotInlineMessage *send_message_)
{
	buf_t buf = buf_add_ui32(0x11965f3a);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument id (string)
	{
		buf = buf_cat(buf, serialize_string(id_));
	}
	//parse argument type (string)
	{
		buf = buf_cat(buf, serialize_string(type_));
	}
	//parse argument title (string)
	if (title_)
	{
		buf = buf_cat(buf, serialize_string(title_));
		*flag1 |= (1 << 1);
	}
	//parse argument description (string)
	if (description_)
	{
		buf = buf_cat(buf, serialize_string(description_));
		*flag1 |= (1 << 2);
	}
	//parse argument url (string)
	if (url_)
	{
		buf = buf_cat(buf, serialize_string(url_));
		*flag1 |= (1 << 3);
	}
	//parse argument thumb (WebDocument)
	if (thumb_)
	{
		buf = buf_cat(buf, *thumb_);
		*flag1 |= (1 << 4);
	}
	//parse argument content (WebDocument)
	if (content_)
	{
		buf = buf_cat(buf, *content_);
		*flag1 |= (1 << 5);
	}
	//parse argument send_message (BotInlineMessage)
	{
		buf = buf_cat(buf, *send_message_);
	}
	return buf;
}

buf_t tl_botInlineMediaResult(const char * id_, const char * type_, Photo *photo_, Document *document_, const char * title_, const char * description_, BotInlineMessage *send_message_)
{
	buf_t buf = buf_add_ui32(0x17db940b);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument id (string)
	{
		buf = buf_cat(buf, serialize_string(id_));
	}
	//parse argument type (string)
	{
		buf = buf_cat(buf, serialize_string(type_));
	}
	//parse argument photo (Photo)
	if (photo_)
	{
		buf = buf_cat(buf, *photo_);
		*flag1 |= (1 << 0);
	}
	//parse argument document (Document)
	if (document_)
	{
		buf = buf_cat(buf, *document_);
		*flag1 |= (1 << 1);
	}
	//parse argument title (string)
	if (title_)
	{
		buf = buf_cat(buf, serialize_string(title_));
		*flag1 |= (1 << 2);
	}
	//parse argument description (string)
	if (description_)
	{
		buf = buf_cat(buf, serialize_string(description_));
		*flag1 |= (1 << 3);
	}
	//parse argument send_message (BotInlineMessage)
	{
		buf = buf_cat(buf, *send_message_);
	}
	return buf;
}

buf_t tl_messages_botResults(bool gallery_, long query_id_, const char * next_offset_, InlineBotSwitchPM *switch_pm_, InlineBotWebView *switch_webview_, BotInlineResult *results_, int results_len, int cache_time_, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0xe021f2f6);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument gallery (true)
	if (gallery_)
		*flag1 |= (1 << 0);
	//parse argument query_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(query_id_));
	}
	//parse argument next_offset (string)
	if (next_offset_)
	{
		buf = buf_cat(buf, serialize_string(next_offset_));
		*flag1 |= (1 << 1);
	}
	//parse argument switch_pm (InlineBotSwitchPM)
	if (switch_pm_)
	{
		buf = buf_cat(buf, *switch_pm_);
		*flag1 |= (1 << 2);
	}
	//parse argument switch_webview (InlineBotWebView)
	if (switch_webview_)
	{
		buf = buf_cat(buf, *switch_webview_);
		*flag1 |= (1 << 3);
	}
	//parse argument results (Vector<BotInlineResult>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(results_len));
		int i;
		for (i=0; i<results_len; ++i){
			buf = buf_cat(buf, results_[i]);
		}
	}
	//parse argument cache_time (int)
	{
		buf = buf_cat(buf, buf_add_ui32(cache_time_));
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_exportedMessageLink(const char * link_, const char * html_)
{
	buf_t buf = buf_add_ui32(0x5dab1af4);
	//parse argument link (string)
	{
		buf = buf_cat(buf, serialize_string(link_));
	}
	//parse argument html (string)
	{
		buf = buf_cat(buf, serialize_string(html_));
	}
	return buf;
}

buf_t tl_messageFwdHeader(bool imported_, bool saved_out_, Peer *from_id_, const char * from_name_, int date_, int channel_post_, const char * post_author_, Peer *saved_from_peer_, int saved_from_msg_id_, Peer *saved_from_id_, const char * saved_from_name_, int saved_date_, const char * psa_type_)
{
	buf_t buf = buf_add_ui32(0x4e4df4bb);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument imported (true)
	if (imported_)
		*flag1 |= (1 << 7);
	//parse argument saved_out (true)
	if (saved_out_)
		*flag1 |= (1 << 11);
	//parse argument from_id (Peer)
	if (from_id_)
	{
		buf = buf_cat(buf, *from_id_);
		*flag1 |= (1 << 0);
	}
	//parse argument from_name (string)
	if (from_name_)
	{
		buf = buf_cat(buf, serialize_string(from_name_));
		*flag1 |= (1 << 5);
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument channel_post (int)
	if (channel_post_)
	{
		buf = buf_cat(buf, buf_add_ui32(channel_post_));
		*flag1 |= (1 << 2);
	}
	//parse argument post_author (string)
	if (post_author_)
	{
		buf = buf_cat(buf, serialize_string(post_author_));
		*flag1 |= (1 << 3);
	}
	//parse argument saved_from_peer (Peer)
	if (saved_from_peer_)
	{
		buf = buf_cat(buf, *saved_from_peer_);
		*flag1 |= (1 << 4);
	}
	//parse argument saved_from_msg_id (int)
	if (saved_from_msg_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(saved_from_msg_id_));
		*flag1 |= (1 << 4);
	}
	//parse argument saved_from_id (Peer)
	if (saved_from_id_)
	{
		buf = buf_cat(buf, *saved_from_id_);
		*flag1 |= (1 << 8);
	}
	//parse argument saved_from_name (string)
	if (saved_from_name_)
	{
		buf = buf_cat(buf, serialize_string(saved_from_name_));
		*flag1 |= (1 << 9);
	}
	//parse argument saved_date (int)
	if (saved_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(saved_date_));
		*flag1 |= (1 << 10);
	}
	//parse argument psa_type (string)
	if (psa_type_)
	{
		buf = buf_cat(buf, serialize_string(psa_type_));
		*flag1 |= (1 << 6);
	}
	return buf;
}

buf_t tl_auth_codeTypeSms()
{
	buf_t buf = buf_add_ui32(0x72a3158c);
	return buf;
}

buf_t tl_auth_codeTypeCall()
{
	buf_t buf = buf_add_ui32(0x741cd3e3);
	return buf;
}

buf_t tl_auth_codeTypeFlashCall()
{
	buf_t buf = buf_add_ui32(0x226ccefb);
	return buf;
}

buf_t tl_auth_codeTypeMissedCall()
{
	buf_t buf = buf_add_ui32(0xd61ad6ee);
	return buf;
}

buf_t tl_auth_codeTypeFragmentSms()
{
	buf_t buf = buf_add_ui32(0x06ed998c);
	return buf;
}

buf_t tl_auth_sentCodeTypeApp(int length_)
{
	buf_t buf = buf_add_ui32(0x3dbb5986);
	//parse argument length (int)
	{
		buf = buf_cat(buf, buf_add_ui32(length_));
	}
	return buf;
}

buf_t tl_auth_sentCodeTypeSms(int length_)
{
	buf_t buf = buf_add_ui32(0xc000bba2);
	//parse argument length (int)
	{
		buf = buf_cat(buf, buf_add_ui32(length_));
	}
	return buf;
}

buf_t tl_auth_sentCodeTypeCall(int length_)
{
	buf_t buf = buf_add_ui32(0x5353e5a7);
	//parse argument length (int)
	{
		buf = buf_cat(buf, buf_add_ui32(length_));
	}
	return buf;
}

buf_t tl_auth_sentCodeTypeFlashCall(const char * pattern_)
{
	buf_t buf = buf_add_ui32(0xab03c6d9);
	//parse argument pattern (string)
	{
		buf = buf_cat(buf, serialize_string(pattern_));
	}
	return buf;
}

buf_t tl_auth_sentCodeTypeMissedCall(const char * prefix_, int length_)
{
	buf_t buf = buf_add_ui32(0x82006484);
	//parse argument prefix (string)
	{
		buf = buf_cat(buf, serialize_string(prefix_));
	}
	//parse argument length (int)
	{
		buf = buf_cat(buf, buf_add_ui32(length_));
	}
	return buf;
}

buf_t tl_auth_sentCodeTypeEmailCode(bool apple_signin_allowed_, bool google_signin_allowed_, const char * email_pattern_, int length_, int reset_available_period_, int reset_pending_date_)
{
	buf_t buf = buf_add_ui32(0xf450f59b);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument apple_signin_allowed (true)
	if (apple_signin_allowed_)
		*flag1 |= (1 << 0);
	//parse argument google_signin_allowed (true)
	if (google_signin_allowed_)
		*flag1 |= (1 << 1);
	//parse argument email_pattern (string)
	{
		buf = buf_cat(buf, serialize_string(email_pattern_));
	}
	//parse argument length (int)
	{
		buf = buf_cat(buf, buf_add_ui32(length_));
	}
	//parse argument reset_available_period (int)
	if (reset_available_period_)
	{
		buf = buf_cat(buf, buf_add_ui32(reset_available_period_));
		*flag1 |= (1 << 3);
	}
	//parse argument reset_pending_date (int)
	if (reset_pending_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(reset_pending_date_));
		*flag1 |= (1 << 4);
	}
	return buf;
}

buf_t tl_auth_sentCodeTypeSetUpEmailRequired(bool apple_signin_allowed_, bool google_signin_allowed_)
{
	buf_t buf = buf_add_ui32(0xa5491dea);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument apple_signin_allowed (true)
	if (apple_signin_allowed_)
		*flag1 |= (1 << 0);
	//parse argument google_signin_allowed (true)
	if (google_signin_allowed_)
		*flag1 |= (1 << 1);
	return buf;
}

buf_t tl_auth_sentCodeTypeFragmentSms(const char * url_, int length_)
{
	buf_t buf = buf_add_ui32(0xd9565c39);
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	//parse argument length (int)
	{
		buf = buf_cat(buf, buf_add_ui32(length_));
	}
	return buf;
}

buf_t tl_auth_sentCodeTypeFirebaseSms(buf_t *nonce_, long play_integrity_project_id_, buf_t *play_integrity_nonce_, const char * receipt_, int push_timeout_, int length_)
{
	buf_t buf = buf_add_ui32(0x009fd736);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument nonce (bytes)
	if (nonce_)
	{
		buf = buf_cat(buf, serialize_bytes(nonce_->data, nonce_->size));
		*flag1 |= (1 << 0);
	}
	//parse argument play_integrity_project_id (long)
	if (play_integrity_project_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(play_integrity_project_id_));
		*flag1 |= (1 << 2);
	}
	//parse argument play_integrity_nonce (bytes)
	if (play_integrity_nonce_)
	{
		buf = buf_cat(buf, serialize_bytes(play_integrity_nonce_->data, play_integrity_nonce_->size));
		*flag1 |= (1 << 2);
	}
	//parse argument receipt (string)
	if (receipt_)
	{
		buf = buf_cat(buf, serialize_string(receipt_));
		*flag1 |= (1 << 1);
	}
	//parse argument push_timeout (int)
	if (push_timeout_)
	{
		buf = buf_cat(buf, buf_add_ui32(push_timeout_));
		*flag1 |= (1 << 1);
	}
	//parse argument length (int)
	{
		buf = buf_cat(buf, buf_add_ui32(length_));
	}
	return buf;
}

buf_t tl_auth_sentCodeTypeSmsWord(const char * beginning_)
{
	buf_t buf = buf_add_ui32(0xa416ac81);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument beginning (string)
	if (beginning_)
	{
		buf = buf_cat(buf, serialize_string(beginning_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_auth_sentCodeTypeSmsPhrase(const char * beginning_)
{
	buf_t buf = buf_add_ui32(0xb37794af);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument beginning (string)
	if (beginning_)
	{
		buf = buf_cat(buf, serialize_string(beginning_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_messages_botCallbackAnswer(bool alert_, bool has_url_, bool native_ui_, const char * message_, const char * url_, int cache_time_)
{
	buf_t buf = buf_add_ui32(0x36585ea4);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument alert (true)
	if (alert_)
		*flag1 |= (1 << 1);
	//parse argument has_url (true)
	if (has_url_)
		*flag1 |= (1 << 3);
	//parse argument native_ui (true)
	if (native_ui_)
		*flag1 |= (1 << 4);
	//parse argument message (string)
	if (message_)
	{
		buf = buf_cat(buf, serialize_string(message_));
		*flag1 |= (1 << 0);
	}
	//parse argument url (string)
	if (url_)
	{
		buf = buf_cat(buf, serialize_string(url_));
		*flag1 |= (1 << 2);
	}
	//parse argument cache_time (int)
	{
		buf = buf_cat(buf, buf_add_ui32(cache_time_));
	}
	return buf;
}

buf_t tl_messages_messageEditData(bool caption_)
{
	buf_t buf = buf_add_ui32(0x26b5dde6);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument caption (true)
	if (caption_)
		*flag1 |= (1 << 0);
	return buf;
}

buf_t tl_inputBotInlineMessageID(int dc_id_, long id_, long access_hash_)
{
	buf_t buf = buf_add_ui32(0x890c3d89);
	//parse argument dc_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(dc_id_));
	}
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	return buf;
}

buf_t tl_inputBotInlineMessageID64(int dc_id_, long owner_id_, int id_, long access_hash_)
{
	buf_t buf = buf_add_ui32(0xb6d915d7);
	//parse argument dc_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(dc_id_));
	}
	//parse argument owner_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(owner_id_));
	}
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	return buf;
}

buf_t tl_inlineBotSwitchPM(const char * text_, const char * start_param_)
{
	buf_t buf = buf_add_ui32(0x3c20629f);
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	//parse argument start_param (string)
	{
		buf = buf_cat(buf, serialize_string(start_param_));
	}
	return buf;
}

buf_t tl_messages_peerDialogs(Dialog *dialogs_, int dialogs_len, Message *messages_, int messages_len, Chat *chats_, int chats_len, User *users_, int users_len, updates_State *state_)
{
	buf_t buf = buf_add_ui32(0x3371c354);
	//parse argument dialogs (Vector<Dialog>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(dialogs_len));
		int i;
		for (i=0; i<dialogs_len; ++i){
			buf = buf_cat(buf, dialogs_[i]);
		}
	}
	//parse argument messages (Vector<Message>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(messages_len));
		int i;
		for (i=0; i<messages_len; ++i){
			buf = buf_cat(buf, messages_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	//parse argument state (updates_State)
	{
		buf = buf_cat(buf, *state_);
	}
	return buf;
}

buf_t tl_topPeer(Peer *peer_, double rating_)
{
	buf_t buf = buf_add_ui32(0xedcdc05b);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument rating (double)
	{
		buf = buf_cat(buf, buf_add_ui64(rating_));
	}
	return buf;
}

buf_t tl_topPeerCategoryBotsPM()
{
	buf_t buf = buf_add_ui32(0xab661b5b);
	return buf;
}

buf_t tl_topPeerCategoryBotsInline()
{
	buf_t buf = buf_add_ui32(0x148677e2);
	return buf;
}

buf_t tl_topPeerCategoryCorrespondents()
{
	buf_t buf = buf_add_ui32(0x0637b7ed);
	return buf;
}

buf_t tl_topPeerCategoryGroups()
{
	buf_t buf = buf_add_ui32(0xbd17a14a);
	return buf;
}

buf_t tl_topPeerCategoryChannels()
{
	buf_t buf = buf_add_ui32(0x161d9628);
	return buf;
}

buf_t tl_topPeerCategoryPhoneCalls()
{
	buf_t buf = buf_add_ui32(0x1e76a78c);
	return buf;
}

buf_t tl_topPeerCategoryForwardUsers()
{
	buf_t buf = buf_add_ui32(0xa8406ca9);
	return buf;
}

buf_t tl_topPeerCategoryForwardChats()
{
	buf_t buf = buf_add_ui32(0xfbeec0f0);
	return buf;
}

buf_t tl_topPeerCategoryBotsApp()
{
	buf_t buf = buf_add_ui32(0xfd9e7bec);
	return buf;
}

buf_t tl_topPeerCategoryPeers(TopPeerCategory *category_, int count_, TopPeer *peers_, int peers_len)
{
	buf_t buf = buf_add_ui32(0xfb834291);
	//parse argument category (TopPeerCategory)
	{
		buf = buf_cat(buf, *category_);
	}
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	//parse argument peers (Vector<TopPeer>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(peers_len));
		int i;
		for (i=0; i<peers_len; ++i){
			buf = buf_cat(buf, peers_[i]);
		}
	}
	return buf;
}

buf_t tl_contacts_topPeersNotModified()
{
	buf_t buf = buf_add_ui32(0xde266ef5);
	return buf;
}

buf_t tl_contacts_topPeers(TopPeerCategoryPeers *categories_, int categories_len, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x70b772a8);
	//parse argument categories (Vector<TopPeerCategoryPeers>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(categories_len));
		int i;
		for (i=0; i<categories_len; ++i){
			buf = buf_cat(buf, categories_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_contacts_topPeersDisabled()
{
	buf_t buf = buf_add_ui32(0xb52c939d);
	return buf;
}

buf_t tl_draftMessageEmpty(int date_)
{
	buf_t buf = buf_add_ui32(0x1b0c841a);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument date (int)
	if (date_)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_draftMessage(bool no_webpage_, bool invert_media_, InputReplyTo *reply_to_, const char * message_, MessageEntity *entities_, int entities_len, InputMedia *media_, int date_, long effect_)
{
	buf_t buf = buf_add_ui32(0x2d65321f);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument no_webpage (true)
	if (no_webpage_)
		*flag1 |= (1 << 1);
	//parse argument invert_media (true)
	if (invert_media_)
		*flag1 |= (1 << 6);
	//parse argument reply_to (InputReplyTo)
	if (reply_to_)
	{
		buf = buf_cat(buf, *reply_to_);
		*flag1 |= (1 << 4);
	}
	//parse argument message (string)
	{
		buf = buf_cat(buf, serialize_string(message_));
	}
	//parse argument entities (Vector<MessageEntity>)
	if (entities_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(entities_len));
		int i;
		for (i=0; i<entities_len; ++i){
			buf = buf_cat(buf, entities_[i]);
		}
		*flag1 |= (1 << 3);
	}
	//parse argument media (InputMedia)
	if (media_)
	{
		buf = buf_cat(buf, *media_);
		*flag1 |= (1 << 5);
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument effect (long)
	if (effect_)
	{
		buf = buf_cat(buf, buf_add_ui64(effect_));
		*flag1 |= (1 << 7);
	}
	return buf;
}

buf_t tl_messages_featuredStickersNotModified(int count_)
{
	buf_t buf = buf_add_ui32(0xc6dc0c66);
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	return buf;
}

buf_t tl_messages_featuredStickers(bool premium_, long hash_, int count_, StickerSetCovered *sets_, int sets_len, long *unread_, int unread_len)
{
	buf_t buf = buf_add_ui32(0xbe382906);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument premium (true)
	if (premium_)
		*flag1 |= (1 << 0);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	//parse argument sets (Vector<StickerSetCovered>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(sets_len));
		int i;
		for (i=0; i<sets_len; ++i){
			buf = buf_cat(buf, sets_[i]);
		}
	}
	//parse argument unread (Vector<long>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(unread_len));
		int i;
		for (i=0; i<unread_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(unread_[i]));
		}
	}
	return buf;
}

buf_t tl_messages_recentStickersNotModified()
{
	buf_t buf = buf_add_ui32(0x0b17f890);
	return buf;
}

buf_t tl_messages_recentStickers(long hash_, StickerPack *packs_, int packs_len, Document *stickers_, int stickers_len, int *dates_, int dates_len)
{
	buf_t buf = buf_add_ui32(0x88d37c56);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	//parse argument packs (Vector<StickerPack>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(packs_len));
		int i;
		for (i=0; i<packs_len; ++i){
			buf = buf_cat(buf, packs_[i]);
		}
	}
	//parse argument stickers (Vector<Document>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(stickers_len));
		int i;
		for (i=0; i<stickers_len; ++i){
			buf = buf_cat(buf, stickers_[i]);
		}
	}
	//parse argument dates (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(dates_len));
		int i;
		for (i=0; i<dates_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(dates_[i]));
		}
	}
	return buf;
}

buf_t tl_messages_archivedStickers(int count_, StickerSetCovered *sets_, int sets_len)
{
	buf_t buf = buf_add_ui32(0x4fcba9c8);
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	//parse argument sets (Vector<StickerSetCovered>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(sets_len));
		int i;
		for (i=0; i<sets_len; ++i){
			buf = buf_cat(buf, sets_[i]);
		}
	}
	return buf;
}

buf_t tl_messages_stickerSetInstallResultSuccess()
{
	buf_t buf = buf_add_ui32(0x38641628);
	return buf;
}

buf_t tl_messages_stickerSetInstallResultArchive(StickerSetCovered *sets_, int sets_len)
{
	buf_t buf = buf_add_ui32(0x35e410a8);
	//parse argument sets (Vector<StickerSetCovered>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(sets_len));
		int i;
		for (i=0; i<sets_len; ++i){
			buf = buf_cat(buf, sets_[i]);
		}
	}
	return buf;
}

buf_t tl_stickerSetCovered(StickerSet *set_, Document *cover_)
{
	buf_t buf = buf_add_ui32(0x6410a5d2);
	//parse argument set (StickerSet)
	{
		buf = buf_cat(buf, *set_);
	}
	//parse argument cover (Document)
	{
		buf = buf_cat(buf, *cover_);
	}
	return buf;
}

buf_t tl_stickerSetMultiCovered(StickerSet *set_, Document *covers_, int covers_len)
{
	buf_t buf = buf_add_ui32(0x3407e51b);
	//parse argument set (StickerSet)
	{
		buf = buf_cat(buf, *set_);
	}
	//parse argument covers (Vector<Document>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(covers_len));
		int i;
		for (i=0; i<covers_len; ++i){
			buf = buf_cat(buf, covers_[i]);
		}
	}
	return buf;
}

buf_t tl_stickerSetFullCovered(StickerSet *set_, StickerPack *packs_, int packs_len, StickerKeyword *keywords_, int keywords_len, Document *documents_, int documents_len)
{
	buf_t buf = buf_add_ui32(0x40d13c0e);
	//parse argument set (StickerSet)
	{
		buf = buf_cat(buf, *set_);
	}
	//parse argument packs (Vector<StickerPack>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(packs_len));
		int i;
		for (i=0; i<packs_len; ++i){
			buf = buf_cat(buf, packs_[i]);
		}
	}
	//parse argument keywords (Vector<StickerKeyword>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(keywords_len));
		int i;
		for (i=0; i<keywords_len; ++i){
			buf = buf_cat(buf, keywords_[i]);
		}
	}
	//parse argument documents (Vector<Document>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(documents_len));
		int i;
		for (i=0; i<documents_len; ++i){
			buf = buf_cat(buf, documents_[i]);
		}
	}
	return buf;
}

buf_t tl_stickerSetNoCovered(StickerSet *set_)
{
	buf_t buf = buf_add_ui32(0x77b15d1c);
	//parse argument set (StickerSet)
	{
		buf = buf_cat(buf, *set_);
	}
	return buf;
}

buf_t tl_maskCoords(int n_, double x_, double y_, double zoom_)
{
	buf_t buf = buf_add_ui32(0xaed6dbb2);
	//parse argument n (int)
	{
		buf = buf_cat(buf, buf_add_ui32(n_));
	}
	//parse argument x (double)
	{
		buf = buf_cat(buf, buf_add_ui64(x_));
	}
	//parse argument y (double)
	{
		buf = buf_cat(buf, buf_add_ui64(y_));
	}
	//parse argument zoom (double)
	{
		buf = buf_cat(buf, buf_add_ui64(zoom_));
	}
	return buf;
}

buf_t tl_inputStickeredMediaPhoto(InputPhoto *id_)
{
	buf_t buf = buf_add_ui32(0x4a992157);
	//parse argument id (InputPhoto)
	{
		buf = buf_cat(buf, *id_);
	}
	return buf;
}

buf_t tl_inputStickeredMediaDocument(InputDocument *id_)
{
	buf_t buf = buf_add_ui32(0x0438865b);
	//parse argument id (InputDocument)
	{
		buf = buf_cat(buf, *id_);
	}
	return buf;
}

buf_t tl_game(long id_, long access_hash_, const char * short_name_, const char * title_, const char * description_, Photo *photo_, Document *document_)
{
	buf_t buf = buf_add_ui32(0xbdf9653b);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	//parse argument short_name (string)
	{
		buf = buf_cat(buf, serialize_string(short_name_));
	}
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument description (string)
	{
		buf = buf_cat(buf, serialize_string(description_));
	}
	//parse argument photo (Photo)
	{
		buf = buf_cat(buf, *photo_);
	}
	//parse argument document (Document)
	if (document_)
	{
		buf = buf_cat(buf, *document_);
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_inputGameID(long id_, long access_hash_)
{
	buf_t buf = buf_add_ui32(0x032c3e77);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	return buf;
}

buf_t tl_inputGameShortName(InputUser *bot_id_, const char * short_name_)
{
	buf_t buf = buf_add_ui32(0xc331e80a);
	//parse argument bot_id (InputUser)
	{
		buf = buf_cat(buf, *bot_id_);
	}
	//parse argument short_name (string)
	{
		buf = buf_cat(buf, serialize_string(short_name_));
	}
	return buf;
}

buf_t tl_highScore(int pos_, long user_id_, int score_)
{
	buf_t buf = buf_add_ui32(0x73a379eb);
	//parse argument pos (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pos_));
	}
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument score (int)
	{
		buf = buf_cat(buf, buf_add_ui32(score_));
	}
	return buf;
}

buf_t tl_messages_highScores(HighScore *scores_, int scores_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x9a3bfd99);
	//parse argument scores (Vector<HighScore>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(scores_len));
		int i;
		for (i=0; i<scores_len; ++i){
			buf = buf_cat(buf, scores_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_textEmpty()
{
	buf_t buf = buf_add_ui32(0xdc3d824f);
	return buf;
}

buf_t tl_textPlain(const char * text_)
{
	buf_t buf = buf_add_ui32(0x744694e0);
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	return buf;
}

buf_t tl_textBold(RichText *text_)
{
	buf_t buf = buf_add_ui32(0x6724abc4);
	//parse argument text (RichText)
	{
		buf = buf_cat(buf, *text_);
	}
	return buf;
}

buf_t tl_textItalic(RichText *text_)
{
	buf_t buf = buf_add_ui32(0xd912a59c);
	//parse argument text (RichText)
	{
		buf = buf_cat(buf, *text_);
	}
	return buf;
}

buf_t tl_textUnderline(RichText *text_)
{
	buf_t buf = buf_add_ui32(0xc12622c4);
	//parse argument text (RichText)
	{
		buf = buf_cat(buf, *text_);
	}
	return buf;
}

buf_t tl_textStrike(RichText *text_)
{
	buf_t buf = buf_add_ui32(0x9bf8bb95);
	//parse argument text (RichText)
	{
		buf = buf_cat(buf, *text_);
	}
	return buf;
}

buf_t tl_textFixed(RichText *text_)
{
	buf_t buf = buf_add_ui32(0x6c3f19b9);
	//parse argument text (RichText)
	{
		buf = buf_cat(buf, *text_);
	}
	return buf;
}

buf_t tl_textUrl(RichText *text_, const char * url_, long webpage_id_)
{
	buf_t buf = buf_add_ui32(0x3c2884c1);
	//parse argument text (RichText)
	{
		buf = buf_cat(buf, *text_);
	}
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	//parse argument webpage_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(webpage_id_));
	}
	return buf;
}

buf_t tl_textEmail(RichText *text_, const char * email_)
{
	buf_t buf = buf_add_ui32(0xde5a0dd6);
	//parse argument text (RichText)
	{
		buf = buf_cat(buf, *text_);
	}
	//parse argument email (string)
	{
		buf = buf_cat(buf, serialize_string(email_));
	}
	return buf;
}

buf_t tl_textConcat(RichText *texts_, int texts_len)
{
	buf_t buf = buf_add_ui32(0x7e6260d7);
	//parse argument texts (Vector<RichText>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(texts_len));
		int i;
		for (i=0; i<texts_len; ++i){
			buf = buf_cat(buf, texts_[i]);
		}
	}
	return buf;
}

buf_t tl_textSubscript(RichText *text_)
{
	buf_t buf = buf_add_ui32(0xed6a8504);
	//parse argument text (RichText)
	{
		buf = buf_cat(buf, *text_);
	}
	return buf;
}

buf_t tl_textSuperscript(RichText *text_)
{
	buf_t buf = buf_add_ui32(0xc7fb5e01);
	//parse argument text (RichText)
	{
		buf = buf_cat(buf, *text_);
	}
	return buf;
}

buf_t tl_textMarked(RichText *text_)
{
	buf_t buf = buf_add_ui32(0x034b8621);
	//parse argument text (RichText)
	{
		buf = buf_cat(buf, *text_);
	}
	return buf;
}

buf_t tl_textPhone(RichText *text_, const char * phone_)
{
	buf_t buf = buf_add_ui32(0x1ccb966a);
	//parse argument text (RichText)
	{
		buf = buf_cat(buf, *text_);
	}
	//parse argument phone (string)
	{
		buf = buf_cat(buf, serialize_string(phone_));
	}
	return buf;
}

buf_t tl_textImage(long document_id_, int w_, int h_)
{
	buf_t buf = buf_add_ui32(0x081ccf4f);
	//parse argument document_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(document_id_));
	}
	//parse argument w (int)
	{
		buf = buf_cat(buf, buf_add_ui32(w_));
	}
	//parse argument h (int)
	{
		buf = buf_cat(buf, buf_add_ui32(h_));
	}
	return buf;
}

buf_t tl_textAnchor(RichText *text_, const char * name_)
{
	buf_t buf = buf_add_ui32(0x35553762);
	//parse argument text (RichText)
	{
		buf = buf_cat(buf, *text_);
	}
	//parse argument name (string)
	{
		buf = buf_cat(buf, serialize_string(name_));
	}
	return buf;
}

buf_t tl_pageBlockUnsupported()
{
	buf_t buf = buf_add_ui32(0x13567e8a);
	return buf;
}

buf_t tl_pageBlockTitle(RichText *text_)
{
	buf_t buf = buf_add_ui32(0x70abc3fd);
	//parse argument text (RichText)
	{
		buf = buf_cat(buf, *text_);
	}
	return buf;
}

buf_t tl_pageBlockSubtitle(RichText *text_)
{
	buf_t buf = buf_add_ui32(0x8ffa9a1f);
	//parse argument text (RichText)
	{
		buf = buf_cat(buf, *text_);
	}
	return buf;
}

buf_t tl_pageBlockAuthorDate(RichText *author_, int published_date_)
{
	buf_t buf = buf_add_ui32(0xbaafe5e0);
	//parse argument author (RichText)
	{
		buf = buf_cat(buf, *author_);
	}
	//parse argument published_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(published_date_));
	}
	return buf;
}

buf_t tl_pageBlockHeader(RichText *text_)
{
	buf_t buf = buf_add_ui32(0xbfd064ec);
	//parse argument text (RichText)
	{
		buf = buf_cat(buf, *text_);
	}
	return buf;
}

buf_t tl_pageBlockSubheader(RichText *text_)
{
	buf_t buf = buf_add_ui32(0xf12bb6e1);
	//parse argument text (RichText)
	{
		buf = buf_cat(buf, *text_);
	}
	return buf;
}

buf_t tl_pageBlockParagraph(RichText *text_)
{
	buf_t buf = buf_add_ui32(0x467a0766);
	//parse argument text (RichText)
	{
		buf = buf_cat(buf, *text_);
	}
	return buf;
}

buf_t tl_pageBlockPreformatted(RichText *text_, const char * language_)
{
	buf_t buf = buf_add_ui32(0xc070d93e);
	//parse argument text (RichText)
	{
		buf = buf_cat(buf, *text_);
	}
	//parse argument language (string)
	{
		buf = buf_cat(buf, serialize_string(language_));
	}
	return buf;
}

buf_t tl_pageBlockFooter(RichText *text_)
{
	buf_t buf = buf_add_ui32(0x48870999);
	//parse argument text (RichText)
	{
		buf = buf_cat(buf, *text_);
	}
	return buf;
}

buf_t tl_pageBlockDivider()
{
	buf_t buf = buf_add_ui32(0xdb20b188);
	return buf;
}

buf_t tl_pageBlockAnchor(const char * name_)
{
	buf_t buf = buf_add_ui32(0xce0d37b0);
	//parse argument name (string)
	{
		buf = buf_cat(buf, serialize_string(name_));
	}
	return buf;
}

buf_t tl_pageBlockList(PageListItem *items_, int items_len)
{
	buf_t buf = buf_add_ui32(0xe4e88011);
	//parse argument items (Vector<PageListItem>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(items_len));
		int i;
		for (i=0; i<items_len; ++i){
			buf = buf_cat(buf, items_[i]);
		}
	}
	return buf;
}

buf_t tl_pageBlockBlockquote(RichText *text_, RichText *caption_)
{
	buf_t buf = buf_add_ui32(0x263d7c26);
	//parse argument text (RichText)
	{
		buf = buf_cat(buf, *text_);
	}
	//parse argument caption (RichText)
	{
		buf = buf_cat(buf, *caption_);
	}
	return buf;
}

buf_t tl_pageBlockPullquote(RichText *text_, RichText *caption_)
{
	buf_t buf = buf_add_ui32(0x4f4456d3);
	//parse argument text (RichText)
	{
		buf = buf_cat(buf, *text_);
	}
	//parse argument caption (RichText)
	{
		buf = buf_cat(buf, *caption_);
	}
	return buf;
}

buf_t tl_pageBlockPhoto(long photo_id_, PageCaption *caption_, const char * url_, long webpage_id_)
{
	buf_t buf = buf_add_ui32(0x1759c560);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument photo_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(photo_id_));
	}
	//parse argument caption (PageCaption)
	{
		buf = buf_cat(buf, *caption_);
	}
	//parse argument url (string)
	if (url_)
	{
		buf = buf_cat(buf, serialize_string(url_));
		*flag1 |= (1 << 0);
	}
	//parse argument webpage_id (long)
	if (webpage_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(webpage_id_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_pageBlockVideo(bool autoplay_, bool loop_, long video_id_, PageCaption *caption_)
{
	buf_t buf = buf_add_ui32(0x7c8fe7b6);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument autoplay (true)
	if (autoplay_)
		*flag1 |= (1 << 0);
	//parse argument loop (true)
	if (loop_)
		*flag1 |= (1 << 1);
	//parse argument video_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(video_id_));
	}
	//parse argument caption (PageCaption)
	{
		buf = buf_cat(buf, *caption_);
	}
	return buf;
}

buf_t tl_pageBlockCover(PageBlock *cover_)
{
	buf_t buf = buf_add_ui32(0x39f23300);
	//parse argument cover (PageBlock)
	{
		buf = buf_cat(buf, *cover_);
	}
	return buf;
}

buf_t tl_pageBlockEmbed(bool full_width_, bool allow_scrolling_, const char * url_, const char * html_, long poster_photo_id_, int w_, int h_, PageCaption *caption_)
{
	buf_t buf = buf_add_ui32(0xa8718dc5);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument full_width (true)
	if (full_width_)
		*flag1 |= (1 << 0);
	//parse argument allow_scrolling (true)
	if (allow_scrolling_)
		*flag1 |= (1 << 3);
	//parse argument url (string)
	if (url_)
	{
		buf = buf_cat(buf, serialize_string(url_));
		*flag1 |= (1 << 1);
	}
	//parse argument html (string)
	if (html_)
	{
		buf = buf_cat(buf, serialize_string(html_));
		*flag1 |= (1 << 2);
	}
	//parse argument poster_photo_id (long)
	if (poster_photo_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(poster_photo_id_));
		*flag1 |= (1 << 4);
	}
	//parse argument w (int)
	if (w_)
	{
		buf = buf_cat(buf, buf_add_ui32(w_));
		*flag1 |= (1 << 5);
	}
	//parse argument h (int)
	if (h_)
	{
		buf = buf_cat(buf, buf_add_ui32(h_));
		*flag1 |= (1 << 5);
	}
	//parse argument caption (PageCaption)
	{
		buf = buf_cat(buf, *caption_);
	}
	return buf;
}

buf_t tl_pageBlockEmbedPost(const char * url_, long webpage_id_, long author_photo_id_, const char * author_, int date_, PageBlock *blocks_, int blocks_len, PageCaption *caption_)
{
	buf_t buf = buf_add_ui32(0xf259a80b);
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	//parse argument webpage_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(webpage_id_));
	}
	//parse argument author_photo_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(author_photo_id_));
	}
	//parse argument author (string)
	{
		buf = buf_cat(buf, serialize_string(author_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument blocks (Vector<PageBlock>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(blocks_len));
		int i;
		for (i=0; i<blocks_len; ++i){
			buf = buf_cat(buf, blocks_[i]);
		}
	}
	//parse argument caption (PageCaption)
	{
		buf = buf_cat(buf, *caption_);
	}
	return buf;
}

buf_t tl_pageBlockCollage(PageBlock *items_, int items_len, PageCaption *caption_)
{
	buf_t buf = buf_add_ui32(0x65a0fa4d);
	//parse argument items (Vector<PageBlock>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(items_len));
		int i;
		for (i=0; i<items_len; ++i){
			buf = buf_cat(buf, items_[i]);
		}
	}
	//parse argument caption (PageCaption)
	{
		buf = buf_cat(buf, *caption_);
	}
	return buf;
}

buf_t tl_pageBlockSlideshow(PageBlock *items_, int items_len, PageCaption *caption_)
{
	buf_t buf = buf_add_ui32(0x031f9590);
	//parse argument items (Vector<PageBlock>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(items_len));
		int i;
		for (i=0; i<items_len; ++i){
			buf = buf_cat(buf, items_[i]);
		}
	}
	//parse argument caption (PageCaption)
	{
		buf = buf_cat(buf, *caption_);
	}
	return buf;
}

buf_t tl_pageBlockChannel(Chat *channel_)
{
	buf_t buf = buf_add_ui32(0xef1751b5);
	//parse argument channel (Chat)
	{
		buf = buf_cat(buf, *channel_);
	}
	return buf;
}

buf_t tl_pageBlockAudio(long audio_id_, PageCaption *caption_)
{
	buf_t buf = buf_add_ui32(0x804361ea);
	//parse argument audio_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(audio_id_));
	}
	//parse argument caption (PageCaption)
	{
		buf = buf_cat(buf, *caption_);
	}
	return buf;
}

buf_t tl_pageBlockKicker(RichText *text_)
{
	buf_t buf = buf_add_ui32(0x1e148390);
	//parse argument text (RichText)
	{
		buf = buf_cat(buf, *text_);
	}
	return buf;
}

buf_t tl_pageBlockTable(bool bordered_, bool striped_, RichText *title_, PageTableRow *rows_, int rows_len)
{
	buf_t buf = buf_add_ui32(0xbf4dea82);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument bordered (true)
	if (bordered_)
		*flag1 |= (1 << 0);
	//parse argument striped (true)
	if (striped_)
		*flag1 |= (1 << 1);
	//parse argument title (RichText)
	{
		buf = buf_cat(buf, *title_);
	}
	//parse argument rows (Vector<PageTableRow>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(rows_len));
		int i;
		for (i=0; i<rows_len; ++i){
			buf = buf_cat(buf, rows_[i]);
		}
	}
	return buf;
}

buf_t tl_pageBlockOrderedList(PageListOrderedItem *items_, int items_len)
{
	buf_t buf = buf_add_ui32(0x9a8ae1e1);
	//parse argument items (Vector<PageListOrderedItem>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(items_len));
		int i;
		for (i=0; i<items_len; ++i){
			buf = buf_cat(buf, items_[i]);
		}
	}
	return buf;
}

buf_t tl_pageBlockDetails(bool open_, PageBlock *blocks_, int blocks_len, RichText *title_)
{
	buf_t buf = buf_add_ui32(0x76768bed);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument open (true)
	if (open_)
		*flag1 |= (1 << 0);
	//parse argument blocks (Vector<PageBlock>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(blocks_len));
		int i;
		for (i=0; i<blocks_len; ++i){
			buf = buf_cat(buf, blocks_[i]);
		}
	}
	//parse argument title (RichText)
	{
		buf = buf_cat(buf, *title_);
	}
	return buf;
}

buf_t tl_pageBlockRelatedArticles(RichText *title_, PageRelatedArticle *articles_, int articles_len)
{
	buf_t buf = buf_add_ui32(0x16115a96);
	//parse argument title (RichText)
	{
		buf = buf_cat(buf, *title_);
	}
	//parse argument articles (Vector<PageRelatedArticle>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(articles_len));
		int i;
		for (i=0; i<articles_len; ++i){
			buf = buf_cat(buf, articles_[i]);
		}
	}
	return buf;
}

buf_t tl_pageBlockMap(GeoPoint *geo_, int zoom_, int w_, int h_, PageCaption *caption_)
{
	buf_t buf = buf_add_ui32(0xa44f3ef6);
	//parse argument geo (GeoPoint)
	{
		buf = buf_cat(buf, *geo_);
	}
	//parse argument zoom (int)
	{
		buf = buf_cat(buf, buf_add_ui32(zoom_));
	}
	//parse argument w (int)
	{
		buf = buf_cat(buf, buf_add_ui32(w_));
	}
	//parse argument h (int)
	{
		buf = buf_cat(buf, buf_add_ui32(h_));
	}
	//parse argument caption (PageCaption)
	{
		buf = buf_cat(buf, *caption_);
	}
	return buf;
}

buf_t tl_phoneCallDiscardReasonMissed()
{
	buf_t buf = buf_add_ui32(0x85e42301);
	return buf;
}

buf_t tl_phoneCallDiscardReasonDisconnect()
{
	buf_t buf = buf_add_ui32(0xe095c1a0);
	return buf;
}

buf_t tl_phoneCallDiscardReasonHangup()
{
	buf_t buf = buf_add_ui32(0x57adc690);
	return buf;
}

buf_t tl_phoneCallDiscardReasonBusy()
{
	buf_t buf = buf_add_ui32(0xfaf7e8c9);
	return buf;
}

buf_t tl_dataJSON(const char * data_)
{
	buf_t buf = buf_add_ui32(0x7d748d04);
	//parse argument data (string)
	{
		buf = buf_cat(buf, serialize_string(data_));
	}
	return buf;
}

buf_t tl_labeledPrice(const char * label_, long amount_)
{
	buf_t buf = buf_add_ui32(0xcb296bf8);
	//parse argument label (string)
	{
		buf = buf_cat(buf, serialize_string(label_));
	}
	//parse argument amount (long)
	{
		buf = buf_cat(buf, buf_add_ui64(amount_));
	}
	return buf;
}

buf_t tl_invoice(bool test_, bool name_requested_, bool phone_requested_, bool email_requested_, bool shipping_address_requested_, bool flexible_, bool phone_to_provider_, bool email_to_provider_, bool recurring_, const char * currency_, LabeledPrice *prices_, int prices_len, long max_tip_amount_, long *suggested_tip_amounts_, int suggested_tip_amounts_len, const char * terms_url_)
{
	buf_t buf = buf_add_ui32(0x5db95a15);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument test (true)
	if (test_)
		*flag1 |= (1 << 0);
	//parse argument name_requested (true)
	if (name_requested_)
		*flag1 |= (1 << 1);
	//parse argument phone_requested (true)
	if (phone_requested_)
		*flag1 |= (1 << 2);
	//parse argument email_requested (true)
	if (email_requested_)
		*flag1 |= (1 << 3);
	//parse argument shipping_address_requested (true)
	if (shipping_address_requested_)
		*flag1 |= (1 << 4);
	//parse argument flexible (true)
	if (flexible_)
		*flag1 |= (1 << 5);
	//parse argument phone_to_provider (true)
	if (phone_to_provider_)
		*flag1 |= (1 << 6);
	//parse argument email_to_provider (true)
	if (email_to_provider_)
		*flag1 |= (1 << 7);
	//parse argument recurring (true)
	if (recurring_)
		*flag1 |= (1 << 9);
	//parse argument currency (string)
	{
		buf = buf_cat(buf, serialize_string(currency_));
	}
	//parse argument prices (Vector<LabeledPrice>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(prices_len));
		int i;
		for (i=0; i<prices_len; ++i){
			buf = buf_cat(buf, prices_[i]);
		}
	}
	//parse argument max_tip_amount (long)
	if (max_tip_amount_)
	{
		buf = buf_cat(buf, buf_add_ui64(max_tip_amount_));
		*flag1 |= (1 << 8);
	}
	//parse argument suggested_tip_amounts (Vector<long>)
	if (suggested_tip_amounts_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(suggested_tip_amounts_len));
		int i;
		for (i=0; i<suggested_tip_amounts_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(suggested_tip_amounts_[i]));
		}
		*flag1 |= (1 << 8);
	}
	//parse argument terms_url (string)
	if (terms_url_)
	{
		buf = buf_cat(buf, serialize_string(terms_url_));
		*flag1 |= (1 << 10);
	}
	return buf;
}

buf_t tl_paymentCharge(const char * id_, const char * provider_charge_id_)
{
	buf_t buf = buf_add_ui32(0xea02c27e);
	//parse argument id (string)
	{
		buf = buf_cat(buf, serialize_string(id_));
	}
	//parse argument provider_charge_id (string)
	{
		buf = buf_cat(buf, serialize_string(provider_charge_id_));
	}
	return buf;
}

buf_t tl_postAddress(const char * street_line1_, const char * street_line2_, const char * city_, const char * state_, const char * country_iso2_, const char * post_code_)
{
	buf_t buf = buf_add_ui32(0x1e8caaeb);
	//parse argument street_line1 (string)
	{
		buf = buf_cat(buf, serialize_string(street_line1_));
	}
	//parse argument street_line2 (string)
	{
		buf = buf_cat(buf, serialize_string(street_line2_));
	}
	//parse argument city (string)
	{
		buf = buf_cat(buf, serialize_string(city_));
	}
	//parse argument state (string)
	{
		buf = buf_cat(buf, serialize_string(state_));
	}
	//parse argument country_iso2 (string)
	{
		buf = buf_cat(buf, serialize_string(country_iso2_));
	}
	//parse argument post_code (string)
	{
		buf = buf_cat(buf, serialize_string(post_code_));
	}
	return buf;
}

buf_t tl_paymentRequestedInfo(const char * name_, const char * phone_, const char * email_, PostAddress *shipping_address_)
{
	buf_t buf = buf_add_ui32(0x909c3f94);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument name (string)
	if (name_)
	{
		buf = buf_cat(buf, serialize_string(name_));
		*flag1 |= (1 << 0);
	}
	//parse argument phone (string)
	if (phone_)
	{
		buf = buf_cat(buf, serialize_string(phone_));
		*flag1 |= (1 << 1);
	}
	//parse argument email (string)
	if (email_)
	{
		buf = buf_cat(buf, serialize_string(email_));
		*flag1 |= (1 << 2);
	}
	//parse argument shipping_address (PostAddress)
	if (shipping_address_)
	{
		buf = buf_cat(buf, *shipping_address_);
		*flag1 |= (1 << 3);
	}
	return buf;
}

buf_t tl_paymentSavedCredentialsCard(const char * id_, const char * title_)
{
	buf_t buf = buf_add_ui32(0xcdc27a1f);
	//parse argument id (string)
	{
		buf = buf_cat(buf, serialize_string(id_));
	}
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	return buf;
}

buf_t tl_webDocument(const char * url_, long access_hash_, int size_, const char * mime_type_, DocumentAttribute *attributes_, int attributes_len)
{
	buf_t buf = buf_add_ui32(0x1c570ed1);
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	//parse argument size (int)
	{
		buf = buf_cat(buf, buf_add_ui32(size_));
	}
	//parse argument mime_type (string)
	{
		buf = buf_cat(buf, serialize_string(mime_type_));
	}
	//parse argument attributes (Vector<DocumentAttribute>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(attributes_len));
		int i;
		for (i=0; i<attributes_len; ++i){
			buf = buf_cat(buf, attributes_[i]);
		}
	}
	return buf;
}

buf_t tl_webDocumentNoProxy(const char * url_, int size_, const char * mime_type_, DocumentAttribute *attributes_, int attributes_len)
{
	buf_t buf = buf_add_ui32(0xf9c8bcc6);
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	//parse argument size (int)
	{
		buf = buf_cat(buf, buf_add_ui32(size_));
	}
	//parse argument mime_type (string)
	{
		buf = buf_cat(buf, serialize_string(mime_type_));
	}
	//parse argument attributes (Vector<DocumentAttribute>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(attributes_len));
		int i;
		for (i=0; i<attributes_len; ++i){
			buf = buf_cat(buf, attributes_[i]);
		}
	}
	return buf;
}

buf_t tl_inputWebDocument(const char * url_, int size_, const char * mime_type_, DocumentAttribute *attributes_, int attributes_len)
{
	buf_t buf = buf_add_ui32(0x9bed434d);
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	//parse argument size (int)
	{
		buf = buf_cat(buf, buf_add_ui32(size_));
	}
	//parse argument mime_type (string)
	{
		buf = buf_cat(buf, serialize_string(mime_type_));
	}
	//parse argument attributes (Vector<DocumentAttribute>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(attributes_len));
		int i;
		for (i=0; i<attributes_len; ++i){
			buf = buf_cat(buf, attributes_[i]);
		}
	}
	return buf;
}

buf_t tl_inputWebFileLocation(const char * url_, long access_hash_)
{
	buf_t buf = buf_add_ui32(0xc239d686);
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	return buf;
}

buf_t tl_inputWebFileGeoPointLocation(InputGeoPoint *geo_point_, long access_hash_, int w_, int h_, int zoom_, int scale_)
{
	buf_t buf = buf_add_ui32(0x9f2221c9);
	//parse argument geo_point (InputGeoPoint)
	{
		buf = buf_cat(buf, *geo_point_);
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	//parse argument w (int)
	{
		buf = buf_cat(buf, buf_add_ui32(w_));
	}
	//parse argument h (int)
	{
		buf = buf_cat(buf, buf_add_ui32(h_));
	}
	//parse argument zoom (int)
	{
		buf = buf_cat(buf, buf_add_ui32(zoom_));
	}
	//parse argument scale (int)
	{
		buf = buf_cat(buf, buf_add_ui32(scale_));
	}
	return buf;
}

buf_t tl_inputWebFileAudioAlbumThumbLocation(bool small_, InputDocument *document_, const char * title_, const char * performer_)
{
	buf_t buf = buf_add_ui32(0xf46fe924);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument small (true)
	if (small_)
		*flag1 |= (1 << 2);
	//parse argument document (InputDocument)
	if (document_)
	{
		buf = buf_cat(buf, *document_);
		*flag1 |= (1 << 0);
	}
	//parse argument title (string)
	if (title_)
	{
		buf = buf_cat(buf, serialize_string(title_));
		*flag1 |= (1 << 1);
	}
	//parse argument performer (string)
	if (performer_)
	{
		buf = buf_cat(buf, serialize_string(performer_));
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_upload_webFile(int size_, const char * mime_type_, storage_FileType *file_type_, int mtime_, buf_t *bytes_)
{
	buf_t buf = buf_add_ui32(0x21e753bc);
	//parse argument size (int)
	{
		buf = buf_cat(buf, buf_add_ui32(size_));
	}
	//parse argument mime_type (string)
	{
		buf = buf_cat(buf, serialize_string(mime_type_));
	}
	//parse argument file_type (storage_FileType)
	{
		buf = buf_cat(buf, *file_type_);
	}
	//parse argument mtime (int)
	{
		buf = buf_cat(buf, buf_add_ui32(mtime_));
	}
	//parse argument bytes (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(bytes_->data, bytes_->size));
	}
	return buf;
}

buf_t tl_payments_paymentForm(bool can_save_credentials_, bool password_missing_, long form_id_, long bot_id_, const char * title_, const char * description_, WebDocument *photo_, Invoice *invoice_, long provider_id_, const char * url_, const char * native_provider_, DataJSON *native_params_, PaymentFormMethod *additional_methods_, int additional_methods_len, PaymentRequestedInfo *saved_info_, PaymentSavedCredentials *saved_credentials_, int saved_credentials_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0xa0058751);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument can_save_credentials (true)
	if (can_save_credentials_)
		*flag1 |= (1 << 2);
	//parse argument password_missing (true)
	if (password_missing_)
		*flag1 |= (1 << 3);
	//parse argument form_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(form_id_));
	}
	//parse argument bot_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(bot_id_));
	}
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument description (string)
	{
		buf = buf_cat(buf, serialize_string(description_));
	}
	//parse argument photo (WebDocument)
	if (photo_)
	{
		buf = buf_cat(buf, *photo_);
		*flag1 |= (1 << 5);
	}
	//parse argument invoice (Invoice)
	{
		buf = buf_cat(buf, *invoice_);
	}
	//parse argument provider_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(provider_id_));
	}
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	//parse argument native_provider (string)
	if (native_provider_)
	{
		buf = buf_cat(buf, serialize_string(native_provider_));
		*flag1 |= (1 << 4);
	}
	//parse argument native_params (DataJSON)
	if (native_params_)
	{
		buf = buf_cat(buf, *native_params_);
		*flag1 |= (1 << 4);
	}
	//parse argument additional_methods (Vector<PaymentFormMethod>)
	if (additional_methods_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(additional_methods_len));
		int i;
		for (i=0; i<additional_methods_len; ++i){
			buf = buf_cat(buf, additional_methods_[i]);
		}
		*flag1 |= (1 << 6);
	}
	//parse argument saved_info (PaymentRequestedInfo)
	if (saved_info_)
	{
		buf = buf_cat(buf, *saved_info_);
		*flag1 |= (1 << 0);
	}
	//parse argument saved_credentials (Vector<PaymentSavedCredentials>)
	if (saved_credentials_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(saved_credentials_len));
		int i;
		for (i=0; i<saved_credentials_len; ++i){
			buf = buf_cat(buf, saved_credentials_[i]);
		}
		*flag1 |= (1 << 1);
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_payments_paymentFormStars(long form_id_, long bot_id_, const char * title_, const char * description_, WebDocument *photo_, Invoice *invoice_, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x7bf6b15c);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument form_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(form_id_));
	}
	//parse argument bot_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(bot_id_));
	}
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument description (string)
	{
		buf = buf_cat(buf, serialize_string(description_));
	}
	//parse argument photo (WebDocument)
	if (photo_)
	{
		buf = buf_cat(buf, *photo_);
		*flag1 |= (1 << 5);
	}
	//parse argument invoice (Invoice)
	{
		buf = buf_cat(buf, *invoice_);
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_payments_paymentFormStarGift(long form_id_, Invoice *invoice_)
{
	buf_t buf = buf_add_ui32(0xb425cfe1);
	//parse argument form_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(form_id_));
	}
	//parse argument invoice (Invoice)
	{
		buf = buf_cat(buf, *invoice_);
	}
	return buf;
}

buf_t tl_payments_validatedRequestedInfo(const char * id_, ShippingOption *shipping_options_, int shipping_options_len)
{
	buf_t buf = buf_add_ui32(0xd1451883);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument id (string)
	if (id_)
	{
		buf = buf_cat(buf, serialize_string(id_));
		*flag1 |= (1 << 0);
	}
	//parse argument shipping_options (Vector<ShippingOption>)
	if (shipping_options_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(shipping_options_len));
		int i;
		for (i=0; i<shipping_options_len; ++i){
			buf = buf_cat(buf, shipping_options_[i]);
		}
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_payments_paymentResult(Updates *updates_)
{
	buf_t buf = buf_add_ui32(0x4e5f810d);
	//parse argument updates (Updates)
	{
		buf = buf_cat(buf, *updates_);
	}
	return buf;
}

buf_t tl_payments_paymentVerificationNeeded(const char * url_)
{
	buf_t buf = buf_add_ui32(0xd8411139);
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	return buf;
}

buf_t tl_payments_paymentReceipt(int date_, long bot_id_, long provider_id_, const char * title_, const char * description_, WebDocument *photo_, Invoice *invoice_, PaymentRequestedInfo *info_, ShippingOption *shipping_, long tip_amount_, const char * currency_, long total_amount_, const char * credentials_title_, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x70c4fe03);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument bot_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(bot_id_));
	}
	//parse argument provider_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(provider_id_));
	}
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument description (string)
	{
		buf = buf_cat(buf, serialize_string(description_));
	}
	//parse argument photo (WebDocument)
	if (photo_)
	{
		buf = buf_cat(buf, *photo_);
		*flag1 |= (1 << 2);
	}
	//parse argument invoice (Invoice)
	{
		buf = buf_cat(buf, *invoice_);
	}
	//parse argument info (PaymentRequestedInfo)
	if (info_)
	{
		buf = buf_cat(buf, *info_);
		*flag1 |= (1 << 0);
	}
	//parse argument shipping (ShippingOption)
	if (shipping_)
	{
		buf = buf_cat(buf, *shipping_);
		*flag1 |= (1 << 1);
	}
	//parse argument tip_amount (long)
	if (tip_amount_)
	{
		buf = buf_cat(buf, buf_add_ui64(tip_amount_));
		*flag1 |= (1 << 3);
	}
	//parse argument currency (string)
	{
		buf = buf_cat(buf, serialize_string(currency_));
	}
	//parse argument total_amount (long)
	{
		buf = buf_cat(buf, buf_add_ui64(total_amount_));
	}
	//parse argument credentials_title (string)
	{
		buf = buf_cat(buf, serialize_string(credentials_title_));
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_payments_paymentReceiptStars(int date_, long bot_id_, const char * title_, const char * description_, WebDocument *photo_, Invoice *invoice_, const char * currency_, long total_amount_, const char * transaction_id_, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0xdabbf83a);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument bot_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(bot_id_));
	}
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument description (string)
	{
		buf = buf_cat(buf, serialize_string(description_));
	}
	//parse argument photo (WebDocument)
	if (photo_)
	{
		buf = buf_cat(buf, *photo_);
		*flag1 |= (1 << 2);
	}
	//parse argument invoice (Invoice)
	{
		buf = buf_cat(buf, *invoice_);
	}
	//parse argument currency (string)
	{
		buf = buf_cat(buf, serialize_string(currency_));
	}
	//parse argument total_amount (long)
	{
		buf = buf_cat(buf, buf_add_ui64(total_amount_));
	}
	//parse argument transaction_id (string)
	{
		buf = buf_cat(buf, serialize_string(transaction_id_));
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_payments_savedInfo(bool has_saved_credentials_, PaymentRequestedInfo *saved_info_)
{
	buf_t buf = buf_add_ui32(0xfb8fe43c);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument has_saved_credentials (true)
	if (has_saved_credentials_)
		*flag1 |= (1 << 1);
	//parse argument saved_info (PaymentRequestedInfo)
	if (saved_info_)
	{
		buf = buf_cat(buf, *saved_info_);
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_inputPaymentCredentialsSaved(const char * id_, buf_t *tmp_password_)
{
	buf_t buf = buf_add_ui32(0xc10eb2cf);
	//parse argument id (string)
	{
		buf = buf_cat(buf, serialize_string(id_));
	}
	//parse argument tmp_password (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(tmp_password_->data, tmp_password_->size));
	}
	return buf;
}

buf_t tl_inputPaymentCredentials(bool save_, DataJSON *data_)
{
	buf_t buf = buf_add_ui32(0x3417d728);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument save (true)
	if (save_)
		*flag1 |= (1 << 0);
	//parse argument data (DataJSON)
	{
		buf = buf_cat(buf, *data_);
	}
	return buf;
}

buf_t tl_inputPaymentCredentialsApplePay(DataJSON *payment_data_)
{
	buf_t buf = buf_add_ui32(0x0aa1c39f);
	//parse argument payment_data (DataJSON)
	{
		buf = buf_cat(buf, *payment_data_);
	}
	return buf;
}

buf_t tl_inputPaymentCredentialsGooglePay(DataJSON *payment_token_)
{
	buf_t buf = buf_add_ui32(0x8ac32801);
	//parse argument payment_token (DataJSON)
	{
		buf = buf_cat(buf, *payment_token_);
	}
	return buf;
}

buf_t tl_account_tmpPassword(buf_t *tmp_password_, int valid_until_)
{
	buf_t buf = buf_add_ui32(0xdb64fd34);
	//parse argument tmp_password (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(tmp_password_->data, tmp_password_->size));
	}
	//parse argument valid_until (int)
	{
		buf = buf_cat(buf, buf_add_ui32(valid_until_));
	}
	return buf;
}

buf_t tl_shippingOption(const char * id_, const char * title_, LabeledPrice *prices_, int prices_len)
{
	buf_t buf = buf_add_ui32(0xb6213cdf);
	//parse argument id (string)
	{
		buf = buf_cat(buf, serialize_string(id_));
	}
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument prices (Vector<LabeledPrice>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(prices_len));
		int i;
		for (i=0; i<prices_len; ++i){
			buf = buf_cat(buf, prices_[i]);
		}
	}
	return buf;
}

buf_t tl_inputStickerSetItem(InputDocument *document_, const char * emoji_, MaskCoords *mask_coords_, const char * keywords_)
{
	buf_t buf = buf_add_ui32(0x32da9e9c);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument document (InputDocument)
	{
		buf = buf_cat(buf, *document_);
	}
	//parse argument emoji (string)
	{
		buf = buf_cat(buf, serialize_string(emoji_));
	}
	//parse argument mask_coords (MaskCoords)
	if (mask_coords_)
	{
		buf = buf_cat(buf, *mask_coords_);
		*flag1 |= (1 << 0);
	}
	//parse argument keywords (string)
	if (keywords_)
	{
		buf = buf_cat(buf, serialize_string(keywords_));
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_inputPhoneCall(long id_, long access_hash_)
{
	buf_t buf = buf_add_ui32(0x1e36fded);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	return buf;
}

buf_t tl_phoneCallEmpty(long id_)
{
	buf_t buf = buf_add_ui32(0x5366c915);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	return buf;
}

buf_t tl_phoneCallWaiting(bool video_, long id_, long access_hash_, int date_, long admin_id_, long participant_id_, PhoneCallProtocol *protocol_, int receive_date_)
{
	buf_t buf = buf_add_ui32(0xc5226f17);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument video (true)
	if (video_)
		*flag1 |= (1 << 6);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument admin_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(admin_id_));
	}
	//parse argument participant_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(participant_id_));
	}
	//parse argument protocol (PhoneCallProtocol)
	{
		buf = buf_cat(buf, *protocol_);
	}
	//parse argument receive_date (int)
	if (receive_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(receive_date_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_phoneCallRequested(bool video_, long id_, long access_hash_, int date_, long admin_id_, long participant_id_, buf_t *g_a_hash_, PhoneCallProtocol *protocol_)
{
	buf_t buf = buf_add_ui32(0x14b0ed0c);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument video (true)
	if (video_)
		*flag1 |= (1 << 6);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument admin_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(admin_id_));
	}
	//parse argument participant_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(participant_id_));
	}
	//parse argument g_a_hash (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(g_a_hash_->data, g_a_hash_->size));
	}
	//parse argument protocol (PhoneCallProtocol)
	{
		buf = buf_cat(buf, *protocol_);
	}
	return buf;
}

buf_t tl_phoneCallAccepted(bool video_, long id_, long access_hash_, int date_, long admin_id_, long participant_id_, buf_t *g_b_, PhoneCallProtocol *protocol_)
{
	buf_t buf = buf_add_ui32(0x3660c311);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument video (true)
	if (video_)
		*flag1 |= (1 << 6);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument admin_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(admin_id_));
	}
	//parse argument participant_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(participant_id_));
	}
	//parse argument g_b (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(g_b_->data, g_b_->size));
	}
	//parse argument protocol (PhoneCallProtocol)
	{
		buf = buf_cat(buf, *protocol_);
	}
	return buf;
}

buf_t tl_phoneCall(bool p2p_allowed_, bool video_, long id_, long access_hash_, int date_, long admin_id_, long participant_id_, buf_t *g_a_or_b_, long key_fingerprint_, PhoneCallProtocol *protocol_, PhoneConnection *connections_, int connections_len, int start_date_, DataJSON *custom_parameters_)
{
	buf_t buf = buf_add_ui32(0x30535af5);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument p2p_allowed (true)
	if (p2p_allowed_)
		*flag1 |= (1 << 5);
	//parse argument video (true)
	if (video_)
		*flag1 |= (1 << 6);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument admin_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(admin_id_));
	}
	//parse argument participant_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(participant_id_));
	}
	//parse argument g_a_or_b (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(g_a_or_b_->data, g_a_or_b_->size));
	}
	//parse argument key_fingerprint (long)
	{
		buf = buf_cat(buf, buf_add_ui64(key_fingerprint_));
	}
	//parse argument protocol (PhoneCallProtocol)
	{
		buf = buf_cat(buf, *protocol_);
	}
	//parse argument connections (Vector<PhoneConnection>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(connections_len));
		int i;
		for (i=0; i<connections_len; ++i){
			buf = buf_cat(buf, connections_[i]);
		}
	}
	//parse argument start_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(start_date_));
	}
	//parse argument custom_parameters (DataJSON)
	if (custom_parameters_)
	{
		buf = buf_cat(buf, *custom_parameters_);
		*flag1 |= (1 << 7);
	}
	return buf;
}

buf_t tl_phoneCallDiscarded(bool need_rating_, bool need_debug_, bool video_, long id_, PhoneCallDiscardReason *reason_, int duration_)
{
	buf_t buf = buf_add_ui32(0x50ca4de1);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument need_rating (true)
	if (need_rating_)
		*flag1 |= (1 << 2);
	//parse argument need_debug (true)
	if (need_debug_)
		*flag1 |= (1 << 3);
	//parse argument video (true)
	if (video_)
		*flag1 |= (1 << 6);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument reason (PhoneCallDiscardReason)
	if (reason_)
	{
		buf = buf_cat(buf, *reason_);
		*flag1 |= (1 << 0);
	}
	//parse argument duration (int)
	if (duration_)
	{
		buf = buf_cat(buf, buf_add_ui32(duration_));
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_phoneConnection(bool tcp_, long id_, const char * ip_, const char * ipv6_, int port_, buf_t *peer_tag_)
{
	buf_t buf = buf_add_ui32(0x9cc123c7);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument tcp (true)
	if (tcp_)
		*flag1 |= (1 << 0);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument ip (string)
	{
		buf = buf_cat(buf, serialize_string(ip_));
	}
	//parse argument ipv6 (string)
	{
		buf = buf_cat(buf, serialize_string(ipv6_));
	}
	//parse argument port (int)
	{
		buf = buf_cat(buf, buf_add_ui32(port_));
	}
	//parse argument peer_tag (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(peer_tag_->data, peer_tag_->size));
	}
	return buf;
}

buf_t tl_phoneConnectionWebrtc(bool turn_, bool stun_, long id_, const char * ip_, const char * ipv6_, int port_, const char * username_, const char * password_)
{
	buf_t buf = buf_add_ui32(0x635fe375);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument turn (true)
	if (turn_)
		*flag1 |= (1 << 0);
	//parse argument stun (true)
	if (stun_)
		*flag1 |= (1 << 1);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument ip (string)
	{
		buf = buf_cat(buf, serialize_string(ip_));
	}
	//parse argument ipv6 (string)
	{
		buf = buf_cat(buf, serialize_string(ipv6_));
	}
	//parse argument port (int)
	{
		buf = buf_cat(buf, buf_add_ui32(port_));
	}
	//parse argument username (string)
	{
		buf = buf_cat(buf, serialize_string(username_));
	}
	//parse argument password (string)
	{
		buf = buf_cat(buf, serialize_string(password_));
	}
	return buf;
}

buf_t tl_phoneCallProtocol(bool udp_p2p_, bool udp_reflector_, int min_layer_, int max_layer_, const char * *library_versions_, int library_versions_len)
{
	buf_t buf = buf_add_ui32(0xfc878fc8);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument udp_p2p (true)
	if (udp_p2p_)
		*flag1 |= (1 << 0);
	//parse argument udp_reflector (true)
	if (udp_reflector_)
		*flag1 |= (1 << 1);
	//parse argument min_layer (int)
	{
		buf = buf_cat(buf, buf_add_ui32(min_layer_));
	}
	//parse argument max_layer (int)
	{
		buf = buf_cat(buf, buf_add_ui32(max_layer_));
	}
	//parse argument library_versions (Vector<string>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(library_versions_len));
		int i;
		for (i=0; i<library_versions_len; ++i){
			buf = buf_cat(buf, serialize_string(library_versions_[i]));
		}
	}
	return buf;
}

buf_t tl_phone_phoneCall(PhoneCall *phone_call_, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0xec82e140);
	//parse argument phone_call (PhoneCall)
	{
		buf = buf_cat(buf, *phone_call_);
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_upload_cdnFileReuploadNeeded(buf_t *request_token_)
{
	buf_t buf = buf_add_ui32(0xeea8e46e);
	//parse argument request_token (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(request_token_->data, request_token_->size));
	}
	return buf;
}

buf_t tl_upload_cdnFile(buf_t *bytes_)
{
	buf_t buf = buf_add_ui32(0xa99fca4f);
	//parse argument bytes (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(bytes_->data, bytes_->size));
	}
	return buf;
}

buf_t tl_cdnPublicKey(int dc_id_, const char * public_key_)
{
	buf_t buf = buf_add_ui32(0xc982eaba);
	//parse argument dc_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(dc_id_));
	}
	//parse argument public_key (string)
	{
		buf = buf_cat(buf, serialize_string(public_key_));
	}
	return buf;
}

buf_t tl_cdnConfig(CdnPublicKey *public_keys_, int public_keys_len)
{
	buf_t buf = buf_add_ui32(0x5725e40a);
	//parse argument public_keys (Vector<CdnPublicKey>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(public_keys_len));
		int i;
		for (i=0; i<public_keys_len; ++i){
			buf = buf_cat(buf, public_keys_[i]);
		}
	}
	return buf;
}

buf_t tl_langPackString(const char * key_, const char * value_)
{
	buf_t buf = buf_add_ui32(0xcad181f6);
	//parse argument key (string)
	{
		buf = buf_cat(buf, serialize_string(key_));
	}
	//parse argument value (string)
	{
		buf = buf_cat(buf, serialize_string(value_));
	}
	return buf;
}

buf_t tl_langPackStringPluralized(const char * key_, const char * zero_value_, const char * one_value_, const char * two_value_, const char * few_value_, const char * many_value_, const char * other_value_)
{
	buf_t buf = buf_add_ui32(0x6c47ac9f);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument key (string)
	{
		buf = buf_cat(buf, serialize_string(key_));
	}
	//parse argument zero_value (string)
	if (zero_value_)
	{
		buf = buf_cat(buf, serialize_string(zero_value_));
		*flag1 |= (1 << 0);
	}
	//parse argument one_value (string)
	if (one_value_)
	{
		buf = buf_cat(buf, serialize_string(one_value_));
		*flag1 |= (1 << 1);
	}
	//parse argument two_value (string)
	if (two_value_)
	{
		buf = buf_cat(buf, serialize_string(two_value_));
		*flag1 |= (1 << 2);
	}
	//parse argument few_value (string)
	if (few_value_)
	{
		buf = buf_cat(buf, serialize_string(few_value_));
		*flag1 |= (1 << 3);
	}
	//parse argument many_value (string)
	if (many_value_)
	{
		buf = buf_cat(buf, serialize_string(many_value_));
		*flag1 |= (1 << 4);
	}
	//parse argument other_value (string)
	{
		buf = buf_cat(buf, serialize_string(other_value_));
	}
	return buf;
}

buf_t tl_langPackStringDeleted(const char * key_)
{
	buf_t buf = buf_add_ui32(0x2979eeb2);
	//parse argument key (string)
	{
		buf = buf_cat(buf, serialize_string(key_));
	}
	return buf;
}

buf_t tl_langPackDifference(const char * lang_code_, int from_version_, int version_, LangPackString *strings_, int strings_len)
{
	buf_t buf = buf_add_ui32(0xf385c1f6);
	//parse argument lang_code (string)
	{
		buf = buf_cat(buf, serialize_string(lang_code_));
	}
	//parse argument from_version (int)
	{
		buf = buf_cat(buf, buf_add_ui32(from_version_));
	}
	//parse argument version (int)
	{
		buf = buf_cat(buf, buf_add_ui32(version_));
	}
	//parse argument strings (Vector<LangPackString>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(strings_len));
		int i;
		for (i=0; i<strings_len; ++i){
			buf = buf_cat(buf, strings_[i]);
		}
	}
	return buf;
}

buf_t tl_langPackLanguage(bool official_, bool rtl_, bool beta_, const char * name_, const char * native_name_, const char * lang_code_, const char * base_lang_code_, const char * plural_code_, int strings_count_, int translated_count_, const char * translations_url_)
{
	buf_t buf = buf_add_ui32(0xeeca5ce3);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument official (true)
	if (official_)
		*flag1 |= (1 << 0);
	//parse argument rtl (true)
	if (rtl_)
		*flag1 |= (1 << 2);
	//parse argument beta (true)
	if (beta_)
		*flag1 |= (1 << 3);
	//parse argument name (string)
	{
		buf = buf_cat(buf, serialize_string(name_));
	}
	//parse argument native_name (string)
	{
		buf = buf_cat(buf, serialize_string(native_name_));
	}
	//parse argument lang_code (string)
	{
		buf = buf_cat(buf, serialize_string(lang_code_));
	}
	//parse argument base_lang_code (string)
	if (base_lang_code_)
	{
		buf = buf_cat(buf, serialize_string(base_lang_code_));
		*flag1 |= (1 << 1);
	}
	//parse argument plural_code (string)
	{
		buf = buf_cat(buf, serialize_string(plural_code_));
	}
	//parse argument strings_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(strings_count_));
	}
	//parse argument translated_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(translated_count_));
	}
	//parse argument translations_url (string)
	{
		buf = buf_cat(buf, serialize_string(translations_url_));
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionChangeTitle(const char * prev_value_, const char * new_value_)
{
	buf_t buf = buf_add_ui32(0xe6dfb825);
	//parse argument prev_value (string)
	{
		buf = buf_cat(buf, serialize_string(prev_value_));
	}
	//parse argument new_value (string)
	{
		buf = buf_cat(buf, serialize_string(new_value_));
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionChangeAbout(const char * prev_value_, const char * new_value_)
{
	buf_t buf = buf_add_ui32(0x55188a2e);
	//parse argument prev_value (string)
	{
		buf = buf_cat(buf, serialize_string(prev_value_));
	}
	//parse argument new_value (string)
	{
		buf = buf_cat(buf, serialize_string(new_value_));
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionChangeUsername(const char * prev_value_, const char * new_value_)
{
	buf_t buf = buf_add_ui32(0x6a4afc38);
	//parse argument prev_value (string)
	{
		buf = buf_cat(buf, serialize_string(prev_value_));
	}
	//parse argument new_value (string)
	{
		buf = buf_cat(buf, serialize_string(new_value_));
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionChangePhoto(Photo *prev_photo_, Photo *new_photo_)
{
	buf_t buf = buf_add_ui32(0x434bd2af);
	//parse argument prev_photo (Photo)
	{
		buf = buf_cat(buf, *prev_photo_);
	}
	//parse argument new_photo (Photo)
	{
		buf = buf_cat(buf, *new_photo_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionToggleInvites(Bool *new_value_)
{
	buf_t buf = buf_add_ui32(0x1b7907ae);
	//parse argument new_value (Bool)
	{
		buf = buf_cat(buf, *new_value_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionToggleSignatures(Bool *new_value_)
{
	buf_t buf = buf_add_ui32(0x26ae0971);
	//parse argument new_value (Bool)
	{
		buf = buf_cat(buf, *new_value_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionUpdatePinned(Message *message_)
{
	buf_t buf = buf_add_ui32(0xe9e82c18);
	//parse argument message (Message)
	{
		buf = buf_cat(buf, *message_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionEditMessage(Message *prev_message_, Message *new_message_)
{
	buf_t buf = buf_add_ui32(0x709b2405);
	//parse argument prev_message (Message)
	{
		buf = buf_cat(buf, *prev_message_);
	}
	//parse argument new_message (Message)
	{
		buf = buf_cat(buf, *new_message_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionDeleteMessage(Message *message_)
{
	buf_t buf = buf_add_ui32(0x42e047bb);
	//parse argument message (Message)
	{
		buf = buf_cat(buf, *message_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionParticipantJoin()
{
	buf_t buf = buf_add_ui32(0x183040d3);
	return buf;
}

buf_t tl_channelAdminLogEventActionParticipantLeave()
{
	buf_t buf = buf_add_ui32(0xf89777f2);
	return buf;
}

buf_t tl_channelAdminLogEventActionParticipantInvite(ChannelParticipant *participant_)
{
	buf_t buf = buf_add_ui32(0xe31c34d8);
	//parse argument participant (ChannelParticipant)
	{
		buf = buf_cat(buf, *participant_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionParticipantToggleBan(ChannelParticipant *prev_participant_, ChannelParticipant *new_participant_)
{
	buf_t buf = buf_add_ui32(0xe6d83d7e);
	//parse argument prev_participant (ChannelParticipant)
	{
		buf = buf_cat(buf, *prev_participant_);
	}
	//parse argument new_participant (ChannelParticipant)
	{
		buf = buf_cat(buf, *new_participant_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionParticipantToggleAdmin(ChannelParticipant *prev_participant_, ChannelParticipant *new_participant_)
{
	buf_t buf = buf_add_ui32(0xd5676710);
	//parse argument prev_participant (ChannelParticipant)
	{
		buf = buf_cat(buf, *prev_participant_);
	}
	//parse argument new_participant (ChannelParticipant)
	{
		buf = buf_cat(buf, *new_participant_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionChangeStickerSet(InputStickerSet *prev_stickerset_, InputStickerSet *new_stickerset_)
{
	buf_t buf = buf_add_ui32(0xb1c3caa7);
	//parse argument prev_stickerset (InputStickerSet)
	{
		buf = buf_cat(buf, *prev_stickerset_);
	}
	//parse argument new_stickerset (InputStickerSet)
	{
		buf = buf_cat(buf, *new_stickerset_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionTogglePreHistoryHidden(Bool *new_value_)
{
	buf_t buf = buf_add_ui32(0x5f5c95f1);
	//parse argument new_value (Bool)
	{
		buf = buf_cat(buf, *new_value_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionDefaultBannedRights(ChatBannedRights *prev_banned_rights_, ChatBannedRights *new_banned_rights_)
{
	buf_t buf = buf_add_ui32(0x2df5fc0a);
	//parse argument prev_banned_rights (ChatBannedRights)
	{
		buf = buf_cat(buf, *prev_banned_rights_);
	}
	//parse argument new_banned_rights (ChatBannedRights)
	{
		buf = buf_cat(buf, *new_banned_rights_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionStopPoll(Message *message_)
{
	buf_t buf = buf_add_ui32(0x8f079643);
	//parse argument message (Message)
	{
		buf = buf_cat(buf, *message_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionChangeLinkedChat(long prev_value_, long new_value_)
{
	buf_t buf = buf_add_ui32(0x050c7ac8);
	//parse argument prev_value (long)
	{
		buf = buf_cat(buf, buf_add_ui64(prev_value_));
	}
	//parse argument new_value (long)
	{
		buf = buf_cat(buf, buf_add_ui64(new_value_));
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionChangeLocation(ChannelLocation *prev_value_, ChannelLocation *new_value_)
{
	buf_t buf = buf_add_ui32(0x0e6b76ae);
	//parse argument prev_value (ChannelLocation)
	{
		buf = buf_cat(buf, *prev_value_);
	}
	//parse argument new_value (ChannelLocation)
	{
		buf = buf_cat(buf, *new_value_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionToggleSlowMode(int prev_value_, int new_value_)
{
	buf_t buf = buf_add_ui32(0x53909779);
	//parse argument prev_value (int)
	{
		buf = buf_cat(buf, buf_add_ui32(prev_value_));
	}
	//parse argument new_value (int)
	{
		buf = buf_cat(buf, buf_add_ui32(new_value_));
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionStartGroupCall(InputGroupCall *call_)
{
	buf_t buf = buf_add_ui32(0x23209745);
	//parse argument call (InputGroupCall)
	{
		buf = buf_cat(buf, *call_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionDiscardGroupCall(InputGroupCall *call_)
{
	buf_t buf = buf_add_ui32(0xdb9f9140);
	//parse argument call (InputGroupCall)
	{
		buf = buf_cat(buf, *call_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionParticipantMute(GroupCallParticipant *participant_)
{
	buf_t buf = buf_add_ui32(0xf92424d2);
	//parse argument participant (GroupCallParticipant)
	{
		buf = buf_cat(buf, *participant_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionParticipantUnmute(GroupCallParticipant *participant_)
{
	buf_t buf = buf_add_ui32(0xe64429c0);
	//parse argument participant (GroupCallParticipant)
	{
		buf = buf_cat(buf, *participant_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionToggleGroupCallSetting(Bool *join_muted_)
{
	buf_t buf = buf_add_ui32(0x56d6a247);
	//parse argument join_muted (Bool)
	{
		buf = buf_cat(buf, *join_muted_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionParticipantJoinByInvite(bool via_chatlist_, ExportedChatInvite *invite_)
{
	buf_t buf = buf_add_ui32(0xfe9fc158);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument via_chatlist (true)
	if (via_chatlist_)
		*flag1 |= (1 << 0);
	//parse argument invite (ExportedChatInvite)
	{
		buf = buf_cat(buf, *invite_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionExportedInviteDelete(ExportedChatInvite *invite_)
{
	buf_t buf = buf_add_ui32(0x5a50fca4);
	//parse argument invite (ExportedChatInvite)
	{
		buf = buf_cat(buf, *invite_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionExportedInviteRevoke(ExportedChatInvite *invite_)
{
	buf_t buf = buf_add_ui32(0x410a134e);
	//parse argument invite (ExportedChatInvite)
	{
		buf = buf_cat(buf, *invite_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionExportedInviteEdit(ExportedChatInvite *prev_invite_, ExportedChatInvite *new_invite_)
{
	buf_t buf = buf_add_ui32(0xe90ebb59);
	//parse argument prev_invite (ExportedChatInvite)
	{
		buf = buf_cat(buf, *prev_invite_);
	}
	//parse argument new_invite (ExportedChatInvite)
	{
		buf = buf_cat(buf, *new_invite_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionParticipantVolume(GroupCallParticipant *participant_)
{
	buf_t buf = buf_add_ui32(0x3e7f6847);
	//parse argument participant (GroupCallParticipant)
	{
		buf = buf_cat(buf, *participant_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionChangeHistoryTTL(int prev_value_, int new_value_)
{
	buf_t buf = buf_add_ui32(0x6e941a38);
	//parse argument prev_value (int)
	{
		buf = buf_cat(buf, buf_add_ui32(prev_value_));
	}
	//parse argument new_value (int)
	{
		buf = buf_cat(buf, buf_add_ui32(new_value_));
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionParticipantJoinByRequest(ExportedChatInvite *invite_, long approved_by_)
{
	buf_t buf = buf_add_ui32(0xafb6144a);
	//parse argument invite (ExportedChatInvite)
	{
		buf = buf_cat(buf, *invite_);
	}
	//parse argument approved_by (long)
	{
		buf = buf_cat(buf, buf_add_ui64(approved_by_));
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionToggleNoForwards(Bool *new_value_)
{
	buf_t buf = buf_add_ui32(0xcb2ac766);
	//parse argument new_value (Bool)
	{
		buf = buf_cat(buf, *new_value_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionSendMessage(Message *message_)
{
	buf_t buf = buf_add_ui32(0x278f2868);
	//parse argument message (Message)
	{
		buf = buf_cat(buf, *message_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionChangeAvailableReactions(ChatReactions *prev_value_, ChatReactions *new_value_)
{
	buf_t buf = buf_add_ui32(0xbe4e0ef8);
	//parse argument prev_value (ChatReactions)
	{
		buf = buf_cat(buf, *prev_value_);
	}
	//parse argument new_value (ChatReactions)
	{
		buf = buf_cat(buf, *new_value_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionChangeUsernames(const char * *prev_value_, int prev_value_len, const char * *new_value_, int new_value_len)
{
	buf_t buf = buf_add_ui32(0xf04fb3a9);
	//parse argument prev_value (Vector<string>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(prev_value_len));
		int i;
		for (i=0; i<prev_value_len; ++i){
			buf = buf_cat(buf, serialize_string(prev_value_[i]));
		}
	}
	//parse argument new_value (Vector<string>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(new_value_len));
		int i;
		for (i=0; i<new_value_len; ++i){
			buf = buf_cat(buf, serialize_string(new_value_[i]));
		}
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionToggleForum(Bool *new_value_)
{
	buf_t buf = buf_add_ui32(0x02cc6383);
	//parse argument new_value (Bool)
	{
		buf = buf_cat(buf, *new_value_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionCreateTopic(ForumTopic *topic_)
{
	buf_t buf = buf_add_ui32(0x58707d28);
	//parse argument topic (ForumTopic)
	{
		buf = buf_cat(buf, *topic_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionEditTopic(ForumTopic *prev_topic_, ForumTopic *new_topic_)
{
	buf_t buf = buf_add_ui32(0xf06fe208);
	//parse argument prev_topic (ForumTopic)
	{
		buf = buf_cat(buf, *prev_topic_);
	}
	//parse argument new_topic (ForumTopic)
	{
		buf = buf_cat(buf, *new_topic_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionDeleteTopic(ForumTopic *topic_)
{
	buf_t buf = buf_add_ui32(0xae168909);
	//parse argument topic (ForumTopic)
	{
		buf = buf_cat(buf, *topic_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionPinTopic(ForumTopic *prev_topic_, ForumTopic *new_topic_)
{
	buf_t buf = buf_add_ui32(0x5d8d353b);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument prev_topic (ForumTopic)
	if (prev_topic_)
	{
		buf = buf_cat(buf, *prev_topic_);
		*flag1 |= (1 << 0);
	}
	//parse argument new_topic (ForumTopic)
	if (new_topic_)
	{
		buf = buf_cat(buf, *new_topic_);
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionToggleAntiSpam(Bool *new_value_)
{
	buf_t buf = buf_add_ui32(0x64f36dfc);
	//parse argument new_value (Bool)
	{
		buf = buf_cat(buf, *new_value_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionChangePeerColor(PeerColor *prev_value_, PeerColor *new_value_)
{
	buf_t buf = buf_add_ui32(0x5796e780);
	//parse argument prev_value (PeerColor)
	{
		buf = buf_cat(buf, *prev_value_);
	}
	//parse argument new_value (PeerColor)
	{
		buf = buf_cat(buf, *new_value_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionChangeProfilePeerColor(PeerColor *prev_value_, PeerColor *new_value_)
{
	buf_t buf = buf_add_ui32(0x5e477b25);
	//parse argument prev_value (PeerColor)
	{
		buf = buf_cat(buf, *prev_value_);
	}
	//parse argument new_value (PeerColor)
	{
		buf = buf_cat(buf, *new_value_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionChangeWallpaper(WallPaper *prev_value_, WallPaper *new_value_)
{
	buf_t buf = buf_add_ui32(0x31bb5d52);
	//parse argument prev_value (WallPaper)
	{
		buf = buf_cat(buf, *prev_value_);
	}
	//parse argument new_value (WallPaper)
	{
		buf = buf_cat(buf, *new_value_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionChangeEmojiStatus(EmojiStatus *prev_value_, EmojiStatus *new_value_)
{
	buf_t buf = buf_add_ui32(0x3ea9feb1);
	//parse argument prev_value (EmojiStatus)
	{
		buf = buf_cat(buf, *prev_value_);
	}
	//parse argument new_value (EmojiStatus)
	{
		buf = buf_cat(buf, *new_value_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionChangeEmojiStickerSet(InputStickerSet *prev_stickerset_, InputStickerSet *new_stickerset_)
{
	buf_t buf = buf_add_ui32(0x46d840ab);
	//parse argument prev_stickerset (InputStickerSet)
	{
		buf = buf_cat(buf, *prev_stickerset_);
	}
	//parse argument new_stickerset (InputStickerSet)
	{
		buf = buf_cat(buf, *new_stickerset_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionToggleSignatureProfiles(Bool *new_value_)
{
	buf_t buf = buf_add_ui32(0x60a79c79);
	//parse argument new_value (Bool)
	{
		buf = buf_cat(buf, *new_value_);
	}
	return buf;
}

buf_t tl_channelAdminLogEventActionParticipantSubExtend(ChannelParticipant *prev_participant_, ChannelParticipant *new_participant_)
{
	buf_t buf = buf_add_ui32(0x64642db3);
	//parse argument prev_participant (ChannelParticipant)
	{
		buf = buf_cat(buf, *prev_participant_);
	}
	//parse argument new_participant (ChannelParticipant)
	{
		buf = buf_cat(buf, *new_participant_);
	}
	return buf;
}

buf_t tl_channelAdminLogEvent(long id_, int date_, long user_id_, ChannelAdminLogEventAction *action_)
{
	buf_t buf = buf_add_ui32(0x1fad68cd);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument action (ChannelAdminLogEventAction)
	{
		buf = buf_cat(buf, *action_);
	}
	return buf;
}

buf_t tl_channels_adminLogResults(ChannelAdminLogEvent *events_, int events_len, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0xed8af74d);
	//parse argument events (Vector<ChannelAdminLogEvent>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(events_len));
		int i;
		for (i=0; i<events_len; ++i){
			buf = buf_cat(buf, events_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_channelAdminLogEventsFilter(bool join_, bool leave_, bool invite_, bool ban_, bool unban_, bool kick_, bool unkick_, bool promote_, bool demote_, bool info_, bool settings_, bool pinned_, bool edit_, bool delete_, bool group_call_, bool invites_, bool send_, bool forums_, bool sub_extend_)
{
	buf_t buf = buf_add_ui32(0xea107ae4);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument join (true)
	if (join_)
		*flag1 |= (1 << 0);
	//parse argument leave (true)
	if (leave_)
		*flag1 |= (1 << 1);
	//parse argument invite (true)
	if (invite_)
		*flag1 |= (1 << 2);
	//parse argument ban (true)
	if (ban_)
		*flag1 |= (1 << 3);
	//parse argument unban (true)
	if (unban_)
		*flag1 |= (1 << 4);
	//parse argument kick (true)
	if (kick_)
		*flag1 |= (1 << 5);
	//parse argument unkick (true)
	if (unkick_)
		*flag1 |= (1 << 6);
	//parse argument promote (true)
	if (promote_)
		*flag1 |= (1 << 7);
	//parse argument demote (true)
	if (demote_)
		*flag1 |= (1 << 8);
	//parse argument info (true)
	if (info_)
		*flag1 |= (1 << 9);
	//parse argument settings (true)
	if (settings_)
		*flag1 |= (1 << 10);
	//parse argument pinned (true)
	if (pinned_)
		*flag1 |= (1 << 11);
	//parse argument edit (true)
	if (edit_)
		*flag1 |= (1 << 12);
	//parse argument delete (true)
	if (delete_)
		*flag1 |= (1 << 13);
	//parse argument group_call (true)
	if (group_call_)
		*flag1 |= (1 << 14);
	//parse argument invites (true)
	if (invites_)
		*flag1 |= (1 << 15);
	//parse argument send (true)
	if (send_)
		*flag1 |= (1 << 16);
	//parse argument forums (true)
	if (forums_)
		*flag1 |= (1 << 17);
	//parse argument sub_extend (true)
	if (sub_extend_)
		*flag1 |= (1 << 18);
	return buf;
}

buf_t tl_popularContact(long client_id_, int importers_)
{
	buf_t buf = buf_add_ui32(0x5ce14175);
	//parse argument client_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(client_id_));
	}
	//parse argument importers (int)
	{
		buf = buf_cat(buf, buf_add_ui32(importers_));
	}
	return buf;
}

buf_t tl_messages_favedStickersNotModified()
{
	buf_t buf = buf_add_ui32(0x9e8fa6d3);
	return buf;
}

buf_t tl_messages_favedStickers(long hash_, StickerPack *packs_, int packs_len, Document *stickers_, int stickers_len)
{
	buf_t buf = buf_add_ui32(0x2cb51097);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	//parse argument packs (Vector<StickerPack>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(packs_len));
		int i;
		for (i=0; i<packs_len; ++i){
			buf = buf_cat(buf, packs_[i]);
		}
	}
	//parse argument stickers (Vector<Document>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(stickers_len));
		int i;
		for (i=0; i<stickers_len; ++i){
			buf = buf_cat(buf, stickers_[i]);
		}
	}
	return buf;
}

buf_t tl_recentMeUrlUnknown(const char * url_)
{
	buf_t buf = buf_add_ui32(0x46e1d13d);
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	return buf;
}

buf_t tl_recentMeUrlUser(const char * url_, long user_id_)
{
	buf_t buf = buf_add_ui32(0xb92c09e2);
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	return buf;
}

buf_t tl_recentMeUrlChat(const char * url_, long chat_id_)
{
	buf_t buf = buf_add_ui32(0xb2da71d2);
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	//parse argument chat_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(chat_id_));
	}
	return buf;
}

buf_t tl_recentMeUrlChatInvite(const char * url_, ChatInvite *chat_invite_)
{
	buf_t buf = buf_add_ui32(0xeb49081d);
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	//parse argument chat_invite (ChatInvite)
	{
		buf = buf_cat(buf, *chat_invite_);
	}
	return buf;
}

buf_t tl_recentMeUrlStickerSet(const char * url_, StickerSetCovered *set_)
{
	buf_t buf = buf_add_ui32(0xbc0a57dc);
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	//parse argument set (StickerSetCovered)
	{
		buf = buf_cat(buf, *set_);
	}
	return buf;
}

buf_t tl_help_recentMeUrls(RecentMeUrl *urls_, int urls_len, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x0e0310d7);
	//parse argument urls (Vector<RecentMeUrl>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(urls_len));
		int i;
		for (i=0; i<urls_len; ++i){
			buf = buf_cat(buf, urls_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_inputSingleMedia(InputMedia *media_, long random_id_, const char * message_, MessageEntity *entities_, int entities_len)
{
	buf_t buf = buf_add_ui32(0x1cc6e91f);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument media (InputMedia)
	{
		buf = buf_cat(buf, *media_);
	}
	//parse argument random_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(random_id_));
	}
	//parse argument message (string)
	{
		buf = buf_cat(buf, serialize_string(message_));
	}
	//parse argument entities (Vector<MessageEntity>)
	if (entities_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(entities_len));
		int i;
		for (i=0; i<entities_len; ++i){
			buf = buf_cat(buf, entities_[i]);
		}
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_webAuthorization(long hash_, long bot_id_, const char * domain_, const char * browser_, const char * platform_, int date_created_, int date_active_, const char * ip_, const char * region_)
{
	buf_t buf = buf_add_ui32(0xa6f8f452);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	//parse argument bot_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(bot_id_));
	}
	//parse argument domain (string)
	{
		buf = buf_cat(buf, serialize_string(domain_));
	}
	//parse argument browser (string)
	{
		buf = buf_cat(buf, serialize_string(browser_));
	}
	//parse argument platform (string)
	{
		buf = buf_cat(buf, serialize_string(platform_));
	}
	//parse argument date_created (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_created_));
	}
	//parse argument date_active (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_active_));
	}
	//parse argument ip (string)
	{
		buf = buf_cat(buf, serialize_string(ip_));
	}
	//parse argument region (string)
	{
		buf = buf_cat(buf, serialize_string(region_));
	}
	return buf;
}

buf_t tl_account_webAuthorizations(WebAuthorization *authorizations_, int authorizations_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0xed56c9fc);
	//parse argument authorizations (Vector<WebAuthorization>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(authorizations_len));
		int i;
		for (i=0; i<authorizations_len; ++i){
			buf = buf_cat(buf, authorizations_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_inputMessageID(int id_)
{
	buf_t buf = buf_add_ui32(0xa676a322);
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	return buf;
}

buf_t tl_inputMessageReplyTo(int id_)
{
	buf_t buf = buf_add_ui32(0xbad88395);
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	return buf;
}

buf_t tl_inputMessagePinned()
{
	buf_t buf = buf_add_ui32(0x86872538);
	return buf;
}

buf_t tl_inputMessageCallbackQuery(int id_, long query_id_)
{
	buf_t buf = buf_add_ui32(0xacfa1a7e);
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument query_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(query_id_));
	}
	return buf;
}

buf_t tl_inputDialogPeer(InputPeer *peer_)
{
	buf_t buf = buf_add_ui32(0xfcaafeb7);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_inputDialogPeerFolder(int folder_id_)
{
	buf_t buf = buf_add_ui32(0x64600527);
	//parse argument folder_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(folder_id_));
	}
	return buf;
}

buf_t tl_dialogPeer(Peer *peer_)
{
	buf_t buf = buf_add_ui32(0xe56dbf05);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_dialogPeerFolder(int folder_id_)
{
	buf_t buf = buf_add_ui32(0x514519e2);
	//parse argument folder_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(folder_id_));
	}
	return buf;
}

buf_t tl_messages_foundStickerSetsNotModified()
{
	buf_t buf = buf_add_ui32(0x0d54b65d);
	return buf;
}

buf_t tl_messages_foundStickerSets(long hash_, StickerSetCovered *sets_, int sets_len)
{
	buf_t buf = buf_add_ui32(0x8af09dd2);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	//parse argument sets (Vector<StickerSetCovered>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(sets_len));
		int i;
		for (i=0; i<sets_len; ++i){
			buf = buf_cat(buf, sets_[i]);
		}
	}
	return buf;
}

buf_t tl_fileHash(long offset_, int limit_, buf_t *hash_)
{
	buf_t buf = buf_add_ui32(0xf39b035c);
	//parse argument offset (long)
	{
		buf = buf_cat(buf, buf_add_ui64(offset_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	//parse argument hash (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(hash_->data, hash_->size));
	}
	return buf;
}

buf_t tl_inputClientProxy(const char * address_, int port_)
{
	buf_t buf = buf_add_ui32(0x75588b3f);
	//parse argument address (string)
	{
		buf = buf_cat(buf, serialize_string(address_));
	}
	//parse argument port (int)
	{
		buf = buf_cat(buf, buf_add_ui32(port_));
	}
	return buf;
}

buf_t tl_help_termsOfServiceUpdateEmpty(int expires_)
{
	buf_t buf = buf_add_ui32(0xe3309f7f);
	//parse argument expires (int)
	{
		buf = buf_cat(buf, buf_add_ui32(expires_));
	}
	return buf;
}

buf_t tl_help_termsOfServiceUpdate(int expires_, help_TermsOfService *terms_of_service_)
{
	buf_t buf = buf_add_ui32(0x28ecf961);
	//parse argument expires (int)
	{
		buf = buf_cat(buf, buf_add_ui32(expires_));
	}
	//parse argument terms_of_service (help_TermsOfService)
	{
		buf = buf_cat(buf, *terms_of_service_);
	}
	return buf;
}

buf_t tl_inputSecureFileUploaded(long id_, int parts_, const char * md5_checksum_, buf_t *file_hash_, buf_t *secret_)
{
	buf_t buf = buf_add_ui32(0x3334b0f0);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument parts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(parts_));
	}
	//parse argument md5_checksum (string)
	{
		buf = buf_cat(buf, serialize_string(md5_checksum_));
	}
	//parse argument file_hash (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(file_hash_->data, file_hash_->size));
	}
	//parse argument secret (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(secret_->data, secret_->size));
	}
	return buf;
}

buf_t tl_inputSecureFile(long id_, long access_hash_)
{
	buf_t buf = buf_add_ui32(0x5367e5be);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	return buf;
}

buf_t tl_secureFileEmpty()
{
	buf_t buf = buf_add_ui32(0x64199744);
	return buf;
}

buf_t tl_secureFile(long id_, long access_hash_, long size_, int dc_id_, int date_, buf_t *file_hash_, buf_t *secret_)
{
	buf_t buf = buf_add_ui32(0x7d09c27e);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	//parse argument size (long)
	{
		buf = buf_cat(buf, buf_add_ui64(size_));
	}
	//parse argument dc_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(dc_id_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument file_hash (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(file_hash_->data, file_hash_->size));
	}
	//parse argument secret (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(secret_->data, secret_->size));
	}
	return buf;
}

buf_t tl_secureData(buf_t *data_, buf_t *data_hash_, buf_t *secret_)
{
	buf_t buf = buf_add_ui32(0x8aeabec3);
	//parse argument data (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(data_->data, data_->size));
	}
	//parse argument data_hash (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(data_hash_->data, data_hash_->size));
	}
	//parse argument secret (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(secret_->data, secret_->size));
	}
	return buf;
}

buf_t tl_securePlainPhone(const char * phone_)
{
	buf_t buf = buf_add_ui32(0x7d6099dd);
	//parse argument phone (string)
	{
		buf = buf_cat(buf, serialize_string(phone_));
	}
	return buf;
}

buf_t tl_securePlainEmail(const char * email_)
{
	buf_t buf = buf_add_ui32(0x21ec5a5f);
	//parse argument email (string)
	{
		buf = buf_cat(buf, serialize_string(email_));
	}
	return buf;
}

buf_t tl_secureValueTypePersonalDetails()
{
	buf_t buf = buf_add_ui32(0x9d2a81e3);
	return buf;
}

buf_t tl_secureValueTypePassport()
{
	buf_t buf = buf_add_ui32(0x3dac6a00);
	return buf;
}

buf_t tl_secureValueTypeDriverLicense()
{
	buf_t buf = buf_add_ui32(0x06e425c4);
	return buf;
}

buf_t tl_secureValueTypeIdentityCard()
{
	buf_t buf = buf_add_ui32(0xa0d0744b);
	return buf;
}

buf_t tl_secureValueTypeInternalPassport()
{
	buf_t buf = buf_add_ui32(0x99a48f23);
	return buf;
}

buf_t tl_secureValueTypeAddress()
{
	buf_t buf = buf_add_ui32(0xcbe31e26);
	return buf;
}

buf_t tl_secureValueTypeUtilityBill()
{
	buf_t buf = buf_add_ui32(0xfc36954e);
	return buf;
}

buf_t tl_secureValueTypeBankStatement()
{
	buf_t buf = buf_add_ui32(0x89137c0d);
	return buf;
}

buf_t tl_secureValueTypeRentalAgreement()
{
	buf_t buf = buf_add_ui32(0x8b883488);
	return buf;
}

buf_t tl_secureValueTypePassportRegistration()
{
	buf_t buf = buf_add_ui32(0x99e3806a);
	return buf;
}

buf_t tl_secureValueTypeTemporaryRegistration()
{
	buf_t buf = buf_add_ui32(0xea02ec33);
	return buf;
}

buf_t tl_secureValueTypePhone()
{
	buf_t buf = buf_add_ui32(0xb320aadb);
	return buf;
}

buf_t tl_secureValueTypeEmail()
{
	buf_t buf = buf_add_ui32(0x8e3ca7ee);
	return buf;
}

buf_t tl_secureValue(SecureValueType *type_, SecureData *data_, SecureFile *front_side_, SecureFile *reverse_side_, SecureFile *selfie_, SecureFile *translation_, int translation_len, SecureFile *files_, int files_len, SecurePlainData *plain_data_, buf_t *hash_)
{
	buf_t buf = buf_add_ui32(0x187fa0ca);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument type (SecureValueType)
	{
		buf = buf_cat(buf, *type_);
	}
	//parse argument data (SecureData)
	if (data_)
	{
		buf = buf_cat(buf, *data_);
		*flag1 |= (1 << 0);
	}
	//parse argument front_side (SecureFile)
	if (front_side_)
	{
		buf = buf_cat(buf, *front_side_);
		*flag1 |= (1 << 1);
	}
	//parse argument reverse_side (SecureFile)
	if (reverse_side_)
	{
		buf = buf_cat(buf, *reverse_side_);
		*flag1 |= (1 << 2);
	}
	//parse argument selfie (SecureFile)
	if (selfie_)
	{
		buf = buf_cat(buf, *selfie_);
		*flag1 |= (1 << 3);
	}
	//parse argument translation (Vector<SecureFile>)
	if (translation_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(translation_len));
		int i;
		for (i=0; i<translation_len; ++i){
			buf = buf_cat(buf, translation_[i]);
		}
		*flag1 |= (1 << 6);
	}
	//parse argument files (Vector<SecureFile>)
	if (files_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(files_len));
		int i;
		for (i=0; i<files_len; ++i){
			buf = buf_cat(buf, files_[i]);
		}
		*flag1 |= (1 << 4);
	}
	//parse argument plain_data (SecurePlainData)
	if (plain_data_)
	{
		buf = buf_cat(buf, *plain_data_);
		*flag1 |= (1 << 5);
	}
	//parse argument hash (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(hash_->data, hash_->size));
	}
	return buf;
}

buf_t tl_inputSecureValue(SecureValueType *type_, SecureData *data_, InputSecureFile *front_side_, InputSecureFile *reverse_side_, InputSecureFile *selfie_, InputSecureFile *translation_, int translation_len, InputSecureFile *files_, int files_len, SecurePlainData *plain_data_)
{
	buf_t buf = buf_add_ui32(0xdb21d0a7);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument type (SecureValueType)
	{
		buf = buf_cat(buf, *type_);
	}
	//parse argument data (SecureData)
	if (data_)
	{
		buf = buf_cat(buf, *data_);
		*flag1 |= (1 << 0);
	}
	//parse argument front_side (InputSecureFile)
	if (front_side_)
	{
		buf = buf_cat(buf, *front_side_);
		*flag1 |= (1 << 1);
	}
	//parse argument reverse_side (InputSecureFile)
	if (reverse_side_)
	{
		buf = buf_cat(buf, *reverse_side_);
		*flag1 |= (1 << 2);
	}
	//parse argument selfie (InputSecureFile)
	if (selfie_)
	{
		buf = buf_cat(buf, *selfie_);
		*flag1 |= (1 << 3);
	}
	//parse argument translation (Vector<InputSecureFile>)
	if (translation_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(translation_len));
		int i;
		for (i=0; i<translation_len; ++i){
			buf = buf_cat(buf, translation_[i]);
		}
		*flag1 |= (1 << 6);
	}
	//parse argument files (Vector<InputSecureFile>)
	if (files_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(files_len));
		int i;
		for (i=0; i<files_len; ++i){
			buf = buf_cat(buf, files_[i]);
		}
		*flag1 |= (1 << 4);
	}
	//parse argument plain_data (SecurePlainData)
	if (plain_data_)
	{
		buf = buf_cat(buf, *plain_data_);
		*flag1 |= (1 << 5);
	}
	return buf;
}

buf_t tl_secureValueHash(SecureValueType *type_, buf_t *hash_)
{
	buf_t buf = buf_add_ui32(0xed1ecdb0);
	//parse argument type (SecureValueType)
	{
		buf = buf_cat(buf, *type_);
	}
	//parse argument hash (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(hash_->data, hash_->size));
	}
	return buf;
}

buf_t tl_secureValueErrorData(SecureValueType *type_, buf_t *data_hash_, const char * field_, const char * text_)
{
	buf_t buf = buf_add_ui32(0xe8a40bd9);
	//parse argument type (SecureValueType)
	{
		buf = buf_cat(buf, *type_);
	}
	//parse argument data_hash (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(data_hash_->data, data_hash_->size));
	}
	//parse argument field (string)
	{
		buf = buf_cat(buf, serialize_string(field_));
	}
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	return buf;
}

buf_t tl_secureValueErrorFrontSide(SecureValueType *type_, buf_t *file_hash_, const char * text_)
{
	buf_t buf = buf_add_ui32(0x00be3dfa);
	//parse argument type (SecureValueType)
	{
		buf = buf_cat(buf, *type_);
	}
	//parse argument file_hash (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(file_hash_->data, file_hash_->size));
	}
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	return buf;
}

buf_t tl_secureValueErrorReverseSide(SecureValueType *type_, buf_t *file_hash_, const char * text_)
{
	buf_t buf = buf_add_ui32(0x868a2aa5);
	//parse argument type (SecureValueType)
	{
		buf = buf_cat(buf, *type_);
	}
	//parse argument file_hash (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(file_hash_->data, file_hash_->size));
	}
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	return buf;
}

buf_t tl_secureValueErrorSelfie(SecureValueType *type_, buf_t *file_hash_, const char * text_)
{
	buf_t buf = buf_add_ui32(0xe537ced6);
	//parse argument type (SecureValueType)
	{
		buf = buf_cat(buf, *type_);
	}
	//parse argument file_hash (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(file_hash_->data, file_hash_->size));
	}
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	return buf;
}

buf_t tl_secureValueErrorFile(SecureValueType *type_, buf_t *file_hash_, const char * text_)
{
	buf_t buf = buf_add_ui32(0x7a700873);
	//parse argument type (SecureValueType)
	{
		buf = buf_cat(buf, *type_);
	}
	//parse argument file_hash (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(file_hash_->data, file_hash_->size));
	}
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	return buf;
}

buf_t tl_secureValueErrorFiles(SecureValueType *type_, buf_t *file_hash_, int file_hash_len, const char * text_)
{
	buf_t buf = buf_add_ui32(0x666220e9);
	//parse argument type (SecureValueType)
	{
		buf = buf_cat(buf, *type_);
	}
	//parse argument file_hash (Vector<bytes>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(file_hash_len));
		int i;
		for (i=0; i<file_hash_len; ++i){
			buf = buf_cat(buf, serialize_bytes(file_hash_[i].data, file_hash_[i].size));
		}
	}
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	return buf;
}

buf_t tl_secureValueError(SecureValueType *type_, buf_t *hash_, const char * text_)
{
	buf_t buf = buf_add_ui32(0x869d758f);
	//parse argument type (SecureValueType)
	{
		buf = buf_cat(buf, *type_);
	}
	//parse argument hash (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(hash_->data, hash_->size));
	}
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	return buf;
}

buf_t tl_secureValueErrorTranslationFile(SecureValueType *type_, buf_t *file_hash_, const char * text_)
{
	buf_t buf = buf_add_ui32(0xa1144770);
	//parse argument type (SecureValueType)
	{
		buf = buf_cat(buf, *type_);
	}
	//parse argument file_hash (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(file_hash_->data, file_hash_->size));
	}
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	return buf;
}

buf_t tl_secureValueErrorTranslationFiles(SecureValueType *type_, buf_t *file_hash_, int file_hash_len, const char * text_)
{
	buf_t buf = buf_add_ui32(0x34636dd8);
	//parse argument type (SecureValueType)
	{
		buf = buf_cat(buf, *type_);
	}
	//parse argument file_hash (Vector<bytes>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(file_hash_len));
		int i;
		for (i=0; i<file_hash_len; ++i){
			buf = buf_cat(buf, serialize_bytes(file_hash_[i].data, file_hash_[i].size));
		}
	}
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	return buf;
}

buf_t tl_secureCredentialsEncrypted(buf_t *data_, buf_t *hash_, buf_t *secret_)
{
	buf_t buf = buf_add_ui32(0x33f0ea47);
	//parse argument data (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(data_->data, data_->size));
	}
	//parse argument hash (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(hash_->data, hash_->size));
	}
	//parse argument secret (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(secret_->data, secret_->size));
	}
	return buf;
}

buf_t tl_account_authorizationForm(SecureRequiredType *required_types_, int required_types_len, SecureValue *values_, int values_len, SecureValueError *errors_, int errors_len, User *users_, int users_len, const char * privacy_policy_url_)
{
	buf_t buf = buf_add_ui32(0xad2e1cd8);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument required_types (Vector<SecureRequiredType>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(required_types_len));
		int i;
		for (i=0; i<required_types_len; ++i){
			buf = buf_cat(buf, required_types_[i]);
		}
	}
	//parse argument values (Vector<SecureValue>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(values_len));
		int i;
		for (i=0; i<values_len; ++i){
			buf = buf_cat(buf, values_[i]);
		}
	}
	//parse argument errors (Vector<SecureValueError>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(errors_len));
		int i;
		for (i=0; i<errors_len; ++i){
			buf = buf_cat(buf, errors_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	//parse argument privacy_policy_url (string)
	if (privacy_policy_url_)
	{
		buf = buf_cat(buf, serialize_string(privacy_policy_url_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_account_sentEmailCode(const char * email_pattern_, int length_)
{
	buf_t buf = buf_add_ui32(0x811f854f);
	//parse argument email_pattern (string)
	{
		buf = buf_cat(buf, serialize_string(email_pattern_));
	}
	//parse argument length (int)
	{
		buf = buf_cat(buf, buf_add_ui32(length_));
	}
	return buf;
}

buf_t tl_help_deepLinkInfoEmpty()
{
	buf_t buf = buf_add_ui32(0x66afa166);
	return buf;
}

buf_t tl_help_deepLinkInfo(bool update_app_, const char * message_, MessageEntity *entities_, int entities_len)
{
	buf_t buf = buf_add_ui32(0x6a4ee832);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument update_app (true)
	if (update_app_)
		*flag1 |= (1 << 0);
	//parse argument message (string)
	{
		buf = buf_cat(buf, serialize_string(message_));
	}
	//parse argument entities (Vector<MessageEntity>)
	if (entities_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(entities_len));
		int i;
		for (i=0; i<entities_len; ++i){
			buf = buf_cat(buf, entities_[i]);
		}
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_savedPhoneContact(const char * phone_, const char * first_name_, const char * last_name_, int date_)
{
	buf_t buf = buf_add_ui32(0x1142bd56);
	//parse argument phone (string)
	{
		buf = buf_cat(buf, serialize_string(phone_));
	}
	//parse argument first_name (string)
	{
		buf = buf_cat(buf, serialize_string(first_name_));
	}
	//parse argument last_name (string)
	{
		buf = buf_cat(buf, serialize_string(last_name_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	return buf;
}

buf_t tl_account_takeout(long id_)
{
	buf_t buf = buf_add_ui32(0x4dba4501);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	return buf;
}

buf_t tl_passwordKdfAlgoUnknown()
{
	buf_t buf = buf_add_ui32(0xd45ab096);
	return buf;
}

buf_t tl_passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow(buf_t *salt1_, buf_t *salt2_, int g_, buf_t *p_)
{
	buf_t buf = buf_add_ui32(0x3a912d4a);
	//parse argument salt1 (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(salt1_->data, salt1_->size));
	}
	//parse argument salt2 (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(salt2_->data, salt2_->size));
	}
	//parse argument g (int)
	{
		buf = buf_cat(buf, buf_add_ui32(g_));
	}
	//parse argument p (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(p_->data, p_->size));
	}
	return buf;
}

buf_t tl_securePasswordKdfAlgoUnknown()
{
	buf_t buf = buf_add_ui32(0x004a8537);
	return buf;
}

buf_t tl_securePasswordKdfAlgoPBKDF2HMACSHA512iter100000(buf_t *salt_)
{
	buf_t buf = buf_add_ui32(0xbbf2dda0);
	//parse argument salt (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(salt_->data, salt_->size));
	}
	return buf;
}

buf_t tl_securePasswordKdfAlgoSHA512(buf_t *salt_)
{
	buf_t buf = buf_add_ui32(0x86471d92);
	//parse argument salt (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(salt_->data, salt_->size));
	}
	return buf;
}

buf_t tl_secureSecretSettings(SecurePasswordKdfAlgo *secure_algo_, buf_t *secure_secret_, long secure_secret_id_)
{
	buf_t buf = buf_add_ui32(0x1527bcac);
	//parse argument secure_algo (SecurePasswordKdfAlgo)
	{
		buf = buf_cat(buf, *secure_algo_);
	}
	//parse argument secure_secret (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(secure_secret_->data, secure_secret_->size));
	}
	//parse argument secure_secret_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(secure_secret_id_));
	}
	return buf;
}

buf_t tl_inputCheckPasswordEmpty()
{
	buf_t buf = buf_add_ui32(0x9880f658);
	return buf;
}

buf_t tl_inputCheckPasswordSRP(long srp_id_, buf_t *A_, buf_t *M1_)
{
	buf_t buf = buf_add_ui32(0xd27ff082);
	//parse argument srp_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(srp_id_));
	}
	//parse argument A (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(A_->data, A_->size));
	}
	//parse argument M1 (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(M1_->data, M1_->size));
	}
	return buf;
}

buf_t tl_secureRequiredType(bool native_names_, bool selfie_required_, bool translation_required_, SecureValueType *type_)
{
	buf_t buf = buf_add_ui32(0x829d99da);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument native_names (true)
	if (native_names_)
		*flag1 |= (1 << 0);
	//parse argument selfie_required (true)
	if (selfie_required_)
		*flag1 |= (1 << 1);
	//parse argument translation_required (true)
	if (translation_required_)
		*flag1 |= (1 << 2);
	//parse argument type (SecureValueType)
	{
		buf = buf_cat(buf, *type_);
	}
	return buf;
}

buf_t tl_secureRequiredTypeOneOf(SecureRequiredType *types_, int types_len)
{
	buf_t buf = buf_add_ui32(0x027477b4);
	//parse argument types (Vector<SecureRequiredType>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(types_len));
		int i;
		for (i=0; i<types_len; ++i){
			buf = buf_cat(buf, types_[i]);
		}
	}
	return buf;
}

buf_t tl_help_passportConfigNotModified()
{
	buf_t buf = buf_add_ui32(0xbfb9f457);
	return buf;
}

buf_t tl_help_passportConfig(int hash_, DataJSON *countries_langs_)
{
	buf_t buf = buf_add_ui32(0xa098d6af);
	//parse argument hash (int)
	{
		buf = buf_cat(buf, buf_add_ui32(hash_));
	}
	//parse argument countries_langs (DataJSON)
	{
		buf = buf_cat(buf, *countries_langs_);
	}
	return buf;
}

buf_t tl_inputAppEvent(double time_, const char * type_, long peer_, JSONValue *data_)
{
	buf_t buf = buf_add_ui32(0x1d1b1245);
	//parse argument time (double)
	{
		buf = buf_cat(buf, buf_add_ui64(time_));
	}
	//parse argument type (string)
	{
		buf = buf_cat(buf, serialize_string(type_));
	}
	//parse argument peer (long)
	{
		buf = buf_cat(buf, buf_add_ui64(peer_));
	}
	//parse argument data (JSONValue)
	{
		buf = buf_cat(buf, *data_);
	}
	return buf;
}

buf_t tl_jsonObjectValue(const char * key_, JSONValue *value_)
{
	buf_t buf = buf_add_ui32(0xc0de1bd9);
	//parse argument key (string)
	{
		buf = buf_cat(buf, serialize_string(key_));
	}
	//parse argument value (JSONValue)
	{
		buf = buf_cat(buf, *value_);
	}
	return buf;
}

buf_t tl_jsonNull()
{
	buf_t buf = buf_add_ui32(0x3f6d7b68);
	return buf;
}

buf_t tl_jsonBool(Bool *value_)
{
	buf_t buf = buf_add_ui32(0xc7345e6a);
	//parse argument value (Bool)
	{
		buf = buf_cat(buf, *value_);
	}
	return buf;
}

buf_t tl_jsonNumber(double value_)
{
	buf_t buf = buf_add_ui32(0x2be0dfa4);
	//parse argument value (double)
	{
		buf = buf_cat(buf, buf_add_ui64(value_));
	}
	return buf;
}

buf_t tl_jsonString(const char * value_)
{
	buf_t buf = buf_add_ui32(0xb71e767a);
	//parse argument value (string)
	{
		buf = buf_cat(buf, serialize_string(value_));
	}
	return buf;
}

buf_t tl_jsonArray(JSONValue *value_, int value_len)
{
	buf_t buf = buf_add_ui32(0xf7444763);
	//parse argument value (Vector<JSONValue>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(value_len));
		int i;
		for (i=0; i<value_len; ++i){
			buf = buf_cat(buf, value_[i]);
		}
	}
	return buf;
}

buf_t tl_jsonObject(JSONObjectValue *value_, int value_len)
{
	buf_t buf = buf_add_ui32(0x99c1d49d);
	//parse argument value (Vector<JSONObjectValue>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(value_len));
		int i;
		for (i=0; i<value_len; ++i){
			buf = buf_cat(buf, value_[i]);
		}
	}
	return buf;
}

buf_t tl_pageTableCell(bool header_, bool align_center_, bool align_right_, bool valign_middle_, bool valign_bottom_, RichText *text_, int colspan_, int rowspan_)
{
	buf_t buf = buf_add_ui32(0x34566b6a);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument header (true)
	if (header_)
		*flag1 |= (1 << 0);
	//parse argument align_center (true)
	if (align_center_)
		*flag1 |= (1 << 3);
	//parse argument align_right (true)
	if (align_right_)
		*flag1 |= (1 << 4);
	//parse argument valign_middle (true)
	if (valign_middle_)
		*flag1 |= (1 << 5);
	//parse argument valign_bottom (true)
	if (valign_bottom_)
		*flag1 |= (1 << 6);
	//parse argument text (RichText)
	if (text_)
	{
		buf = buf_cat(buf, *text_);
		*flag1 |= (1 << 7);
	}
	//parse argument colspan (int)
	if (colspan_)
	{
		buf = buf_cat(buf, buf_add_ui32(colspan_));
		*flag1 |= (1 << 1);
	}
	//parse argument rowspan (int)
	if (rowspan_)
	{
		buf = buf_cat(buf, buf_add_ui32(rowspan_));
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_pageTableRow(PageTableCell *cells_, int cells_len)
{
	buf_t buf = buf_add_ui32(0xe0c0c5e5);
	//parse argument cells (Vector<PageTableCell>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(cells_len));
		int i;
		for (i=0; i<cells_len; ++i){
			buf = buf_cat(buf, cells_[i]);
		}
	}
	return buf;
}

buf_t tl_pageCaption(RichText *text_, RichText *credit_)
{
	buf_t buf = buf_add_ui32(0x6f747657);
	//parse argument text (RichText)
	{
		buf = buf_cat(buf, *text_);
	}
	//parse argument credit (RichText)
	{
		buf = buf_cat(buf, *credit_);
	}
	return buf;
}

buf_t tl_pageListItemText(RichText *text_)
{
	buf_t buf = buf_add_ui32(0xb92fb6cd);
	//parse argument text (RichText)
	{
		buf = buf_cat(buf, *text_);
	}
	return buf;
}

buf_t tl_pageListItemBlocks(PageBlock *blocks_, int blocks_len)
{
	buf_t buf = buf_add_ui32(0x25e073fc);
	//parse argument blocks (Vector<PageBlock>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(blocks_len));
		int i;
		for (i=0; i<blocks_len; ++i){
			buf = buf_cat(buf, blocks_[i]);
		}
	}
	return buf;
}

buf_t tl_pageListOrderedItemText(const char * num_, RichText *text_)
{
	buf_t buf = buf_add_ui32(0x5e068047);
	//parse argument num (string)
	{
		buf = buf_cat(buf, serialize_string(num_));
	}
	//parse argument text (RichText)
	{
		buf = buf_cat(buf, *text_);
	}
	return buf;
}

buf_t tl_pageListOrderedItemBlocks(const char * num_, PageBlock *blocks_, int blocks_len)
{
	buf_t buf = buf_add_ui32(0x98dd8936);
	//parse argument num (string)
	{
		buf = buf_cat(buf, serialize_string(num_));
	}
	//parse argument blocks (Vector<PageBlock>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(blocks_len));
		int i;
		for (i=0; i<blocks_len; ++i){
			buf = buf_cat(buf, blocks_[i]);
		}
	}
	return buf;
}

buf_t tl_pageRelatedArticle(const char * url_, long webpage_id_, const char * title_, const char * description_, long photo_id_, const char * author_, int published_date_)
{
	buf_t buf = buf_add_ui32(0xb390dc08);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	//parse argument webpage_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(webpage_id_));
	}
	//parse argument title (string)
	if (title_)
	{
		buf = buf_cat(buf, serialize_string(title_));
		*flag1 |= (1 << 0);
	}
	//parse argument description (string)
	if (description_)
	{
		buf = buf_cat(buf, serialize_string(description_));
		*flag1 |= (1 << 1);
	}
	//parse argument photo_id (long)
	if (photo_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(photo_id_));
		*flag1 |= (1 << 2);
	}
	//parse argument author (string)
	if (author_)
	{
		buf = buf_cat(buf, serialize_string(author_));
		*flag1 |= (1 << 3);
	}
	//parse argument published_date (int)
	if (published_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(published_date_));
		*flag1 |= (1 << 4);
	}
	return buf;
}

buf_t tl_page(bool part_, bool rtl_, bool v2_, const char * url_, PageBlock *blocks_, int blocks_len, Photo *photos_, int photos_len, Document *documents_, int documents_len, int views_)
{
	buf_t buf = buf_add_ui32(0x98657f0d);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument part (true)
	if (part_)
		*flag1 |= (1 << 0);
	//parse argument rtl (true)
	if (rtl_)
		*flag1 |= (1 << 1);
	//parse argument v2 (true)
	if (v2_)
		*flag1 |= (1 << 2);
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	//parse argument blocks (Vector<PageBlock>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(blocks_len));
		int i;
		for (i=0; i<blocks_len; ++i){
			buf = buf_cat(buf, blocks_[i]);
		}
	}
	//parse argument photos (Vector<Photo>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(photos_len));
		int i;
		for (i=0; i<photos_len; ++i){
			buf = buf_cat(buf, photos_[i]);
		}
	}
	//parse argument documents (Vector<Document>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(documents_len));
		int i;
		for (i=0; i<documents_len; ++i){
			buf = buf_cat(buf, documents_[i]);
		}
	}
	//parse argument views (int)
	if (views_)
	{
		buf = buf_cat(buf, buf_add_ui32(views_));
		*flag1 |= (1 << 3);
	}
	return buf;
}

buf_t tl_help_supportName(const char * name_)
{
	buf_t buf = buf_add_ui32(0x8c05f1c9);
	//parse argument name (string)
	{
		buf = buf_cat(buf, serialize_string(name_));
	}
	return buf;
}

buf_t tl_help_userInfoEmpty()
{
	buf_t buf = buf_add_ui32(0xf3ae2eed);
	return buf;
}

buf_t tl_help_userInfo(const char * message_, MessageEntity *entities_, int entities_len, const char * author_, int date_)
{
	buf_t buf = buf_add_ui32(0x01eb3758);
	//parse argument message (string)
	{
		buf = buf_cat(buf, serialize_string(message_));
	}
	//parse argument entities (Vector<MessageEntity>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(entities_len));
		int i;
		for (i=0; i<entities_len; ++i){
			buf = buf_cat(buf, entities_[i]);
		}
	}
	//parse argument author (string)
	{
		buf = buf_cat(buf, serialize_string(author_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	return buf;
}

buf_t tl_pollAnswer(TextWithEntities *text_, buf_t *option_)
{
	buf_t buf = buf_add_ui32(0xff16e2ca);
	//parse argument text (TextWithEntities)
	{
		buf = buf_cat(buf, *text_);
	}
	//parse argument option (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(option_->data, option_->size));
	}
	return buf;
}

buf_t tl_poll(long id_, bool closed_, bool public_voters_, bool multiple_choice_, bool quiz_, TextWithEntities *question_, PollAnswer *answers_, int answers_len, int close_period_, int close_date_)
{
	buf_t buf = buf_add_ui32(0x58747131);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument closed (true)
	if (closed_)
		*flag1 |= (1 << 0);
	//parse argument public_voters (true)
	if (public_voters_)
		*flag1 |= (1 << 1);
	//parse argument multiple_choice (true)
	if (multiple_choice_)
		*flag1 |= (1 << 2);
	//parse argument quiz (true)
	if (quiz_)
		*flag1 |= (1 << 3);
	//parse argument question (TextWithEntities)
	{
		buf = buf_cat(buf, *question_);
	}
	//parse argument answers (Vector<PollAnswer>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(answers_len));
		int i;
		for (i=0; i<answers_len; ++i){
			buf = buf_cat(buf, answers_[i]);
		}
	}
	//parse argument close_period (int)
	if (close_period_)
	{
		buf = buf_cat(buf, buf_add_ui32(close_period_));
		*flag1 |= (1 << 4);
	}
	//parse argument close_date (int)
	if (close_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(close_date_));
		*flag1 |= (1 << 5);
	}
	return buf;
}

buf_t tl_pollAnswerVoters(bool chosen_, bool correct_, buf_t *option_, int voters_)
{
	buf_t buf = buf_add_ui32(0x3b6ddad2);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument chosen (true)
	if (chosen_)
		*flag1 |= (1 << 0);
	//parse argument correct (true)
	if (correct_)
		*flag1 |= (1 << 1);
	//parse argument option (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(option_->data, option_->size));
	}
	//parse argument voters (int)
	{
		buf = buf_cat(buf, buf_add_ui32(voters_));
	}
	return buf;
}

buf_t tl_pollResults(bool min_, PollAnswerVoters *results_, int results_len, int total_voters_, Peer *recent_voters_, int recent_voters_len, const char * solution_, MessageEntity *solution_entities_, int solution_entities_len)
{
	buf_t buf = buf_add_ui32(0x7adf2420);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument min (true)
	if (min_)
		*flag1 |= (1 << 0);
	//parse argument results (Vector<PollAnswerVoters>)
	if (results_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(results_len));
		int i;
		for (i=0; i<results_len; ++i){
			buf = buf_cat(buf, results_[i]);
		}
		*flag1 |= (1 << 1);
	}
	//parse argument total_voters (int)
	if (total_voters_)
	{
		buf = buf_cat(buf, buf_add_ui32(total_voters_));
		*flag1 |= (1 << 2);
	}
	//parse argument recent_voters (Vector<Peer>)
	if (recent_voters_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(recent_voters_len));
		int i;
		for (i=0; i<recent_voters_len; ++i){
			buf = buf_cat(buf, recent_voters_[i]);
		}
		*flag1 |= (1 << 3);
	}
	//parse argument solution (string)
	if (solution_)
	{
		buf = buf_cat(buf, serialize_string(solution_));
		*flag1 |= (1 << 4);
	}
	//parse argument solution_entities (Vector<MessageEntity>)
	if (solution_entities_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(solution_entities_len));
		int i;
		for (i=0; i<solution_entities_len; ++i){
			buf = buf_cat(buf, solution_entities_[i]);
		}
		*flag1 |= (1 << 4);
	}
	return buf;
}

buf_t tl_chatOnlines(int onlines_)
{
	buf_t buf = buf_add_ui32(0xf041e250);
	//parse argument onlines (int)
	{
		buf = buf_cat(buf, buf_add_ui32(onlines_));
	}
	return buf;
}

buf_t tl_statsURL(const char * url_)
{
	buf_t buf = buf_add_ui32(0x47a971e0);
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	return buf;
}

buf_t tl_chatAdminRights(bool change_info_, bool post_messages_, bool edit_messages_, bool delete_messages_, bool ban_users_, bool invite_users_, bool pin_messages_, bool add_admins_, bool anonymous_, bool manage_call_, bool other_, bool manage_topics_, bool post_stories_, bool edit_stories_, bool delete_stories_)
{
	buf_t buf = buf_add_ui32(0x5fb224d5);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument change_info (true)
	if (change_info_)
		*flag1 |= (1 << 0);
	//parse argument post_messages (true)
	if (post_messages_)
		*flag1 |= (1 << 1);
	//parse argument edit_messages (true)
	if (edit_messages_)
		*flag1 |= (1 << 2);
	//parse argument delete_messages (true)
	if (delete_messages_)
		*flag1 |= (1 << 3);
	//parse argument ban_users (true)
	if (ban_users_)
		*flag1 |= (1 << 4);
	//parse argument invite_users (true)
	if (invite_users_)
		*flag1 |= (1 << 5);
	//parse argument pin_messages (true)
	if (pin_messages_)
		*flag1 |= (1 << 7);
	//parse argument add_admins (true)
	if (add_admins_)
		*flag1 |= (1 << 9);
	//parse argument anonymous (true)
	if (anonymous_)
		*flag1 |= (1 << 10);
	//parse argument manage_call (true)
	if (manage_call_)
		*flag1 |= (1 << 11);
	//parse argument other (true)
	if (other_)
		*flag1 |= (1 << 12);
	//parse argument manage_topics (true)
	if (manage_topics_)
		*flag1 |= (1 << 13);
	//parse argument post_stories (true)
	if (post_stories_)
		*flag1 |= (1 << 14);
	//parse argument edit_stories (true)
	if (edit_stories_)
		*flag1 |= (1 << 15);
	//parse argument delete_stories (true)
	if (delete_stories_)
		*flag1 |= (1 << 16);
	return buf;
}

buf_t tl_chatBannedRights(bool view_messages_, bool send_messages_, bool send_media_, bool send_stickers_, bool send_gifs_, bool send_games_, bool send_inline_, bool embed_links_, bool send_polls_, bool change_info_, bool invite_users_, bool pin_messages_, bool manage_topics_, bool send_photos_, bool send_videos_, bool send_roundvideos_, bool send_audios_, bool send_voices_, bool send_docs_, bool send_plain_, int until_date_)
{
	buf_t buf = buf_add_ui32(0x9f120418);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument view_messages (true)
	if (view_messages_)
		*flag1 |= (1 << 0);
	//parse argument send_messages (true)
	if (send_messages_)
		*flag1 |= (1 << 1);
	//parse argument send_media (true)
	if (send_media_)
		*flag1 |= (1 << 2);
	//parse argument send_stickers (true)
	if (send_stickers_)
		*flag1 |= (1 << 3);
	//parse argument send_gifs (true)
	if (send_gifs_)
		*flag1 |= (1 << 4);
	//parse argument send_games (true)
	if (send_games_)
		*flag1 |= (1 << 5);
	//parse argument send_inline (true)
	if (send_inline_)
		*flag1 |= (1 << 6);
	//parse argument embed_links (true)
	if (embed_links_)
		*flag1 |= (1 << 7);
	//parse argument send_polls (true)
	if (send_polls_)
		*flag1 |= (1 << 8);
	//parse argument change_info (true)
	if (change_info_)
		*flag1 |= (1 << 10);
	//parse argument invite_users (true)
	if (invite_users_)
		*flag1 |= (1 << 15);
	//parse argument pin_messages (true)
	if (pin_messages_)
		*flag1 |= (1 << 17);
	//parse argument manage_topics (true)
	if (manage_topics_)
		*flag1 |= (1 << 18);
	//parse argument send_photos (true)
	if (send_photos_)
		*flag1 |= (1 << 19);
	//parse argument send_videos (true)
	if (send_videos_)
		*flag1 |= (1 << 20);
	//parse argument send_roundvideos (true)
	if (send_roundvideos_)
		*flag1 |= (1 << 21);
	//parse argument send_audios (true)
	if (send_audios_)
		*flag1 |= (1 << 22);
	//parse argument send_voices (true)
	if (send_voices_)
		*flag1 |= (1 << 23);
	//parse argument send_docs (true)
	if (send_docs_)
		*flag1 |= (1 << 24);
	//parse argument send_plain (true)
	if (send_plain_)
		*flag1 |= (1 << 25);
	//parse argument until_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(until_date_));
	}
	return buf;
}

buf_t tl_inputWallPaper(long id_, long access_hash_)
{
	buf_t buf = buf_add_ui32(0xe630b979);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	return buf;
}

buf_t tl_inputWallPaperSlug(const char * slug_)
{
	buf_t buf = buf_add_ui32(0x72091c80);
	//parse argument slug (string)
	{
		buf = buf_cat(buf, serialize_string(slug_));
	}
	return buf;
}

buf_t tl_inputWallPaperNoFile(long id_)
{
	buf_t buf = buf_add_ui32(0x967a462e);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	return buf;
}

buf_t tl_account_wallPapersNotModified()
{
	buf_t buf = buf_add_ui32(0x1c199183);
	return buf;
}

buf_t tl_account_wallPapers(long hash_, WallPaper *wallpapers_, int wallpapers_len)
{
	buf_t buf = buf_add_ui32(0xcdc3858c);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	//parse argument wallpapers (Vector<WallPaper>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(wallpapers_len));
		int i;
		for (i=0; i<wallpapers_len; ++i){
			buf = buf_cat(buf, wallpapers_[i]);
		}
	}
	return buf;
}

buf_t tl_codeSettings(bool allow_flashcall_, bool current_number_, bool allow_app_hash_, bool allow_missed_call_, bool allow_firebase_, bool unknown_number_, buf_t *logout_tokens_, int logout_tokens_len, const char * token_, Bool *app_sandbox_)
{
	buf_t buf = buf_add_ui32(0xad253d78);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument allow_flashcall (true)
	if (allow_flashcall_)
		*flag1 |= (1 << 0);
	//parse argument current_number (true)
	if (current_number_)
		*flag1 |= (1 << 1);
	//parse argument allow_app_hash (true)
	if (allow_app_hash_)
		*flag1 |= (1 << 4);
	//parse argument allow_missed_call (true)
	if (allow_missed_call_)
		*flag1 |= (1 << 5);
	//parse argument allow_firebase (true)
	if (allow_firebase_)
		*flag1 |= (1 << 7);
	//parse argument unknown_number (true)
	if (unknown_number_)
		*flag1 |= (1 << 9);
	//parse argument logout_tokens (Vector<bytes>)
	if (logout_tokens_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(logout_tokens_len));
		int i;
		for (i=0; i<logout_tokens_len; ++i){
			buf = buf_cat(buf, serialize_bytes(logout_tokens_[i].data, logout_tokens_[i].size));
		}
		*flag1 |= (1 << 6);
	}
	//parse argument token (string)
	if (token_)
	{
		buf = buf_cat(buf, serialize_string(token_));
		*flag1 |= (1 << 8);
	}
	//parse argument app_sandbox (Bool)
	if (app_sandbox_)
	{
		buf = buf_cat(buf, *app_sandbox_);
		*flag1 |= (1 << 8);
	}
	return buf;
}

buf_t tl_wallPaperSettings(bool blur_, bool motion_, int background_color_, int second_background_color_, int third_background_color_, int fourth_background_color_, int intensity_, int rotation_, const char * emoticon_)
{
	buf_t buf = buf_add_ui32(0x372efcd0);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument blur (true)
	if (blur_)
		*flag1 |= (1 << 1);
	//parse argument motion (true)
	if (motion_)
		*flag1 |= (1 << 2);
	//parse argument background_color (int)
	if (background_color_)
	{
		buf = buf_cat(buf, buf_add_ui32(background_color_));
		*flag1 |= (1 << 0);
	}
	//parse argument second_background_color (int)
	if (second_background_color_)
	{
		buf = buf_cat(buf, buf_add_ui32(second_background_color_));
		*flag1 |= (1 << 4);
	}
	//parse argument third_background_color (int)
	if (third_background_color_)
	{
		buf = buf_cat(buf, buf_add_ui32(third_background_color_));
		*flag1 |= (1 << 5);
	}
	//parse argument fourth_background_color (int)
	if (fourth_background_color_)
	{
		buf = buf_cat(buf, buf_add_ui32(fourth_background_color_));
		*flag1 |= (1 << 6);
	}
	//parse argument intensity (int)
	if (intensity_)
	{
		buf = buf_cat(buf, buf_add_ui32(intensity_));
		*flag1 |= (1 << 3);
	}
	//parse argument rotation (int)
	if (rotation_)
	{
		buf = buf_cat(buf, buf_add_ui32(rotation_));
		*flag1 |= (1 << 4);
	}
	//parse argument emoticon (string)
	if (emoticon_)
	{
		buf = buf_cat(buf, serialize_string(emoticon_));
		*flag1 |= (1 << 7);
	}
	return buf;
}

buf_t tl_autoDownloadSettings(bool disabled_, bool video_preload_large_, bool audio_preload_next_, bool phonecalls_less_data_, bool stories_preload_, int photo_size_max_, long video_size_max_, long file_size_max_, int video_upload_maxbitrate_, int small_queue_active_operations_max_, int large_queue_active_operations_max_)
{
	buf_t buf = buf_add_ui32(0xbaa57628);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument disabled (true)
	if (disabled_)
		*flag1 |= (1 << 0);
	//parse argument video_preload_large (true)
	if (video_preload_large_)
		*flag1 |= (1 << 1);
	//parse argument audio_preload_next (true)
	if (audio_preload_next_)
		*flag1 |= (1 << 2);
	//parse argument phonecalls_less_data (true)
	if (phonecalls_less_data_)
		*flag1 |= (1 << 3);
	//parse argument stories_preload (true)
	if (stories_preload_)
		*flag1 |= (1 << 4);
	//parse argument photo_size_max (int)
	{
		buf = buf_cat(buf, buf_add_ui32(photo_size_max_));
	}
	//parse argument video_size_max (long)
	{
		buf = buf_cat(buf, buf_add_ui64(video_size_max_));
	}
	//parse argument file_size_max (long)
	{
		buf = buf_cat(buf, buf_add_ui64(file_size_max_));
	}
	//parse argument video_upload_maxbitrate (int)
	{
		buf = buf_cat(buf, buf_add_ui32(video_upload_maxbitrate_));
	}
	//parse argument small_queue_active_operations_max (int)
	{
		buf = buf_cat(buf, buf_add_ui32(small_queue_active_operations_max_));
	}
	//parse argument large_queue_active_operations_max (int)
	{
		buf = buf_cat(buf, buf_add_ui32(large_queue_active_operations_max_));
	}
	return buf;
}

buf_t tl_account_autoDownloadSettings(AutoDownloadSettings *low_, AutoDownloadSettings *medium_, AutoDownloadSettings *high_)
{
	buf_t buf = buf_add_ui32(0x63cacf26);
	//parse argument low (AutoDownloadSettings)
	{
		buf = buf_cat(buf, *low_);
	}
	//parse argument medium (AutoDownloadSettings)
	{
		buf = buf_cat(buf, *medium_);
	}
	//parse argument high (AutoDownloadSettings)
	{
		buf = buf_cat(buf, *high_);
	}
	return buf;
}

buf_t tl_emojiKeyword(const char * keyword_, const char * *emoticons_, int emoticons_len)
{
	buf_t buf = buf_add_ui32(0xd5b3b9f9);
	//parse argument keyword (string)
	{
		buf = buf_cat(buf, serialize_string(keyword_));
	}
	//parse argument emoticons (Vector<string>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(emoticons_len));
		int i;
		for (i=0; i<emoticons_len; ++i){
			buf = buf_cat(buf, serialize_string(emoticons_[i]));
		}
	}
	return buf;
}

buf_t tl_emojiKeywordDeleted(const char * keyword_, const char * *emoticons_, int emoticons_len)
{
	buf_t buf = buf_add_ui32(0x236df622);
	//parse argument keyword (string)
	{
		buf = buf_cat(buf, serialize_string(keyword_));
	}
	//parse argument emoticons (Vector<string>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(emoticons_len));
		int i;
		for (i=0; i<emoticons_len; ++i){
			buf = buf_cat(buf, serialize_string(emoticons_[i]));
		}
	}
	return buf;
}

buf_t tl_emojiKeywordsDifference(const char * lang_code_, int from_version_, int version_, EmojiKeyword *keywords_, int keywords_len)
{
	buf_t buf = buf_add_ui32(0x5cc761bd);
	//parse argument lang_code (string)
	{
		buf = buf_cat(buf, serialize_string(lang_code_));
	}
	//parse argument from_version (int)
	{
		buf = buf_cat(buf, buf_add_ui32(from_version_));
	}
	//parse argument version (int)
	{
		buf = buf_cat(buf, buf_add_ui32(version_));
	}
	//parse argument keywords (Vector<EmojiKeyword>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(keywords_len));
		int i;
		for (i=0; i<keywords_len; ++i){
			buf = buf_cat(buf, keywords_[i]);
		}
	}
	return buf;
}

buf_t tl_emojiURL(const char * url_)
{
	buf_t buf = buf_add_ui32(0xa575739d);
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	return buf;
}

buf_t tl_emojiLanguage(const char * lang_code_)
{
	buf_t buf = buf_add_ui32(0xb3fb5361);
	//parse argument lang_code (string)
	{
		buf = buf_cat(buf, serialize_string(lang_code_));
	}
	return buf;
}

buf_t tl_folder(bool autofill_new_broadcasts_, bool autofill_public_groups_, bool autofill_new_correspondents_, int id_, const char * title_, ChatPhoto *photo_)
{
	buf_t buf = buf_add_ui32(0xff544e65);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument autofill_new_broadcasts (true)
	if (autofill_new_broadcasts_)
		*flag1 |= (1 << 0);
	//parse argument autofill_public_groups (true)
	if (autofill_public_groups_)
		*flag1 |= (1 << 1);
	//parse argument autofill_new_correspondents (true)
	if (autofill_new_correspondents_)
		*flag1 |= (1 << 2);
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument photo (ChatPhoto)
	if (photo_)
	{
		buf = buf_cat(buf, *photo_);
		*flag1 |= (1 << 3);
	}
	return buf;
}

buf_t tl_inputFolderPeer(InputPeer *peer_, int folder_id_)
{
	buf_t buf = buf_add_ui32(0xfbd2c296);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument folder_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(folder_id_));
	}
	return buf;
}

buf_t tl_folderPeer(Peer *peer_, int folder_id_)
{
	buf_t buf = buf_add_ui32(0xe9baa668);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument folder_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(folder_id_));
	}
	return buf;
}

buf_t tl_messages_searchCounter(bool inexact_, MessagesFilter *filter_, int count_)
{
	buf_t buf = buf_add_ui32(0xe844ebff);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument inexact (true)
	if (inexact_)
		*flag1 |= (1 << 1);
	//parse argument filter (MessagesFilter)
	{
		buf = buf_cat(buf, *filter_);
	}
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	return buf;
}

buf_t tl_urlAuthResultRequest(bool request_write_access_, User *bot_, const char * domain_)
{
	buf_t buf = buf_add_ui32(0x92d33a0e);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument request_write_access (true)
	if (request_write_access_)
		*flag1 |= (1 << 0);
	//parse argument bot (User)
	{
		buf = buf_cat(buf, *bot_);
	}
	//parse argument domain (string)
	{
		buf = buf_cat(buf, serialize_string(domain_));
	}
	return buf;
}

buf_t tl_urlAuthResultAccepted(const char * url_)
{
	buf_t buf = buf_add_ui32(0x8f8c0e4e);
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	return buf;
}

buf_t tl_urlAuthResultDefault()
{
	buf_t buf = buf_add_ui32(0xa9d6db1f);
	return buf;
}

buf_t tl_channelLocationEmpty()
{
	buf_t buf = buf_add_ui32(0xbfb5ad8b);
	return buf;
}

buf_t tl_channelLocation(GeoPoint *geo_point_, const char * address_)
{
	buf_t buf = buf_add_ui32(0x209b82db);
	//parse argument geo_point (GeoPoint)
	{
		buf = buf_cat(buf, *geo_point_);
	}
	//parse argument address (string)
	{
		buf = buf_cat(buf, serialize_string(address_));
	}
	return buf;
}

buf_t tl_peerLocated(Peer *peer_, int expires_, int distance_)
{
	buf_t buf = buf_add_ui32(0xca461b5d);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument expires (int)
	{
		buf = buf_cat(buf, buf_add_ui32(expires_));
	}
	//parse argument distance (int)
	{
		buf = buf_cat(buf, buf_add_ui32(distance_));
	}
	return buf;
}

buf_t tl_peerSelfLocated(int expires_)
{
	buf_t buf = buf_add_ui32(0xf8ec284b);
	//parse argument expires (int)
	{
		buf = buf_cat(buf, buf_add_ui32(expires_));
	}
	return buf;
}

buf_t tl_restrictionReason(const char * platform_, const char * reason_, const char * text_)
{
	buf_t buf = buf_add_ui32(0xd072acb4);
	//parse argument platform (string)
	{
		buf = buf_cat(buf, serialize_string(platform_));
	}
	//parse argument reason (string)
	{
		buf = buf_cat(buf, serialize_string(reason_));
	}
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	return buf;
}

buf_t tl_inputTheme(long id_, long access_hash_)
{
	buf_t buf = buf_add_ui32(0x3c5693e9);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	return buf;
}

buf_t tl_inputThemeSlug(const char * slug_)
{
	buf_t buf = buf_add_ui32(0xf5890df1);
	//parse argument slug (string)
	{
		buf = buf_cat(buf, serialize_string(slug_));
	}
	return buf;
}

buf_t tl_theme(bool creator_, bool default_, bool for_chat_, long id_, long access_hash_, const char * slug_, const char * title_, Document *document_, ThemeSettings *settings_, int settings_len, const char * emoticon_, int installs_count_)
{
	buf_t buf = buf_add_ui32(0xa00e67d6);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument creator (true)
	if (creator_)
		*flag1 |= (1 << 0);
	//parse argument default (true)
	if (default_)
		*flag1 |= (1 << 1);
	//parse argument for_chat (true)
	if (for_chat_)
		*flag1 |= (1 << 5);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	//parse argument slug (string)
	{
		buf = buf_cat(buf, serialize_string(slug_));
	}
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument document (Document)
	if (document_)
	{
		buf = buf_cat(buf, *document_);
		*flag1 |= (1 << 2);
	}
	//parse argument settings (Vector<ThemeSettings>)
	if (settings_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(settings_len));
		int i;
		for (i=0; i<settings_len; ++i){
			buf = buf_cat(buf, settings_[i]);
		}
		*flag1 |= (1 << 3);
	}
	//parse argument emoticon (string)
	if (emoticon_)
	{
		buf = buf_cat(buf, serialize_string(emoticon_));
		*flag1 |= (1 << 6);
	}
	//parse argument installs_count (int)
	if (installs_count_)
	{
		buf = buf_cat(buf, buf_add_ui32(installs_count_));
		*flag1 |= (1 << 4);
	}
	return buf;
}

buf_t tl_account_themesNotModified()
{
	buf_t buf = buf_add_ui32(0xf41eb622);
	return buf;
}

buf_t tl_account_themes(long hash_, Theme *themes_, int themes_len)
{
	buf_t buf = buf_add_ui32(0x9a3d8c6d);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	//parse argument themes (Vector<Theme>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(themes_len));
		int i;
		for (i=0; i<themes_len; ++i){
			buf = buf_cat(buf, themes_[i]);
		}
	}
	return buf;
}

buf_t tl_auth_loginToken(int expires_, buf_t *token_)
{
	buf_t buf = buf_add_ui32(0x629f1980);
	//parse argument expires (int)
	{
		buf = buf_cat(buf, buf_add_ui32(expires_));
	}
	//parse argument token (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(token_->data, token_->size));
	}
	return buf;
}

buf_t tl_auth_loginTokenMigrateTo(int dc_id_, buf_t *token_)
{
	buf_t buf = buf_add_ui32(0x068e9916);
	//parse argument dc_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(dc_id_));
	}
	//parse argument token (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(token_->data, token_->size));
	}
	return buf;
}

buf_t tl_auth_loginTokenSuccess(auth_Authorization *authorization_)
{
	buf_t buf = buf_add_ui32(0x390d5c5e);
	//parse argument authorization (auth_Authorization)
	{
		buf = buf_cat(buf, *authorization_);
	}
	return buf;
}

buf_t tl_account_contentSettings(bool sensitive_enabled_, bool sensitive_can_change_)
{
	buf_t buf = buf_add_ui32(0x57e28221);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument sensitive_enabled (true)
	if (sensitive_enabled_)
		*flag1 |= (1 << 0);
	//parse argument sensitive_can_change (true)
	if (sensitive_can_change_)
		*flag1 |= (1 << 1);
	return buf;
}

buf_t tl_messages_inactiveChats(int *dates_, int dates_len, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0xa927fec5);
	//parse argument dates (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(dates_len));
		int i;
		for (i=0; i<dates_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(dates_[i]));
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_baseThemeClassic()
{
	buf_t buf = buf_add_ui32(0xc3a12462);
	return buf;
}

buf_t tl_baseThemeDay()
{
	buf_t buf = buf_add_ui32(0xfbd81688);
	return buf;
}

buf_t tl_baseThemeNight()
{
	buf_t buf = buf_add_ui32(0xb7b31ea8);
	return buf;
}

buf_t tl_baseThemeTinted()
{
	buf_t buf = buf_add_ui32(0x6d5f77ee);
	return buf;
}

buf_t tl_baseThemeArctic()
{
	buf_t buf = buf_add_ui32(0x5b11125a);
	return buf;
}

buf_t tl_inputThemeSettings(bool message_colors_animated_, BaseTheme *base_theme_, int accent_color_, int outbox_accent_color_, int *message_colors_, int message_colors_len, InputWallPaper *wallpaper_, WallPaperSettings *wallpaper_settings_)
{
	buf_t buf = buf_add_ui32(0x8fde504f);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument message_colors_animated (true)
	if (message_colors_animated_)
		*flag1 |= (1 << 2);
	//parse argument base_theme (BaseTheme)
	{
		buf = buf_cat(buf, *base_theme_);
	}
	//parse argument accent_color (int)
	{
		buf = buf_cat(buf, buf_add_ui32(accent_color_));
	}
	//parse argument outbox_accent_color (int)
	if (outbox_accent_color_)
	{
		buf = buf_cat(buf, buf_add_ui32(outbox_accent_color_));
		*flag1 |= (1 << 3);
	}
	//parse argument message_colors (Vector<int>)
	if (message_colors_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(message_colors_len));
		int i;
		for (i=0; i<message_colors_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(message_colors_[i]));
		}
		*flag1 |= (1 << 0);
	}
	//parse argument wallpaper (InputWallPaper)
	if (wallpaper_)
	{
		buf = buf_cat(buf, *wallpaper_);
		*flag1 |= (1 << 1);
	}
	//parse argument wallpaper_settings (WallPaperSettings)
	if (wallpaper_settings_)
	{
		buf = buf_cat(buf, *wallpaper_settings_);
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_themeSettings(bool message_colors_animated_, BaseTheme *base_theme_, int accent_color_, int outbox_accent_color_, int *message_colors_, int message_colors_len, WallPaper *wallpaper_)
{
	buf_t buf = buf_add_ui32(0xfa58b6d4);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument message_colors_animated (true)
	if (message_colors_animated_)
		*flag1 |= (1 << 2);
	//parse argument base_theme (BaseTheme)
	{
		buf = buf_cat(buf, *base_theme_);
	}
	//parse argument accent_color (int)
	{
		buf = buf_cat(buf, buf_add_ui32(accent_color_));
	}
	//parse argument outbox_accent_color (int)
	if (outbox_accent_color_)
	{
		buf = buf_cat(buf, buf_add_ui32(outbox_accent_color_));
		*flag1 |= (1 << 3);
	}
	//parse argument message_colors (Vector<int>)
	if (message_colors_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(message_colors_len));
		int i;
		for (i=0; i<message_colors_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(message_colors_[i]));
		}
		*flag1 |= (1 << 0);
	}
	//parse argument wallpaper (WallPaper)
	if (wallpaper_)
	{
		buf = buf_cat(buf, *wallpaper_);
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_webPageAttributeTheme(Document *documents_, int documents_len, ThemeSettings *settings_)
{
	buf_t buf = buf_add_ui32(0x54b56617);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument documents (Vector<Document>)
	if (documents_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(documents_len));
		int i;
		for (i=0; i<documents_len; ++i){
			buf = buf_cat(buf, documents_[i]);
		}
		*flag1 |= (1 << 0);
	}
	//parse argument settings (ThemeSettings)
	if (settings_)
	{
		buf = buf_cat(buf, *settings_);
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_webPageAttributeStory(Peer *peer_, int id_, StoryItem *story_)
{
	buf_t buf = buf_add_ui32(0x2e94c3e7);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument story (StoryItem)
	if (story_)
	{
		buf = buf_cat(buf, *story_);
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_webPageAttributeStickerSet(bool emojis_, bool text_color_, Document *stickers_, int stickers_len)
{
	buf_t buf = buf_add_ui32(0x50cc03d3);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument emojis (true)
	if (emojis_)
		*flag1 |= (1 << 0);
	//parse argument text_color (true)
	if (text_color_)
		*flag1 |= (1 << 1);
	//parse argument stickers (Vector<Document>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(stickers_len));
		int i;
		for (i=0; i<stickers_len; ++i){
			buf = buf_cat(buf, stickers_[i]);
		}
	}
	return buf;
}

buf_t tl_messages_votesList(int count_, MessagePeerVote *votes_, int votes_len, Chat *chats_, int chats_len, User *users_, int users_len, const char * next_offset_)
{
	buf_t buf = buf_add_ui32(0x4899484e);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	//parse argument votes (Vector<MessagePeerVote>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(votes_len));
		int i;
		for (i=0; i<votes_len; ++i){
			buf = buf_cat(buf, votes_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	//parse argument next_offset (string)
	if (next_offset_)
	{
		buf = buf_cat(buf, serialize_string(next_offset_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_bankCardOpenUrl(const char * url_, const char * name_)
{
	buf_t buf = buf_add_ui32(0xf568028a);
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	//parse argument name (string)
	{
		buf = buf_cat(buf, serialize_string(name_));
	}
	return buf;
}

buf_t tl_payments_bankCardData(const char * title_, BankCardOpenUrl *open_urls_, int open_urls_len)
{
	buf_t buf = buf_add_ui32(0x3e24e573);
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument open_urls (Vector<BankCardOpenUrl>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(open_urls_len));
		int i;
		for (i=0; i<open_urls_len; ++i){
			buf = buf_cat(buf, open_urls_[i]);
		}
	}
	return buf;
}

buf_t tl_dialogFilter(bool contacts_, bool non_contacts_, bool groups_, bool broadcasts_, bool bots_, bool exclude_muted_, bool exclude_read_, bool exclude_archived_, int id_, const char * title_, const char * emoticon_, int color_, InputPeer *pinned_peers_, int pinned_peers_len, InputPeer *include_peers_, int include_peers_len, InputPeer *exclude_peers_, int exclude_peers_len)
{
	buf_t buf = buf_add_ui32(0x5fb5523b);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument contacts (true)
	if (contacts_)
		*flag1 |= (1 << 0);
	//parse argument non_contacts (true)
	if (non_contacts_)
		*flag1 |= (1 << 1);
	//parse argument groups (true)
	if (groups_)
		*flag1 |= (1 << 2);
	//parse argument broadcasts (true)
	if (broadcasts_)
		*flag1 |= (1 << 3);
	//parse argument bots (true)
	if (bots_)
		*flag1 |= (1 << 4);
	//parse argument exclude_muted (true)
	if (exclude_muted_)
		*flag1 |= (1 << 11);
	//parse argument exclude_read (true)
	if (exclude_read_)
		*flag1 |= (1 << 12);
	//parse argument exclude_archived (true)
	if (exclude_archived_)
		*flag1 |= (1 << 13);
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument emoticon (string)
	if (emoticon_)
	{
		buf = buf_cat(buf, serialize_string(emoticon_));
		*flag1 |= (1 << 25);
	}
	//parse argument color (int)
	if (color_)
	{
		buf = buf_cat(buf, buf_add_ui32(color_));
		*flag1 |= (1 << 27);
	}
	//parse argument pinned_peers (Vector<InputPeer>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(pinned_peers_len));
		int i;
		for (i=0; i<pinned_peers_len; ++i){
			buf = buf_cat(buf, pinned_peers_[i]);
		}
	}
	//parse argument include_peers (Vector<InputPeer>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(include_peers_len));
		int i;
		for (i=0; i<include_peers_len; ++i){
			buf = buf_cat(buf, include_peers_[i]);
		}
	}
	//parse argument exclude_peers (Vector<InputPeer>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(exclude_peers_len));
		int i;
		for (i=0; i<exclude_peers_len; ++i){
			buf = buf_cat(buf, exclude_peers_[i]);
		}
	}
	return buf;
}

buf_t tl_dialogFilterDefault()
{
	buf_t buf = buf_add_ui32(0x363293ae);
	return buf;
}

buf_t tl_dialogFilterChatlist(bool has_my_invites_, int id_, const char * title_, const char * emoticon_, int color_, InputPeer *pinned_peers_, int pinned_peers_len, InputPeer *include_peers_, int include_peers_len)
{
	buf_t buf = buf_add_ui32(0x9fe28ea4);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument has_my_invites (true)
	if (has_my_invites_)
		*flag1 |= (1 << 26);
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument emoticon (string)
	if (emoticon_)
	{
		buf = buf_cat(buf, serialize_string(emoticon_));
		*flag1 |= (1 << 25);
	}
	//parse argument color (int)
	if (color_)
	{
		buf = buf_cat(buf, buf_add_ui32(color_));
		*flag1 |= (1 << 27);
	}
	//parse argument pinned_peers (Vector<InputPeer>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(pinned_peers_len));
		int i;
		for (i=0; i<pinned_peers_len; ++i){
			buf = buf_cat(buf, pinned_peers_[i]);
		}
	}
	//parse argument include_peers (Vector<InputPeer>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(include_peers_len));
		int i;
		for (i=0; i<include_peers_len; ++i){
			buf = buf_cat(buf, include_peers_[i]);
		}
	}
	return buf;
}

buf_t tl_dialogFilterSuggested(DialogFilter *filter_, const char * description_)
{
	buf_t buf = buf_add_ui32(0x77744d4a);
	//parse argument filter (DialogFilter)
	{
		buf = buf_cat(buf, *filter_);
	}
	//parse argument description (string)
	{
		buf = buf_cat(buf, serialize_string(description_));
	}
	return buf;
}

buf_t tl_statsDateRangeDays(int min_date_, int max_date_)
{
	buf_t buf = buf_add_ui32(0xb637edaf);
	//parse argument min_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(min_date_));
	}
	//parse argument max_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(max_date_));
	}
	return buf;
}

buf_t tl_statsAbsValueAndPrev(double current_, double previous_)
{
	buf_t buf = buf_add_ui32(0xcb43acde);
	//parse argument current (double)
	{
		buf = buf_cat(buf, buf_add_ui64(current_));
	}
	//parse argument previous (double)
	{
		buf = buf_cat(buf, buf_add_ui64(previous_));
	}
	return buf;
}

buf_t tl_statsPercentValue(double part_, double total_)
{
	buf_t buf = buf_add_ui32(0xcbce2fe0);
	//parse argument part (double)
	{
		buf = buf_cat(buf, buf_add_ui64(part_));
	}
	//parse argument total (double)
	{
		buf = buf_cat(buf, buf_add_ui64(total_));
	}
	return buf;
}

buf_t tl_statsGraphAsync(const char * token_)
{
	buf_t buf = buf_add_ui32(0x4a27eb2d);
	//parse argument token (string)
	{
		buf = buf_cat(buf, serialize_string(token_));
	}
	return buf;
}

buf_t tl_statsGraphError(const char * error_)
{
	buf_t buf = buf_add_ui32(0xbedc9822);
	//parse argument error (string)
	{
		buf = buf_cat(buf, serialize_string(error_));
	}
	return buf;
}

buf_t tl_statsGraph(DataJSON *json_, const char * zoom_token_)
{
	buf_t buf = buf_add_ui32(0x8ea464b6);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument json (DataJSON)
	{
		buf = buf_cat(buf, *json_);
	}
	//parse argument zoom_token (string)
	if (zoom_token_)
	{
		buf = buf_cat(buf, serialize_string(zoom_token_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_stats_broadcastStats(StatsDateRangeDays *period_, StatsAbsValueAndPrev *followers_, StatsAbsValueAndPrev *views_per_post_, StatsAbsValueAndPrev *shares_per_post_, StatsAbsValueAndPrev *reactions_per_post_, StatsAbsValueAndPrev *views_per_story_, StatsAbsValueAndPrev *shares_per_story_, StatsAbsValueAndPrev *reactions_per_story_, StatsPercentValue *enabled_notifications_, StatsGraph *growth_graph_, StatsGraph *followers_graph_, StatsGraph *mute_graph_, StatsGraph *top_hours_graph_, StatsGraph *interactions_graph_, StatsGraph *iv_interactions_graph_, StatsGraph *views_by_source_graph_, StatsGraph *new_followers_by_source_graph_, StatsGraph *languages_graph_, StatsGraph *reactions_by_emotion_graph_, StatsGraph *story_interactions_graph_, StatsGraph *story_reactions_by_emotion_graph_, PostInteractionCounters *recent_posts_interactions_, int recent_posts_interactions_len)
{
	buf_t buf = buf_add_ui32(0x396ca5fc);
	//parse argument period (StatsDateRangeDays)
	{
		buf = buf_cat(buf, *period_);
	}
	//parse argument followers (StatsAbsValueAndPrev)
	{
		buf = buf_cat(buf, *followers_);
	}
	//parse argument views_per_post (StatsAbsValueAndPrev)
	{
		buf = buf_cat(buf, *views_per_post_);
	}
	//parse argument shares_per_post (StatsAbsValueAndPrev)
	{
		buf = buf_cat(buf, *shares_per_post_);
	}
	//parse argument reactions_per_post (StatsAbsValueAndPrev)
	{
		buf = buf_cat(buf, *reactions_per_post_);
	}
	//parse argument views_per_story (StatsAbsValueAndPrev)
	{
		buf = buf_cat(buf, *views_per_story_);
	}
	//parse argument shares_per_story (StatsAbsValueAndPrev)
	{
		buf = buf_cat(buf, *shares_per_story_);
	}
	//parse argument reactions_per_story (StatsAbsValueAndPrev)
	{
		buf = buf_cat(buf, *reactions_per_story_);
	}
	//parse argument enabled_notifications (StatsPercentValue)
	{
		buf = buf_cat(buf, *enabled_notifications_);
	}
	//parse argument growth_graph (StatsGraph)
	{
		buf = buf_cat(buf, *growth_graph_);
	}
	//parse argument followers_graph (StatsGraph)
	{
		buf = buf_cat(buf, *followers_graph_);
	}
	//parse argument mute_graph (StatsGraph)
	{
		buf = buf_cat(buf, *mute_graph_);
	}
	//parse argument top_hours_graph (StatsGraph)
	{
		buf = buf_cat(buf, *top_hours_graph_);
	}
	//parse argument interactions_graph (StatsGraph)
	{
		buf = buf_cat(buf, *interactions_graph_);
	}
	//parse argument iv_interactions_graph (StatsGraph)
	{
		buf = buf_cat(buf, *iv_interactions_graph_);
	}
	//parse argument views_by_source_graph (StatsGraph)
	{
		buf = buf_cat(buf, *views_by_source_graph_);
	}
	//parse argument new_followers_by_source_graph (StatsGraph)
	{
		buf = buf_cat(buf, *new_followers_by_source_graph_);
	}
	//parse argument languages_graph (StatsGraph)
	{
		buf = buf_cat(buf, *languages_graph_);
	}
	//parse argument reactions_by_emotion_graph (StatsGraph)
	{
		buf = buf_cat(buf, *reactions_by_emotion_graph_);
	}
	//parse argument story_interactions_graph (StatsGraph)
	{
		buf = buf_cat(buf, *story_interactions_graph_);
	}
	//parse argument story_reactions_by_emotion_graph (StatsGraph)
	{
		buf = buf_cat(buf, *story_reactions_by_emotion_graph_);
	}
	//parse argument recent_posts_interactions (Vector<PostInteractionCounters>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(recent_posts_interactions_len));
		int i;
		for (i=0; i<recent_posts_interactions_len; ++i){
			buf = buf_cat(buf, recent_posts_interactions_[i]);
		}
	}
	return buf;
}

buf_t tl_help_promoDataEmpty(int expires_)
{
	buf_t buf = buf_add_ui32(0x98f6ac75);
	//parse argument expires (int)
	{
		buf = buf_cat(buf, buf_add_ui32(expires_));
	}
	return buf;
}

buf_t tl_help_promoData(bool proxy_, int expires_, Peer *peer_, Chat *chats_, int chats_len, User *users_, int users_len, const char * psa_type_, const char * psa_message_)
{
	buf_t buf = buf_add_ui32(0x8c39793f);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument proxy (true)
	if (proxy_)
		*flag1 |= (1 << 0);
	//parse argument expires (int)
	{
		buf = buf_cat(buf, buf_add_ui32(expires_));
	}
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	//parse argument psa_type (string)
	if (psa_type_)
	{
		buf = buf_cat(buf, serialize_string(psa_type_));
		*flag1 |= (1 << 1);
	}
	//parse argument psa_message (string)
	if (psa_message_)
	{
		buf = buf_cat(buf, serialize_string(psa_message_));
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_videoSize(const char * type_, int w_, int h_, int size_, double video_start_ts_)
{
	buf_t buf = buf_add_ui32(0xde33b094);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument type (string)
	{
		buf = buf_cat(buf, serialize_string(type_));
	}
	//parse argument w (int)
	{
		buf = buf_cat(buf, buf_add_ui32(w_));
	}
	//parse argument h (int)
	{
		buf = buf_cat(buf, buf_add_ui32(h_));
	}
	//parse argument size (int)
	{
		buf = buf_cat(buf, buf_add_ui32(size_));
	}
	//parse argument video_start_ts (double)
	if (video_start_ts_)
	{
		buf = buf_cat(buf, buf_add_ui64(video_start_ts_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_videoSizeEmojiMarkup(long emoji_id_, int *background_colors_, int background_colors_len)
{
	buf_t buf = buf_add_ui32(0xf85c413c);
	//parse argument emoji_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(emoji_id_));
	}
	//parse argument background_colors (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(background_colors_len));
		int i;
		for (i=0; i<background_colors_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(background_colors_[i]));
		}
	}
	return buf;
}

buf_t tl_videoSizeStickerMarkup(InputStickerSet *stickerset_, long sticker_id_, int *background_colors_, int background_colors_len)
{
	buf_t buf = buf_add_ui32(0x0da082fe);
	//parse argument stickerset (InputStickerSet)
	{
		buf = buf_cat(buf, *stickerset_);
	}
	//parse argument sticker_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(sticker_id_));
	}
	//parse argument background_colors (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(background_colors_len));
		int i;
		for (i=0; i<background_colors_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(background_colors_[i]));
		}
	}
	return buf;
}

buf_t tl_statsGroupTopPoster(long user_id_, int messages_, int avg_chars_)
{
	buf_t buf = buf_add_ui32(0x9d04af9b);
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument messages (int)
	{
		buf = buf_cat(buf, buf_add_ui32(messages_));
	}
	//parse argument avg_chars (int)
	{
		buf = buf_cat(buf, buf_add_ui32(avg_chars_));
	}
	return buf;
}

buf_t tl_statsGroupTopAdmin(long user_id_, int deleted_, int kicked_, int banned_)
{
	buf_t buf = buf_add_ui32(0xd7584c87);
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument deleted (int)
	{
		buf = buf_cat(buf, buf_add_ui32(deleted_));
	}
	//parse argument kicked (int)
	{
		buf = buf_cat(buf, buf_add_ui32(kicked_));
	}
	//parse argument banned (int)
	{
		buf = buf_cat(buf, buf_add_ui32(banned_));
	}
	return buf;
}

buf_t tl_statsGroupTopInviter(long user_id_, int invitations_)
{
	buf_t buf = buf_add_ui32(0x535f779d);
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument invitations (int)
	{
		buf = buf_cat(buf, buf_add_ui32(invitations_));
	}
	return buf;
}

buf_t tl_stats_megagroupStats(StatsDateRangeDays *period_, StatsAbsValueAndPrev *members_, StatsAbsValueAndPrev *messages_, StatsAbsValueAndPrev *viewers_, StatsAbsValueAndPrev *posters_, StatsGraph *growth_graph_, StatsGraph *members_graph_, StatsGraph *new_members_by_source_graph_, StatsGraph *languages_graph_, StatsGraph *messages_graph_, StatsGraph *actions_graph_, StatsGraph *top_hours_graph_, StatsGraph *weekdays_graph_, StatsGroupTopPoster *top_posters_, int top_posters_len, StatsGroupTopAdmin *top_admins_, int top_admins_len, StatsGroupTopInviter *top_inviters_, int top_inviters_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0xef7ff916);
	//parse argument period (StatsDateRangeDays)
	{
		buf = buf_cat(buf, *period_);
	}
	//parse argument members (StatsAbsValueAndPrev)
	{
		buf = buf_cat(buf, *members_);
	}
	//parse argument messages (StatsAbsValueAndPrev)
	{
		buf = buf_cat(buf, *messages_);
	}
	//parse argument viewers (StatsAbsValueAndPrev)
	{
		buf = buf_cat(buf, *viewers_);
	}
	//parse argument posters (StatsAbsValueAndPrev)
	{
		buf = buf_cat(buf, *posters_);
	}
	//parse argument growth_graph (StatsGraph)
	{
		buf = buf_cat(buf, *growth_graph_);
	}
	//parse argument members_graph (StatsGraph)
	{
		buf = buf_cat(buf, *members_graph_);
	}
	//parse argument new_members_by_source_graph (StatsGraph)
	{
		buf = buf_cat(buf, *new_members_by_source_graph_);
	}
	//parse argument languages_graph (StatsGraph)
	{
		buf = buf_cat(buf, *languages_graph_);
	}
	//parse argument messages_graph (StatsGraph)
	{
		buf = buf_cat(buf, *messages_graph_);
	}
	//parse argument actions_graph (StatsGraph)
	{
		buf = buf_cat(buf, *actions_graph_);
	}
	//parse argument top_hours_graph (StatsGraph)
	{
		buf = buf_cat(buf, *top_hours_graph_);
	}
	//parse argument weekdays_graph (StatsGraph)
	{
		buf = buf_cat(buf, *weekdays_graph_);
	}
	//parse argument top_posters (Vector<StatsGroupTopPoster>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(top_posters_len));
		int i;
		for (i=0; i<top_posters_len; ++i){
			buf = buf_cat(buf, top_posters_[i]);
		}
	}
	//parse argument top_admins (Vector<StatsGroupTopAdmin>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(top_admins_len));
		int i;
		for (i=0; i<top_admins_len; ++i){
			buf = buf_cat(buf, top_admins_[i]);
		}
	}
	//parse argument top_inviters (Vector<StatsGroupTopInviter>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(top_inviters_len));
		int i;
		for (i=0; i<top_inviters_len; ++i){
			buf = buf_cat(buf, top_inviters_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_globalPrivacySettings(bool archive_and_mute_new_noncontact_peers_, bool keep_archived_unmuted_, bool keep_archived_folders_, bool hide_read_marks_, bool new_noncontact_peers_require_premium_)
{
	buf_t buf = buf_add_ui32(0x734c4ccb);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument archive_and_mute_new_noncontact_peers (true)
	if (archive_and_mute_new_noncontact_peers_)
		*flag1 |= (1 << 0);
	//parse argument keep_archived_unmuted (true)
	if (keep_archived_unmuted_)
		*flag1 |= (1 << 1);
	//parse argument keep_archived_folders (true)
	if (keep_archived_folders_)
		*flag1 |= (1 << 2);
	//parse argument hide_read_marks (true)
	if (hide_read_marks_)
		*flag1 |= (1 << 3);
	//parse argument new_noncontact_peers_require_premium (true)
	if (new_noncontact_peers_require_premium_)
		*flag1 |= (1 << 4);
	return buf;
}

buf_t tl_help_countryCode(const char * country_code_, const char * *prefixes_, int prefixes_len, const char * *patterns_, int patterns_len)
{
	buf_t buf = buf_add_ui32(0x4203c5ef);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument country_code (string)
	{
		buf = buf_cat(buf, serialize_string(country_code_));
	}
	//parse argument prefixes (Vector<string>)
	if (prefixes_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(prefixes_len));
		int i;
		for (i=0; i<prefixes_len; ++i){
			buf = buf_cat(buf, serialize_string(prefixes_[i]));
		}
		*flag1 |= (1 << 0);
	}
	//parse argument patterns (Vector<string>)
	if (patterns_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(patterns_len));
		int i;
		for (i=0; i<patterns_len; ++i){
			buf = buf_cat(buf, serialize_string(patterns_[i]));
		}
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_help_country(bool hidden_, const char * iso2_, const char * default_name_, const char * name_, help_CountryCode *country_codes_, int country_codes_len)
{
	buf_t buf = buf_add_ui32(0xc3878e23);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument hidden (true)
	if (hidden_)
		*flag1 |= (1 << 0);
	//parse argument iso2 (string)
	{
		buf = buf_cat(buf, serialize_string(iso2_));
	}
	//parse argument default_name (string)
	{
		buf = buf_cat(buf, serialize_string(default_name_));
	}
	//parse argument name (string)
	if (name_)
	{
		buf = buf_cat(buf, serialize_string(name_));
		*flag1 |= (1 << 1);
	}
	//parse argument country_codes (Vector<help_CountryCode>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(country_codes_len));
		int i;
		for (i=0; i<country_codes_len; ++i){
			buf = buf_cat(buf, country_codes_[i]);
		}
	}
	return buf;
}

buf_t tl_help_countriesListNotModified()
{
	buf_t buf = buf_add_ui32(0x93cc1f32);
	return buf;
}

buf_t tl_help_countriesList(help_Country *countries_, int countries_len, int hash_)
{
	buf_t buf = buf_add_ui32(0x87d0759e);
	//parse argument countries (Vector<help_Country>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(countries_len));
		int i;
		for (i=0; i<countries_len; ++i){
			buf = buf_cat(buf, countries_[i]);
		}
	}
	//parse argument hash (int)
	{
		buf = buf_cat(buf, buf_add_ui32(hash_));
	}
	return buf;
}

buf_t tl_messageViews(int views_, int forwards_, MessageReplies *replies_)
{
	buf_t buf = buf_add_ui32(0x455b853d);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument views (int)
	if (views_)
	{
		buf = buf_cat(buf, buf_add_ui32(views_));
		*flag1 |= (1 << 0);
	}
	//parse argument forwards (int)
	if (forwards_)
	{
		buf = buf_cat(buf, buf_add_ui32(forwards_));
		*flag1 |= (1 << 1);
	}
	//parse argument replies (MessageReplies)
	if (replies_)
	{
		buf = buf_cat(buf, *replies_);
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_messages_messageViews(MessageViews *views_, int views_len, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0xb6c4f543);
	//parse argument views (Vector<MessageViews>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(views_len));
		int i;
		for (i=0; i<views_len; ++i){
			buf = buf_cat(buf, views_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_messages_discussionMessage(Message *messages_, int messages_len, int max_id_, int read_inbox_max_id_, int read_outbox_max_id_, int unread_count_, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0xa6341782);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument messages (Vector<Message>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(messages_len));
		int i;
		for (i=0; i<messages_len; ++i){
			buf = buf_cat(buf, messages_[i]);
		}
	}
	//parse argument max_id (int)
	if (max_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(max_id_));
		*flag1 |= (1 << 0);
	}
	//parse argument read_inbox_max_id (int)
	if (read_inbox_max_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(read_inbox_max_id_));
		*flag1 |= (1 << 1);
	}
	//parse argument read_outbox_max_id (int)
	if (read_outbox_max_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(read_outbox_max_id_));
		*flag1 |= (1 << 2);
	}
	//parse argument unread_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(unread_count_));
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_messageReplyHeader(bool reply_to_scheduled_, bool forum_topic_, bool quote_, int reply_to_msg_id_, Peer *reply_to_peer_id_, MessageFwdHeader *reply_from_, MessageMedia *reply_media_, int reply_to_top_id_, const char * quote_text_, MessageEntity *quote_entities_, int quote_entities_len, int quote_offset_)
{
	buf_t buf = buf_add_ui32(0xafbc09db);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument reply_to_scheduled (true)
	if (reply_to_scheduled_)
		*flag1 |= (1 << 2);
	//parse argument forum_topic (true)
	if (forum_topic_)
		*flag1 |= (1 << 3);
	//parse argument quote (true)
	if (quote_)
		*flag1 |= (1 << 9);
	//parse argument reply_to_msg_id (int)
	if (reply_to_msg_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(reply_to_msg_id_));
		*flag1 |= (1 << 4);
	}
	//parse argument reply_to_peer_id (Peer)
	if (reply_to_peer_id_)
	{
		buf = buf_cat(buf, *reply_to_peer_id_);
		*flag1 |= (1 << 0);
	}
	//parse argument reply_from (MessageFwdHeader)
	if (reply_from_)
	{
		buf = buf_cat(buf, *reply_from_);
		*flag1 |= (1 << 5);
	}
	//parse argument reply_media (MessageMedia)
	if (reply_media_)
	{
		buf = buf_cat(buf, *reply_media_);
		*flag1 |= (1 << 8);
	}
	//parse argument reply_to_top_id (int)
	if (reply_to_top_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(reply_to_top_id_));
		*flag1 |= (1 << 1);
	}
	//parse argument quote_text (string)
	if (quote_text_)
	{
		buf = buf_cat(buf, serialize_string(quote_text_));
		*flag1 |= (1 << 6);
	}
	//parse argument quote_entities (Vector<MessageEntity>)
	if (quote_entities_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(quote_entities_len));
		int i;
		for (i=0; i<quote_entities_len; ++i){
			buf = buf_cat(buf, quote_entities_[i]);
		}
		*flag1 |= (1 << 7);
	}
	//parse argument quote_offset (int)
	if (quote_offset_)
	{
		buf = buf_cat(buf, buf_add_ui32(quote_offset_));
		*flag1 |= (1 << 10);
	}
	return buf;
}

buf_t tl_messageReplyStoryHeader(Peer *peer_, int story_id_)
{
	buf_t buf = buf_add_ui32(0x0e5af939);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument story_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(story_id_));
	}
	return buf;
}

buf_t tl_messageReplies(bool comments_, int replies_, int replies_pts_, Peer *recent_repliers_, int recent_repliers_len, long channel_id_, int max_id_, int read_max_id_)
{
	buf_t buf = buf_add_ui32(0x83d60fc2);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument comments (true)
	if (comments_)
		*flag1 |= (1 << 0);
	//parse argument replies (int)
	{
		buf = buf_cat(buf, buf_add_ui32(replies_));
	}
	//parse argument replies_pts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(replies_pts_));
	}
	//parse argument recent_repliers (Vector<Peer>)
	if (recent_repliers_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(recent_repliers_len));
		int i;
		for (i=0; i<recent_repliers_len; ++i){
			buf = buf_cat(buf, recent_repliers_[i]);
		}
		*flag1 |= (1 << 1);
	}
	//parse argument channel_id (long)
	if (channel_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(channel_id_));
		*flag1 |= (1 << 0);
	}
	//parse argument max_id (int)
	if (max_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(max_id_));
		*flag1 |= (1 << 2);
	}
	//parse argument read_max_id (int)
	if (read_max_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(read_max_id_));
		*flag1 |= (1 << 3);
	}
	return buf;
}

buf_t tl_peerBlocked(Peer *peer_id_, int date_)
{
	buf_t buf = buf_add_ui32(0xe8fd8014);
	//parse argument peer_id (Peer)
	{
		buf = buf_cat(buf, *peer_id_);
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	return buf;
}

buf_t tl_stats_messageStats(StatsGraph *views_graph_, StatsGraph *reactions_by_emotion_graph_)
{
	buf_t buf = buf_add_ui32(0x7fe91c14);
	//parse argument views_graph (StatsGraph)
	{
		buf = buf_cat(buf, *views_graph_);
	}
	//parse argument reactions_by_emotion_graph (StatsGraph)
	{
		buf = buf_cat(buf, *reactions_by_emotion_graph_);
	}
	return buf;
}

buf_t tl_groupCallDiscarded(long id_, long access_hash_, int duration_)
{
	buf_t buf = buf_add_ui32(0x7780bcb4);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	//parse argument duration (int)
	{
		buf = buf_cat(buf, buf_add_ui32(duration_));
	}
	return buf;
}

buf_t tl_groupCall(bool join_muted_, bool can_change_join_muted_, bool join_date_asc_, bool schedule_start_subscribed_, bool can_start_video_, bool record_video_active_, bool rtmp_stream_, bool listeners_hidden_, long id_, long access_hash_, int participants_count_, const char * title_, int stream_dc_id_, int record_start_date_, int schedule_date_, int unmuted_video_count_, int unmuted_video_limit_, int version_)
{
	buf_t buf = buf_add_ui32(0xd597650c);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument join_muted (true)
	if (join_muted_)
		*flag1 |= (1 << 1);
	//parse argument can_change_join_muted (true)
	if (can_change_join_muted_)
		*flag1 |= (1 << 2);
	//parse argument join_date_asc (true)
	if (join_date_asc_)
		*flag1 |= (1 << 6);
	//parse argument schedule_start_subscribed (true)
	if (schedule_start_subscribed_)
		*flag1 |= (1 << 8);
	//parse argument can_start_video (true)
	if (can_start_video_)
		*flag1 |= (1 << 9);
	//parse argument record_video_active (true)
	if (record_video_active_)
		*flag1 |= (1 << 11);
	//parse argument rtmp_stream (true)
	if (rtmp_stream_)
		*flag1 |= (1 << 12);
	//parse argument listeners_hidden (true)
	if (listeners_hidden_)
		*flag1 |= (1 << 13);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	//parse argument participants_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(participants_count_));
	}
	//parse argument title (string)
	if (title_)
	{
		buf = buf_cat(buf, serialize_string(title_));
		*flag1 |= (1 << 3);
	}
	//parse argument stream_dc_id (int)
	if (stream_dc_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(stream_dc_id_));
		*flag1 |= (1 << 4);
	}
	//parse argument record_start_date (int)
	if (record_start_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(record_start_date_));
		*flag1 |= (1 << 5);
	}
	//parse argument schedule_date (int)
	if (schedule_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(schedule_date_));
		*flag1 |= (1 << 7);
	}
	//parse argument unmuted_video_count (int)
	if (unmuted_video_count_)
	{
		buf = buf_cat(buf, buf_add_ui32(unmuted_video_count_));
		*flag1 |= (1 << 10);
	}
	//parse argument unmuted_video_limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(unmuted_video_limit_));
	}
	//parse argument version (int)
	{
		buf = buf_cat(buf, buf_add_ui32(version_));
	}
	return buf;
}

buf_t tl_inputGroupCall(long id_, long access_hash_)
{
	buf_t buf = buf_add_ui32(0xd8aa840f);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	return buf;
}

buf_t tl_groupCallParticipant(bool muted_, bool left_, bool can_self_unmute_, bool just_joined_, bool versioned_, bool min_, bool muted_by_you_, bool volume_by_admin_, bool self_, bool video_joined_, Peer *peer_, int date_, int active_date_, int source_, int volume_, const char * about_, long raise_hand_rating_, GroupCallParticipantVideo *video_, GroupCallParticipantVideo *presentation_)
{
	buf_t buf = buf_add_ui32(0xeba636fe);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument muted (true)
	if (muted_)
		*flag1 |= (1 << 0);
	//parse argument left (true)
	if (left_)
		*flag1 |= (1 << 1);
	//parse argument can_self_unmute (true)
	if (can_self_unmute_)
		*flag1 |= (1 << 2);
	//parse argument just_joined (true)
	if (just_joined_)
		*flag1 |= (1 << 4);
	//parse argument versioned (true)
	if (versioned_)
		*flag1 |= (1 << 5);
	//parse argument min (true)
	if (min_)
		*flag1 |= (1 << 8);
	//parse argument muted_by_you (true)
	if (muted_by_you_)
		*flag1 |= (1 << 9);
	//parse argument volume_by_admin (true)
	if (volume_by_admin_)
		*flag1 |= (1 << 10);
	//parse argument self (true)
	if (self_)
		*flag1 |= (1 << 12);
	//parse argument video_joined (true)
	if (video_joined_)
		*flag1 |= (1 << 15);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument active_date (int)
	if (active_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(active_date_));
		*flag1 |= (1 << 3);
	}
	//parse argument source (int)
	{
		buf = buf_cat(buf, buf_add_ui32(source_));
	}
	//parse argument volume (int)
	if (volume_)
	{
		buf = buf_cat(buf, buf_add_ui32(volume_));
		*flag1 |= (1 << 7);
	}
	//parse argument about (string)
	if (about_)
	{
		buf = buf_cat(buf, serialize_string(about_));
		*flag1 |= (1 << 11);
	}
	//parse argument raise_hand_rating (long)
	if (raise_hand_rating_)
	{
		buf = buf_cat(buf, buf_add_ui64(raise_hand_rating_));
		*flag1 |= (1 << 13);
	}
	//parse argument video (GroupCallParticipantVideo)
	if (video_)
	{
		buf = buf_cat(buf, *video_);
		*flag1 |= (1 << 6);
	}
	//parse argument presentation (GroupCallParticipantVideo)
	if (presentation_)
	{
		buf = buf_cat(buf, *presentation_);
		*flag1 |= (1 << 14);
	}
	return buf;
}

buf_t tl_phone_groupCall(GroupCall *call_, GroupCallParticipant *participants_, int participants_len, const char * participants_next_offset_, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x9e727aad);
	//parse argument call (GroupCall)
	{
		buf = buf_cat(buf, *call_);
	}
	//parse argument participants (Vector<GroupCallParticipant>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(participants_len));
		int i;
		for (i=0; i<participants_len; ++i){
			buf = buf_cat(buf, participants_[i]);
		}
	}
	//parse argument participants_next_offset (string)
	{
		buf = buf_cat(buf, serialize_string(participants_next_offset_));
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_phone_groupParticipants(int count_, GroupCallParticipant *participants_, int participants_len, const char * next_offset_, Chat *chats_, int chats_len, User *users_, int users_len, int version_)
{
	buf_t buf = buf_add_ui32(0xf47751b6);
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	//parse argument participants (Vector<GroupCallParticipant>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(participants_len));
		int i;
		for (i=0; i<participants_len; ++i){
			buf = buf_cat(buf, participants_[i]);
		}
	}
	//parse argument next_offset (string)
	{
		buf = buf_cat(buf, serialize_string(next_offset_));
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	//parse argument version (int)
	{
		buf = buf_cat(buf, buf_add_ui32(version_));
	}
	return buf;
}

buf_t tl_inlineQueryPeerTypeSameBotPM()
{
	buf_t buf = buf_add_ui32(0x3081ed9d);
	return buf;
}

buf_t tl_inlineQueryPeerTypePM()
{
	buf_t buf = buf_add_ui32(0x833c0fac);
	return buf;
}

buf_t tl_inlineQueryPeerTypeChat()
{
	buf_t buf = buf_add_ui32(0xd766c50a);
	return buf;
}

buf_t tl_inlineQueryPeerTypeMegagroup()
{
	buf_t buf = buf_add_ui32(0x5ec4be43);
	return buf;
}

buf_t tl_inlineQueryPeerTypeBroadcast()
{
	buf_t buf = buf_add_ui32(0x6334ee9a);
	return buf;
}

buf_t tl_inlineQueryPeerTypeBotPM()
{
	buf_t buf = buf_add_ui32(0x0e3b2d0c);
	return buf;
}

buf_t tl_messages_historyImport(long id_)
{
	buf_t buf = buf_add_ui32(0x1662af0b);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	return buf;
}

buf_t tl_messages_historyImportParsed(bool pm_, bool group_, const char * title_)
{
	buf_t buf = buf_add_ui32(0x5e0fb7b9);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument pm (true)
	if (pm_)
		*flag1 |= (1 << 0);
	//parse argument group (true)
	if (group_)
		*flag1 |= (1 << 1);
	//parse argument title (string)
	if (title_)
	{
		buf = buf_cat(buf, serialize_string(title_));
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_messages_affectedFoundMessages(int pts_, int pts_count_, int offset_, int *messages_, int messages_len)
{
	buf_t buf = buf_add_ui32(0xef8d3e6c);
	//parse argument pts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_));
	}
	//parse argument pts_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_count_));
	}
	//parse argument offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_));
	}
	//parse argument messages (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(messages_len));
		int i;
		for (i=0; i<messages_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(messages_[i]));
		}
	}
	return buf;
}

buf_t tl_chatInviteImporter(bool requested_, bool via_chatlist_, long user_id_, int date_, const char * about_, long approved_by_)
{
	buf_t buf = buf_add_ui32(0x8c5adfd9);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument requested (true)
	if (requested_)
		*flag1 |= (1 << 0);
	//parse argument via_chatlist (true)
	if (via_chatlist_)
		*flag1 |= (1 << 3);
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument about (string)
	if (about_)
	{
		buf = buf_cat(buf, serialize_string(about_));
		*flag1 |= (1 << 2);
	}
	//parse argument approved_by (long)
	if (approved_by_)
	{
		buf = buf_cat(buf, buf_add_ui64(approved_by_));
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_messages_exportedChatInvites(int count_, ExportedChatInvite *invites_, int invites_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0xbdc62dcc);
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	//parse argument invites (Vector<ExportedChatInvite>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(invites_len));
		int i;
		for (i=0; i<invites_len; ++i){
			buf = buf_cat(buf, invites_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_messages_exportedChatInvite(ExportedChatInvite *invite_, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x1871be50);
	//parse argument invite (ExportedChatInvite)
	{
		buf = buf_cat(buf, *invite_);
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_messages_exportedChatInviteReplaced(ExportedChatInvite *invite_, ExportedChatInvite *new_invite_, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x222600ef);
	//parse argument invite (ExportedChatInvite)
	{
		buf = buf_cat(buf, *invite_);
	}
	//parse argument new_invite (ExportedChatInvite)
	{
		buf = buf_cat(buf, *new_invite_);
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_messages_chatInviteImporters(int count_, ChatInviteImporter *importers_, int importers_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x81b6b00a);
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	//parse argument importers (Vector<ChatInviteImporter>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(importers_len));
		int i;
		for (i=0; i<importers_len; ++i){
			buf = buf_cat(buf, importers_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_chatAdminWithInvites(long admin_id_, int invites_count_, int revoked_invites_count_)
{
	buf_t buf = buf_add_ui32(0xf2ecef23);
	//parse argument admin_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(admin_id_));
	}
	//parse argument invites_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(invites_count_));
	}
	//parse argument revoked_invites_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(revoked_invites_count_));
	}
	return buf;
}

buf_t tl_messages_chatAdminsWithInvites(ChatAdminWithInvites *admins_, int admins_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0xb69b72d7);
	//parse argument admins (Vector<ChatAdminWithInvites>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(admins_len));
		int i;
		for (i=0; i<admins_len; ++i){
			buf = buf_cat(buf, admins_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_messages_checkedHistoryImportPeer(const char * confirm_text_)
{
	buf_t buf = buf_add_ui32(0xa24de717);
	//parse argument confirm_text (string)
	{
		buf = buf_cat(buf, serialize_string(confirm_text_));
	}
	return buf;
}

buf_t tl_phone_joinAsPeers(Peer *peers_, int peers_len, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0xafe5623f);
	//parse argument peers (Vector<Peer>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(peers_len));
		int i;
		for (i=0; i<peers_len; ++i){
			buf = buf_cat(buf, peers_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_phone_exportedGroupCallInvite(const char * link_)
{
	buf_t buf = buf_add_ui32(0x204bd158);
	//parse argument link (string)
	{
		buf = buf_cat(buf, serialize_string(link_));
	}
	return buf;
}

buf_t tl_groupCallParticipantVideoSourceGroup(const char * semantics_, int *sources_, int sources_len)
{
	buf_t buf = buf_add_ui32(0xdcb118b7);
	//parse argument semantics (string)
	{
		buf = buf_cat(buf, serialize_string(semantics_));
	}
	//parse argument sources (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(sources_len));
		int i;
		for (i=0; i<sources_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(sources_[i]));
		}
	}
	return buf;
}

buf_t tl_groupCallParticipantVideo(bool paused_, const char * endpoint_, GroupCallParticipantVideoSourceGroup *source_groups_, int source_groups_len, int audio_source_)
{
	buf_t buf = buf_add_ui32(0x67753ac8);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument paused (true)
	if (paused_)
		*flag1 |= (1 << 0);
	//parse argument endpoint (string)
	{
		buf = buf_cat(buf, serialize_string(endpoint_));
	}
	//parse argument source_groups (Vector<GroupCallParticipantVideoSourceGroup>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(source_groups_len));
		int i;
		for (i=0; i<source_groups_len; ++i){
			buf = buf_cat(buf, source_groups_[i]);
		}
	}
	//parse argument audio_source (int)
	if (audio_source_)
	{
		buf = buf_cat(buf, buf_add_ui32(audio_source_));
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_stickers_suggestedShortName(const char * short_name_)
{
	buf_t buf = buf_add_ui32(0x85fea03f);
	//parse argument short_name (string)
	{
		buf = buf_cat(buf, serialize_string(short_name_));
	}
	return buf;
}

buf_t tl_botCommandScopeDefault()
{
	buf_t buf = buf_add_ui32(0x2f6cb2ab);
	return buf;
}

buf_t tl_botCommandScopeUsers()
{
	buf_t buf = buf_add_ui32(0x3c4f04d8);
	return buf;
}

buf_t tl_botCommandScopeChats()
{
	buf_t buf = buf_add_ui32(0x6fe1a881);
	return buf;
}

buf_t tl_botCommandScopeChatAdmins()
{
	buf_t buf = buf_add_ui32(0xb9aa606a);
	return buf;
}

buf_t tl_botCommandScopePeer(InputPeer *peer_)
{
	buf_t buf = buf_add_ui32(0xdb9d897d);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_botCommandScopePeerAdmins(InputPeer *peer_)
{
	buf_t buf = buf_add_ui32(0x3fd863d1);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_botCommandScopePeerUser(InputPeer *peer_, InputUser *user_id_)
{
	buf_t buf = buf_add_ui32(0x0a1321f3);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument user_id (InputUser)
	{
		buf = buf_cat(buf, *user_id_);
	}
	return buf;
}

buf_t tl_account_resetPasswordFailedWait(int retry_date_)
{
	buf_t buf = buf_add_ui32(0xe3779861);
	//parse argument retry_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(retry_date_));
	}
	return buf;
}

buf_t tl_account_resetPasswordRequestedWait(int until_date_)
{
	buf_t buf = buf_add_ui32(0xe9effc7d);
	//parse argument until_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(until_date_));
	}
	return buf;
}

buf_t tl_account_resetPasswordOk()
{
	buf_t buf = buf_add_ui32(0xe926d63e);
	return buf;
}

buf_t tl_sponsoredMessage(bool recommended_, bool can_report_, buf_t *random_id_, const char * url_, const char * title_, const char * message_, MessageEntity *entities_, int entities_len, Photo *photo_, MessageMedia *media_, PeerColor *color_, const char * button_text_, const char * sponsor_info_, const char * additional_info_)
{
	buf_t buf = buf_add_ui32(0x4d93a990);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument recommended (true)
	if (recommended_)
		*flag1 |= (1 << 5);
	//parse argument can_report (true)
	if (can_report_)
		*flag1 |= (1 << 12);
	//parse argument random_id (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(random_id_->data, random_id_->size));
	}
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument message (string)
	{
		buf = buf_cat(buf, serialize_string(message_));
	}
	//parse argument entities (Vector<MessageEntity>)
	if (entities_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(entities_len));
		int i;
		for (i=0; i<entities_len; ++i){
			buf = buf_cat(buf, entities_[i]);
		}
		*flag1 |= (1 << 1);
	}
	//parse argument photo (Photo)
	if (photo_)
	{
		buf = buf_cat(buf, *photo_);
		*flag1 |= (1 << 6);
	}
	//parse argument media (MessageMedia)
	if (media_)
	{
		buf = buf_cat(buf, *media_);
		*flag1 |= (1 << 14);
	}
	//parse argument color (PeerColor)
	if (color_)
	{
		buf = buf_cat(buf, *color_);
		*flag1 |= (1 << 13);
	}
	//parse argument button_text (string)
	{
		buf = buf_cat(buf, serialize_string(button_text_));
	}
	//parse argument sponsor_info (string)
	if (sponsor_info_)
	{
		buf = buf_cat(buf, serialize_string(sponsor_info_));
		*flag1 |= (1 << 7);
	}
	//parse argument additional_info (string)
	if (additional_info_)
	{
		buf = buf_cat(buf, serialize_string(additional_info_));
		*flag1 |= (1 << 8);
	}
	return buf;
}

buf_t tl_messages_sponsoredMessages(int posts_between_, SponsoredMessage *messages_, int messages_len, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0xc9ee1d87);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument posts_between (int)
	if (posts_between_)
	{
		buf = buf_cat(buf, buf_add_ui32(posts_between_));
		*flag1 |= (1 << 0);
	}
	//parse argument messages (Vector<SponsoredMessage>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(messages_len));
		int i;
		for (i=0; i<messages_len; ++i){
			buf = buf_cat(buf, messages_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_messages_sponsoredMessagesEmpty()
{
	buf_t buf = buf_add_ui32(0x1839490f);
	return buf;
}

buf_t tl_searchResultsCalendarPeriod(int date_, int min_msg_id_, int max_msg_id_, int count_)
{
	buf_t buf = buf_add_ui32(0xc9b0539f);
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument min_msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(min_msg_id_));
	}
	//parse argument max_msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(max_msg_id_));
	}
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	return buf;
}

buf_t tl_messages_searchResultsCalendar(bool inexact_, int count_, int min_date_, int min_msg_id_, int offset_id_offset_, SearchResultsCalendarPeriod *periods_, int periods_len, Message *messages_, int messages_len, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x147ee23c);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument inexact (true)
	if (inexact_)
		*flag1 |= (1 << 0);
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	//parse argument min_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(min_date_));
	}
	//parse argument min_msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(min_msg_id_));
	}
	//parse argument offset_id_offset (int)
	if (offset_id_offset_)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_id_offset_));
		*flag1 |= (1 << 1);
	}
	//parse argument periods (Vector<SearchResultsCalendarPeriod>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(periods_len));
		int i;
		for (i=0; i<periods_len; ++i){
			buf = buf_cat(buf, periods_[i]);
		}
	}
	//parse argument messages (Vector<Message>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(messages_len));
		int i;
		for (i=0; i<messages_len; ++i){
			buf = buf_cat(buf, messages_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_searchResultPosition(int msg_id_, int date_, int offset_)
{
	buf_t buf = buf_add_ui32(0x7f648b67);
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_));
	}
	return buf;
}

buf_t tl_messages_searchResultsPositions(int count_, SearchResultsPosition *positions_, int positions_len)
{
	buf_t buf = buf_add_ui32(0x53b22baf);
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	//parse argument positions (Vector<SearchResultsPosition>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(positions_len));
		int i;
		for (i=0; i<positions_len; ++i){
			buf = buf_cat(buf, positions_[i]);
		}
	}
	return buf;
}

buf_t tl_channels_sendAsPeers(SendAsPeer *peers_, int peers_len, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0xf496b0c6);
	//parse argument peers (Vector<SendAsPeer>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(peers_len));
		int i;
		for (i=0; i<peers_len; ++i){
			buf = buf_cat(buf, peers_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_users_userFull(UserFull *full_user_, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x3b6d152e);
	//parse argument full_user (UserFull)
	{
		buf = buf_cat(buf, *full_user_);
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_messages_peerSettings(PeerSettings *settings_, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x6880b94d);
	//parse argument settings (PeerSettings)
	{
		buf = buf_cat(buf, *settings_);
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_auth_loggedOut(buf_t *future_auth_token_)
{
	buf_t buf = buf_add_ui32(0xc3a2835f);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument future_auth_token (bytes)
	if (future_auth_token_)
	{
		buf = buf_cat(buf, serialize_bytes(future_auth_token_->data, future_auth_token_->size));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_reactionCount(int chosen_order_, Reaction *reaction_, int count_)
{
	buf_t buf = buf_add_ui32(0xa3d1cb80);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument chosen_order (int)
	if (chosen_order_)
	{
		buf = buf_cat(buf, buf_add_ui32(chosen_order_));
		*flag1 |= (1 << 0);
	}
	//parse argument reaction (Reaction)
	{
		buf = buf_cat(buf, *reaction_);
	}
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	return buf;
}

buf_t tl_messageReactions(bool min_, bool can_see_list_, bool reactions_as_tags_, ReactionCount *results_, int results_len, MessagePeerReaction *recent_reactions_, int recent_reactions_len, MessageReactor *top_reactors_, int top_reactors_len)
{
	buf_t buf = buf_add_ui32(0x0a339f0b);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument min (true)
	if (min_)
		*flag1 |= (1 << 0);
	//parse argument can_see_list (true)
	if (can_see_list_)
		*flag1 |= (1 << 2);
	//parse argument reactions_as_tags (true)
	if (reactions_as_tags_)
		*flag1 |= (1 << 3);
	//parse argument results (Vector<ReactionCount>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(results_len));
		int i;
		for (i=0; i<results_len; ++i){
			buf = buf_cat(buf, results_[i]);
		}
	}
	//parse argument recent_reactions (Vector<MessagePeerReaction>)
	if (recent_reactions_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(recent_reactions_len));
		int i;
		for (i=0; i<recent_reactions_len; ++i){
			buf = buf_cat(buf, recent_reactions_[i]);
		}
		*flag1 |= (1 << 1);
	}
	//parse argument top_reactors (Vector<MessageReactor>)
	if (top_reactors_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(top_reactors_len));
		int i;
		for (i=0; i<top_reactors_len; ++i){
			buf = buf_cat(buf, top_reactors_[i]);
		}
		*flag1 |= (1 << 4);
	}
	return buf;
}

buf_t tl_messages_messageReactionsList(int count_, MessagePeerReaction *reactions_, int reactions_len, Chat *chats_, int chats_len, User *users_, int users_len, const char * next_offset_)
{
	buf_t buf = buf_add_ui32(0x31bd492d);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	//parse argument reactions (Vector<MessagePeerReaction>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(reactions_len));
		int i;
		for (i=0; i<reactions_len; ++i){
			buf = buf_cat(buf, reactions_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	//parse argument next_offset (string)
	if (next_offset_)
	{
		buf = buf_cat(buf, serialize_string(next_offset_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_availableReaction(bool inactive_, bool premium_, const char * reaction_, const char * title_, Document *static_icon_, Document *appear_animation_, Document *select_animation_, Document *activate_animation_, Document *effect_animation_, Document *around_animation_, Document *center_icon_)
{
	buf_t buf = buf_add_ui32(0xc077ec01);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument inactive (true)
	if (inactive_)
		*flag1 |= (1 << 0);
	//parse argument premium (true)
	if (premium_)
		*flag1 |= (1 << 2);
	//parse argument reaction (string)
	{
		buf = buf_cat(buf, serialize_string(reaction_));
	}
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument static_icon (Document)
	{
		buf = buf_cat(buf, *static_icon_);
	}
	//parse argument appear_animation (Document)
	{
		buf = buf_cat(buf, *appear_animation_);
	}
	//parse argument select_animation (Document)
	{
		buf = buf_cat(buf, *select_animation_);
	}
	//parse argument activate_animation (Document)
	{
		buf = buf_cat(buf, *activate_animation_);
	}
	//parse argument effect_animation (Document)
	{
		buf = buf_cat(buf, *effect_animation_);
	}
	//parse argument around_animation (Document)
	if (around_animation_)
	{
		buf = buf_cat(buf, *around_animation_);
		*flag1 |= (1 << 1);
	}
	//parse argument center_icon (Document)
	if (center_icon_)
	{
		buf = buf_cat(buf, *center_icon_);
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_messages_availableReactionsNotModified()
{
	buf_t buf = buf_add_ui32(0x9f071957);
	return buf;
}

buf_t tl_messages_availableReactions(int hash_, AvailableReaction *reactions_, int reactions_len)
{
	buf_t buf = buf_add_ui32(0x768e3aad);
	//parse argument hash (int)
	{
		buf = buf_cat(buf, buf_add_ui32(hash_));
	}
	//parse argument reactions (Vector<AvailableReaction>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(reactions_len));
		int i;
		for (i=0; i<reactions_len; ++i){
			buf = buf_cat(buf, reactions_[i]);
		}
	}
	return buf;
}

buf_t tl_messagePeerReaction(bool big_, bool unread_, bool my_, Peer *peer_id_, int date_, Reaction *reaction_)
{
	buf_t buf = buf_add_ui32(0x8c79b63c);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument big (true)
	if (big_)
		*flag1 |= (1 << 0);
	//parse argument unread (true)
	if (unread_)
		*flag1 |= (1 << 1);
	//parse argument my (true)
	if (my_)
		*flag1 |= (1 << 2);
	//parse argument peer_id (Peer)
	{
		buf = buf_cat(buf, *peer_id_);
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument reaction (Reaction)
	{
		buf = buf_cat(buf, *reaction_);
	}
	return buf;
}

buf_t tl_groupCallStreamChannel(int channel_, int scale_, long last_timestamp_ms_)
{
	buf_t buf = buf_add_ui32(0x80eb48af);
	//parse argument channel (int)
	{
		buf = buf_cat(buf, buf_add_ui32(channel_));
	}
	//parse argument scale (int)
	{
		buf = buf_cat(buf, buf_add_ui32(scale_));
	}
	//parse argument last_timestamp_ms (long)
	{
		buf = buf_cat(buf, buf_add_ui64(last_timestamp_ms_));
	}
	return buf;
}

buf_t tl_phone_groupCallStreamChannels(GroupCallStreamChannel *channels_, int channels_len)
{
	buf_t buf = buf_add_ui32(0xd0e482b2);
	//parse argument channels (Vector<GroupCallStreamChannel>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(channels_len));
		int i;
		for (i=0; i<channels_len; ++i){
			buf = buf_cat(buf, channels_[i]);
		}
	}
	return buf;
}

buf_t tl_phone_groupCallStreamRtmpUrl(const char * url_, const char * key_)
{
	buf_t buf = buf_add_ui32(0x2dbf3432);
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	//parse argument key (string)
	{
		buf = buf_cat(buf, serialize_string(key_));
	}
	return buf;
}

buf_t tl_attachMenuBotIconColor(const char * name_, int color_)
{
	buf_t buf = buf_add_ui32(0x4576f3f0);
	//parse argument name (string)
	{
		buf = buf_cat(buf, serialize_string(name_));
	}
	//parse argument color (int)
	{
		buf = buf_cat(buf, buf_add_ui32(color_));
	}
	return buf;
}

buf_t tl_attachMenuBotIcon(const char * name_, Document *icon_, AttachMenuBotIconColor *colors_, int colors_len)
{
	buf_t buf = buf_add_ui32(0xb2a7386b);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument name (string)
	{
		buf = buf_cat(buf, serialize_string(name_));
	}
	//parse argument icon (Document)
	{
		buf = buf_cat(buf, *icon_);
	}
	//parse argument colors (Vector<AttachMenuBotIconColor>)
	if (colors_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(colors_len));
		int i;
		for (i=0; i<colors_len; ++i){
			buf = buf_cat(buf, colors_[i]);
		}
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_attachMenuBot(bool inactive_, bool has_settings_, bool request_write_access_, bool show_in_attach_menu_, bool show_in_side_menu_, bool side_menu_disclaimer_needed_, long bot_id_, const char * short_name_, AttachMenuPeerType *peer_types_, int peer_types_len, AttachMenuBotIcon *icons_, int icons_len)
{
	buf_t buf = buf_add_ui32(0xd90d8dfe);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument inactive (true)
	if (inactive_)
		*flag1 |= (1 << 0);
	//parse argument has_settings (true)
	if (has_settings_)
		*flag1 |= (1 << 1);
	//parse argument request_write_access (true)
	if (request_write_access_)
		*flag1 |= (1 << 2);
	//parse argument show_in_attach_menu (true)
	if (show_in_attach_menu_)
		*flag1 |= (1 << 3);
	//parse argument show_in_side_menu (true)
	if (show_in_side_menu_)
		*flag1 |= (1 << 4);
	//parse argument side_menu_disclaimer_needed (true)
	if (side_menu_disclaimer_needed_)
		*flag1 |= (1 << 5);
	//parse argument bot_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(bot_id_));
	}
	//parse argument short_name (string)
	{
		buf = buf_cat(buf, serialize_string(short_name_));
	}
	//parse argument peer_types (Vector<AttachMenuPeerType>)
	if (peer_types_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(peer_types_len));
		int i;
		for (i=0; i<peer_types_len; ++i){
			buf = buf_cat(buf, peer_types_[i]);
		}
		*flag1 |= (1 << 3);
	}
	//parse argument icons (Vector<AttachMenuBotIcon>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(icons_len));
		int i;
		for (i=0; i<icons_len; ++i){
			buf = buf_cat(buf, icons_[i]);
		}
	}
	return buf;
}

buf_t tl_attachMenuBotsNotModified()
{
	buf_t buf = buf_add_ui32(0xf1d88a5c);
	return buf;
}

buf_t tl_attachMenuBots(long hash_, AttachMenuBot *bots_, int bots_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x3c4301c0);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	//parse argument bots (Vector<AttachMenuBot>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(bots_len));
		int i;
		for (i=0; i<bots_len; ++i){
			buf = buf_cat(buf, bots_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_attachMenuBotsBot(AttachMenuBot *bot_, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x93bf667f);
	//parse argument bot (AttachMenuBot)
	{
		buf = buf_cat(buf, *bot_);
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_webViewResultUrl(bool fullsize_, long query_id_, const char * url_)
{
	buf_t buf = buf_add_ui32(0x4d22ff98);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument fullsize (true)
	if (fullsize_)
		*flag1 |= (1 << 1);
	//parse argument query_id (long)
	if (query_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(query_id_));
		*flag1 |= (1 << 0);
	}
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	return buf;
}

buf_t tl_webViewMessageSent(InputBotInlineMessageID *msg_id_)
{
	buf_t buf = buf_add_ui32(0x0c94511c);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument msg_id (InputBotInlineMessageID)
	if (msg_id_)
	{
		buf = buf_cat(buf, *msg_id_);
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_botMenuButtonDefault()
{
	buf_t buf = buf_add_ui32(0x7533a588);
	return buf;
}

buf_t tl_botMenuButtonCommands()
{
	buf_t buf = buf_add_ui32(0x4258c205);
	return buf;
}

buf_t tl_botMenuButton(const char * text_, const char * url_)
{
	buf_t buf = buf_add_ui32(0xc7b57ce6);
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	return buf;
}

buf_t tl_account_savedRingtonesNotModified()
{
	buf_t buf = buf_add_ui32(0xfbf6e8b1);
	return buf;
}

buf_t tl_account_savedRingtones(long hash_, Document *ringtones_, int ringtones_len)
{
	buf_t buf = buf_add_ui32(0xc1e92cc5);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	//parse argument ringtones (Vector<Document>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(ringtones_len));
		int i;
		for (i=0; i<ringtones_len; ++i){
			buf = buf_cat(buf, ringtones_[i]);
		}
	}
	return buf;
}

buf_t tl_notificationSoundDefault()
{
	buf_t buf = buf_add_ui32(0x97e8bebe);
	return buf;
}

buf_t tl_notificationSoundNone()
{
	buf_t buf = buf_add_ui32(0x6f0c34df);
	return buf;
}

buf_t tl_notificationSoundLocal(const char * title_, const char * data_)
{
	buf_t buf = buf_add_ui32(0x830b9ae4);
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument data (string)
	{
		buf = buf_cat(buf, serialize_string(data_));
	}
	return buf;
}

buf_t tl_notificationSoundRingtone(long id_)
{
	buf_t buf = buf_add_ui32(0xff6c8049);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	return buf;
}

buf_t tl_account_savedRingtone()
{
	buf_t buf = buf_add_ui32(0xb7263f6d);
	return buf;
}

buf_t tl_account_savedRingtoneConverted(Document *document_)
{
	buf_t buf = buf_add_ui32(0x1f307eb7);
	//parse argument document (Document)
	{
		buf = buf_cat(buf, *document_);
	}
	return buf;
}

buf_t tl_attachMenuPeerTypeSameBotPM()
{
	buf_t buf = buf_add_ui32(0x7d6be90e);
	return buf;
}

buf_t tl_attachMenuPeerTypeBotPM()
{
	buf_t buf = buf_add_ui32(0xc32bfa1a);
	return buf;
}

buf_t tl_attachMenuPeerTypePM()
{
	buf_t buf = buf_add_ui32(0xf146d31f);
	return buf;
}

buf_t tl_attachMenuPeerTypeChat()
{
	buf_t buf = buf_add_ui32(0x0509113f);
	return buf;
}

buf_t tl_attachMenuPeerTypeBroadcast()
{
	buf_t buf = buf_add_ui32(0x7bfbdefc);
	return buf;
}

buf_t tl_inputInvoiceMessage(InputPeer *peer_, int msg_id_)
{
	buf_t buf = buf_add_ui32(0xc5b56859);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	return buf;
}

buf_t tl_inputInvoiceSlug(const char * slug_)
{
	buf_t buf = buf_add_ui32(0xc326caef);
	//parse argument slug (string)
	{
		buf = buf_cat(buf, serialize_string(slug_));
	}
	return buf;
}

buf_t tl_inputInvoicePremiumGiftCode(InputStorePaymentPurpose *purpose_, PremiumGiftCodeOption *option_)
{
	buf_t buf = buf_add_ui32(0x98986c0d);
	//parse argument purpose (InputStorePaymentPurpose)
	{
		buf = buf_cat(buf, *purpose_);
	}
	//parse argument option (PremiumGiftCodeOption)
	{
		buf = buf_cat(buf, *option_);
	}
	return buf;
}

buf_t tl_inputInvoiceStars(InputStorePaymentPurpose *purpose_)
{
	buf_t buf = buf_add_ui32(0x65f00ce3);
	//parse argument purpose (InputStorePaymentPurpose)
	{
		buf = buf_cat(buf, *purpose_);
	}
	return buf;
}

buf_t tl_inputInvoiceChatInviteSubscription(const char * hash_)
{
	buf_t buf = buf_add_ui32(0x34e793f1);
	//parse argument hash (string)
	{
		buf = buf_cat(buf, serialize_string(hash_));
	}
	return buf;
}

buf_t tl_inputInvoiceStarGift(bool hide_name_, InputUser *user_id_, long gift_id_, TextWithEntities *message_)
{
	buf_t buf = buf_add_ui32(0x25d8c1d8);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument hide_name (true)
	if (hide_name_)
		*flag1 |= (1 << 0);
	//parse argument user_id (InputUser)
	{
		buf = buf_cat(buf, *user_id_);
	}
	//parse argument gift_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(gift_id_));
	}
	//parse argument message (TextWithEntities)
	if (message_)
	{
		buf = buf_cat(buf, *message_);
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_payments_exportedInvoice(const char * url_)
{
	buf_t buf = buf_add_ui32(0xaed0cbd9);
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	return buf;
}

buf_t tl_messages_transcribedAudio(bool pending_, long transcription_id_, const char * text_, int trial_remains_num_, int trial_remains_until_date_)
{
	buf_t buf = buf_add_ui32(0xcfb9d957);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument pending (true)
	if (pending_)
		*flag1 |= (1 << 0);
	//parse argument transcription_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(transcription_id_));
	}
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	//parse argument trial_remains_num (int)
	if (trial_remains_num_)
	{
		buf = buf_cat(buf, buf_add_ui32(trial_remains_num_));
		*flag1 |= (1 << 1);
	}
	//parse argument trial_remains_until_date (int)
	if (trial_remains_until_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(trial_remains_until_date_));
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_help_premiumPromo(const char * status_text_, MessageEntity *status_entities_, int status_entities_len, const char * *video_sections_, int video_sections_len, Document *videos_, int videos_len, PremiumSubscriptionOption *period_options_, int period_options_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x5334759c);
	//parse argument status_text (string)
	{
		buf = buf_cat(buf, serialize_string(status_text_));
	}
	//parse argument status_entities (Vector<MessageEntity>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(status_entities_len));
		int i;
		for (i=0; i<status_entities_len; ++i){
			buf = buf_cat(buf, status_entities_[i]);
		}
	}
	//parse argument video_sections (Vector<string>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(video_sections_len));
		int i;
		for (i=0; i<video_sections_len; ++i){
			buf = buf_cat(buf, serialize_string(video_sections_[i]));
		}
	}
	//parse argument videos (Vector<Document>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(videos_len));
		int i;
		for (i=0; i<videos_len; ++i){
			buf = buf_cat(buf, videos_[i]);
		}
	}
	//parse argument period_options (Vector<PremiumSubscriptionOption>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(period_options_len));
		int i;
		for (i=0; i<period_options_len; ++i){
			buf = buf_cat(buf, period_options_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_inputStorePaymentPremiumSubscription(bool restore_, bool upgrade_)
{
	buf_t buf = buf_add_ui32(0xa6751e66);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument restore (true)
	if (restore_)
		*flag1 |= (1 << 0);
	//parse argument upgrade (true)
	if (upgrade_)
		*flag1 |= (1 << 1);
	return buf;
}

buf_t tl_inputStorePaymentGiftPremium(InputUser *user_id_, const char * currency_, long amount_)
{
	buf_t buf = buf_add_ui32(0x616f7fe8);
	//parse argument user_id (InputUser)
	{
		buf = buf_cat(buf, *user_id_);
	}
	//parse argument currency (string)
	{
		buf = buf_cat(buf, serialize_string(currency_));
	}
	//parse argument amount (long)
	{
		buf = buf_cat(buf, buf_add_ui64(amount_));
	}
	return buf;
}

buf_t tl_inputStorePaymentPremiumGiftCode(InputUser *users_, int users_len, InputPeer *boost_peer_, const char * currency_, long amount_)
{
	buf_t buf = buf_add_ui32(0xa3805f3f);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument users (Vector<InputUser>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	//parse argument boost_peer (InputPeer)
	if (boost_peer_)
	{
		buf = buf_cat(buf, *boost_peer_);
		*flag1 |= (1 << 0);
	}
	//parse argument currency (string)
	{
		buf = buf_cat(buf, serialize_string(currency_));
	}
	//parse argument amount (long)
	{
		buf = buf_cat(buf, buf_add_ui64(amount_));
	}
	return buf;
}

buf_t tl_inputStorePaymentPremiumGiveaway(bool only_new_subscribers_, bool winners_are_visible_, InputPeer *boost_peer_, InputPeer *additional_peers_, int additional_peers_len, const char * *countries_iso2_, int countries_iso2_len, const char * prize_description_, long random_id_, int until_date_, const char * currency_, long amount_)
{
	buf_t buf = buf_add_ui32(0x160544ca);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument only_new_subscribers (true)
	if (only_new_subscribers_)
		*flag1 |= (1 << 0);
	//parse argument winners_are_visible (true)
	if (winners_are_visible_)
		*flag1 |= (1 << 3);
	//parse argument boost_peer (InputPeer)
	{
		buf = buf_cat(buf, *boost_peer_);
	}
	//parse argument additional_peers (Vector<InputPeer>)
	if (additional_peers_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(additional_peers_len));
		int i;
		for (i=0; i<additional_peers_len; ++i){
			buf = buf_cat(buf, additional_peers_[i]);
		}
		*flag1 |= (1 << 1);
	}
	//parse argument countries_iso2 (Vector<string>)
	if (countries_iso2_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(countries_iso2_len));
		int i;
		for (i=0; i<countries_iso2_len; ++i){
			buf = buf_cat(buf, serialize_string(countries_iso2_[i]));
		}
		*flag1 |= (1 << 2);
	}
	//parse argument prize_description (string)
	if (prize_description_)
	{
		buf = buf_cat(buf, serialize_string(prize_description_));
		*flag1 |= (1 << 4);
	}
	//parse argument random_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(random_id_));
	}
	//parse argument until_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(until_date_));
	}
	//parse argument currency (string)
	{
		buf = buf_cat(buf, serialize_string(currency_));
	}
	//parse argument amount (long)
	{
		buf = buf_cat(buf, buf_add_ui64(amount_));
	}
	return buf;
}

buf_t tl_inputStorePaymentStarsTopup(long stars_, const char * currency_, long amount_)
{
	buf_t buf = buf_add_ui32(0xdddd0f56);
	//parse argument stars (long)
	{
		buf = buf_cat(buf, buf_add_ui64(stars_));
	}
	//parse argument currency (string)
	{
		buf = buf_cat(buf, serialize_string(currency_));
	}
	//parse argument amount (long)
	{
		buf = buf_cat(buf, buf_add_ui64(amount_));
	}
	return buf;
}

buf_t tl_inputStorePaymentStarsGift(InputUser *user_id_, long stars_, const char * currency_, long amount_)
{
	buf_t buf = buf_add_ui32(0x1d741ef7);
	//parse argument user_id (InputUser)
	{
		buf = buf_cat(buf, *user_id_);
	}
	//parse argument stars (long)
	{
		buf = buf_cat(buf, buf_add_ui64(stars_));
	}
	//parse argument currency (string)
	{
		buf = buf_cat(buf, serialize_string(currency_));
	}
	//parse argument amount (long)
	{
		buf = buf_cat(buf, buf_add_ui64(amount_));
	}
	return buf;
}

buf_t tl_inputStorePaymentStarsGiveaway(bool only_new_subscribers_, bool winners_are_visible_, long stars_, InputPeer *boost_peer_, InputPeer *additional_peers_, int additional_peers_len, const char * *countries_iso2_, int countries_iso2_len, const char * prize_description_, long random_id_, int until_date_, const char * currency_, long amount_, int users_)
{
	buf_t buf = buf_add_ui32(0x751f08fa);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument only_new_subscribers (true)
	if (only_new_subscribers_)
		*flag1 |= (1 << 0);
	//parse argument winners_are_visible (true)
	if (winners_are_visible_)
		*flag1 |= (1 << 3);
	//parse argument stars (long)
	{
		buf = buf_cat(buf, buf_add_ui64(stars_));
	}
	//parse argument boost_peer (InputPeer)
	{
		buf = buf_cat(buf, *boost_peer_);
	}
	//parse argument additional_peers (Vector<InputPeer>)
	if (additional_peers_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(additional_peers_len));
		int i;
		for (i=0; i<additional_peers_len; ++i){
			buf = buf_cat(buf, additional_peers_[i]);
		}
		*flag1 |= (1 << 1);
	}
	//parse argument countries_iso2 (Vector<string>)
	if (countries_iso2_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(countries_iso2_len));
		int i;
		for (i=0; i<countries_iso2_len; ++i){
			buf = buf_cat(buf, serialize_string(countries_iso2_[i]));
		}
		*flag1 |= (1 << 2);
	}
	//parse argument prize_description (string)
	if (prize_description_)
	{
		buf = buf_cat(buf, serialize_string(prize_description_));
		*flag1 |= (1 << 4);
	}
	//parse argument random_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(random_id_));
	}
	//parse argument until_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(until_date_));
	}
	//parse argument currency (string)
	{
		buf = buf_cat(buf, serialize_string(currency_));
	}
	//parse argument amount (long)
	{
		buf = buf_cat(buf, buf_add_ui64(amount_));
	}
	//parse argument users (int)
	{
		buf = buf_cat(buf, buf_add_ui32(users_));
	}
	return buf;
}

buf_t tl_premiumGiftOption(int months_, const char * currency_, long amount_, const char * bot_url_, const char * store_product_)
{
	buf_t buf = buf_add_ui32(0x74c34319);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument months (int)
	{
		buf = buf_cat(buf, buf_add_ui32(months_));
	}
	//parse argument currency (string)
	{
		buf = buf_cat(buf, serialize_string(currency_));
	}
	//parse argument amount (long)
	{
		buf = buf_cat(buf, buf_add_ui64(amount_));
	}
	//parse argument bot_url (string)
	{
		buf = buf_cat(buf, serialize_string(bot_url_));
	}
	//parse argument store_product (string)
	if (store_product_)
	{
		buf = buf_cat(buf, serialize_string(store_product_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_paymentFormMethod(const char * url_, const char * title_)
{
	buf_t buf = buf_add_ui32(0x88f8f21b);
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	return buf;
}

buf_t tl_emojiStatusEmpty()
{
	buf_t buf = buf_add_ui32(0x2de11aae);
	return buf;
}

buf_t tl_emojiStatus(long document_id_)
{
	buf_t buf = buf_add_ui32(0x929b619d);
	//parse argument document_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(document_id_));
	}
	return buf;
}

buf_t tl_emojiStatusUntil(long document_id_, int until_)
{
	buf_t buf = buf_add_ui32(0xfa30a8c7);
	//parse argument document_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(document_id_));
	}
	//parse argument until (int)
	{
		buf = buf_cat(buf, buf_add_ui32(until_));
	}
	return buf;
}

buf_t tl_account_emojiStatusesNotModified()
{
	buf_t buf = buf_add_ui32(0xd08ce645);
	return buf;
}

buf_t tl_account_emojiStatuses(long hash_, EmojiStatus *statuses_, int statuses_len)
{
	buf_t buf = buf_add_ui32(0x90c467d1);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	//parse argument statuses (Vector<EmojiStatus>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(statuses_len));
		int i;
		for (i=0; i<statuses_len; ++i){
			buf = buf_cat(buf, statuses_[i]);
		}
	}
	return buf;
}

buf_t tl_reactionEmpty()
{
	buf_t buf = buf_add_ui32(0x79f5d419);
	return buf;
}

buf_t tl_reactionEmoji(const char * emoticon_)
{
	buf_t buf = buf_add_ui32(0x1b2286b8);
	//parse argument emoticon (string)
	{
		buf = buf_cat(buf, serialize_string(emoticon_));
	}
	return buf;
}

buf_t tl_reactionCustomEmoji(long document_id_)
{
	buf_t buf = buf_add_ui32(0x8935fc73);
	//parse argument document_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(document_id_));
	}
	return buf;
}

buf_t tl_reactionPaid()
{
	buf_t buf = buf_add_ui32(0x523da4eb);
	return buf;
}

buf_t tl_chatReactionsNone()
{
	buf_t buf = buf_add_ui32(0xeafc32bc);
	return buf;
}

buf_t tl_chatReactionsAll(bool allow_custom_)
{
	buf_t buf = buf_add_ui32(0x52928bca);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument allow_custom (true)
	if (allow_custom_)
		*flag1 |= (1 << 0);
	return buf;
}

buf_t tl_chatReactionsSome(Reaction *reactions_, int reactions_len)
{
	buf_t buf = buf_add_ui32(0x661d4037);
	//parse argument reactions (Vector<Reaction>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(reactions_len));
		int i;
		for (i=0; i<reactions_len; ++i){
			buf = buf_cat(buf, reactions_[i]);
		}
	}
	return buf;
}

buf_t tl_messages_reactionsNotModified()
{
	buf_t buf = buf_add_ui32(0xb06fdbdf);
	return buf;
}

buf_t tl_messages_reactions(long hash_, Reaction *reactions_, int reactions_len)
{
	buf_t buf = buf_add_ui32(0xeafdf716);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	//parse argument reactions (Vector<Reaction>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(reactions_len));
		int i;
		for (i=0; i<reactions_len; ++i){
			buf = buf_cat(buf, reactions_[i]);
		}
	}
	return buf;
}

buf_t tl_emailVerifyPurposeLoginSetup(const char * phone_number_, const char * phone_code_hash_)
{
	buf_t buf = buf_add_ui32(0x4345be73);
	//parse argument phone_number (string)
	{
		buf = buf_cat(buf, serialize_string(phone_number_));
	}
	//parse argument phone_code_hash (string)
	{
		buf = buf_cat(buf, serialize_string(phone_code_hash_));
	}
	return buf;
}

buf_t tl_emailVerifyPurposeLoginChange()
{
	buf_t buf = buf_add_ui32(0x527d22eb);
	return buf;
}

buf_t tl_emailVerifyPurposePassport()
{
	buf_t buf = buf_add_ui32(0xbbf51685);
	return buf;
}

buf_t tl_emailVerificationCode(const char * code_)
{
	buf_t buf = buf_add_ui32(0x922e55a9);
	//parse argument code (string)
	{
		buf = buf_cat(buf, serialize_string(code_));
	}
	return buf;
}

buf_t tl_emailVerificationGoogle(const char * token_)
{
	buf_t buf = buf_add_ui32(0xdb909ec2);
	//parse argument token (string)
	{
		buf = buf_cat(buf, serialize_string(token_));
	}
	return buf;
}

buf_t tl_emailVerificationApple(const char * token_)
{
	buf_t buf = buf_add_ui32(0x96d074fd);
	//parse argument token (string)
	{
		buf = buf_cat(buf, serialize_string(token_));
	}
	return buf;
}

buf_t tl_account_emailVerified(const char * email_)
{
	buf_t buf = buf_add_ui32(0x2b96cd1b);
	//parse argument email (string)
	{
		buf = buf_cat(buf, serialize_string(email_));
	}
	return buf;
}

buf_t tl_account_emailVerifiedLogin(const char * email_, auth_SentCode *sent_code_)
{
	buf_t buf = buf_add_ui32(0xe1bb0d61);
	//parse argument email (string)
	{
		buf = buf_cat(buf, serialize_string(email_));
	}
	//parse argument sent_code (auth_SentCode)
	{
		buf = buf_cat(buf, *sent_code_);
	}
	return buf;
}

buf_t tl_premiumSubscriptionOption(bool current_, bool can_purchase_upgrade_, const char * transaction_, int months_, const char * currency_, long amount_, const char * bot_url_, const char * store_product_)
{
	buf_t buf = buf_add_ui32(0x5f2d1df2);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument current (true)
	if (current_)
		*flag1 |= (1 << 1);
	//parse argument can_purchase_upgrade (true)
	if (can_purchase_upgrade_)
		*flag1 |= (1 << 2);
	//parse argument transaction (string)
	if (transaction_)
	{
		buf = buf_cat(buf, serialize_string(transaction_));
		*flag1 |= (1 << 3);
	}
	//parse argument months (int)
	{
		buf = buf_cat(buf, buf_add_ui32(months_));
	}
	//parse argument currency (string)
	{
		buf = buf_cat(buf, serialize_string(currency_));
	}
	//parse argument amount (long)
	{
		buf = buf_cat(buf, buf_add_ui64(amount_));
	}
	//parse argument bot_url (string)
	{
		buf = buf_cat(buf, serialize_string(bot_url_));
	}
	//parse argument store_product (string)
	if (store_product_)
	{
		buf = buf_cat(buf, serialize_string(store_product_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_sendAsPeer(bool premium_required_, Peer *peer_)
{
	buf_t buf = buf_add_ui32(0xb81c7034);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument premium_required (true)
	if (premium_required_)
		*flag1 |= (1 << 0);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_messageExtendedMediaPreview(int w_, int h_, PhotoSize *thumb_, int video_duration_)
{
	buf_t buf = buf_add_ui32(0xad628cc8);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument w (int)
	if (w_)
	{
		buf = buf_cat(buf, buf_add_ui32(w_));
		*flag1 |= (1 << 0);
	}
	//parse argument h (int)
	if (h_)
	{
		buf = buf_cat(buf, buf_add_ui32(h_));
		*flag1 |= (1 << 0);
	}
	//parse argument thumb (PhotoSize)
	if (thumb_)
	{
		buf = buf_cat(buf, *thumb_);
		*flag1 |= (1 << 1);
	}
	//parse argument video_duration (int)
	if (video_duration_)
	{
		buf = buf_cat(buf, buf_add_ui32(video_duration_));
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_messageExtendedMedia(MessageMedia *media_)
{
	buf_t buf = buf_add_ui32(0xee479c64);
	//parse argument media (MessageMedia)
	{
		buf = buf_cat(buf, *media_);
	}
	return buf;
}

buf_t tl_stickerKeyword(long document_id_, const char * *keyword_, int keyword_len)
{
	buf_t buf = buf_add_ui32(0xfcfeb29c);
	//parse argument document_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(document_id_));
	}
	//parse argument keyword (Vector<string>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(keyword_len));
		int i;
		for (i=0; i<keyword_len; ++i){
			buf = buf_cat(buf, serialize_string(keyword_[i]));
		}
	}
	return buf;
}

buf_t tl_username(bool editable_, bool active_, const char * username_)
{
	buf_t buf = buf_add_ui32(0xb4073647);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument editable (true)
	if (editable_)
		*flag1 |= (1 << 0);
	//parse argument active (true)
	if (active_)
		*flag1 |= (1 << 1);
	//parse argument username (string)
	{
		buf = buf_cat(buf, serialize_string(username_));
	}
	return buf;
}

buf_t tl_forumTopicDeleted(int id_)
{
	buf_t buf = buf_add_ui32(0x023f109b);
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	return buf;
}

buf_t tl_forumTopic(bool my_, bool closed_, bool pinned_, bool short_, bool hidden_, int id_, int date_, const char * title_, int icon_color_, long icon_emoji_id_, int top_message_, int read_inbox_max_id_, int read_outbox_max_id_, int unread_count_, int unread_mentions_count_, int unread_reactions_count_, Peer *from_id_, PeerNotifySettings *notify_settings_, DraftMessage *draft_)
{
	buf_t buf = buf_add_ui32(0x71701da9);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument my (true)
	if (my_)
		*flag1 |= (1 << 1);
	//parse argument closed (true)
	if (closed_)
		*flag1 |= (1 << 2);
	//parse argument pinned (true)
	if (pinned_)
		*flag1 |= (1 << 3);
	//parse argument short (true)
	if (short_)
		*flag1 |= (1 << 5);
	//parse argument hidden (true)
	if (hidden_)
		*flag1 |= (1 << 6);
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument icon_color (int)
	{
		buf = buf_cat(buf, buf_add_ui32(icon_color_));
	}
	//parse argument icon_emoji_id (long)
	if (icon_emoji_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(icon_emoji_id_));
		*flag1 |= (1 << 0);
	}
	//parse argument top_message (int)
	{
		buf = buf_cat(buf, buf_add_ui32(top_message_));
	}
	//parse argument read_inbox_max_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(read_inbox_max_id_));
	}
	//parse argument read_outbox_max_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(read_outbox_max_id_));
	}
	//parse argument unread_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(unread_count_));
	}
	//parse argument unread_mentions_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(unread_mentions_count_));
	}
	//parse argument unread_reactions_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(unread_reactions_count_));
	}
	//parse argument from_id (Peer)
	{
		buf = buf_cat(buf, *from_id_);
	}
	//parse argument notify_settings (PeerNotifySettings)
	{
		buf = buf_cat(buf, *notify_settings_);
	}
	//parse argument draft (DraftMessage)
	if (draft_)
	{
		buf = buf_cat(buf, *draft_);
		*flag1 |= (1 << 4);
	}
	return buf;
}

buf_t tl_messages_forumTopics(bool order_by_create_date_, int count_, ForumTopic *topics_, int topics_len, Message *messages_, int messages_len, Chat *chats_, int chats_len, User *users_, int users_len, int pts_)
{
	buf_t buf = buf_add_ui32(0x367617d3);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument order_by_create_date (true)
	if (order_by_create_date_)
		*flag1 |= (1 << 0);
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	//parse argument topics (Vector<ForumTopic>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(topics_len));
		int i;
		for (i=0; i<topics_len; ++i){
			buf = buf_cat(buf, topics_[i]);
		}
	}
	//parse argument messages (Vector<Message>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(messages_len));
		int i;
		for (i=0; i<messages_len; ++i){
			buf = buf_cat(buf, messages_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	//parse argument pts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_));
	}
	return buf;
}

buf_t tl_defaultHistoryTTL(int period_)
{
	buf_t buf = buf_add_ui32(0x43b46b20);
	//parse argument period (int)
	{
		buf = buf_cat(buf, buf_add_ui32(period_));
	}
	return buf;
}

buf_t tl_exportedContactToken(const char * url_, int expires_)
{
	buf_t buf = buf_add_ui32(0x41bf109b);
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	//parse argument expires (int)
	{
		buf = buf_cat(buf, buf_add_ui32(expires_));
	}
	return buf;
}

buf_t tl_requestPeerTypeUser(Bool *bot_, Bool *premium_)
{
	buf_t buf = buf_add_ui32(0x5f3b8a00);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument bot (Bool)
	if (bot_)
	{
		buf = buf_cat(buf, *bot_);
		*flag1 |= (1 << 0);
	}
	//parse argument premium (Bool)
	if (premium_)
	{
		buf = buf_cat(buf, *premium_);
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_requestPeerTypeChat(bool creator_, bool bot_participant_, Bool *has_username_, Bool *forum_, ChatAdminRights *user_admin_rights_, ChatAdminRights *bot_admin_rights_)
{
	buf_t buf = buf_add_ui32(0xc9f06e1b);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument creator (true)
	if (creator_)
		*flag1 |= (1 << 0);
	//parse argument bot_participant (true)
	if (bot_participant_)
		*flag1 |= (1 << 5);
	//parse argument has_username (Bool)
	if (has_username_)
	{
		buf = buf_cat(buf, *has_username_);
		*flag1 |= (1 << 3);
	}
	//parse argument forum (Bool)
	if (forum_)
	{
		buf = buf_cat(buf, *forum_);
		*flag1 |= (1 << 4);
	}
	//parse argument user_admin_rights (ChatAdminRights)
	if (user_admin_rights_)
	{
		buf = buf_cat(buf, *user_admin_rights_);
		*flag1 |= (1 << 1);
	}
	//parse argument bot_admin_rights (ChatAdminRights)
	if (bot_admin_rights_)
	{
		buf = buf_cat(buf, *bot_admin_rights_);
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_requestPeerTypeBroadcast(bool creator_, Bool *has_username_, ChatAdminRights *user_admin_rights_, ChatAdminRights *bot_admin_rights_)
{
	buf_t buf = buf_add_ui32(0x339bef6c);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument creator (true)
	if (creator_)
		*flag1 |= (1 << 0);
	//parse argument has_username (Bool)
	if (has_username_)
	{
		buf = buf_cat(buf, *has_username_);
		*flag1 |= (1 << 3);
	}
	//parse argument user_admin_rights (ChatAdminRights)
	if (user_admin_rights_)
	{
		buf = buf_cat(buf, *user_admin_rights_);
		*flag1 |= (1 << 1);
	}
	//parse argument bot_admin_rights (ChatAdminRights)
	if (bot_admin_rights_)
	{
		buf = buf_cat(buf, *bot_admin_rights_);
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_emojiListNotModified()
{
	buf_t buf = buf_add_ui32(0x481eadfa);
	return buf;
}

buf_t tl_emojiList(long hash_, long *document_id_, int document_id_len)
{
	buf_t buf = buf_add_ui32(0x7a1e11d1);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	//parse argument document_id (Vector<long>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(document_id_len));
		int i;
		for (i=0; i<document_id_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(document_id_[i]));
		}
	}
	return buf;
}

buf_t tl_emojiGroup(const char * title_, long icon_emoji_id_, const char * *emoticons_, int emoticons_len)
{
	buf_t buf = buf_add_ui32(0x7a9abda9);
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument icon_emoji_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(icon_emoji_id_));
	}
	//parse argument emoticons (Vector<string>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(emoticons_len));
		int i;
		for (i=0; i<emoticons_len; ++i){
			buf = buf_cat(buf, serialize_string(emoticons_[i]));
		}
	}
	return buf;
}

buf_t tl_emojiGroupGreeting(const char * title_, long icon_emoji_id_, const char * *emoticons_, int emoticons_len)
{
	buf_t buf = buf_add_ui32(0x80d26cc7);
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument icon_emoji_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(icon_emoji_id_));
	}
	//parse argument emoticons (Vector<string>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(emoticons_len));
		int i;
		for (i=0; i<emoticons_len; ++i){
			buf = buf_cat(buf, serialize_string(emoticons_[i]));
		}
	}
	return buf;
}

buf_t tl_emojiGroupPremium(const char * title_, long icon_emoji_id_)
{
	buf_t buf = buf_add_ui32(0x093bcf34);
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument icon_emoji_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(icon_emoji_id_));
	}
	return buf;
}

buf_t tl_messages_emojiGroupsNotModified()
{
	buf_t buf = buf_add_ui32(0x6fb4ad87);
	return buf;
}

buf_t tl_messages_emojiGroups(int hash_, EmojiGroup *groups_, int groups_len)
{
	buf_t buf = buf_add_ui32(0x881fb94b);
	//parse argument hash (int)
	{
		buf = buf_cat(buf, buf_add_ui32(hash_));
	}
	//parse argument groups (Vector<EmojiGroup>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(groups_len));
		int i;
		for (i=0; i<groups_len; ++i){
			buf = buf_cat(buf, groups_[i]);
		}
	}
	return buf;
}

buf_t tl_textWithEntities(const char * text_, MessageEntity *entities_, int entities_len)
{
	buf_t buf = buf_add_ui32(0x751f3146);
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	//parse argument entities (Vector<MessageEntity>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(entities_len));
		int i;
		for (i=0; i<entities_len; ++i){
			buf = buf_cat(buf, entities_[i]);
		}
	}
	return buf;
}

buf_t tl_messages_translateResult(TextWithEntities *result_, int result_len)
{
	buf_t buf = buf_add_ui32(0x33db32f8);
	//parse argument result (Vector<TextWithEntities>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(result_len));
		int i;
		for (i=0; i<result_len; ++i){
			buf = buf_cat(buf, result_[i]);
		}
	}
	return buf;
}

buf_t tl_autoSaveSettings(bool photos_, bool videos_, long video_max_size_)
{
	buf_t buf = buf_add_ui32(0xc84834ce);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument photos (true)
	if (photos_)
		*flag1 |= (1 << 0);
	//parse argument videos (true)
	if (videos_)
		*flag1 |= (1 << 1);
	//parse argument video_max_size (long)
	if (video_max_size_)
	{
		buf = buf_cat(buf, buf_add_ui64(video_max_size_));
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_autoSaveException(Peer *peer_, AutoSaveSettings *settings_)
{
	buf_t buf = buf_add_ui32(0x81602d47);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument settings (AutoSaveSettings)
	{
		buf = buf_cat(buf, *settings_);
	}
	return buf;
}

buf_t tl_account_autoSaveSettings(AutoSaveSettings *users_settings_, AutoSaveSettings *chats_settings_, AutoSaveSettings *broadcasts_settings_, AutoSaveException *exceptions_, int exceptions_len, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x4c3e069d);
	//parse argument users_settings (AutoSaveSettings)
	{
		buf = buf_cat(buf, *users_settings_);
	}
	//parse argument chats_settings (AutoSaveSettings)
	{
		buf = buf_cat(buf, *chats_settings_);
	}
	//parse argument broadcasts_settings (AutoSaveSettings)
	{
		buf = buf_cat(buf, *broadcasts_settings_);
	}
	//parse argument exceptions (Vector<AutoSaveException>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(exceptions_len));
		int i;
		for (i=0; i<exceptions_len; ++i){
			buf = buf_cat(buf, exceptions_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_help_appConfigNotModified()
{
	buf_t buf = buf_add_ui32(0x7cde641d);
	return buf;
}

buf_t tl_help_appConfig(int hash_, JSONValue *config_)
{
	buf_t buf = buf_add_ui32(0xdd18782e);
	//parse argument hash (int)
	{
		buf = buf_cat(buf, buf_add_ui32(hash_));
	}
	//parse argument config (JSONValue)
	{
		buf = buf_cat(buf, *config_);
	}
	return buf;
}

buf_t tl_inputBotAppID(long id_, long access_hash_)
{
	buf_t buf = buf_add_ui32(0xa920bd7a);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	return buf;
}

buf_t tl_inputBotAppShortName(InputUser *bot_id_, const char * short_name_)
{
	buf_t buf = buf_add_ui32(0x908c0407);
	//parse argument bot_id (InputUser)
	{
		buf = buf_cat(buf, *bot_id_);
	}
	//parse argument short_name (string)
	{
		buf = buf_cat(buf, serialize_string(short_name_));
	}
	return buf;
}

buf_t tl_botAppNotModified()
{
	buf_t buf = buf_add_ui32(0x5da674b7);
	return buf;
}

buf_t tl_botApp(long id_, long access_hash_, const char * short_name_, const char * title_, const char * description_, Photo *photo_, Document *document_, long hash_)
{
	buf_t buf = buf_add_ui32(0x95fcd1d6);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument access_hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(access_hash_));
	}
	//parse argument short_name (string)
	{
		buf = buf_cat(buf, serialize_string(short_name_));
	}
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument description (string)
	{
		buf = buf_cat(buf, serialize_string(description_));
	}
	//parse argument photo (Photo)
	{
		buf = buf_cat(buf, *photo_);
	}
	//parse argument document (Document)
	if (document_)
	{
		buf = buf_cat(buf, *document_);
		*flag1 |= (1 << 0);
	}
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_messages_botApp(bool inactive_, bool request_write_access_, bool has_settings_, BotApp *app_)
{
	buf_t buf = buf_add_ui32(0xeb50adf5);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument inactive (true)
	if (inactive_)
		*flag1 |= (1 << 0);
	//parse argument request_write_access (true)
	if (request_write_access_)
		*flag1 |= (1 << 1);
	//parse argument has_settings (true)
	if (has_settings_)
		*flag1 |= (1 << 2);
	//parse argument app (BotApp)
	{
		buf = buf_cat(buf, *app_);
	}
	return buf;
}

buf_t tl_inlineBotWebView(const char * text_, const char * url_)
{
	buf_t buf = buf_add_ui32(0xb57295d5);
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	return buf;
}

buf_t tl_readParticipantDate(long user_id_, int date_)
{
	buf_t buf = buf_add_ui32(0x4a4ff172);
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	return buf;
}

buf_t tl_inputChatlistDialogFilter(int filter_id_)
{
	buf_t buf = buf_add_ui32(0xf3e0da33);
	//parse argument filter_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(filter_id_));
	}
	return buf;
}

buf_t tl_exportedChatlistInvite(const char * title_, const char * url_, Peer *peers_, int peers_len)
{
	buf_t buf = buf_add_ui32(0x0c5181ac);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	//parse argument peers (Vector<Peer>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(peers_len));
		int i;
		for (i=0; i<peers_len; ++i){
			buf = buf_cat(buf, peers_[i]);
		}
	}
	return buf;
}

buf_t tl_chatlists_exportedChatlistInvite(DialogFilter *filter_, ExportedChatlistInvite *invite_)
{
	buf_t buf = buf_add_ui32(0x10e6e3a6);
	//parse argument filter (DialogFilter)
	{
		buf = buf_cat(buf, *filter_);
	}
	//parse argument invite (ExportedChatlistInvite)
	{
		buf = buf_cat(buf, *invite_);
	}
	return buf;
}

buf_t tl_chatlists_exportedInvites(ExportedChatlistInvite *invites_, int invites_len, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x10ab6dc7);
	//parse argument invites (Vector<ExportedChatlistInvite>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(invites_len));
		int i;
		for (i=0; i<invites_len; ++i){
			buf = buf_cat(buf, invites_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_chatlists_chatlistInviteAlready(int filter_id_, Peer *missing_peers_, int missing_peers_len, Peer *already_peers_, int already_peers_len, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0xfa87f659);
	//parse argument filter_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(filter_id_));
	}
	//parse argument missing_peers (Vector<Peer>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(missing_peers_len));
		int i;
		for (i=0; i<missing_peers_len; ++i){
			buf = buf_cat(buf, missing_peers_[i]);
		}
	}
	//parse argument already_peers (Vector<Peer>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(already_peers_len));
		int i;
		for (i=0; i<already_peers_len; ++i){
			buf = buf_cat(buf, already_peers_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_chatlists_chatlistInvite(const char * title_, const char * emoticon_, Peer *peers_, int peers_len, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x1dcd839d);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument emoticon (string)
	if (emoticon_)
	{
		buf = buf_cat(buf, serialize_string(emoticon_));
		*flag1 |= (1 << 0);
	}
	//parse argument peers (Vector<Peer>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(peers_len));
		int i;
		for (i=0; i<peers_len; ++i){
			buf = buf_cat(buf, peers_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_chatlists_chatlistUpdates(Peer *missing_peers_, int missing_peers_len, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x93bd878d);
	//parse argument missing_peers (Vector<Peer>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(missing_peers_len));
		int i;
		for (i=0; i<missing_peers_len; ++i){
			buf = buf_cat(buf, missing_peers_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_bots_botInfo(const char * name_, const char * about_, const char * description_)
{
	buf_t buf = buf_add_ui32(0xe8a775b0);
	//parse argument name (string)
	{
		buf = buf_cat(buf, serialize_string(name_));
	}
	//parse argument about (string)
	{
		buf = buf_cat(buf, serialize_string(about_));
	}
	//parse argument description (string)
	{
		buf = buf_cat(buf, serialize_string(description_));
	}
	return buf;
}

buf_t tl_messagePeerVote(Peer *peer_, buf_t *option_, int date_)
{
	buf_t buf = buf_add_ui32(0xb6cc2d5c);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument option (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(option_->data, option_->size));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	return buf;
}

buf_t tl_messagePeerVoteInputOption(Peer *peer_, int date_)
{
	buf_t buf = buf_add_ui32(0x74cda504);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	return buf;
}

buf_t tl_messagePeerVoteMultiple(Peer *peer_, buf_t *options_, int options_len, int date_)
{
	buf_t buf = buf_add_ui32(0x4628f6e6);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument options (Vector<bytes>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(options_len));
		int i;
		for (i=0; i<options_len; ++i){
			buf = buf_cat(buf, serialize_bytes(options_[i].data, options_[i].size));
		}
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	return buf;
}

buf_t tl_storyViews(bool has_viewers_, int views_count_, int forwards_count_, ReactionCount *reactions_, int reactions_len, int reactions_count_, long *recent_viewers_, int recent_viewers_len)
{
	buf_t buf = buf_add_ui32(0x8d595cd6);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument has_viewers (true)
	if (has_viewers_)
		*flag1 |= (1 << 1);
	//parse argument views_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(views_count_));
	}
	//parse argument forwards_count (int)
	if (forwards_count_)
	{
		buf = buf_cat(buf, buf_add_ui32(forwards_count_));
		*flag1 |= (1 << 2);
	}
	//parse argument reactions (Vector<ReactionCount>)
	if (reactions_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(reactions_len));
		int i;
		for (i=0; i<reactions_len; ++i){
			buf = buf_cat(buf, reactions_[i]);
		}
		*flag1 |= (1 << 3);
	}
	//parse argument reactions_count (int)
	if (reactions_count_)
	{
		buf = buf_cat(buf, buf_add_ui32(reactions_count_));
		*flag1 |= (1 << 4);
	}
	//parse argument recent_viewers (Vector<long>)
	if (recent_viewers_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(recent_viewers_len));
		int i;
		for (i=0; i<recent_viewers_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(recent_viewers_[i]));
		}
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_storyItemDeleted(int id_)
{
	buf_t buf = buf_add_ui32(0x51e6ee4f);
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	return buf;
}

buf_t tl_storyItemSkipped(bool close_friends_, int id_, int date_, int expire_date_)
{
	buf_t buf = buf_add_ui32(0xffadc913);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument close_friends (true)
	if (close_friends_)
		*flag1 |= (1 << 8);
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument expire_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(expire_date_));
	}
	return buf;
}

buf_t tl_storyItem(bool pinned_, bool public_, bool close_friends_, bool min_, bool noforwards_, bool edited_, bool contacts_, bool selected_contacts_, bool out_, int id_, int date_, Peer *from_id_, StoryFwdHeader *fwd_from_, int expire_date_, const char * caption_, MessageEntity *entities_, int entities_len, MessageMedia *media_, MediaArea *media_areas_, int media_areas_len, PrivacyRule *privacy_, int privacy_len, StoryViews *views_, Reaction *sent_reaction_)
{
	buf_t buf = buf_add_ui32(0x79b26a24);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument pinned (true)
	if (pinned_)
		*flag1 |= (1 << 5);
	//parse argument public (true)
	if (public_)
		*flag1 |= (1 << 7);
	//parse argument close_friends (true)
	if (close_friends_)
		*flag1 |= (1 << 8);
	//parse argument min (true)
	if (min_)
		*flag1 |= (1 << 9);
	//parse argument noforwards (true)
	if (noforwards_)
		*flag1 |= (1 << 10);
	//parse argument edited (true)
	if (edited_)
		*flag1 |= (1 << 11);
	//parse argument contacts (true)
	if (contacts_)
		*flag1 |= (1 << 12);
	//parse argument selected_contacts (true)
	if (selected_contacts_)
		*flag1 |= (1 << 13);
	//parse argument out (true)
	if (out_)
		*flag1 |= (1 << 16);
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument from_id (Peer)
	if (from_id_)
	{
		buf = buf_cat(buf, *from_id_);
		*flag1 |= (1 << 18);
	}
	//parse argument fwd_from (StoryFwdHeader)
	if (fwd_from_)
	{
		buf = buf_cat(buf, *fwd_from_);
		*flag1 |= (1 << 17);
	}
	//parse argument expire_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(expire_date_));
	}
	//parse argument caption (string)
	if (caption_)
	{
		buf = buf_cat(buf, serialize_string(caption_));
		*flag1 |= (1 << 0);
	}
	//parse argument entities (Vector<MessageEntity>)
	if (entities_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(entities_len));
		int i;
		for (i=0; i<entities_len; ++i){
			buf = buf_cat(buf, entities_[i]);
		}
		*flag1 |= (1 << 1);
	}
	//parse argument media (MessageMedia)
	{
		buf = buf_cat(buf, *media_);
	}
	//parse argument media_areas (Vector<MediaArea>)
	if (media_areas_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(media_areas_len));
		int i;
		for (i=0; i<media_areas_len; ++i){
			buf = buf_cat(buf, media_areas_[i]);
		}
		*flag1 |= (1 << 14);
	}
	//parse argument privacy (Vector<PrivacyRule>)
	if (privacy_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(privacy_len));
		int i;
		for (i=0; i<privacy_len; ++i){
			buf = buf_cat(buf, privacy_[i]);
		}
		*flag1 |= (1 << 2);
	}
	//parse argument views (StoryViews)
	if (views_)
	{
		buf = buf_cat(buf, *views_);
		*flag1 |= (1 << 3);
	}
	//parse argument sent_reaction (Reaction)
	if (sent_reaction_)
	{
		buf = buf_cat(buf, *sent_reaction_);
		*flag1 |= (1 << 15);
	}
	return buf;
}

buf_t tl_stories_allStoriesNotModified(const char * state_, StoriesStealthMode *stealth_mode_)
{
	buf_t buf = buf_add_ui32(0x1158fe3e);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument state (string)
	{
		buf = buf_cat(buf, serialize_string(state_));
	}
	//parse argument stealth_mode (StoriesStealthMode)
	{
		buf = buf_cat(buf, *stealth_mode_);
	}
	return buf;
}

buf_t tl_stories_allStories(bool has_more_, int count_, const char * state_, PeerStories *peer_stories_, int peer_stories_len, Chat *chats_, int chats_len, User *users_, int users_len, StoriesStealthMode *stealth_mode_)
{
	buf_t buf = buf_add_ui32(0x6efc5e81);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument has_more (true)
	if (has_more_)
		*flag1 |= (1 << 0);
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	//parse argument state (string)
	{
		buf = buf_cat(buf, serialize_string(state_));
	}
	//parse argument peer_stories (Vector<PeerStories>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(peer_stories_len));
		int i;
		for (i=0; i<peer_stories_len; ++i){
			buf = buf_cat(buf, peer_stories_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	//parse argument stealth_mode (StoriesStealthMode)
	{
		buf = buf_cat(buf, *stealth_mode_);
	}
	return buf;
}

buf_t tl_stories_stories(int count_, StoryItem *stories_, int stories_len, int *pinned_to_top_, int pinned_to_top_len, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x63c3dd0a);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	//parse argument stories (Vector<StoryItem>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(stories_len));
		int i;
		for (i=0; i<stories_len; ++i){
			buf = buf_cat(buf, stories_[i]);
		}
	}
	//parse argument pinned_to_top (Vector<int>)
	if (pinned_to_top_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(pinned_to_top_len));
		int i;
		for (i=0; i<pinned_to_top_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(pinned_to_top_[i]));
		}
		*flag1 |= (1 << 0);
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_storyView(bool blocked_, bool blocked_my_stories_from_, long user_id_, int date_, Reaction *reaction_)
{
	buf_t buf = buf_add_ui32(0xb0bdeac5);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument blocked (true)
	if (blocked_)
		*flag1 |= (1 << 0);
	//parse argument blocked_my_stories_from (true)
	if (blocked_my_stories_from_)
		*flag1 |= (1 << 1);
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument reaction (Reaction)
	if (reaction_)
	{
		buf = buf_cat(buf, *reaction_);
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_storyViewPublicForward(bool blocked_, bool blocked_my_stories_from_, Message *message_)
{
	buf_t buf = buf_add_ui32(0x9083670b);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument blocked (true)
	if (blocked_)
		*flag1 |= (1 << 0);
	//parse argument blocked_my_stories_from (true)
	if (blocked_my_stories_from_)
		*flag1 |= (1 << 1);
	//parse argument message (Message)
	{
		buf = buf_cat(buf, *message_);
	}
	return buf;
}

buf_t tl_storyViewPublicRepost(bool blocked_, bool blocked_my_stories_from_, Peer *peer_id_, StoryItem *story_)
{
	buf_t buf = buf_add_ui32(0xbd74cf49);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument blocked (true)
	if (blocked_)
		*flag1 |= (1 << 0);
	//parse argument blocked_my_stories_from (true)
	if (blocked_my_stories_from_)
		*flag1 |= (1 << 1);
	//parse argument peer_id (Peer)
	{
		buf = buf_cat(buf, *peer_id_);
	}
	//parse argument story (StoryItem)
	{
		buf = buf_cat(buf, *story_);
	}
	return buf;
}

buf_t tl_stories_storyViewsList(int count_, int views_count_, int forwards_count_, int reactions_count_, StoryView *views_, int views_len, Chat *chats_, int chats_len, User *users_, int users_len, const char * next_offset_)
{
	buf_t buf = buf_add_ui32(0x59d78fc5);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	//parse argument views_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(views_count_));
	}
	//parse argument forwards_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(forwards_count_));
	}
	//parse argument reactions_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(reactions_count_));
	}
	//parse argument views (Vector<StoryView>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(views_len));
		int i;
		for (i=0; i<views_len; ++i){
			buf = buf_cat(buf, views_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	//parse argument next_offset (string)
	if (next_offset_)
	{
		buf = buf_cat(buf, serialize_string(next_offset_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_stories_storyViews(StoryViews *views_, int views_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0xde9eed1d);
	//parse argument views (Vector<StoryViews>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(views_len));
		int i;
		for (i=0; i<views_len; ++i){
			buf = buf_cat(buf, views_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_inputReplyToMessage(int reply_to_msg_id_, int top_msg_id_, InputPeer *reply_to_peer_id_, const char * quote_text_, MessageEntity *quote_entities_, int quote_entities_len, int quote_offset_)
{
	buf_t buf = buf_add_ui32(0x22c0f6d5);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument reply_to_msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(reply_to_msg_id_));
	}
	//parse argument top_msg_id (int)
	if (top_msg_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(top_msg_id_));
		*flag1 |= (1 << 0);
	}
	//parse argument reply_to_peer_id (InputPeer)
	if (reply_to_peer_id_)
	{
		buf = buf_cat(buf, *reply_to_peer_id_);
		*flag1 |= (1 << 1);
	}
	//parse argument quote_text (string)
	if (quote_text_)
	{
		buf = buf_cat(buf, serialize_string(quote_text_));
		*flag1 |= (1 << 2);
	}
	//parse argument quote_entities (Vector<MessageEntity>)
	if (quote_entities_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(quote_entities_len));
		int i;
		for (i=0; i<quote_entities_len; ++i){
			buf = buf_cat(buf, quote_entities_[i]);
		}
		*flag1 |= (1 << 3);
	}
	//parse argument quote_offset (int)
	if (quote_offset_)
	{
		buf = buf_cat(buf, buf_add_ui32(quote_offset_));
		*flag1 |= (1 << 4);
	}
	return buf;
}

buf_t tl_inputReplyToStory(InputPeer *peer_, int story_id_)
{
	buf_t buf = buf_add_ui32(0x5881323a);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument story_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(story_id_));
	}
	return buf;
}

buf_t tl_exportedStoryLink(const char * link_)
{
	buf_t buf = buf_add_ui32(0x3fc9053b);
	//parse argument link (string)
	{
		buf = buf_cat(buf, serialize_string(link_));
	}
	return buf;
}

buf_t tl_storiesStealthMode(int active_until_date_, int cooldown_until_date_)
{
	buf_t buf = buf_add_ui32(0x712e27fd);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument active_until_date (int)
	if (active_until_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(active_until_date_));
		*flag1 |= (1 << 0);
	}
	//parse argument cooldown_until_date (int)
	if (cooldown_until_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(cooldown_until_date_));
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_mediaAreaCoordinates(double x_, double y_, double w_, double h_, double rotation_, double radius_)
{
	buf_t buf = buf_add_ui32(0xcfc9e002);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument x (double)
	{
		buf = buf_cat(buf, buf_add_ui64(x_));
	}
	//parse argument y (double)
	{
		buf = buf_cat(buf, buf_add_ui64(y_));
	}
	//parse argument w (double)
	{
		buf = buf_cat(buf, buf_add_ui64(w_));
	}
	//parse argument h (double)
	{
		buf = buf_cat(buf, buf_add_ui64(h_));
	}
	//parse argument rotation (double)
	{
		buf = buf_cat(buf, buf_add_ui64(rotation_));
	}
	//parse argument radius (double)
	if (radius_)
	{
		buf = buf_cat(buf, buf_add_ui64(radius_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_mediaAreaVenue(MediaAreaCoordinates *coordinates_, GeoPoint *geo_, const char * title_, const char * address_, const char * provider_, const char * venue_id_, const char * venue_type_)
{
	buf_t buf = buf_add_ui32(0xbe82db9c);
	//parse argument coordinates (MediaAreaCoordinates)
	{
		buf = buf_cat(buf, *coordinates_);
	}
	//parse argument geo (GeoPoint)
	{
		buf = buf_cat(buf, *geo_);
	}
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument address (string)
	{
		buf = buf_cat(buf, serialize_string(address_));
	}
	//parse argument provider (string)
	{
		buf = buf_cat(buf, serialize_string(provider_));
	}
	//parse argument venue_id (string)
	{
		buf = buf_cat(buf, serialize_string(venue_id_));
	}
	//parse argument venue_type (string)
	{
		buf = buf_cat(buf, serialize_string(venue_type_));
	}
	return buf;
}

buf_t tl_inputMediaAreaVenue(MediaAreaCoordinates *coordinates_, long query_id_, const char * result_id_)
{
	buf_t buf = buf_add_ui32(0xb282217f);
	//parse argument coordinates (MediaAreaCoordinates)
	{
		buf = buf_cat(buf, *coordinates_);
	}
	//parse argument query_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(query_id_));
	}
	//parse argument result_id (string)
	{
		buf = buf_cat(buf, serialize_string(result_id_));
	}
	return buf;
}

buf_t tl_mediaAreaGeoPoint(MediaAreaCoordinates *coordinates_, GeoPoint *geo_, GeoPointAddress *address_)
{
	buf_t buf = buf_add_ui32(0xcad5452d);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument coordinates (MediaAreaCoordinates)
	{
		buf = buf_cat(buf, *coordinates_);
	}
	//parse argument geo (GeoPoint)
	{
		buf = buf_cat(buf, *geo_);
	}
	//parse argument address (GeoPointAddress)
	if (address_)
	{
		buf = buf_cat(buf, *address_);
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_mediaAreaSuggestedReaction(bool dark_, bool flipped_, MediaAreaCoordinates *coordinates_, Reaction *reaction_)
{
	buf_t buf = buf_add_ui32(0x14455871);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument dark (true)
	if (dark_)
		*flag1 |= (1 << 0);
	//parse argument flipped (true)
	if (flipped_)
		*flag1 |= (1 << 1);
	//parse argument coordinates (MediaAreaCoordinates)
	{
		buf = buf_cat(buf, *coordinates_);
	}
	//parse argument reaction (Reaction)
	{
		buf = buf_cat(buf, *reaction_);
	}
	return buf;
}

buf_t tl_mediaAreaChannelPost(MediaAreaCoordinates *coordinates_, long channel_id_, int msg_id_)
{
	buf_t buf = buf_add_ui32(0x770416af);
	//parse argument coordinates (MediaAreaCoordinates)
	{
		buf = buf_cat(buf, *coordinates_);
	}
	//parse argument channel_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(channel_id_));
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	return buf;
}

buf_t tl_inputMediaAreaChannelPost(MediaAreaCoordinates *coordinates_, InputChannel *channel_, int msg_id_)
{
	buf_t buf = buf_add_ui32(0x2271f2bf);
	//parse argument coordinates (MediaAreaCoordinates)
	{
		buf = buf_cat(buf, *coordinates_);
	}
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	return buf;
}

buf_t tl_mediaAreaUrl(MediaAreaCoordinates *coordinates_, const char * url_)
{
	buf_t buf = buf_add_ui32(0x37381085);
	//parse argument coordinates (MediaAreaCoordinates)
	{
		buf = buf_cat(buf, *coordinates_);
	}
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	return buf;
}

buf_t tl_mediaAreaWeather(MediaAreaCoordinates *coordinates_, const char * emoji_, double temperature_c_, int color_)
{
	buf_t buf = buf_add_ui32(0x49a6549c);
	//parse argument coordinates (MediaAreaCoordinates)
	{
		buf = buf_cat(buf, *coordinates_);
	}
	//parse argument emoji (string)
	{
		buf = buf_cat(buf, serialize_string(emoji_));
	}
	//parse argument temperature_c (double)
	{
		buf = buf_cat(buf, buf_add_ui64(temperature_c_));
	}
	//parse argument color (int)
	{
		buf = buf_cat(buf, buf_add_ui32(color_));
	}
	return buf;
}

buf_t tl_peerStories(Peer *peer_, int max_read_id_, StoryItem *stories_, int stories_len)
{
	buf_t buf = buf_add_ui32(0x9a35e999);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument max_read_id (int)
	if (max_read_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(max_read_id_));
		*flag1 |= (1 << 0);
	}
	//parse argument stories (Vector<StoryItem>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(stories_len));
		int i;
		for (i=0; i<stories_len; ++i){
			buf = buf_cat(buf, stories_[i]);
		}
	}
	return buf;
}

buf_t tl_stories_peerStories(PeerStories *stories_, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0xcae68768);
	//parse argument stories (PeerStories)
	{
		buf = buf_cat(buf, *stories_);
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_messages_webPage(WebPage *webpage_, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0xfd5e12bd);
	//parse argument webpage (WebPage)
	{
		buf = buf_cat(buf, *webpage_);
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_premiumGiftCodeOption(int users_, int months_, const char * store_product_, int store_quantity_, const char * currency_, long amount_)
{
	buf_t buf = buf_add_ui32(0x257e962b);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument users (int)
	{
		buf = buf_cat(buf, buf_add_ui32(users_));
	}
	//parse argument months (int)
	{
		buf = buf_cat(buf, buf_add_ui32(months_));
	}
	//parse argument store_product (string)
	if (store_product_)
	{
		buf = buf_cat(buf, serialize_string(store_product_));
		*flag1 |= (1 << 0);
	}
	//parse argument store_quantity (int)
	if (store_quantity_)
	{
		buf = buf_cat(buf, buf_add_ui32(store_quantity_));
		*flag1 |= (1 << 1);
	}
	//parse argument currency (string)
	{
		buf = buf_cat(buf, serialize_string(currency_));
	}
	//parse argument amount (long)
	{
		buf = buf_cat(buf, buf_add_ui64(amount_));
	}
	return buf;
}

buf_t tl_payments_checkedGiftCode(bool via_giveaway_, Peer *from_id_, int giveaway_msg_id_, long to_id_, int date_, int months_, int used_date_, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x284a1096);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument via_giveaway (true)
	if (via_giveaway_)
		*flag1 |= (1 << 2);
	//parse argument from_id (Peer)
	if (from_id_)
	{
		buf = buf_cat(buf, *from_id_);
		*flag1 |= (1 << 4);
	}
	//parse argument giveaway_msg_id (int)
	if (giveaway_msg_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(giveaway_msg_id_));
		*flag1 |= (1 << 3);
	}
	//parse argument to_id (long)
	if (to_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(to_id_));
		*flag1 |= (1 << 0);
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument months (int)
	{
		buf = buf_cat(buf, buf_add_ui32(months_));
	}
	//parse argument used_date (int)
	if (used_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(used_date_));
		*flag1 |= (1 << 1);
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_payments_giveawayInfo(bool participating_, bool preparing_results_, int start_date_, int joined_too_early_date_, long admin_disallowed_chat_id_, const char * disallowed_country_)
{
	buf_t buf = buf_add_ui32(0x4367daa0);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument participating (true)
	if (participating_)
		*flag1 |= (1 << 0);
	//parse argument preparing_results (true)
	if (preparing_results_)
		*flag1 |= (1 << 3);
	//parse argument start_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(start_date_));
	}
	//parse argument joined_too_early_date (int)
	if (joined_too_early_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(joined_too_early_date_));
		*flag1 |= (1 << 1);
	}
	//parse argument admin_disallowed_chat_id (long)
	if (admin_disallowed_chat_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(admin_disallowed_chat_id_));
		*flag1 |= (1 << 2);
	}
	//parse argument disallowed_country (string)
	if (disallowed_country_)
	{
		buf = buf_cat(buf, serialize_string(disallowed_country_));
		*flag1 |= (1 << 4);
	}
	return buf;
}

buf_t tl_payments_giveawayInfoResults(bool winner_, bool refunded_, int start_date_, const char * gift_code_slug_, long stars_prize_, int finish_date_, int winners_count_, int activated_count_)
{
	buf_t buf = buf_add_ui32(0xe175e66f);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument winner (true)
	if (winner_)
		*flag1 |= (1 << 0);
	//parse argument refunded (true)
	if (refunded_)
		*flag1 |= (1 << 1);
	//parse argument start_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(start_date_));
	}
	//parse argument gift_code_slug (string)
	if (gift_code_slug_)
	{
		buf = buf_cat(buf, serialize_string(gift_code_slug_));
		*flag1 |= (1 << 3);
	}
	//parse argument stars_prize (long)
	if (stars_prize_)
	{
		buf = buf_cat(buf, buf_add_ui64(stars_prize_));
		*flag1 |= (1 << 4);
	}
	//parse argument finish_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(finish_date_));
	}
	//parse argument winners_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(winners_count_));
	}
	//parse argument activated_count (int)
	if (activated_count_)
	{
		buf = buf_cat(buf, buf_add_ui32(activated_count_));
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_prepaidGiveaway(long id_, int months_, int quantity_, int date_)
{
	buf_t buf = buf_add_ui32(0xb2539d54);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument months (int)
	{
		buf = buf_cat(buf, buf_add_ui32(months_));
	}
	//parse argument quantity (int)
	{
		buf = buf_cat(buf, buf_add_ui32(quantity_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	return buf;
}

buf_t tl_prepaidStarsGiveaway(long id_, long stars_, int quantity_, int boosts_, int date_)
{
	buf_t buf = buf_add_ui32(0x9a9d77e0);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument stars (long)
	{
		buf = buf_cat(buf, buf_add_ui64(stars_));
	}
	//parse argument quantity (int)
	{
		buf = buf_cat(buf, buf_add_ui32(quantity_));
	}
	//parse argument boosts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(boosts_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	return buf;
}

buf_t tl_boost(bool gift_, bool giveaway_, bool unclaimed_, const char * id_, long user_id_, int giveaway_msg_id_, int date_, int expires_, const char * used_gift_slug_, int multiplier_, long stars_)
{
	buf_t buf = buf_add_ui32(0x4b3e14d6);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument gift (true)
	if (gift_)
		*flag1 |= (1 << 1);
	//parse argument giveaway (true)
	if (giveaway_)
		*flag1 |= (1 << 2);
	//parse argument unclaimed (true)
	if (unclaimed_)
		*flag1 |= (1 << 3);
	//parse argument id (string)
	{
		buf = buf_cat(buf, serialize_string(id_));
	}
	//parse argument user_id (long)
	if (user_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
		*flag1 |= (1 << 0);
	}
	//parse argument giveaway_msg_id (int)
	if (giveaway_msg_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(giveaway_msg_id_));
		*flag1 |= (1 << 2);
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument expires (int)
	{
		buf = buf_cat(buf, buf_add_ui32(expires_));
	}
	//parse argument used_gift_slug (string)
	if (used_gift_slug_)
	{
		buf = buf_cat(buf, serialize_string(used_gift_slug_));
		*flag1 |= (1 << 4);
	}
	//parse argument multiplier (int)
	if (multiplier_)
	{
		buf = buf_cat(buf, buf_add_ui32(multiplier_));
		*flag1 |= (1 << 5);
	}
	//parse argument stars (long)
	if (stars_)
	{
		buf = buf_cat(buf, buf_add_ui64(stars_));
		*flag1 |= (1 << 6);
	}
	return buf;
}

buf_t tl_premium_boostsList(int count_, Boost *boosts_, int boosts_len, const char * next_offset_, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x86f8613c);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	//parse argument boosts (Vector<Boost>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(boosts_len));
		int i;
		for (i=0; i<boosts_len; ++i){
			buf = buf_cat(buf, boosts_[i]);
		}
	}
	//parse argument next_offset (string)
	if (next_offset_)
	{
		buf = buf_cat(buf, serialize_string(next_offset_));
		*flag1 |= (1 << 0);
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_myBoost(int slot_, Peer *peer_, int date_, int expires_, int cooldown_until_date_)
{
	buf_t buf = buf_add_ui32(0xc448415c);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument slot (int)
	{
		buf = buf_cat(buf, buf_add_ui32(slot_));
	}
	//parse argument peer (Peer)
	if (peer_)
	{
		buf = buf_cat(buf, *peer_);
		*flag1 |= (1 << 0);
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument expires (int)
	{
		buf = buf_cat(buf, buf_add_ui32(expires_));
	}
	//parse argument cooldown_until_date (int)
	if (cooldown_until_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(cooldown_until_date_));
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_premium_myBoosts(MyBoost *my_boosts_, int my_boosts_len, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x9ae228e2);
	//parse argument my_boosts (Vector<MyBoost>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(my_boosts_len));
		int i;
		for (i=0; i<my_boosts_len; ++i){
			buf = buf_cat(buf, my_boosts_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_premium_boostsStatus(bool my_boost_, int level_, int current_level_boosts_, int boosts_, int gift_boosts_, int next_level_boosts_, StatsPercentValue *premium_audience_, const char * boost_url_, PrepaidGiveaway *prepaid_giveaways_, int prepaid_giveaways_len, int *my_boost_slots_, int my_boost_slots_len)
{
	buf_t buf = buf_add_ui32(0x4959427a);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument my_boost (true)
	if (my_boost_)
		*flag1 |= (1 << 2);
	//parse argument level (int)
	{
		buf = buf_cat(buf, buf_add_ui32(level_));
	}
	//parse argument current_level_boosts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(current_level_boosts_));
	}
	//parse argument boosts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(boosts_));
	}
	//parse argument gift_boosts (int)
	if (gift_boosts_)
	{
		buf = buf_cat(buf, buf_add_ui32(gift_boosts_));
		*flag1 |= (1 << 4);
	}
	//parse argument next_level_boosts (int)
	if (next_level_boosts_)
	{
		buf = buf_cat(buf, buf_add_ui32(next_level_boosts_));
		*flag1 |= (1 << 0);
	}
	//parse argument premium_audience (StatsPercentValue)
	if (premium_audience_)
	{
		buf = buf_cat(buf, *premium_audience_);
		*flag1 |= (1 << 1);
	}
	//parse argument boost_url (string)
	{
		buf = buf_cat(buf, serialize_string(boost_url_));
	}
	//parse argument prepaid_giveaways (Vector<PrepaidGiveaway>)
	if (prepaid_giveaways_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(prepaid_giveaways_len));
		int i;
		for (i=0; i<prepaid_giveaways_len; ++i){
			buf = buf_cat(buf, prepaid_giveaways_[i]);
		}
		*flag1 |= (1 << 3);
	}
	//parse argument my_boost_slots (Vector<int>)
	if (my_boost_slots_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(my_boost_slots_len));
		int i;
		for (i=0; i<my_boost_slots_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(my_boost_slots_[i]));
		}
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_storyFwdHeader(bool modified_, Peer *from_, const char * from_name_, int story_id_)
{
	buf_t buf = buf_add_ui32(0xb826e150);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument modified (true)
	if (modified_)
		*flag1 |= (1 << 3);
	//parse argument from (Peer)
	if (from_)
	{
		buf = buf_cat(buf, *from_);
		*flag1 |= (1 << 0);
	}
	//parse argument from_name (string)
	if (from_name_)
	{
		buf = buf_cat(buf, serialize_string(from_name_));
		*flag1 |= (1 << 1);
	}
	//parse argument story_id (int)
	if (story_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(story_id_));
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_postInteractionCountersMessage(int msg_id_, int views_, int forwards_, int reactions_)
{
	buf_t buf = buf_add_ui32(0xe7058e7f);
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	//parse argument views (int)
	{
		buf = buf_cat(buf, buf_add_ui32(views_));
	}
	//parse argument forwards (int)
	{
		buf = buf_cat(buf, buf_add_ui32(forwards_));
	}
	//parse argument reactions (int)
	{
		buf = buf_cat(buf, buf_add_ui32(reactions_));
	}
	return buf;
}

buf_t tl_postInteractionCountersStory(int story_id_, int views_, int forwards_, int reactions_)
{
	buf_t buf = buf_add_ui32(0x8a480e27);
	//parse argument story_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(story_id_));
	}
	//parse argument views (int)
	{
		buf = buf_cat(buf, buf_add_ui32(views_));
	}
	//parse argument forwards (int)
	{
		buf = buf_cat(buf, buf_add_ui32(forwards_));
	}
	//parse argument reactions (int)
	{
		buf = buf_cat(buf, buf_add_ui32(reactions_));
	}
	return buf;
}

buf_t tl_stats_storyStats(StatsGraph *views_graph_, StatsGraph *reactions_by_emotion_graph_)
{
	buf_t buf = buf_add_ui32(0x50cd067c);
	//parse argument views_graph (StatsGraph)
	{
		buf = buf_cat(buf, *views_graph_);
	}
	//parse argument reactions_by_emotion_graph (StatsGraph)
	{
		buf = buf_cat(buf, *reactions_by_emotion_graph_);
	}
	return buf;
}

buf_t tl_publicForwardMessage(Message *message_)
{
	buf_t buf = buf_add_ui32(0x01f2bf4a);
	//parse argument message (Message)
	{
		buf = buf_cat(buf, *message_);
	}
	return buf;
}

buf_t tl_publicForwardStory(Peer *peer_, StoryItem *story_)
{
	buf_t buf = buf_add_ui32(0xedf3add0);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument story (StoryItem)
	{
		buf = buf_cat(buf, *story_);
	}
	return buf;
}

buf_t tl_stats_publicForwards(int count_, PublicForward *forwards_, int forwards_len, const char * next_offset_, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x93037e20);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	//parse argument forwards (Vector<PublicForward>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(forwards_len));
		int i;
		for (i=0; i<forwards_len; ++i){
			buf = buf_cat(buf, forwards_[i]);
		}
	}
	//parse argument next_offset (string)
	if (next_offset_)
	{
		buf = buf_cat(buf, serialize_string(next_offset_));
		*flag1 |= (1 << 0);
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_peerColor(int color_, long background_emoji_id_)
{
	buf_t buf = buf_add_ui32(0xb54b5acf);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument color (int)
	if (color_)
	{
		buf = buf_cat(buf, buf_add_ui32(color_));
		*flag1 |= (1 << 0);
	}
	//parse argument background_emoji_id (long)
	if (background_emoji_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(background_emoji_id_));
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_help_peerColorSet(int *colors_, int colors_len)
{
	buf_t buf = buf_add_ui32(0x26219a58);
	//parse argument colors (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(colors_len));
		int i;
		for (i=0; i<colors_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(colors_[i]));
		}
	}
	return buf;
}

buf_t tl_help_peerColorProfileSet(int *palette_colors_, int palette_colors_len, int *bg_colors_, int bg_colors_len, int *story_colors_, int story_colors_len)
{
	buf_t buf = buf_add_ui32(0x767d61eb);
	//parse argument palette_colors (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(palette_colors_len));
		int i;
		for (i=0; i<palette_colors_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(palette_colors_[i]));
		}
	}
	//parse argument bg_colors (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(bg_colors_len));
		int i;
		for (i=0; i<bg_colors_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(bg_colors_[i]));
		}
	}
	//parse argument story_colors (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(story_colors_len));
		int i;
		for (i=0; i<story_colors_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(story_colors_[i]));
		}
	}
	return buf;
}

buf_t tl_help_peerColorOption(bool hidden_, int color_id_, help_PeerColorSet *colors_, help_PeerColorSet *dark_colors_, int channel_min_level_, int group_min_level_)
{
	buf_t buf = buf_add_ui32(0xadec6ebe);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument hidden (true)
	if (hidden_)
		*flag1 |= (1 << 0);
	//parse argument color_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(color_id_));
	}
	//parse argument colors (help_PeerColorSet)
	if (colors_)
	{
		buf = buf_cat(buf, *colors_);
		*flag1 |= (1 << 1);
	}
	//parse argument dark_colors (help_PeerColorSet)
	if (dark_colors_)
	{
		buf = buf_cat(buf, *dark_colors_);
		*flag1 |= (1 << 2);
	}
	//parse argument channel_min_level (int)
	if (channel_min_level_)
	{
		buf = buf_cat(buf, buf_add_ui32(channel_min_level_));
		*flag1 |= (1 << 3);
	}
	//parse argument group_min_level (int)
	if (group_min_level_)
	{
		buf = buf_cat(buf, buf_add_ui32(group_min_level_));
		*flag1 |= (1 << 4);
	}
	return buf;
}

buf_t tl_help_peerColorsNotModified()
{
	buf_t buf = buf_add_ui32(0x2ba1f5ce);
	return buf;
}

buf_t tl_help_peerColors(int hash_, help_PeerColorOption *colors_, int colors_len)
{
	buf_t buf = buf_add_ui32(0x00f8ed08);
	//parse argument hash (int)
	{
		buf = buf_cat(buf, buf_add_ui32(hash_));
	}
	//parse argument colors (Vector<help_PeerColorOption>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(colors_len));
		int i;
		for (i=0; i<colors_len; ++i){
			buf = buf_cat(buf, colors_[i]);
		}
	}
	return buf;
}

buf_t tl_storyReaction(Peer *peer_id_, int date_, Reaction *reaction_)
{
	buf_t buf = buf_add_ui32(0x6090d6d5);
	//parse argument peer_id (Peer)
	{
		buf = buf_cat(buf, *peer_id_);
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument reaction (Reaction)
	{
		buf = buf_cat(buf, *reaction_);
	}
	return buf;
}

buf_t tl_storyReactionPublicForward(Message *message_)
{
	buf_t buf = buf_add_ui32(0xbbab2643);
	//parse argument message (Message)
	{
		buf = buf_cat(buf, *message_);
	}
	return buf;
}

buf_t tl_storyReactionPublicRepost(Peer *peer_id_, StoryItem *story_)
{
	buf_t buf = buf_add_ui32(0xcfcd0f13);
	//parse argument peer_id (Peer)
	{
		buf = buf_cat(buf, *peer_id_);
	}
	//parse argument story (StoryItem)
	{
		buf = buf_cat(buf, *story_);
	}
	return buf;
}

buf_t tl_stories_storyReactionsList(int count_, StoryReaction *reactions_, int reactions_len, Chat *chats_, int chats_len, User *users_, int users_len, const char * next_offset_)
{
	buf_t buf = buf_add_ui32(0xaa5f789c);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	//parse argument reactions (Vector<StoryReaction>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(reactions_len));
		int i;
		for (i=0; i<reactions_len; ++i){
			buf = buf_cat(buf, reactions_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	//parse argument next_offset (string)
	if (next_offset_)
	{
		buf = buf_cat(buf, serialize_string(next_offset_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_savedDialog(bool pinned_, Peer *peer_, int top_message_)
{
	buf_t buf = buf_add_ui32(0xbd87cb6c);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument pinned (true)
	if (pinned_)
		*flag1 |= (1 << 2);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument top_message (int)
	{
		buf = buf_cat(buf, buf_add_ui32(top_message_));
	}
	return buf;
}

buf_t tl_messages_savedDialogs(SavedDialog *dialogs_, int dialogs_len, Message *messages_, int messages_len, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0xf83ae221);
	//parse argument dialogs (Vector<SavedDialog>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(dialogs_len));
		int i;
		for (i=0; i<dialogs_len; ++i){
			buf = buf_cat(buf, dialogs_[i]);
		}
	}
	//parse argument messages (Vector<Message>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(messages_len));
		int i;
		for (i=0; i<messages_len; ++i){
			buf = buf_cat(buf, messages_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_messages_savedDialogsSlice(int count_, SavedDialog *dialogs_, int dialogs_len, Message *messages_, int messages_len, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x44ba9dd9);
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	//parse argument dialogs (Vector<SavedDialog>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(dialogs_len));
		int i;
		for (i=0; i<dialogs_len; ++i){
			buf = buf_cat(buf, dialogs_[i]);
		}
	}
	//parse argument messages (Vector<Message>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(messages_len));
		int i;
		for (i=0; i<messages_len; ++i){
			buf = buf_cat(buf, messages_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_messages_savedDialogsNotModified(int count_)
{
	buf_t buf = buf_add_ui32(0xc01f6fe8);
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	return buf;
}

buf_t tl_savedReactionTag(Reaction *reaction_, const char * title_, int count_)
{
	buf_t buf = buf_add_ui32(0xcb6ff828);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument reaction (Reaction)
	{
		buf = buf_cat(buf, *reaction_);
	}
	//parse argument title (string)
	if (title_)
	{
		buf = buf_cat(buf, serialize_string(title_));
		*flag1 |= (1 << 0);
	}
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	return buf;
}

buf_t tl_messages_savedReactionTagsNotModified()
{
	buf_t buf = buf_add_ui32(0x889b59ef);
	return buf;
}

buf_t tl_messages_savedReactionTags(SavedReactionTag *tags_, int tags_len, long hash_)
{
	buf_t buf = buf_add_ui32(0x3259950a);
	//parse argument tags (Vector<SavedReactionTag>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(tags_len));
		int i;
		for (i=0; i<tags_len; ++i){
			buf = buf_cat(buf, tags_[i]);
		}
	}
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_outboxReadDate(int date_)
{
	buf_t buf = buf_add_ui32(0x3bb842ac);
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	return buf;
}

buf_t tl_smsjobs_eligibleToJoin(const char * terms_url_, int monthly_sent_sms_)
{
	buf_t buf = buf_add_ui32(0xdc8b44cf);
	//parse argument terms_url (string)
	{
		buf = buf_cat(buf, serialize_string(terms_url_));
	}
	//parse argument monthly_sent_sms (int)
	{
		buf = buf_cat(buf, buf_add_ui32(monthly_sent_sms_));
	}
	return buf;
}

buf_t tl_smsjobs_status(bool allow_international_, int recent_sent_, int recent_since_, int recent_remains_, int total_sent_, int total_since_, const char * last_gift_slug_, const char * terms_url_)
{
	buf_t buf = buf_add_ui32(0x2aee9191);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument allow_international (true)
	if (allow_international_)
		*flag1 |= (1 << 0);
	//parse argument recent_sent (int)
	{
		buf = buf_cat(buf, buf_add_ui32(recent_sent_));
	}
	//parse argument recent_since (int)
	{
		buf = buf_cat(buf, buf_add_ui32(recent_since_));
	}
	//parse argument recent_remains (int)
	{
		buf = buf_cat(buf, buf_add_ui32(recent_remains_));
	}
	//parse argument total_sent (int)
	{
		buf = buf_cat(buf, buf_add_ui32(total_sent_));
	}
	//parse argument total_since (int)
	{
		buf = buf_cat(buf, buf_add_ui32(total_since_));
	}
	//parse argument last_gift_slug (string)
	if (last_gift_slug_)
	{
		buf = buf_cat(buf, serialize_string(last_gift_slug_));
		*flag1 |= (1 << 1);
	}
	//parse argument terms_url (string)
	{
		buf = buf_cat(buf, serialize_string(terms_url_));
	}
	return buf;
}

buf_t tl_smsJob(const char * job_id_, const char * phone_number_, const char * text_)
{
	buf_t buf = buf_add_ui32(0xe6a1eeb8);
	//parse argument job_id (string)
	{
		buf = buf_cat(buf, serialize_string(job_id_));
	}
	//parse argument phone_number (string)
	{
		buf = buf_cat(buf, serialize_string(phone_number_));
	}
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	return buf;
}

buf_t tl_businessWeeklyOpen(int start_minute_, int end_minute_)
{
	buf_t buf = buf_add_ui32(0x120b1ab9);
	//parse argument start_minute (int)
	{
		buf = buf_cat(buf, buf_add_ui32(start_minute_));
	}
	//parse argument end_minute (int)
	{
		buf = buf_cat(buf, buf_add_ui32(end_minute_));
	}
	return buf;
}

buf_t tl_businessWorkHours(bool open_now_, const char * timezone_id_, BusinessWeeklyOpen *weekly_open_, int weekly_open_len)
{
	buf_t buf = buf_add_ui32(0x8c92b098);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument open_now (true)
	if (open_now_)
		*flag1 |= (1 << 0);
	//parse argument timezone_id (string)
	{
		buf = buf_cat(buf, serialize_string(timezone_id_));
	}
	//parse argument weekly_open (Vector<BusinessWeeklyOpen>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(weekly_open_len));
		int i;
		for (i=0; i<weekly_open_len; ++i){
			buf = buf_cat(buf, weekly_open_[i]);
		}
	}
	return buf;
}

buf_t tl_businessLocation(GeoPoint *geo_point_, const char * address_)
{
	buf_t buf = buf_add_ui32(0xac5c1af7);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument geo_point (GeoPoint)
	if (geo_point_)
	{
		buf = buf_cat(buf, *geo_point_);
		*flag1 |= (1 << 0);
	}
	//parse argument address (string)
	{
		buf = buf_cat(buf, serialize_string(address_));
	}
	return buf;
}

buf_t tl_inputBusinessRecipients(bool existing_chats_, bool new_chats_, bool contacts_, bool non_contacts_, bool exclude_selected_, InputUser *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x6f8b32aa);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument existing_chats (true)
	if (existing_chats_)
		*flag1 |= (1 << 0);
	//parse argument new_chats (true)
	if (new_chats_)
		*flag1 |= (1 << 1);
	//parse argument contacts (true)
	if (contacts_)
		*flag1 |= (1 << 2);
	//parse argument non_contacts (true)
	if (non_contacts_)
		*flag1 |= (1 << 3);
	//parse argument exclude_selected (true)
	if (exclude_selected_)
		*flag1 |= (1 << 5);
	//parse argument users (Vector<InputUser>)
	if (users_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
		*flag1 |= (1 << 4);
	}
	return buf;
}

buf_t tl_businessRecipients(bool existing_chats_, bool new_chats_, bool contacts_, bool non_contacts_, bool exclude_selected_, long *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x21108ff7);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument existing_chats (true)
	if (existing_chats_)
		*flag1 |= (1 << 0);
	//parse argument new_chats (true)
	if (new_chats_)
		*flag1 |= (1 << 1);
	//parse argument contacts (true)
	if (contacts_)
		*flag1 |= (1 << 2);
	//parse argument non_contacts (true)
	if (non_contacts_)
		*flag1 |= (1 << 3);
	//parse argument exclude_selected (true)
	if (exclude_selected_)
		*flag1 |= (1 << 5);
	//parse argument users (Vector<long>)
	if (users_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(users_[i]));
		}
		*flag1 |= (1 << 4);
	}
	return buf;
}

buf_t tl_businessAwayMessageScheduleAlways()
{
	buf_t buf = buf_add_ui32(0xc9b9e2b9);
	return buf;
}

buf_t tl_businessAwayMessageScheduleOutsideWorkHours()
{
	buf_t buf = buf_add_ui32(0xc3f2f501);
	return buf;
}

buf_t tl_businessAwayMessageScheduleCustom(int start_date_, int end_date_)
{
	buf_t buf = buf_add_ui32(0xcc4d9ecc);
	//parse argument start_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(start_date_));
	}
	//parse argument end_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(end_date_));
	}
	return buf;
}

buf_t tl_inputBusinessGreetingMessage(int shortcut_id_, InputBusinessRecipients *recipients_, int no_activity_days_)
{
	buf_t buf = buf_add_ui32(0x0194cb3b);
	//parse argument shortcut_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(shortcut_id_));
	}
	//parse argument recipients (InputBusinessRecipients)
	{
		buf = buf_cat(buf, *recipients_);
	}
	//parse argument no_activity_days (int)
	{
		buf = buf_cat(buf, buf_add_ui32(no_activity_days_));
	}
	return buf;
}

buf_t tl_businessGreetingMessage(int shortcut_id_, BusinessRecipients *recipients_, int no_activity_days_)
{
	buf_t buf = buf_add_ui32(0xe519abab);
	//parse argument shortcut_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(shortcut_id_));
	}
	//parse argument recipients (BusinessRecipients)
	{
		buf = buf_cat(buf, *recipients_);
	}
	//parse argument no_activity_days (int)
	{
		buf = buf_cat(buf, buf_add_ui32(no_activity_days_));
	}
	return buf;
}

buf_t tl_inputBusinessAwayMessage(bool offline_only_, int shortcut_id_, BusinessAwayMessageSchedule *schedule_, InputBusinessRecipients *recipients_)
{
	buf_t buf = buf_add_ui32(0x832175e0);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument offline_only (true)
	if (offline_only_)
		*flag1 |= (1 << 0);
	//parse argument shortcut_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(shortcut_id_));
	}
	//parse argument schedule (BusinessAwayMessageSchedule)
	{
		buf = buf_cat(buf, *schedule_);
	}
	//parse argument recipients (InputBusinessRecipients)
	{
		buf = buf_cat(buf, *recipients_);
	}
	return buf;
}

buf_t tl_businessAwayMessage(bool offline_only_, int shortcut_id_, BusinessAwayMessageSchedule *schedule_, BusinessRecipients *recipients_)
{
	buf_t buf = buf_add_ui32(0xef156a5c);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument offline_only (true)
	if (offline_only_)
		*flag1 |= (1 << 0);
	//parse argument shortcut_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(shortcut_id_));
	}
	//parse argument schedule (BusinessAwayMessageSchedule)
	{
		buf = buf_cat(buf, *schedule_);
	}
	//parse argument recipients (BusinessRecipients)
	{
		buf = buf_cat(buf, *recipients_);
	}
	return buf;
}

buf_t tl_timezone(const char * id_, const char * name_, int utc_offset_)
{
	buf_t buf = buf_add_ui32(0xff9289f5);
	//parse argument id (string)
	{
		buf = buf_cat(buf, serialize_string(id_));
	}
	//parse argument name (string)
	{
		buf = buf_cat(buf, serialize_string(name_));
	}
	//parse argument utc_offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(utc_offset_));
	}
	return buf;
}

buf_t tl_help_timezonesListNotModified()
{
	buf_t buf = buf_add_ui32(0x970708cc);
	return buf;
}

buf_t tl_help_timezonesList(Timezone *timezones_, int timezones_len, int hash_)
{
	buf_t buf = buf_add_ui32(0x7b74ed71);
	//parse argument timezones (Vector<Timezone>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(timezones_len));
		int i;
		for (i=0; i<timezones_len; ++i){
			buf = buf_cat(buf, timezones_[i]);
		}
	}
	//parse argument hash (int)
	{
		buf = buf_cat(buf, buf_add_ui32(hash_));
	}
	return buf;
}

buf_t tl_quickReply(int shortcut_id_, const char * shortcut_, int top_message_, int count_)
{
	buf_t buf = buf_add_ui32(0x0697102b);
	//parse argument shortcut_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(shortcut_id_));
	}
	//parse argument shortcut (string)
	{
		buf = buf_cat(buf, serialize_string(shortcut_));
	}
	//parse argument top_message (int)
	{
		buf = buf_cat(buf, buf_add_ui32(top_message_));
	}
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	return buf;
}

buf_t tl_inputQuickReplyShortcut(const char * shortcut_)
{
	buf_t buf = buf_add_ui32(0x24596d41);
	//parse argument shortcut (string)
	{
		buf = buf_cat(buf, serialize_string(shortcut_));
	}
	return buf;
}

buf_t tl_inputQuickReplyShortcutId(int shortcut_id_)
{
	buf_t buf = buf_add_ui32(0x01190cf1);
	//parse argument shortcut_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(shortcut_id_));
	}
	return buf;
}

buf_t tl_messages_quickReplies(QuickReply *quick_replies_, int quick_replies_len, Message *messages_, int messages_len, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0xc68d6695);
	//parse argument quick_replies (Vector<QuickReply>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(quick_replies_len));
		int i;
		for (i=0; i<quick_replies_len; ++i){
			buf = buf_cat(buf, quick_replies_[i]);
		}
	}
	//parse argument messages (Vector<Message>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(messages_len));
		int i;
		for (i=0; i<messages_len; ++i){
			buf = buf_cat(buf, messages_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_messages_quickRepliesNotModified()
{
	buf_t buf = buf_add_ui32(0x5f91eb5b);
	return buf;
}

buf_t tl_connectedBot(bool can_reply_, long bot_id_, BusinessBotRecipients *recipients_)
{
	buf_t buf = buf_add_ui32(0xbd068601);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument can_reply (true)
	if (can_reply_)
		*flag1 |= (1 << 0);
	//parse argument bot_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(bot_id_));
	}
	//parse argument recipients (BusinessBotRecipients)
	{
		buf = buf_cat(buf, *recipients_);
	}
	return buf;
}

buf_t tl_account_connectedBots(ConnectedBot *connected_bots_, int connected_bots_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x17d7f87b);
	//parse argument connected_bots (Vector<ConnectedBot>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(connected_bots_len));
		int i;
		for (i=0; i<connected_bots_len; ++i){
			buf = buf_cat(buf, connected_bots_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_messages_dialogFilters(bool tags_enabled_, DialogFilter *filters_, int filters_len)
{
	buf_t buf = buf_add_ui32(0x2ad93719);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument tags_enabled (true)
	if (tags_enabled_)
		*flag1 |= (1 << 0);
	//parse argument filters (Vector<DialogFilter>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(filters_len));
		int i;
		for (i=0; i<filters_len; ++i){
			buf = buf_cat(buf, filters_[i]);
		}
	}
	return buf;
}

buf_t tl_birthday(int day_, int month_, int year_)
{
	buf_t buf = buf_add_ui32(0x6c8e1e06);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument day (int)
	{
		buf = buf_cat(buf, buf_add_ui32(day_));
	}
	//parse argument month (int)
	{
		buf = buf_cat(buf, buf_add_ui32(month_));
	}
	//parse argument year (int)
	if (year_)
	{
		buf = buf_cat(buf, buf_add_ui32(year_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_botBusinessConnection(bool can_reply_, bool disabled_, const char * connection_id_, long user_id_, int dc_id_, int date_)
{
	buf_t buf = buf_add_ui32(0x896433b4);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument can_reply (true)
	if (can_reply_)
		*flag1 |= (1 << 0);
	//parse argument disabled (true)
	if (disabled_)
		*flag1 |= (1 << 1);
	//parse argument connection_id (string)
	{
		buf = buf_cat(buf, serialize_string(connection_id_));
	}
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument dc_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(dc_id_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	return buf;
}

buf_t tl_inputBusinessIntro(const char * title_, const char * description_, InputDocument *sticker_)
{
	buf_t buf = buf_add_ui32(0x09c469cd);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument description (string)
	{
		buf = buf_cat(buf, serialize_string(description_));
	}
	//parse argument sticker (InputDocument)
	if (sticker_)
	{
		buf = buf_cat(buf, *sticker_);
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_businessIntro(const char * title_, const char * description_, Document *sticker_)
{
	buf_t buf = buf_add_ui32(0x5a0a066d);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument description (string)
	{
		buf = buf_cat(buf, serialize_string(description_));
	}
	//parse argument sticker (Document)
	if (sticker_)
	{
		buf = buf_cat(buf, *sticker_);
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_messages_myStickers(int count_, StickerSetCovered *sets_, int sets_len)
{
	buf_t buf = buf_add_ui32(0xfaff629d);
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	//parse argument sets (Vector<StickerSetCovered>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(sets_len));
		int i;
		for (i=0; i<sets_len; ++i){
			buf = buf_cat(buf, sets_[i]);
		}
	}
	return buf;
}

buf_t tl_inputCollectibleUsername(const char * username_)
{
	buf_t buf = buf_add_ui32(0xe39460a9);
	//parse argument username (string)
	{
		buf = buf_cat(buf, serialize_string(username_));
	}
	return buf;
}

buf_t tl_inputCollectiblePhone(const char * phone_)
{
	buf_t buf = buf_add_ui32(0xa2e214a4);
	//parse argument phone (string)
	{
		buf = buf_cat(buf, serialize_string(phone_));
	}
	return buf;
}

buf_t tl_fragment_collectibleInfo(int purchase_date_, const char * currency_, long amount_, const char * crypto_currency_, long crypto_amount_, const char * url_)
{
	buf_t buf = buf_add_ui32(0x6ebdff91);
	//parse argument purchase_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(purchase_date_));
	}
	//parse argument currency (string)
	{
		buf = buf_cat(buf, serialize_string(currency_));
	}
	//parse argument amount (long)
	{
		buf = buf_cat(buf, buf_add_ui64(amount_));
	}
	//parse argument crypto_currency (string)
	{
		buf = buf_cat(buf, serialize_string(crypto_currency_));
	}
	//parse argument crypto_amount (long)
	{
		buf = buf_cat(buf, buf_add_ui64(crypto_amount_));
	}
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	return buf;
}

buf_t tl_inputBusinessBotRecipients(bool existing_chats_, bool new_chats_, bool contacts_, bool non_contacts_, bool exclude_selected_, InputUser *users_, int users_len, InputUser *exclude_users_, int exclude_users_len)
{
	buf_t buf = buf_add_ui32(0xc4e5921e);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument existing_chats (true)
	if (existing_chats_)
		*flag1 |= (1 << 0);
	//parse argument new_chats (true)
	if (new_chats_)
		*flag1 |= (1 << 1);
	//parse argument contacts (true)
	if (contacts_)
		*flag1 |= (1 << 2);
	//parse argument non_contacts (true)
	if (non_contacts_)
		*flag1 |= (1 << 3);
	//parse argument exclude_selected (true)
	if (exclude_selected_)
		*flag1 |= (1 << 5);
	//parse argument users (Vector<InputUser>)
	if (users_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
		*flag1 |= (1 << 4);
	}
	//parse argument exclude_users (Vector<InputUser>)
	if (exclude_users_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(exclude_users_len));
		int i;
		for (i=0; i<exclude_users_len; ++i){
			buf = buf_cat(buf, exclude_users_[i]);
		}
		*flag1 |= (1 << 6);
	}
	return buf;
}

buf_t tl_businessBotRecipients(bool existing_chats_, bool new_chats_, bool contacts_, bool non_contacts_, bool exclude_selected_, long *users_, int users_len, long *exclude_users_, int exclude_users_len)
{
	buf_t buf = buf_add_ui32(0xb88cf373);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument existing_chats (true)
	if (existing_chats_)
		*flag1 |= (1 << 0);
	//parse argument new_chats (true)
	if (new_chats_)
		*flag1 |= (1 << 1);
	//parse argument contacts (true)
	if (contacts_)
		*flag1 |= (1 << 2);
	//parse argument non_contacts (true)
	if (non_contacts_)
		*flag1 |= (1 << 3);
	//parse argument exclude_selected (true)
	if (exclude_selected_)
		*flag1 |= (1 << 5);
	//parse argument users (Vector<long>)
	if (users_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(users_[i]));
		}
		*flag1 |= (1 << 4);
	}
	//parse argument exclude_users (Vector<long>)
	if (exclude_users_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(exclude_users_len));
		int i;
		for (i=0; i<exclude_users_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(exclude_users_[i]));
		}
		*flag1 |= (1 << 6);
	}
	return buf;
}

buf_t tl_contactBirthday(long contact_id_, Birthday *birthday_)
{
	buf_t buf = buf_add_ui32(0x1d998733);
	//parse argument contact_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(contact_id_));
	}
	//parse argument birthday (Birthday)
	{
		buf = buf_cat(buf, *birthday_);
	}
	return buf;
}

buf_t tl_contacts_contactBirthdays(ContactBirthday *contacts_, int contacts_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x114ff30d);
	//parse argument contacts (Vector<ContactBirthday>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(contacts_len));
		int i;
		for (i=0; i<contacts_len; ++i){
			buf = buf_cat(buf, contacts_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_missingInvitee(bool premium_would_allow_invite_, bool premium_required_for_pm_, long user_id_)
{
	buf_t buf = buf_add_ui32(0x628c9224);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument premium_would_allow_invite (true)
	if (premium_would_allow_invite_)
		*flag1 |= (1 << 0);
	//parse argument premium_required_for_pm (true)
	if (premium_required_for_pm_)
		*flag1 |= (1 << 1);
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	return buf;
}

buf_t tl_messages_invitedUsers(Updates *updates_, MissingInvitee *missing_invitees_, int missing_invitees_len)
{
	buf_t buf = buf_add_ui32(0x7f5defa6);
	//parse argument updates (Updates)
	{
		buf = buf_cat(buf, *updates_);
	}
	//parse argument missing_invitees (Vector<MissingInvitee>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(missing_invitees_len));
		int i;
		for (i=0; i<missing_invitees_len; ++i){
			buf = buf_cat(buf, missing_invitees_[i]);
		}
	}
	return buf;
}

buf_t tl_inputBusinessChatLink(const char * message_, MessageEntity *entities_, int entities_len, const char * title_)
{
	buf_t buf = buf_add_ui32(0x11679fa7);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument message (string)
	{
		buf = buf_cat(buf, serialize_string(message_));
	}
	//parse argument entities (Vector<MessageEntity>)
	if (entities_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(entities_len));
		int i;
		for (i=0; i<entities_len; ++i){
			buf = buf_cat(buf, entities_[i]);
		}
		*flag1 |= (1 << 0);
	}
	//parse argument title (string)
	if (title_)
	{
		buf = buf_cat(buf, serialize_string(title_));
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_businessChatLink(const char * link_, const char * message_, MessageEntity *entities_, int entities_len, const char * title_, int views_)
{
	buf_t buf = buf_add_ui32(0xb4ae666f);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument link (string)
	{
		buf = buf_cat(buf, serialize_string(link_));
	}
	//parse argument message (string)
	{
		buf = buf_cat(buf, serialize_string(message_));
	}
	//parse argument entities (Vector<MessageEntity>)
	if (entities_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(entities_len));
		int i;
		for (i=0; i<entities_len; ++i){
			buf = buf_cat(buf, entities_[i]);
		}
		*flag1 |= (1 << 0);
	}
	//parse argument title (string)
	if (title_)
	{
		buf = buf_cat(buf, serialize_string(title_));
		*flag1 |= (1 << 1);
	}
	//parse argument views (int)
	{
		buf = buf_cat(buf, buf_add_ui32(views_));
	}
	return buf;
}

buf_t tl_account_businessChatLinks(BusinessChatLink *links_, int links_len, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0xec43a2d1);
	//parse argument links (Vector<BusinessChatLink>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(links_len));
		int i;
		for (i=0; i<links_len; ++i){
			buf = buf_cat(buf, links_[i]);
		}
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_account_resolvedBusinessChatLinks(Peer *peer_, const char * message_, MessageEntity *entities_, int entities_len, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x9a23af21);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument message (string)
	{
		buf = buf_cat(buf, serialize_string(message_));
	}
	//parse argument entities (Vector<MessageEntity>)
	if (entities_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(entities_len));
		int i;
		for (i=0; i<entities_len; ++i){
			buf = buf_cat(buf, entities_[i]);
		}
		*flag1 |= (1 << 0);
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_requestedPeerUser(long user_id_, const char * first_name_, const char * last_name_, const char * username_, Photo *photo_)
{
	buf_t buf = buf_add_ui32(0xd62ff46a);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument user_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(user_id_));
	}
	//parse argument first_name (string)
	if (first_name_)
	{
		buf = buf_cat(buf, serialize_string(first_name_));
		*flag1 |= (1 << 0);
	}
	//parse argument last_name (string)
	if (last_name_)
	{
		buf = buf_cat(buf, serialize_string(last_name_));
		*flag1 |= (1 << 0);
	}
	//parse argument username (string)
	if (username_)
	{
		buf = buf_cat(buf, serialize_string(username_));
		*flag1 |= (1 << 1);
	}
	//parse argument photo (Photo)
	if (photo_)
	{
		buf = buf_cat(buf, *photo_);
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_requestedPeerChat(long chat_id_, const char * title_, Photo *photo_)
{
	buf_t buf = buf_add_ui32(0x7307544f);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument chat_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(chat_id_));
	}
	//parse argument title (string)
	if (title_)
	{
		buf = buf_cat(buf, serialize_string(title_));
		*flag1 |= (1 << 0);
	}
	//parse argument photo (Photo)
	if (photo_)
	{
		buf = buf_cat(buf, *photo_);
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_requestedPeerChannel(long channel_id_, const char * title_, const char * username_, Photo *photo_)
{
	buf_t buf = buf_add_ui32(0x8ba403e4);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument channel_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(channel_id_));
	}
	//parse argument title (string)
	if (title_)
	{
		buf = buf_cat(buf, serialize_string(title_));
		*flag1 |= (1 << 0);
	}
	//parse argument username (string)
	if (username_)
	{
		buf = buf_cat(buf, serialize_string(username_));
		*flag1 |= (1 << 1);
	}
	//parse argument photo (Photo)
	if (photo_)
	{
		buf = buf_cat(buf, *photo_);
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_sponsoredMessageReportOption(const char * text_, buf_t *option_)
{
	buf_t buf = buf_add_ui32(0x430d3150);
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	//parse argument option (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(option_->data, option_->size));
	}
	return buf;
}

buf_t tl_channels_sponsoredMessageReportResultChooseOption(const char * title_, SponsoredMessageReportOption *options_, int options_len)
{
	buf_t buf = buf_add_ui32(0x846f9e42);
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument options (Vector<SponsoredMessageReportOption>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(options_len));
		int i;
		for (i=0; i<options_len; ++i){
			buf = buf_cat(buf, options_[i]);
		}
	}
	return buf;
}

buf_t tl_channels_sponsoredMessageReportResultAdsHidden()
{
	buf_t buf = buf_add_ui32(0x3e3bcf2f);
	return buf;
}

buf_t tl_channels_sponsoredMessageReportResultReported()
{
	buf_t buf = buf_add_ui32(0xad798849);
	return buf;
}

buf_t tl_stats_broadcastRevenueStats(StatsGraph *top_hours_graph_, StatsGraph *revenue_graph_, BroadcastRevenueBalances *balances_, double usd_rate_)
{
	buf_t buf = buf_add_ui32(0x5407e297);
	//parse argument top_hours_graph (StatsGraph)
	{
		buf = buf_cat(buf, *top_hours_graph_);
	}
	//parse argument revenue_graph (StatsGraph)
	{
		buf = buf_cat(buf, *revenue_graph_);
	}
	//parse argument balances (BroadcastRevenueBalances)
	{
		buf = buf_cat(buf, *balances_);
	}
	//parse argument usd_rate (double)
	{
		buf = buf_cat(buf, buf_add_ui64(usd_rate_));
	}
	return buf;
}

buf_t tl_stats_broadcastRevenueWithdrawalUrl(const char * url_)
{
	buf_t buf = buf_add_ui32(0xec659737);
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	return buf;
}

buf_t tl_broadcastRevenueTransactionProceeds(long amount_, int from_date_, int to_date_)
{
	buf_t buf = buf_add_ui32(0x557e2cc4);
	//parse argument amount (long)
	{
		buf = buf_cat(buf, buf_add_ui64(amount_));
	}
	//parse argument from_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(from_date_));
	}
	//parse argument to_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(to_date_));
	}
	return buf;
}

buf_t tl_broadcastRevenueTransactionWithdrawal(bool pending_, bool failed_, long amount_, int date_, const char * provider_, int transaction_date_, const char * transaction_url_)
{
	buf_t buf = buf_add_ui32(0x5a590978);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument pending (true)
	if (pending_)
		*flag1 |= (1 << 0);
	//parse argument failed (true)
	if (failed_)
		*flag1 |= (1 << 2);
	//parse argument amount (long)
	{
		buf = buf_cat(buf, buf_add_ui64(amount_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument provider (string)
	{
		buf = buf_cat(buf, serialize_string(provider_));
	}
	//parse argument transaction_date (int)
	if (transaction_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(transaction_date_));
		*flag1 |= (1 << 1);
	}
	//parse argument transaction_url (string)
	if (transaction_url_)
	{
		buf = buf_cat(buf, serialize_string(transaction_url_));
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_broadcastRevenueTransactionRefund(long amount_, int date_, const char * provider_)
{
	buf_t buf = buf_add_ui32(0x42d30d2e);
	//parse argument amount (long)
	{
		buf = buf_cat(buf, buf_add_ui64(amount_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument provider (string)
	{
		buf = buf_cat(buf, serialize_string(provider_));
	}
	return buf;
}

buf_t tl_stats_broadcastRevenueTransactions(int count_, BroadcastRevenueTransaction *transactions_, int transactions_len)
{
	buf_t buf = buf_add_ui32(0x87158466);
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	//parse argument transactions (Vector<BroadcastRevenueTransaction>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(transactions_len));
		int i;
		for (i=0; i<transactions_len; ++i){
			buf = buf_cat(buf, transactions_[i]);
		}
	}
	return buf;
}

buf_t tl_reactionNotificationsFromContacts()
{
	buf_t buf = buf_add_ui32(0xbac3a61a);
	return buf;
}

buf_t tl_reactionNotificationsFromAll()
{
	buf_t buf = buf_add_ui32(0x4b9e22a0);
	return buf;
}

buf_t tl_reactionsNotifySettings(ReactionNotificationsFrom *messages_notify_from_, ReactionNotificationsFrom *stories_notify_from_, NotificationSound *sound_, Bool *show_previews_)
{
	buf_t buf = buf_add_ui32(0x56e34970);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument messages_notify_from (ReactionNotificationsFrom)
	if (messages_notify_from_)
	{
		buf = buf_cat(buf, *messages_notify_from_);
		*flag1 |= (1 << 0);
	}
	//parse argument stories_notify_from (ReactionNotificationsFrom)
	if (stories_notify_from_)
	{
		buf = buf_cat(buf, *stories_notify_from_);
		*flag1 |= (1 << 1);
	}
	//parse argument sound (NotificationSound)
	{
		buf = buf_cat(buf, *sound_);
	}
	//parse argument show_previews (Bool)
	{
		buf = buf_cat(buf, *show_previews_);
	}
	return buf;
}

buf_t tl_broadcastRevenueBalances(bool withdrawal_enabled_, long current_balance_, long available_balance_, long overall_revenue_)
{
	buf_t buf = buf_add_ui32(0xc3ff71e7);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument withdrawal_enabled (true)
	if (withdrawal_enabled_)
		*flag1 |= (1 << 0);
	//parse argument current_balance (long)
	{
		buf = buf_cat(buf, buf_add_ui64(current_balance_));
	}
	//parse argument available_balance (long)
	{
		buf = buf_cat(buf, buf_add_ui64(available_balance_));
	}
	//parse argument overall_revenue (long)
	{
		buf = buf_cat(buf, buf_add_ui64(overall_revenue_));
	}
	return buf;
}

buf_t tl_availableEffect(bool premium_required_, long id_, const char * emoticon_, long static_icon_id_, long effect_sticker_id_, long effect_animation_id_)
{
	buf_t buf = buf_add_ui32(0x93c3e27e);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument premium_required (true)
	if (premium_required_)
		*flag1 |= (1 << 2);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument emoticon (string)
	{
		buf = buf_cat(buf, serialize_string(emoticon_));
	}
	//parse argument static_icon_id (long)
	if (static_icon_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(static_icon_id_));
		*flag1 |= (1 << 0);
	}
	//parse argument effect_sticker_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(effect_sticker_id_));
	}
	//parse argument effect_animation_id (long)
	if (effect_animation_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(effect_animation_id_));
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_messages_availableEffectsNotModified()
{
	buf_t buf = buf_add_ui32(0xd1ed9a5b);
	return buf;
}

buf_t tl_messages_availableEffects(int hash_, AvailableEffect *effects_, int effects_len, Document *documents_, int documents_len)
{
	buf_t buf = buf_add_ui32(0xbddb616e);
	//parse argument hash (int)
	{
		buf = buf_cat(buf, buf_add_ui32(hash_));
	}
	//parse argument effects (Vector<AvailableEffect>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(effects_len));
		int i;
		for (i=0; i<effects_len; ++i){
			buf = buf_cat(buf, effects_[i]);
		}
	}
	//parse argument documents (Vector<Document>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(documents_len));
		int i;
		for (i=0; i<documents_len; ++i){
			buf = buf_cat(buf, documents_[i]);
		}
	}
	return buf;
}

buf_t tl_factCheck(bool need_check_, const char * country_, TextWithEntities *text_, long hash_)
{
	buf_t buf = buf_add_ui32(0xb89bfccf);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument need_check (true)
	if (need_check_)
		*flag1 |= (1 << 0);
	//parse argument country (string)
	if (country_)
	{
		buf = buf_cat(buf, serialize_string(country_));
		*flag1 |= (1 << 1);
	}
	//parse argument text (TextWithEntities)
	if (text_)
	{
		buf = buf_cat(buf, *text_);
		*flag1 |= (1 << 1);
	}
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_starsTransactionPeerUnsupported()
{
	buf_t buf = buf_add_ui32(0x95f2bfe4);
	return buf;
}

buf_t tl_starsTransactionPeerAppStore()
{
	buf_t buf = buf_add_ui32(0xb457b375);
	return buf;
}

buf_t tl_starsTransactionPeerPlayMarket()
{
	buf_t buf = buf_add_ui32(0x7b560a0b);
	return buf;
}

buf_t tl_starsTransactionPeerPremiumBot()
{
	buf_t buf = buf_add_ui32(0x250dbaf8);
	return buf;
}

buf_t tl_starsTransactionPeerFragment()
{
	buf_t buf = buf_add_ui32(0xe92fd902);
	return buf;
}

buf_t tl_starsTransactionPeer(Peer *peer_)
{
	buf_t buf = buf_add_ui32(0xd80da15d);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_starsTransactionPeerAds()
{
	buf_t buf = buf_add_ui32(0x60682812);
	return buf;
}

buf_t tl_starsTopupOption(bool extended_, long stars_, const char * store_product_, const char * currency_, long amount_)
{
	buf_t buf = buf_add_ui32(0x0bd915c0);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument extended (true)
	if (extended_)
		*flag1 |= (1 << 1);
	//parse argument stars (long)
	{
		buf = buf_cat(buf, buf_add_ui64(stars_));
	}
	//parse argument store_product (string)
	if (store_product_)
	{
		buf = buf_cat(buf, serialize_string(store_product_));
		*flag1 |= (1 << 0);
	}
	//parse argument currency (string)
	{
		buf = buf_cat(buf, serialize_string(currency_));
	}
	//parse argument amount (long)
	{
		buf = buf_cat(buf, buf_add_ui64(amount_));
	}
	return buf;
}

buf_t tl_starsTransaction(bool refund_, bool pending_, bool failed_, bool gift_, bool reaction_, const char * id_, long stars_, int date_, StarsTransactionPeer *peer_, const char * title_, const char * description_, WebDocument *photo_, int transaction_date_, const char * transaction_url_, buf_t *bot_payload_, int msg_id_, MessageMedia *extended_media_, int extended_media_len, int subscription_period_, int giveaway_post_id_, StarGift *stargift_)
{
	buf_t buf = buf_add_ui32(0x0a9ee4c2);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument refund (true)
	if (refund_)
		*flag1 |= (1 << 3);
	//parse argument pending (true)
	if (pending_)
		*flag1 |= (1 << 4);
	//parse argument failed (true)
	if (failed_)
		*flag1 |= (1 << 6);
	//parse argument gift (true)
	if (gift_)
		*flag1 |= (1 << 10);
	//parse argument reaction (true)
	if (reaction_)
		*flag1 |= (1 << 11);
	//parse argument id (string)
	{
		buf = buf_cat(buf, serialize_string(id_));
	}
	//parse argument stars (long)
	{
		buf = buf_cat(buf, buf_add_ui64(stars_));
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument peer (StarsTransactionPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument title (string)
	if (title_)
	{
		buf = buf_cat(buf, serialize_string(title_));
		*flag1 |= (1 << 0);
	}
	//parse argument description (string)
	if (description_)
	{
		buf = buf_cat(buf, serialize_string(description_));
		*flag1 |= (1 << 1);
	}
	//parse argument photo (WebDocument)
	if (photo_)
	{
		buf = buf_cat(buf, *photo_);
		*flag1 |= (1 << 2);
	}
	//parse argument transaction_date (int)
	if (transaction_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(transaction_date_));
		*flag1 |= (1 << 5);
	}
	//parse argument transaction_url (string)
	if (transaction_url_)
	{
		buf = buf_cat(buf, serialize_string(transaction_url_));
		*flag1 |= (1 << 5);
	}
	//parse argument bot_payload (bytes)
	if (bot_payload_)
	{
		buf = buf_cat(buf, serialize_bytes(bot_payload_->data, bot_payload_->size));
		*flag1 |= (1 << 7);
	}
	//parse argument msg_id (int)
	if (msg_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
		*flag1 |= (1 << 8);
	}
	//parse argument extended_media (Vector<MessageMedia>)
	if (extended_media_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(extended_media_len));
		int i;
		for (i=0; i<extended_media_len; ++i){
			buf = buf_cat(buf, extended_media_[i]);
		}
		*flag1 |= (1 << 9);
	}
	//parse argument subscription_period (int)
	if (subscription_period_)
	{
		buf = buf_cat(buf, buf_add_ui32(subscription_period_));
		*flag1 |= (1 << 12);
	}
	//parse argument giveaway_post_id (int)
	if (giveaway_post_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(giveaway_post_id_));
		*flag1 |= (1 << 13);
	}
	//parse argument stargift (StarGift)
	if (stargift_)
	{
		buf = buf_cat(buf, *stargift_);
		*flag1 |= (1 << 14);
	}
	return buf;
}

buf_t tl_payments_starsStatus(long balance_, StarsSubscription *subscriptions_, int subscriptions_len, const char * subscriptions_next_offset_, long subscriptions_missing_balance_, StarsTransaction *history_, int history_len, const char * next_offset_, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0xbbfa316c);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument balance (long)
	{
		buf = buf_cat(buf, buf_add_ui64(balance_));
	}
	//parse argument subscriptions (Vector<StarsSubscription>)
	if (subscriptions_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(subscriptions_len));
		int i;
		for (i=0; i<subscriptions_len; ++i){
			buf = buf_cat(buf, subscriptions_[i]);
		}
		*flag1 |= (1 << 1);
	}
	//parse argument subscriptions_next_offset (string)
	if (subscriptions_next_offset_)
	{
		buf = buf_cat(buf, serialize_string(subscriptions_next_offset_));
		*flag1 |= (1 << 2);
	}
	//parse argument subscriptions_missing_balance (long)
	if (subscriptions_missing_balance_)
	{
		buf = buf_cat(buf, buf_add_ui64(subscriptions_missing_balance_));
		*flag1 |= (1 << 4);
	}
	//parse argument history (Vector<StarsTransaction>)
	if (history_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(history_len));
		int i;
		for (i=0; i<history_len; ++i){
			buf = buf_cat(buf, history_[i]);
		}
		*flag1 |= (1 << 3);
	}
	//parse argument next_offset (string)
	if (next_offset_)
	{
		buf = buf_cat(buf, serialize_string(next_offset_));
		*flag1 |= (1 << 0);
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_foundStory(Peer *peer_, StoryItem *story_)
{
	buf_t buf = buf_add_ui32(0xe87acbc0);
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument story (StoryItem)
	{
		buf = buf_cat(buf, *story_);
	}
	return buf;
}

buf_t tl_stories_foundStories(int count_, FoundStory *stories_, int stories_len, const char * next_offset_, Chat *chats_, int chats_len, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0xe2de7737);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	//parse argument stories (Vector<FoundStory>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(stories_len));
		int i;
		for (i=0; i<stories_len; ++i){
			buf = buf_cat(buf, stories_[i]);
		}
	}
	//parse argument next_offset (string)
	if (next_offset_)
	{
		buf = buf_cat(buf, serialize_string(next_offset_));
		*flag1 |= (1 << 0);
	}
	//parse argument chats (Vector<Chat>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(chats_len));
		int i;
		for (i=0; i<chats_len; ++i){
			buf = buf_cat(buf, chats_[i]);
		}
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_geoPointAddress(const char * country_iso2_, const char * state_, const char * city_, const char * street_)
{
	buf_t buf = buf_add_ui32(0xde4c5d93);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument country_iso2 (string)
	{
		buf = buf_cat(buf, serialize_string(country_iso2_));
	}
	//parse argument state (string)
	if (state_)
	{
		buf = buf_cat(buf, serialize_string(state_));
		*flag1 |= (1 << 0);
	}
	//parse argument city (string)
	if (city_)
	{
		buf = buf_cat(buf, serialize_string(city_));
		*flag1 |= (1 << 1);
	}
	//parse argument street (string)
	if (street_)
	{
		buf = buf_cat(buf, serialize_string(street_));
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_starsRevenueStatus(bool withdrawal_enabled_, long current_balance_, long available_balance_, long overall_revenue_, int next_withdrawal_at_)
{
	buf_t buf = buf_add_ui32(0x79342946);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument withdrawal_enabled (true)
	if (withdrawal_enabled_)
		*flag1 |= (1 << 0);
	//parse argument current_balance (long)
	{
		buf = buf_cat(buf, buf_add_ui64(current_balance_));
	}
	//parse argument available_balance (long)
	{
		buf = buf_cat(buf, buf_add_ui64(available_balance_));
	}
	//parse argument overall_revenue (long)
	{
		buf = buf_cat(buf, buf_add_ui64(overall_revenue_));
	}
	//parse argument next_withdrawal_at (int)
	if (next_withdrawal_at_)
	{
		buf = buf_cat(buf, buf_add_ui32(next_withdrawal_at_));
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_payments_starsRevenueStats(StatsGraph *revenue_graph_, StarsRevenueStatus *status_, double usd_rate_)
{
	buf_t buf = buf_add_ui32(0xc92bb73b);
	//parse argument revenue_graph (StatsGraph)
	{
		buf = buf_cat(buf, *revenue_graph_);
	}
	//parse argument status (StarsRevenueStatus)
	{
		buf = buf_cat(buf, *status_);
	}
	//parse argument usd_rate (double)
	{
		buf = buf_cat(buf, buf_add_ui64(usd_rate_));
	}
	return buf;
}

buf_t tl_payments_starsRevenueWithdrawalUrl(const char * url_)
{
	buf_t buf = buf_add_ui32(0x1dab80b7);
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	return buf;
}

buf_t tl_payments_starsRevenueAdsAccountUrl(const char * url_)
{
	buf_t buf = buf_add_ui32(0x394e7f21);
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	return buf;
}

buf_t tl_inputStarsTransaction(bool refund_, const char * id_)
{
	buf_t buf = buf_add_ui32(0x206ae6d1);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument refund (true)
	if (refund_)
		*flag1 |= (1 << 0);
	//parse argument id (string)
	{
		buf = buf_cat(buf, serialize_string(id_));
	}
	return buf;
}

buf_t tl_starsGiftOption(bool extended_, long stars_, const char * store_product_, const char * currency_, long amount_)
{
	buf_t buf = buf_add_ui32(0x5e0589f1);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument extended (true)
	if (extended_)
		*flag1 |= (1 << 1);
	//parse argument stars (long)
	{
		buf = buf_cat(buf, buf_add_ui64(stars_));
	}
	//parse argument store_product (string)
	if (store_product_)
	{
		buf = buf_cat(buf, serialize_string(store_product_));
		*flag1 |= (1 << 0);
	}
	//parse argument currency (string)
	{
		buf = buf_cat(buf, serialize_string(currency_));
	}
	//parse argument amount (long)
	{
		buf = buf_cat(buf, buf_add_ui64(amount_));
	}
	return buf;
}

buf_t tl_bots_popularAppBots(const char * next_offset_, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x1991b13b);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument next_offset (string)
	if (next_offset_)
	{
		buf = buf_cat(buf, serialize_string(next_offset_));
		*flag1 |= (1 << 0);
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_botPreviewMedia(int date_, MessageMedia *media_)
{
	buf_t buf = buf_add_ui32(0x23e91ba3);
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument media (MessageMedia)
	{
		buf = buf_cat(buf, *media_);
	}
	return buf;
}

buf_t tl_bots_previewInfo(BotPreviewMedia *media_, int media_len, const char * *lang_codes_, int lang_codes_len)
{
	buf_t buf = buf_add_ui32(0x0ca71d64);
	//parse argument media (Vector<BotPreviewMedia>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(media_len));
		int i;
		for (i=0; i<media_len; ++i){
			buf = buf_cat(buf, media_[i]);
		}
	}
	//parse argument lang_codes (Vector<string>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(lang_codes_len));
		int i;
		for (i=0; i<lang_codes_len; ++i){
			buf = buf_cat(buf, serialize_string(lang_codes_[i]));
		}
	}
	return buf;
}

buf_t tl_starsSubscriptionPricing(int period_, long amount_)
{
	buf_t buf = buf_add_ui32(0x05416d58);
	//parse argument period (int)
	{
		buf = buf_cat(buf, buf_add_ui32(period_));
	}
	//parse argument amount (long)
	{
		buf = buf_cat(buf, buf_add_ui64(amount_));
	}
	return buf;
}

buf_t tl_starsSubscription(bool canceled_, bool can_refulfill_, bool missing_balance_, const char * id_, Peer *peer_, int until_date_, StarsSubscriptionPricing *pricing_, const char * chat_invite_hash_)
{
	buf_t buf = buf_add_ui32(0x538ecf18);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument canceled (true)
	if (canceled_)
		*flag1 |= (1 << 0);
	//parse argument can_refulfill (true)
	if (can_refulfill_)
		*flag1 |= (1 << 1);
	//parse argument missing_balance (true)
	if (missing_balance_)
		*flag1 |= (1 << 2);
	//parse argument id (string)
	{
		buf = buf_cat(buf, serialize_string(id_));
	}
	//parse argument peer (Peer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument until_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(until_date_));
	}
	//parse argument pricing (StarsSubscriptionPricing)
	{
		buf = buf_cat(buf, *pricing_);
	}
	//parse argument chat_invite_hash (string)
	if (chat_invite_hash_)
	{
		buf = buf_cat(buf, serialize_string(chat_invite_hash_));
		*flag1 |= (1 << 3);
	}
	return buf;
}

buf_t tl_messageReactor(bool top_, bool my_, bool anonymous_, Peer *peer_id_, int count_)
{
	buf_t buf = buf_add_ui32(0x4ba3a95a);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument top (true)
	if (top_)
		*flag1 |= (1 << 0);
	//parse argument my (true)
	if (my_)
		*flag1 |= (1 << 1);
	//parse argument anonymous (true)
	if (anonymous_)
		*flag1 |= (1 << 2);
	//parse argument peer_id (Peer)
	if (peer_id_)
	{
		buf = buf_cat(buf, *peer_id_);
		*flag1 |= (1 << 3);
	}
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	return buf;
}

buf_t tl_starsGiveawayOption(bool extended_, bool default_, long stars_, int yearly_boosts_, const char * store_product_, const char * currency_, long amount_, StarsGiveawayWinnersOption *winners_, int winners_len)
{
	buf_t buf = buf_add_ui32(0x94ce852a);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument extended (true)
	if (extended_)
		*flag1 |= (1 << 0);
	//parse argument default (true)
	if (default_)
		*flag1 |= (1 << 1);
	//parse argument stars (long)
	{
		buf = buf_cat(buf, buf_add_ui64(stars_));
	}
	//parse argument yearly_boosts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(yearly_boosts_));
	}
	//parse argument store_product (string)
	if (store_product_)
	{
		buf = buf_cat(buf, serialize_string(store_product_));
		*flag1 |= (1 << 2);
	}
	//parse argument currency (string)
	{
		buf = buf_cat(buf, serialize_string(currency_));
	}
	//parse argument amount (long)
	{
		buf = buf_cat(buf, buf_add_ui64(amount_));
	}
	//parse argument winners (Vector<StarsGiveawayWinnersOption>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(winners_len));
		int i;
		for (i=0; i<winners_len; ++i){
			buf = buf_cat(buf, winners_[i]);
		}
	}
	return buf;
}

buf_t tl_starsGiveawayWinnersOption(bool default_, int users_, long per_user_stars_)
{
	buf_t buf = buf_add_ui32(0x54236209);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument default (true)
	if (default_)
		*flag1 |= (1 << 0);
	//parse argument users (int)
	{
		buf = buf_cat(buf, buf_add_ui32(users_));
	}
	//parse argument per_user_stars (long)
	{
		buf = buf_cat(buf, buf_add_ui64(per_user_stars_));
	}
	return buf;
}

buf_t tl_starGift(bool limited_, long id_, Document *sticker_, long stars_, int availability_remains_, int availability_total_, long convert_stars_)
{
	buf_t buf = buf_add_ui32(0xaea174ee);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument limited (true)
	if (limited_)
		*flag1 |= (1 << 0);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument sticker (Document)
	{
		buf = buf_cat(buf, *sticker_);
	}
	//parse argument stars (long)
	{
		buf = buf_cat(buf, buf_add_ui64(stars_));
	}
	//parse argument availability_remains (int)
	if (availability_remains_)
	{
		buf = buf_cat(buf, buf_add_ui32(availability_remains_));
		*flag1 |= (1 << 0);
	}
	//parse argument availability_total (int)
	if (availability_total_)
	{
		buf = buf_cat(buf, buf_add_ui32(availability_total_));
		*flag1 |= (1 << 0);
	}
	//parse argument convert_stars (long)
	{
		buf = buf_cat(buf, buf_add_ui64(convert_stars_));
	}
	return buf;
}

buf_t tl_payments_starGiftsNotModified()
{
	buf_t buf = buf_add_ui32(0xa388a368);
	return buf;
}

buf_t tl_payments_starGifts(int hash_, StarGift *gifts_, int gifts_len)
{
	buf_t buf = buf_add_ui32(0x901689ea);
	//parse argument hash (int)
	{
		buf = buf_cat(buf, buf_add_ui32(hash_));
	}
	//parse argument gifts (Vector<StarGift>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(gifts_len));
		int i;
		for (i=0; i<gifts_len; ++i){
			buf = buf_cat(buf, gifts_[i]);
		}
	}
	return buf;
}

buf_t tl_userStarGift(bool name_hidden_, bool unsaved_, long from_id_, int date_, StarGift *gift_, TextWithEntities *message_, int msg_id_, long convert_stars_)
{
	buf_t buf = buf_add_ui32(0xeea49a6e);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument name_hidden (true)
	if (name_hidden_)
		*flag1 |= (1 << 0);
	//parse argument unsaved (true)
	if (unsaved_)
		*flag1 |= (1 << 5);
	//parse argument from_id (long)
	if (from_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(from_id_));
		*flag1 |= (1 << 1);
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument gift (StarGift)
	{
		buf = buf_cat(buf, *gift_);
	}
	//parse argument message (TextWithEntities)
	if (message_)
	{
		buf = buf_cat(buf, *message_);
		*flag1 |= (1 << 2);
	}
	//parse argument msg_id (int)
	if (msg_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
		*flag1 |= (1 << 3);
	}
	//parse argument convert_stars (long)
	if (convert_stars_)
	{
		buf = buf_cat(buf, buf_add_ui64(convert_stars_));
		*flag1 |= (1 << 4);
	}
	return buf;
}

buf_t tl_payments_userStarGifts(int count_, UserStarGift *gifts_, int gifts_len, const char * next_offset_, User *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x6b65b517);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	//parse argument gifts (Vector<UserStarGift>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(gifts_len));
		int i;
		for (i=0; i<gifts_len; ++i){
			buf = buf_cat(buf, gifts_[i]);
		}
	}
	//parse argument next_offset (string)
	if (next_offset_)
	{
		buf = buf_cat(buf, serialize_string(next_offset_));
		*flag1 |= (1 << 0);
	}
	//parse argument users (Vector<User>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_messageReportOption(const char * text_, buf_t *option_)
{
	buf_t buf = buf_add_ui32(0x7903e3d9);
	//parse argument text (string)
	{
		buf = buf_cat(buf, serialize_string(text_));
	}
	//parse argument option (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(option_->data, option_->size));
	}
	return buf;
}

buf_t tl_reportResultChooseOption(const char * title_, MessageReportOption *options_, int options_len)
{
	buf_t buf = buf_add_ui32(0xf0e4e0b6);
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument options (Vector<MessageReportOption>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(options_len));
		int i;
		for (i=0; i<options_len; ++i){
			buf = buf_cat(buf, options_[i]);
		}
	}
	return buf;
}

buf_t tl_reportResultAddComment(bool optional_, buf_t *option_)
{
	buf_t buf = buf_add_ui32(0x6f09ac31);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument optional (true)
	if (optional_)
		*flag1 |= (1 << 0);
	//parse argument option (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(option_->data, option_->size));
	}
	return buf;
}

buf_t tl_reportResultReported()
{
	buf_t buf = buf_add_ui32(0x8db33c4b);
	return buf;
}

buf_t tl_invokeAfterMsg(long msg_id_, X *query_)
{
	buf_t buf = buf_add_ui32(0xcb9f372d);
	//parse argument msg_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(msg_id_));
	}
	//parse argument query (!X)
	{
		buf = buf_cat(buf, *query_);
	}
	return buf;
}

buf_t tl_invokeAfterMsgs(long *msg_ids_, int msg_ids_len, X *query_)
{
	buf_t buf = buf_add_ui32(0x3dc4b4f0);
	//parse argument msg_ids (Vector<long>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(msg_ids_len));
		int i;
		for (i=0; i<msg_ids_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(msg_ids_[i]));
		}
	}
	//parse argument query (!X)
	{
		buf = buf_cat(buf, *query_);
	}
	return buf;
}

buf_t tl_initConnection(int api_id_, const char * device_model_, const char * system_version_, const char * app_version_, const char * system_lang_code_, const char * lang_pack_, const char * lang_code_, InputClientProxy *proxy_, JSONValue *params_, X *query_)
{
	buf_t buf = buf_add_ui32(0xc1cd5ea9);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument api_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(api_id_));
	}
	//parse argument device_model (string)
	{
		buf = buf_cat(buf, serialize_string(device_model_));
	}
	//parse argument system_version (string)
	{
		buf = buf_cat(buf, serialize_string(system_version_));
	}
	//parse argument app_version (string)
	{
		buf = buf_cat(buf, serialize_string(app_version_));
	}
	//parse argument system_lang_code (string)
	{
		buf = buf_cat(buf, serialize_string(system_lang_code_));
	}
	//parse argument lang_pack (string)
	{
		buf = buf_cat(buf, serialize_string(lang_pack_));
	}
	//parse argument lang_code (string)
	{
		buf = buf_cat(buf, serialize_string(lang_code_));
	}
	//parse argument proxy (InputClientProxy)
	if (proxy_)
	{
		buf = buf_cat(buf, *proxy_);
		*flag1 |= (1 << 0);
	}
	//parse argument params (JSONValue)
	if (params_)
	{
		buf = buf_cat(buf, *params_);
		*flag1 |= (1 << 1);
	}
	//parse argument query (!X)
	{
		buf = buf_cat(buf, *query_);
	}
	return buf;
}

buf_t tl_invokeWithLayer(int layer_, X *query_)
{
	buf_t buf = buf_add_ui32(0xda9b0d0d);
	//parse argument layer (int)
	{
		buf = buf_cat(buf, buf_add_ui32(layer_));
	}
	//parse argument query (!X)
	{
		buf = buf_cat(buf, *query_);
	}
	return buf;
}

buf_t tl_invokeWithoutUpdates(X *query_)
{
	buf_t buf = buf_add_ui32(0xbf9459b7);
	//parse argument query (!X)
	{
		buf = buf_cat(buf, *query_);
	}
	return buf;
}

buf_t tl_invokeWithMessagesRange(MessageRange *range_, X *query_)
{
	buf_t buf = buf_add_ui32(0x365275f2);
	//parse argument range (MessageRange)
	{
		buf = buf_cat(buf, *range_);
	}
	//parse argument query (!X)
	{
		buf = buf_cat(buf, *query_);
	}
	return buf;
}

buf_t tl_invokeWithTakeout(long takeout_id_, X *query_)
{
	buf_t buf = buf_add_ui32(0xaca9fd2e);
	//parse argument takeout_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(takeout_id_));
	}
	//parse argument query (!X)
	{
		buf = buf_cat(buf, *query_);
	}
	return buf;
}

buf_t tl_invokeWithBusinessConnection(const char * connection_id_, X *query_)
{
	buf_t buf = buf_add_ui32(0xdd289f8e);
	//parse argument connection_id (string)
	{
		buf = buf_cat(buf, serialize_string(connection_id_));
	}
	//parse argument query (!X)
	{
		buf = buf_cat(buf, *query_);
	}
	return buf;
}

buf_t tl_invokeWithGooglePlayIntegrity(const char * nonce_, const char * token_, X *query_)
{
	buf_t buf = buf_add_ui32(0x1df92984);
	//parse argument nonce (string)
	{
		buf = buf_cat(buf, serialize_string(nonce_));
	}
	//parse argument token (string)
	{
		buf = buf_cat(buf, serialize_string(token_));
	}
	//parse argument query (!X)
	{
		buf = buf_cat(buf, *query_);
	}
	return buf;
}

buf_t tl_invokeWithApnsSecret(const char * nonce_, const char * secret_, X *query_)
{
	buf_t buf = buf_add_ui32(0x0dae54f8);
	//parse argument nonce (string)
	{
		buf = buf_cat(buf, serialize_string(nonce_));
	}
	//parse argument secret (string)
	{
		buf = buf_cat(buf, serialize_string(secret_));
	}
	//parse argument query (!X)
	{
		buf = buf_cat(buf, *query_);
	}
	return buf;
}

buf_t tl_auth_sendCode(const char * phone_number_, int api_id_, const char * api_hash_, CodeSettings *settings_)
{
	buf_t buf = buf_add_ui32(0xa677244f);
	//parse argument phone_number (string)
	{
		buf = buf_cat(buf, serialize_string(phone_number_));
	}
	//parse argument api_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(api_id_));
	}
	//parse argument api_hash (string)
	{
		buf = buf_cat(buf, serialize_string(api_hash_));
	}
	//parse argument settings (CodeSettings)
	{
		buf = buf_cat(buf, *settings_);
	}
	return buf;
}

buf_t tl_auth_signUp(bool no_joined_notifications_, const char * phone_number_, const char * phone_code_hash_, const char * first_name_, const char * last_name_)
{
	buf_t buf = buf_add_ui32(0xaac7b717);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument no_joined_notifications (true)
	if (no_joined_notifications_)
		*flag1 |= (1 << 0);
	//parse argument phone_number (string)
	{
		buf = buf_cat(buf, serialize_string(phone_number_));
	}
	//parse argument phone_code_hash (string)
	{
		buf = buf_cat(buf, serialize_string(phone_code_hash_));
	}
	//parse argument first_name (string)
	{
		buf = buf_cat(buf, serialize_string(first_name_));
	}
	//parse argument last_name (string)
	{
		buf = buf_cat(buf, serialize_string(last_name_));
	}
	return buf;
}

buf_t tl_auth_signIn(const char * phone_number_, const char * phone_code_hash_, const char * phone_code_, EmailVerification *email_verification_)
{
	buf_t buf = buf_add_ui32(0x8d52a951);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument phone_number (string)
	{
		buf = buf_cat(buf, serialize_string(phone_number_));
	}
	//parse argument phone_code_hash (string)
	{
		buf = buf_cat(buf, serialize_string(phone_code_hash_));
	}
	//parse argument phone_code (string)
	if (phone_code_)
	{
		buf = buf_cat(buf, serialize_string(phone_code_));
		*flag1 |= (1 << 0);
	}
	//parse argument email_verification (EmailVerification)
	if (email_verification_)
	{
		buf = buf_cat(buf, *email_verification_);
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_auth_logOut()
{
	buf_t buf = buf_add_ui32(0x3e72ba19);
	return buf;
}

buf_t tl_auth_resetAuthorizations()
{
	buf_t buf = buf_add_ui32(0x9fab0d1a);
	return buf;
}

buf_t tl_auth_exportAuthorization(int dc_id_)
{
	buf_t buf = buf_add_ui32(0xe5bfffcd);
	//parse argument dc_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(dc_id_));
	}
	return buf;
}

buf_t tl_auth_importAuthorization(long id_, buf_t *bytes_)
{
	buf_t buf = buf_add_ui32(0xa57a7dad);
	//parse argument id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(id_));
	}
	//parse argument bytes (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(bytes_->data, bytes_->size));
	}
	return buf;
}

buf_t tl_auth_bindTempAuthKey(long perm_auth_key_id_, long nonce_, int expires_at_, buf_t *encrypted_message_)
{
	buf_t buf = buf_add_ui32(0xcdd42a05);
	//parse argument perm_auth_key_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(perm_auth_key_id_));
	}
	//parse argument nonce (long)
	{
		buf = buf_cat(buf, buf_add_ui64(nonce_));
	}
	//parse argument expires_at (int)
	{
		buf = buf_cat(buf, buf_add_ui32(expires_at_));
	}
	//parse argument encrypted_message (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(encrypted_message_->data, encrypted_message_->size));
	}
	return buf;
}

buf_t tl_auth_importBotAuthorization(int flags_, int api_id_, const char * api_hash_, const char * bot_auth_token_)
{
	buf_t buf = buf_add_ui32(0x67a3ff2c);
	//parse argument flags (int)
	{
		buf = buf_cat(buf, buf_add_ui32(flags_));
	}
	//parse argument api_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(api_id_));
	}
	//parse argument api_hash (string)
	{
		buf = buf_cat(buf, serialize_string(api_hash_));
	}
	//parse argument bot_auth_token (string)
	{
		buf = buf_cat(buf, serialize_string(bot_auth_token_));
	}
	return buf;
}

buf_t tl_auth_checkPassword(InputCheckPasswordSRP *password_)
{
	buf_t buf = buf_add_ui32(0xd18b4d16);
	//parse argument password (InputCheckPasswordSRP)
	{
		buf = buf_cat(buf, *password_);
	}
	return buf;
}

buf_t tl_auth_requestPasswordRecovery()
{
	buf_t buf = buf_add_ui32(0xd897bc66);
	return buf;
}

buf_t tl_auth_recoverPassword(const char * code_, account_PasswordInputSettings *new_settings_)
{
	buf_t buf = buf_add_ui32(0x37096c70);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument code (string)
	{
		buf = buf_cat(buf, serialize_string(code_));
	}
	//parse argument new_settings (account_PasswordInputSettings)
	if (new_settings_)
	{
		buf = buf_cat(buf, *new_settings_);
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_auth_resendCode(const char * phone_number_, const char * phone_code_hash_, const char * reason_)
{
	buf_t buf = buf_add_ui32(0xcae47523);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument phone_number (string)
	{
		buf = buf_cat(buf, serialize_string(phone_number_));
	}
	//parse argument phone_code_hash (string)
	{
		buf = buf_cat(buf, serialize_string(phone_code_hash_));
	}
	//parse argument reason (string)
	if (reason_)
	{
		buf = buf_cat(buf, serialize_string(reason_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_auth_cancelCode(const char * phone_number_, const char * phone_code_hash_)
{
	buf_t buf = buf_add_ui32(0x1f040578);
	//parse argument phone_number (string)
	{
		buf = buf_cat(buf, serialize_string(phone_number_));
	}
	//parse argument phone_code_hash (string)
	{
		buf = buf_cat(buf, serialize_string(phone_code_hash_));
	}
	return buf;
}

buf_t tl_auth_dropTempAuthKeys(long *except_auth_keys_, int except_auth_keys_len)
{
	buf_t buf = buf_add_ui32(0x8e48a188);
	//parse argument except_auth_keys (Vector<long>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(except_auth_keys_len));
		int i;
		for (i=0; i<except_auth_keys_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(except_auth_keys_[i]));
		}
	}
	return buf;
}

buf_t tl_auth_exportLoginToken(int api_id_, const char * api_hash_, long *except_ids_, int except_ids_len)
{
	buf_t buf = buf_add_ui32(0xb7e085fe);
	//parse argument api_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(api_id_));
	}
	//parse argument api_hash (string)
	{
		buf = buf_cat(buf, serialize_string(api_hash_));
	}
	//parse argument except_ids (Vector<long>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(except_ids_len));
		int i;
		for (i=0; i<except_ids_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(except_ids_[i]));
		}
	}
	return buf;
}

buf_t tl_auth_importLoginToken(buf_t *token_)
{
	buf_t buf = buf_add_ui32(0x95ac5ce4);
	//parse argument token (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(token_->data, token_->size));
	}
	return buf;
}

buf_t tl_auth_acceptLoginToken(buf_t *token_)
{
	buf_t buf = buf_add_ui32(0xe894ad4d);
	//parse argument token (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(token_->data, token_->size));
	}
	return buf;
}

buf_t tl_auth_checkRecoveryPassword(const char * code_)
{
	buf_t buf = buf_add_ui32(0x0d36bf79);
	//parse argument code (string)
	{
		buf = buf_cat(buf, serialize_string(code_));
	}
	return buf;
}

buf_t tl_auth_importWebTokenAuthorization(int api_id_, const char * api_hash_, const char * web_auth_token_)
{
	buf_t buf = buf_add_ui32(0x2db873a9);
	//parse argument api_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(api_id_));
	}
	//parse argument api_hash (string)
	{
		buf = buf_cat(buf, serialize_string(api_hash_));
	}
	//parse argument web_auth_token (string)
	{
		buf = buf_cat(buf, serialize_string(web_auth_token_));
	}
	return buf;
}

buf_t tl_auth_requestFirebaseSms(const char * phone_number_, const char * phone_code_hash_, const char * safety_net_token_, const char * play_integrity_token_, const char * ios_push_secret_)
{
	buf_t buf = buf_add_ui32(0x8e39261e);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument phone_number (string)
	{
		buf = buf_cat(buf, serialize_string(phone_number_));
	}
	//parse argument phone_code_hash (string)
	{
		buf = buf_cat(buf, serialize_string(phone_code_hash_));
	}
	//parse argument safety_net_token (string)
	if (safety_net_token_)
	{
		buf = buf_cat(buf, serialize_string(safety_net_token_));
		*flag1 |= (1 << 0);
	}
	//parse argument play_integrity_token (string)
	if (play_integrity_token_)
	{
		buf = buf_cat(buf, serialize_string(play_integrity_token_));
		*flag1 |= (1 << 2);
	}
	//parse argument ios_push_secret (string)
	if (ios_push_secret_)
	{
		buf = buf_cat(buf, serialize_string(ios_push_secret_));
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_auth_resetLoginEmail(const char * phone_number_, const char * phone_code_hash_)
{
	buf_t buf = buf_add_ui32(0x7e960193);
	//parse argument phone_number (string)
	{
		buf = buf_cat(buf, serialize_string(phone_number_));
	}
	//parse argument phone_code_hash (string)
	{
		buf = buf_cat(buf, serialize_string(phone_code_hash_));
	}
	return buf;
}

buf_t tl_auth_reportMissingCode(const char * phone_number_, const char * phone_code_hash_, const char * mnc_)
{
	buf_t buf = buf_add_ui32(0xcb9deff6);
	//parse argument phone_number (string)
	{
		buf = buf_cat(buf, serialize_string(phone_number_));
	}
	//parse argument phone_code_hash (string)
	{
		buf = buf_cat(buf, serialize_string(phone_code_hash_));
	}
	//parse argument mnc (string)
	{
		buf = buf_cat(buf, serialize_string(mnc_));
	}
	return buf;
}

buf_t tl_account_registerDevice(bool no_muted_, int token_type_, const char * token_, Bool *app_sandbox_, buf_t *secret_, long *other_uids_, int other_uids_len)
{
	buf_t buf = buf_add_ui32(0xec86017a);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument no_muted (true)
	if (no_muted_)
		*flag1 |= (1 << 0);
	//parse argument token_type (int)
	{
		buf = buf_cat(buf, buf_add_ui32(token_type_));
	}
	//parse argument token (string)
	{
		buf = buf_cat(buf, serialize_string(token_));
	}
	//parse argument app_sandbox (Bool)
	{
		buf = buf_cat(buf, *app_sandbox_);
	}
	//parse argument secret (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(secret_->data, secret_->size));
	}
	//parse argument other_uids (Vector<long>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(other_uids_len));
		int i;
		for (i=0; i<other_uids_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(other_uids_[i]));
		}
	}
	return buf;
}

buf_t tl_account_unregisterDevice(int token_type_, const char * token_, long *other_uids_, int other_uids_len)
{
	buf_t buf = buf_add_ui32(0x6a0d3206);
	//parse argument token_type (int)
	{
		buf = buf_cat(buf, buf_add_ui32(token_type_));
	}
	//parse argument token (string)
	{
		buf = buf_cat(buf, serialize_string(token_));
	}
	//parse argument other_uids (Vector<long>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(other_uids_len));
		int i;
		for (i=0; i<other_uids_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(other_uids_[i]));
		}
	}
	return buf;
}

buf_t tl_account_updateNotifySettings(InputNotifyPeer *peer_, InputPeerNotifySettings *settings_)
{
	buf_t buf = buf_add_ui32(0x84be5b93);
	//parse argument peer (InputNotifyPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument settings (InputPeerNotifySettings)
	{
		buf = buf_cat(buf, *settings_);
	}
	return buf;
}

buf_t tl_account_getNotifySettings(InputNotifyPeer *peer_)
{
	buf_t buf = buf_add_ui32(0x12b3ad31);
	//parse argument peer (InputNotifyPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_account_resetNotifySettings()
{
	buf_t buf = buf_add_ui32(0xdb7e1747);
	return buf;
}

buf_t tl_account_updateProfile(const char * first_name_, const char * last_name_, const char * about_)
{
	buf_t buf = buf_add_ui32(0x78515775);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument first_name (string)
	if (first_name_)
	{
		buf = buf_cat(buf, serialize_string(first_name_));
		*flag1 |= (1 << 0);
	}
	//parse argument last_name (string)
	if (last_name_)
	{
		buf = buf_cat(buf, serialize_string(last_name_));
		*flag1 |= (1 << 1);
	}
	//parse argument about (string)
	if (about_)
	{
		buf = buf_cat(buf, serialize_string(about_));
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_account_updateStatus(Bool *offline_)
{
	buf_t buf = buf_add_ui32(0x6628562c);
	//parse argument offline (Bool)
	{
		buf = buf_cat(buf, *offline_);
	}
	return buf;
}

buf_t tl_account_getWallPapers(long hash_)
{
	buf_t buf = buf_add_ui32(0x07967d36);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_account_reportPeer(InputPeer *peer_, ReportReason *reason_, const char * message_)
{
	buf_t buf = buf_add_ui32(0xc5ba3d86);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument reason (ReportReason)
	{
		buf = buf_cat(buf, *reason_);
	}
	//parse argument message (string)
	{
		buf = buf_cat(buf, serialize_string(message_));
	}
	return buf;
}

buf_t tl_account_checkUsername(const char * username_)
{
	buf_t buf = buf_add_ui32(0x2714d86c);
	//parse argument username (string)
	{
		buf = buf_cat(buf, serialize_string(username_));
	}
	return buf;
}

buf_t tl_account_updateUsername(const char * username_)
{
	buf_t buf = buf_add_ui32(0x3e0bdd7c);
	//parse argument username (string)
	{
		buf = buf_cat(buf, serialize_string(username_));
	}
	return buf;
}

buf_t tl_account_getPrivacy(InputPrivacyKey *key_)
{
	buf_t buf = buf_add_ui32(0xdadbc950);
	//parse argument key (InputPrivacyKey)
	{
		buf = buf_cat(buf, *key_);
	}
	return buf;
}

buf_t tl_account_setPrivacy(InputPrivacyKey *key_, InputPrivacyRule *rules_, int rules_len)
{
	buf_t buf = buf_add_ui32(0xc9f81ce8);
	//parse argument key (InputPrivacyKey)
	{
		buf = buf_cat(buf, *key_);
	}
	//parse argument rules (Vector<InputPrivacyRule>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(rules_len));
		int i;
		for (i=0; i<rules_len; ++i){
			buf = buf_cat(buf, rules_[i]);
		}
	}
	return buf;
}

buf_t tl_account_deleteAccount(const char * reason_, InputCheckPasswordSRP *password_)
{
	buf_t buf = buf_add_ui32(0xa2c0cf74);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument reason (string)
	{
		buf = buf_cat(buf, serialize_string(reason_));
	}
	//parse argument password (InputCheckPasswordSRP)
	if (password_)
	{
		buf = buf_cat(buf, *password_);
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_account_getAccountTTL()
{
	buf_t buf = buf_add_ui32(0x08fc711d);
	return buf;
}

buf_t tl_account_setAccountTTL(AccountDaysTTL *ttl_)
{
	buf_t buf = buf_add_ui32(0x2442485e);
	//parse argument ttl (AccountDaysTTL)
	{
		buf = buf_cat(buf, *ttl_);
	}
	return buf;
}

buf_t tl_account_sendChangePhoneCode(const char * phone_number_, CodeSettings *settings_)
{
	buf_t buf = buf_add_ui32(0x82574ae5);
	//parse argument phone_number (string)
	{
		buf = buf_cat(buf, serialize_string(phone_number_));
	}
	//parse argument settings (CodeSettings)
	{
		buf = buf_cat(buf, *settings_);
	}
	return buf;
}

buf_t tl_account_changePhone(const char * phone_number_, const char * phone_code_hash_, const char * phone_code_)
{
	buf_t buf = buf_add_ui32(0x70c32edb);
	//parse argument phone_number (string)
	{
		buf = buf_cat(buf, serialize_string(phone_number_));
	}
	//parse argument phone_code_hash (string)
	{
		buf = buf_cat(buf, serialize_string(phone_code_hash_));
	}
	//parse argument phone_code (string)
	{
		buf = buf_cat(buf, serialize_string(phone_code_));
	}
	return buf;
}

buf_t tl_account_updateDeviceLocked(int period_)
{
	buf_t buf = buf_add_ui32(0x38df3532);
	//parse argument period (int)
	{
		buf = buf_cat(buf, buf_add_ui32(period_));
	}
	return buf;
}

buf_t tl_account_getAuthorizations()
{
	buf_t buf = buf_add_ui32(0xe320c158);
	return buf;
}

buf_t tl_account_resetAuthorization(long hash_)
{
	buf_t buf = buf_add_ui32(0xdf77f3bc);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_account_getPassword()
{
	buf_t buf = buf_add_ui32(0x548a30f5);
	return buf;
}

buf_t tl_account_getPasswordSettings(InputCheckPasswordSRP *password_)
{
	buf_t buf = buf_add_ui32(0x9cd4eaf9);
	//parse argument password (InputCheckPasswordSRP)
	{
		buf = buf_cat(buf, *password_);
	}
	return buf;
}

buf_t tl_account_updatePasswordSettings(InputCheckPasswordSRP *password_, account_PasswordInputSettings *new_settings_)
{
	buf_t buf = buf_add_ui32(0xa59b102f);
	//parse argument password (InputCheckPasswordSRP)
	{
		buf = buf_cat(buf, *password_);
	}
	//parse argument new_settings (account_PasswordInputSettings)
	{
		buf = buf_cat(buf, *new_settings_);
	}
	return buf;
}

buf_t tl_account_sendConfirmPhoneCode(const char * hash_, CodeSettings *settings_)
{
	buf_t buf = buf_add_ui32(0x1b3faa88);
	//parse argument hash (string)
	{
		buf = buf_cat(buf, serialize_string(hash_));
	}
	//parse argument settings (CodeSettings)
	{
		buf = buf_cat(buf, *settings_);
	}
	return buf;
}

buf_t tl_account_confirmPhone(const char * phone_code_hash_, const char * phone_code_)
{
	buf_t buf = buf_add_ui32(0x5f2178c3);
	//parse argument phone_code_hash (string)
	{
		buf = buf_cat(buf, serialize_string(phone_code_hash_));
	}
	//parse argument phone_code (string)
	{
		buf = buf_cat(buf, serialize_string(phone_code_));
	}
	return buf;
}

buf_t tl_account_getTmpPassword(InputCheckPasswordSRP *password_, int period_)
{
	buf_t buf = buf_add_ui32(0x449e0b51);
	//parse argument password (InputCheckPasswordSRP)
	{
		buf = buf_cat(buf, *password_);
	}
	//parse argument period (int)
	{
		buf = buf_cat(buf, buf_add_ui32(period_));
	}
	return buf;
}

buf_t tl_account_getWebAuthorizations()
{
	buf_t buf = buf_add_ui32(0x182e6d6f);
	return buf;
}

buf_t tl_account_resetWebAuthorization(long hash_)
{
	buf_t buf = buf_add_ui32(0x2d01b9ef);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_account_resetWebAuthorizations()
{
	buf_t buf = buf_add_ui32(0x682d2594);
	return buf;
}

buf_t tl_account_getAllSecureValues()
{
	buf_t buf = buf_add_ui32(0xb288bc7d);
	return buf;
}

buf_t tl_account_getSecureValue(SecureValueType *types_, int types_len)
{
	buf_t buf = buf_add_ui32(0x73665bc2);
	//parse argument types (Vector<SecureValueType>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(types_len));
		int i;
		for (i=0; i<types_len; ++i){
			buf = buf_cat(buf, types_[i]);
		}
	}
	return buf;
}

buf_t tl_account_saveSecureValue(InputSecureValue *value_, long secure_secret_id_)
{
	buf_t buf = buf_add_ui32(0x899fe31d);
	//parse argument value (InputSecureValue)
	{
		buf = buf_cat(buf, *value_);
	}
	//parse argument secure_secret_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(secure_secret_id_));
	}
	return buf;
}

buf_t tl_account_deleteSecureValue(SecureValueType *types_, int types_len)
{
	buf_t buf = buf_add_ui32(0xb880bc4b);
	//parse argument types (Vector<SecureValueType>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(types_len));
		int i;
		for (i=0; i<types_len; ++i){
			buf = buf_cat(buf, types_[i]);
		}
	}
	return buf;
}

buf_t tl_account_getAuthorizationForm(long bot_id_, const char * scope_, const char * public_key_)
{
	buf_t buf = buf_add_ui32(0xa929597a);
	//parse argument bot_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(bot_id_));
	}
	//parse argument scope (string)
	{
		buf = buf_cat(buf, serialize_string(scope_));
	}
	//parse argument public_key (string)
	{
		buf = buf_cat(buf, serialize_string(public_key_));
	}
	return buf;
}

buf_t tl_account_acceptAuthorization(long bot_id_, const char * scope_, const char * public_key_, SecureValueHash *value_hashes_, int value_hashes_len, SecureCredentialsEncrypted *credentials_)
{
	buf_t buf = buf_add_ui32(0xf3ed4c73);
	//parse argument bot_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(bot_id_));
	}
	//parse argument scope (string)
	{
		buf = buf_cat(buf, serialize_string(scope_));
	}
	//parse argument public_key (string)
	{
		buf = buf_cat(buf, serialize_string(public_key_));
	}
	//parse argument value_hashes (Vector<SecureValueHash>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(value_hashes_len));
		int i;
		for (i=0; i<value_hashes_len; ++i){
			buf = buf_cat(buf, value_hashes_[i]);
		}
	}
	//parse argument credentials (SecureCredentialsEncrypted)
	{
		buf = buf_cat(buf, *credentials_);
	}
	return buf;
}

buf_t tl_account_sendVerifyPhoneCode(const char * phone_number_, CodeSettings *settings_)
{
	buf_t buf = buf_add_ui32(0xa5a356f9);
	//parse argument phone_number (string)
	{
		buf = buf_cat(buf, serialize_string(phone_number_));
	}
	//parse argument settings (CodeSettings)
	{
		buf = buf_cat(buf, *settings_);
	}
	return buf;
}

buf_t tl_account_verifyPhone(const char * phone_number_, const char * phone_code_hash_, const char * phone_code_)
{
	buf_t buf = buf_add_ui32(0x4dd3a7f6);
	//parse argument phone_number (string)
	{
		buf = buf_cat(buf, serialize_string(phone_number_));
	}
	//parse argument phone_code_hash (string)
	{
		buf = buf_cat(buf, serialize_string(phone_code_hash_));
	}
	//parse argument phone_code (string)
	{
		buf = buf_cat(buf, serialize_string(phone_code_));
	}
	return buf;
}

buf_t tl_account_sendVerifyEmailCode(EmailVerifyPurpose *purpose_, const char * email_)
{
	buf_t buf = buf_add_ui32(0x98e037bb);
	//parse argument purpose (EmailVerifyPurpose)
	{
		buf = buf_cat(buf, *purpose_);
	}
	//parse argument email (string)
	{
		buf = buf_cat(buf, serialize_string(email_));
	}
	return buf;
}

buf_t tl_account_verifyEmail(EmailVerifyPurpose *purpose_, EmailVerification *verification_)
{
	buf_t buf = buf_add_ui32(0x032da4cf);
	//parse argument purpose (EmailVerifyPurpose)
	{
		buf = buf_cat(buf, *purpose_);
	}
	//parse argument verification (EmailVerification)
	{
		buf = buf_cat(buf, *verification_);
	}
	return buf;
}

buf_t tl_account_initTakeoutSession(bool contacts_, bool message_users_, bool message_chats_, bool message_megagroups_, bool message_channels_, bool files_, long file_max_size_)
{
	buf_t buf = buf_add_ui32(0x8ef3eab0);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument contacts (true)
	if (contacts_)
		*flag1 |= (1 << 0);
	//parse argument message_users (true)
	if (message_users_)
		*flag1 |= (1 << 1);
	//parse argument message_chats (true)
	if (message_chats_)
		*flag1 |= (1 << 2);
	//parse argument message_megagroups (true)
	if (message_megagroups_)
		*flag1 |= (1 << 3);
	//parse argument message_channels (true)
	if (message_channels_)
		*flag1 |= (1 << 4);
	//parse argument files (true)
	if (files_)
		*flag1 |= (1 << 5);
	//parse argument file_max_size (long)
	if (file_max_size_)
	{
		buf = buf_cat(buf, buf_add_ui64(file_max_size_));
		*flag1 |= (1 << 5);
	}
	return buf;
}

buf_t tl_account_finishTakeoutSession(bool success_)
{
	buf_t buf = buf_add_ui32(0x1d2652ee);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument success (true)
	if (success_)
		*flag1 |= (1 << 0);
	return buf;
}

buf_t tl_account_confirmPasswordEmail(const char * code_)
{
	buf_t buf = buf_add_ui32(0x8fdf1920);
	//parse argument code (string)
	{
		buf = buf_cat(buf, serialize_string(code_));
	}
	return buf;
}

buf_t tl_account_resendPasswordEmail()
{
	buf_t buf = buf_add_ui32(0x7a7f2a15);
	return buf;
}

buf_t tl_account_cancelPasswordEmail()
{
	buf_t buf = buf_add_ui32(0xc1cbd5b6);
	return buf;
}

buf_t tl_account_getContactSignUpNotification()
{
	buf_t buf = buf_add_ui32(0x9f07c728);
	return buf;
}

buf_t tl_account_setContactSignUpNotification(Bool *silent_)
{
	buf_t buf = buf_add_ui32(0xcff43f61);
	//parse argument silent (Bool)
	{
		buf = buf_cat(buf, *silent_);
	}
	return buf;
}

buf_t tl_account_getNotifyExceptions(bool compare_sound_, bool compare_stories_, InputNotifyPeer *peer_)
{
	buf_t buf = buf_add_ui32(0x53577479);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument compare_sound (true)
	if (compare_sound_)
		*flag1 |= (1 << 1);
	//parse argument compare_stories (true)
	if (compare_stories_)
		*flag1 |= (1 << 2);
	//parse argument peer (InputNotifyPeer)
	if (peer_)
	{
		buf = buf_cat(buf, *peer_);
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_account_getWallPaper(InputWallPaper *wallpaper_)
{
	buf_t buf = buf_add_ui32(0xfc8ddbea);
	//parse argument wallpaper (InputWallPaper)
	{
		buf = buf_cat(buf, *wallpaper_);
	}
	return buf;
}

buf_t tl_account_uploadWallPaper(bool for_chat_, InputFile *file_, const char * mime_type_, WallPaperSettings *settings_)
{
	buf_t buf = buf_add_ui32(0xe39a8f03);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument for_chat (true)
	if (for_chat_)
		*flag1 |= (1 << 0);
	//parse argument file (InputFile)
	{
		buf = buf_cat(buf, *file_);
	}
	//parse argument mime_type (string)
	{
		buf = buf_cat(buf, serialize_string(mime_type_));
	}
	//parse argument settings (WallPaperSettings)
	{
		buf = buf_cat(buf, *settings_);
	}
	return buf;
}

buf_t tl_account_saveWallPaper(InputWallPaper *wallpaper_, Bool *unsave_, WallPaperSettings *settings_)
{
	buf_t buf = buf_add_ui32(0x6c5a5b37);
	//parse argument wallpaper (InputWallPaper)
	{
		buf = buf_cat(buf, *wallpaper_);
	}
	//parse argument unsave (Bool)
	{
		buf = buf_cat(buf, *unsave_);
	}
	//parse argument settings (WallPaperSettings)
	{
		buf = buf_cat(buf, *settings_);
	}
	return buf;
}

buf_t tl_account_installWallPaper(InputWallPaper *wallpaper_, WallPaperSettings *settings_)
{
	buf_t buf = buf_add_ui32(0xfeed5769);
	//parse argument wallpaper (InputWallPaper)
	{
		buf = buf_cat(buf, *wallpaper_);
	}
	//parse argument settings (WallPaperSettings)
	{
		buf = buf_cat(buf, *settings_);
	}
	return buf;
}

buf_t tl_account_resetWallPapers()
{
	buf_t buf = buf_add_ui32(0xbb3b9804);
	return buf;
}

buf_t tl_account_getAutoDownloadSettings()
{
	buf_t buf = buf_add_ui32(0x56da0b3f);
	return buf;
}

buf_t tl_account_saveAutoDownloadSettings(bool low_, bool high_, AutoDownloadSettings *settings_)
{
	buf_t buf = buf_add_ui32(0x76f36233);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument low (true)
	if (low_)
		*flag1 |= (1 << 0);
	//parse argument high (true)
	if (high_)
		*flag1 |= (1 << 1);
	//parse argument settings (AutoDownloadSettings)
	{
		buf = buf_cat(buf, *settings_);
	}
	return buf;
}

buf_t tl_account_uploadTheme(InputFile *file_, InputFile *thumb_, const char * file_name_, const char * mime_type_)
{
	buf_t buf = buf_add_ui32(0x1c3db333);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument file (InputFile)
	{
		buf = buf_cat(buf, *file_);
	}
	//parse argument thumb (InputFile)
	if (thumb_)
	{
		buf = buf_cat(buf, *thumb_);
		*flag1 |= (1 << 0);
	}
	//parse argument file_name (string)
	{
		buf = buf_cat(buf, serialize_string(file_name_));
	}
	//parse argument mime_type (string)
	{
		buf = buf_cat(buf, serialize_string(mime_type_));
	}
	return buf;
}

buf_t tl_account_createTheme(const char * slug_, const char * title_, InputDocument *document_, InputThemeSettings *settings_, int settings_len)
{
	buf_t buf = buf_add_ui32(0x652e4400);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument slug (string)
	{
		buf = buf_cat(buf, serialize_string(slug_));
	}
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument document (InputDocument)
	if (document_)
	{
		buf = buf_cat(buf, *document_);
		*flag1 |= (1 << 2);
	}
	//parse argument settings (Vector<InputThemeSettings>)
	if (settings_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(settings_len));
		int i;
		for (i=0; i<settings_len; ++i){
			buf = buf_cat(buf, settings_[i]);
		}
		*flag1 |= (1 << 3);
	}
	return buf;
}

buf_t tl_account_updateTheme(const char * format_, InputTheme *theme_, const char * slug_, const char * title_, InputDocument *document_, InputThemeSettings *settings_, int settings_len)
{
	buf_t buf = buf_add_ui32(0x2bf40ccc);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument format (string)
	{
		buf = buf_cat(buf, serialize_string(format_));
	}
	//parse argument theme (InputTheme)
	{
		buf = buf_cat(buf, *theme_);
	}
	//parse argument slug (string)
	if (slug_)
	{
		buf = buf_cat(buf, serialize_string(slug_));
		*flag1 |= (1 << 0);
	}
	//parse argument title (string)
	if (title_)
	{
		buf = buf_cat(buf, serialize_string(title_));
		*flag1 |= (1 << 1);
	}
	//parse argument document (InputDocument)
	if (document_)
	{
		buf = buf_cat(buf, *document_);
		*flag1 |= (1 << 2);
	}
	//parse argument settings (Vector<InputThemeSettings>)
	if (settings_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(settings_len));
		int i;
		for (i=0; i<settings_len; ++i){
			buf = buf_cat(buf, settings_[i]);
		}
		*flag1 |= (1 << 3);
	}
	return buf;
}

buf_t tl_account_saveTheme(InputTheme *theme_, Bool *unsave_)
{
	buf_t buf = buf_add_ui32(0xf257106c);
	//parse argument theme (InputTheme)
	{
		buf = buf_cat(buf, *theme_);
	}
	//parse argument unsave (Bool)
	{
		buf = buf_cat(buf, *unsave_);
	}
	return buf;
}

buf_t tl_account_installTheme(bool dark_, InputTheme *theme_, const char * format_, BaseTheme *base_theme_)
{
	buf_t buf = buf_add_ui32(0xc727bb3b);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument dark (true)
	if (dark_)
		*flag1 |= (1 << 0);
	//parse argument theme (InputTheme)
	if (theme_)
	{
		buf = buf_cat(buf, *theme_);
		*flag1 |= (1 << 1);
	}
	//parse argument format (string)
	if (format_)
	{
		buf = buf_cat(buf, serialize_string(format_));
		*flag1 |= (1 << 2);
	}
	//parse argument base_theme (BaseTheme)
	if (base_theme_)
	{
		buf = buf_cat(buf, *base_theme_);
		*flag1 |= (1 << 3);
	}
	return buf;
}

buf_t tl_account_getTheme(const char * format_, InputTheme *theme_)
{
	buf_t buf = buf_add_ui32(0x3a5869ec);
	//parse argument format (string)
	{
		buf = buf_cat(buf, serialize_string(format_));
	}
	//parse argument theme (InputTheme)
	{
		buf = buf_cat(buf, *theme_);
	}
	return buf;
}

buf_t tl_account_getThemes(const char * format_, long hash_)
{
	buf_t buf = buf_add_ui32(0x7206e458);
	//parse argument format (string)
	{
		buf = buf_cat(buf, serialize_string(format_));
	}
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_account_setContentSettings(bool sensitive_enabled_)
{
	buf_t buf = buf_add_ui32(0xb574b16b);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument sensitive_enabled (true)
	if (sensitive_enabled_)
		*flag1 |= (1 << 0);
	return buf;
}

buf_t tl_account_getContentSettings()
{
	buf_t buf = buf_add_ui32(0x8b9b4dae);
	return buf;
}

buf_t tl_account_getMultiWallPapers(InputWallPaper *wallpapers_, int wallpapers_len)
{
	buf_t buf = buf_add_ui32(0x65ad71dc);
	//parse argument wallpapers (Vector<InputWallPaper>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(wallpapers_len));
		int i;
		for (i=0; i<wallpapers_len; ++i){
			buf = buf_cat(buf, wallpapers_[i]);
		}
	}
	return buf;
}

buf_t tl_account_getGlobalPrivacySettings()
{
	buf_t buf = buf_add_ui32(0xeb2b4cf6);
	return buf;
}

buf_t tl_account_setGlobalPrivacySettings(GlobalPrivacySettings *settings_)
{
	buf_t buf = buf_add_ui32(0x1edaaac2);
	//parse argument settings (GlobalPrivacySettings)
	{
		buf = buf_cat(buf, *settings_);
	}
	return buf;
}

buf_t tl_account_reportProfilePhoto(InputPeer *peer_, InputPhoto *photo_id_, ReportReason *reason_, const char * message_)
{
	buf_t buf = buf_add_ui32(0xfa8cc6f5);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument photo_id (InputPhoto)
	{
		buf = buf_cat(buf, *photo_id_);
	}
	//parse argument reason (ReportReason)
	{
		buf = buf_cat(buf, *reason_);
	}
	//parse argument message (string)
	{
		buf = buf_cat(buf, serialize_string(message_));
	}
	return buf;
}

buf_t tl_account_resetPassword()
{
	buf_t buf = buf_add_ui32(0x9308ce1b);
	return buf;
}

buf_t tl_account_declinePasswordReset()
{
	buf_t buf = buf_add_ui32(0x4c9409f6);
	return buf;
}

buf_t tl_account_getChatThemes(long hash_)
{
	buf_t buf = buf_add_ui32(0xd638de89);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_account_setAuthorizationTTL(int authorization_ttl_days_)
{
	buf_t buf = buf_add_ui32(0xbf899aa0);
	//parse argument authorization_ttl_days (int)
	{
		buf = buf_cat(buf, buf_add_ui32(authorization_ttl_days_));
	}
	return buf;
}

buf_t tl_account_changeAuthorizationSettings(bool confirmed_, long hash_, Bool *encrypted_requests_disabled_, Bool *call_requests_disabled_)
{
	buf_t buf = buf_add_ui32(0x40f48462);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument confirmed (true)
	if (confirmed_)
		*flag1 |= (1 << 3);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	//parse argument encrypted_requests_disabled (Bool)
	if (encrypted_requests_disabled_)
	{
		buf = buf_cat(buf, *encrypted_requests_disabled_);
		*flag1 |= (1 << 0);
	}
	//parse argument call_requests_disabled (Bool)
	if (call_requests_disabled_)
	{
		buf = buf_cat(buf, *call_requests_disabled_);
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_account_getSavedRingtones(long hash_)
{
	buf_t buf = buf_add_ui32(0xe1902288);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_account_saveRingtone(InputDocument *id_, Bool *unsave_)
{
	buf_t buf = buf_add_ui32(0x3dea5b03);
	//parse argument id (InputDocument)
	{
		buf = buf_cat(buf, *id_);
	}
	//parse argument unsave (Bool)
	{
		buf = buf_cat(buf, *unsave_);
	}
	return buf;
}

buf_t tl_account_uploadRingtone(InputFile *file_, const char * file_name_, const char * mime_type_)
{
	buf_t buf = buf_add_ui32(0x831a83a2);
	//parse argument file (InputFile)
	{
		buf = buf_cat(buf, *file_);
	}
	//parse argument file_name (string)
	{
		buf = buf_cat(buf, serialize_string(file_name_));
	}
	//parse argument mime_type (string)
	{
		buf = buf_cat(buf, serialize_string(mime_type_));
	}
	return buf;
}

buf_t tl_account_updateEmojiStatus(EmojiStatus *emoji_status_)
{
	buf_t buf = buf_add_ui32(0xfbd3de6b);
	//parse argument emoji_status (EmojiStatus)
	{
		buf = buf_cat(buf, *emoji_status_);
	}
	return buf;
}

buf_t tl_account_getDefaultEmojiStatuses(long hash_)
{
	buf_t buf = buf_add_ui32(0xd6753386);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_account_getRecentEmojiStatuses(long hash_)
{
	buf_t buf = buf_add_ui32(0x0f578105);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_account_clearRecentEmojiStatuses()
{
	buf_t buf = buf_add_ui32(0x18201aae);
	return buf;
}

buf_t tl_account_reorderUsernames(const char * *order_, int order_len)
{
	buf_t buf = buf_add_ui32(0xef500eab);
	//parse argument order (Vector<string>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(order_len));
		int i;
		for (i=0; i<order_len; ++i){
			buf = buf_cat(buf, serialize_string(order_[i]));
		}
	}
	return buf;
}

buf_t tl_account_toggleUsername(const char * username_, Bool *active_)
{
	buf_t buf = buf_add_ui32(0x58d6b376);
	//parse argument username (string)
	{
		buf = buf_cat(buf, serialize_string(username_));
	}
	//parse argument active (Bool)
	{
		buf = buf_cat(buf, *active_);
	}
	return buf;
}

buf_t tl_account_getDefaultProfilePhotoEmojis(long hash_)
{
	buf_t buf = buf_add_ui32(0xe2750328);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_account_getDefaultGroupPhotoEmojis(long hash_)
{
	buf_t buf = buf_add_ui32(0x915860ae);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_account_getAutoSaveSettings()
{
	buf_t buf = buf_add_ui32(0xadcbbcda);
	return buf;
}

buf_t tl_account_saveAutoSaveSettings(bool users_, bool chats_, bool broadcasts_, InputPeer *peer_, AutoSaveSettings *settings_)
{
	buf_t buf = buf_add_ui32(0xd69b8361);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument users (true)
	if (users_)
		*flag1 |= (1 << 0);
	//parse argument chats (true)
	if (chats_)
		*flag1 |= (1 << 1);
	//parse argument broadcasts (true)
	if (broadcasts_)
		*flag1 |= (1 << 2);
	//parse argument peer (InputPeer)
	if (peer_)
	{
		buf = buf_cat(buf, *peer_);
		*flag1 |= (1 << 3);
	}
	//parse argument settings (AutoSaveSettings)
	{
		buf = buf_cat(buf, *settings_);
	}
	return buf;
}

buf_t tl_account_deleteAutoSaveExceptions()
{
	buf_t buf = buf_add_ui32(0x53bc0020);
	return buf;
}

buf_t tl_account_invalidateSignInCodes(const char * *codes_, int codes_len)
{
	buf_t buf = buf_add_ui32(0xca8ae8ba);
	//parse argument codes (Vector<string>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(codes_len));
		int i;
		for (i=0; i<codes_len; ++i){
			buf = buf_cat(buf, serialize_string(codes_[i]));
		}
	}
	return buf;
}

buf_t tl_account_updateColor(bool for_profile_, int color_, long background_emoji_id_)
{
	buf_t buf = buf_add_ui32(0x7cefa15d);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument for_profile (true)
	if (for_profile_)
		*flag1 |= (1 << 1);
	//parse argument color (int)
	if (color_)
	{
		buf = buf_cat(buf, buf_add_ui32(color_));
		*flag1 |= (1 << 2);
	}
	//parse argument background_emoji_id (long)
	if (background_emoji_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(background_emoji_id_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_account_getDefaultBackgroundEmojis(long hash_)
{
	buf_t buf = buf_add_ui32(0xa60ab9ce);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_account_getChannelDefaultEmojiStatuses(long hash_)
{
	buf_t buf = buf_add_ui32(0x7727a7d5);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_account_getChannelRestrictedStatusEmojis(long hash_)
{
	buf_t buf = buf_add_ui32(0x35a9e0d5);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_account_updateBusinessWorkHours(BusinessWorkHours *business_work_hours_)
{
	buf_t buf = buf_add_ui32(0x4b00e066);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument business_work_hours (BusinessWorkHours)
	if (business_work_hours_)
	{
		buf = buf_cat(buf, *business_work_hours_);
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_account_updateBusinessLocation(InputGeoPoint *geo_point_, const char * address_)
{
	buf_t buf = buf_add_ui32(0x9e6b131a);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument geo_point (InputGeoPoint)
	if (geo_point_)
	{
		buf = buf_cat(buf, *geo_point_);
		*flag1 |= (1 << 1);
	}
	//parse argument address (string)
	if (address_)
	{
		buf = buf_cat(buf, serialize_string(address_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_account_updateBusinessGreetingMessage(InputBusinessGreetingMessage *message_)
{
	buf_t buf = buf_add_ui32(0x66cdafc4);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument message (InputBusinessGreetingMessage)
	if (message_)
	{
		buf = buf_cat(buf, *message_);
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_account_updateBusinessAwayMessage(InputBusinessAwayMessage *message_)
{
	buf_t buf = buf_add_ui32(0xa26a7fa5);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument message (InputBusinessAwayMessage)
	if (message_)
	{
		buf = buf_cat(buf, *message_);
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_account_updateConnectedBot(bool can_reply_, bool deleted_, InputUser *bot_, InputBusinessBotRecipients *recipients_)
{
	buf_t buf = buf_add_ui32(0x43d8521d);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument can_reply (true)
	if (can_reply_)
		*flag1 |= (1 << 0);
	//parse argument deleted (true)
	if (deleted_)
		*flag1 |= (1 << 1);
	//parse argument bot (InputUser)
	{
		buf = buf_cat(buf, *bot_);
	}
	//parse argument recipients (InputBusinessBotRecipients)
	{
		buf = buf_cat(buf, *recipients_);
	}
	return buf;
}

buf_t tl_account_getConnectedBots()
{
	buf_t buf = buf_add_ui32(0x4ea4c80f);
	return buf;
}

buf_t tl_account_getBotBusinessConnection(const char * connection_id_)
{
	buf_t buf = buf_add_ui32(0x76a86270);
	//parse argument connection_id (string)
	{
		buf = buf_cat(buf, serialize_string(connection_id_));
	}
	return buf;
}

buf_t tl_account_updateBusinessIntro(InputBusinessIntro *intro_)
{
	buf_t buf = buf_add_ui32(0xa614d034);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument intro (InputBusinessIntro)
	if (intro_)
	{
		buf = buf_cat(buf, *intro_);
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_account_toggleConnectedBotPaused(InputPeer *peer_, Bool *paused_)
{
	buf_t buf = buf_add_ui32(0x646e1097);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument paused (Bool)
	{
		buf = buf_cat(buf, *paused_);
	}
	return buf;
}

buf_t tl_account_disablePeerConnectedBot(InputPeer *peer_)
{
	buf_t buf = buf_add_ui32(0x5e437ed9);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_account_updateBirthday(Birthday *birthday_)
{
	buf_t buf = buf_add_ui32(0xcc6e0c11);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument birthday (Birthday)
	if (birthday_)
	{
		buf = buf_cat(buf, *birthday_);
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_account_createBusinessChatLink(InputBusinessChatLink *link_)
{
	buf_t buf = buf_add_ui32(0x8851e68e);
	//parse argument link (InputBusinessChatLink)
	{
		buf = buf_cat(buf, *link_);
	}
	return buf;
}

buf_t tl_account_editBusinessChatLink(const char * slug_, InputBusinessChatLink *link_)
{
	buf_t buf = buf_add_ui32(0x8c3410af);
	//parse argument slug (string)
	{
		buf = buf_cat(buf, serialize_string(slug_));
	}
	//parse argument link (InputBusinessChatLink)
	{
		buf = buf_cat(buf, *link_);
	}
	return buf;
}

buf_t tl_account_deleteBusinessChatLink(const char * slug_)
{
	buf_t buf = buf_add_ui32(0x60073674);
	//parse argument slug (string)
	{
		buf = buf_cat(buf, serialize_string(slug_));
	}
	return buf;
}

buf_t tl_account_getBusinessChatLinks()
{
	buf_t buf = buf_add_ui32(0x6f70dde1);
	return buf;
}

buf_t tl_account_resolveBusinessChatLink(const char * slug_)
{
	buf_t buf = buf_add_ui32(0x5492e5ee);
	//parse argument slug (string)
	{
		buf = buf_cat(buf, serialize_string(slug_));
	}
	return buf;
}

buf_t tl_account_updatePersonalChannel(InputChannel *channel_)
{
	buf_t buf = buf_add_ui32(0xd94305e0);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	return buf;
}

buf_t tl_account_toggleSponsoredMessages(Bool *enabled_)
{
	buf_t buf = buf_add_ui32(0xb9d9a38d);
	//parse argument enabled (Bool)
	{
		buf = buf_cat(buf, *enabled_);
	}
	return buf;
}

buf_t tl_account_getReactionsNotifySettings()
{
	buf_t buf = buf_add_ui32(0x06dd654c);
	return buf;
}

buf_t tl_account_setReactionsNotifySettings(ReactionsNotifySettings *settings_)
{
	buf_t buf = buf_add_ui32(0x316ce548);
	//parse argument settings (ReactionsNotifySettings)
	{
		buf = buf_cat(buf, *settings_);
	}
	return buf;
}

buf_t tl_users_getUsers(InputUser *id_, int id_len)
{
	buf_t buf = buf_add_ui32(0x0d91a548);
	//parse argument id (Vector<InputUser>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, id_[i]);
		}
	}
	return buf;
}

buf_t tl_users_getFullUser(InputUser *id_)
{
	buf_t buf = buf_add_ui32(0xb60f5918);
	//parse argument id (InputUser)
	{
		buf = buf_cat(buf, *id_);
	}
	return buf;
}

buf_t tl_users_setSecureValueErrors(InputUser *id_, SecureValueError *errors_, int errors_len)
{
	buf_t buf = buf_add_ui32(0x90c894b5);
	//parse argument id (InputUser)
	{
		buf = buf_cat(buf, *id_);
	}
	//parse argument errors (Vector<SecureValueError>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(errors_len));
		int i;
		for (i=0; i<errors_len; ++i){
			buf = buf_cat(buf, errors_[i]);
		}
	}
	return buf;
}

buf_t tl_users_getIsPremiumRequiredToContact(InputUser *id_, int id_len)
{
	buf_t buf = buf_add_ui32(0xa622aa10);
	//parse argument id (Vector<InputUser>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, id_[i]);
		}
	}
	return buf;
}

buf_t tl_contacts_getContactIDs(long hash_)
{
	buf_t buf = buf_add_ui32(0x7adc669d);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_contacts_getStatuses()
{
	buf_t buf = buf_add_ui32(0xc4a353ee);
	return buf;
}

buf_t tl_contacts_getContacts(long hash_)
{
	buf_t buf = buf_add_ui32(0x5dd69e12);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_contacts_importContacts(InputContact *contacts_, int contacts_len)
{
	buf_t buf = buf_add_ui32(0x2c800be5);
	//parse argument contacts (Vector<InputContact>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(contacts_len));
		int i;
		for (i=0; i<contacts_len; ++i){
			buf = buf_cat(buf, contacts_[i]);
		}
	}
	return buf;
}

buf_t tl_contacts_deleteContacts(InputUser *id_, int id_len)
{
	buf_t buf = buf_add_ui32(0x096a0e00);
	//parse argument id (Vector<InputUser>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, id_[i]);
		}
	}
	return buf;
}

buf_t tl_contacts_deleteByPhones(const char * *phones_, int phones_len)
{
	buf_t buf = buf_add_ui32(0x1013fd9e);
	//parse argument phones (Vector<string>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(phones_len));
		int i;
		for (i=0; i<phones_len; ++i){
			buf = buf_cat(buf, serialize_string(phones_[i]));
		}
	}
	return buf;
}

buf_t tl_contacts_block(bool my_stories_from_, InputPeer *id_)
{
	buf_t buf = buf_add_ui32(0x2e2e8734);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument my_stories_from (true)
	if (my_stories_from_)
		*flag1 |= (1 << 0);
	//parse argument id (InputPeer)
	{
		buf = buf_cat(buf, *id_);
	}
	return buf;
}

buf_t tl_contacts_unblock(bool my_stories_from_, InputPeer *id_)
{
	buf_t buf = buf_add_ui32(0xb550d328);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument my_stories_from (true)
	if (my_stories_from_)
		*flag1 |= (1 << 0);
	//parse argument id (InputPeer)
	{
		buf = buf_cat(buf, *id_);
	}
	return buf;
}

buf_t tl_contacts_getBlocked(bool my_stories_from_, int offset_, int limit_)
{
	buf_t buf = buf_add_ui32(0x9a868f80);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument my_stories_from (true)
	if (my_stories_from_)
		*flag1 |= (1 << 0);
	//parse argument offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	return buf;
}

buf_t tl_contacts_search(const char * q_, int limit_)
{
	buf_t buf = buf_add_ui32(0x11f812d8);
	//parse argument q (string)
	{
		buf = buf_cat(buf, serialize_string(q_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	return buf;
}

buf_t tl_contacts_resolveUsername(const char * username_)
{
	buf_t buf = buf_add_ui32(0xf93ccba3);
	//parse argument username (string)
	{
		buf = buf_cat(buf, serialize_string(username_));
	}
	return buf;
}

buf_t tl_contacts_getTopPeers(bool correspondents_, bool bots_pm_, bool bots_inline_, bool phone_calls_, bool forward_users_, bool forward_chats_, bool groups_, bool channels_, bool bots_app_, int offset_, int limit_, long hash_)
{
	buf_t buf = buf_add_ui32(0x973478b6);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument correspondents (true)
	if (correspondents_)
		*flag1 |= (1 << 0);
	//parse argument bots_pm (true)
	if (bots_pm_)
		*flag1 |= (1 << 1);
	//parse argument bots_inline (true)
	if (bots_inline_)
		*flag1 |= (1 << 2);
	//parse argument phone_calls (true)
	if (phone_calls_)
		*flag1 |= (1 << 3);
	//parse argument forward_users (true)
	if (forward_users_)
		*flag1 |= (1 << 4);
	//parse argument forward_chats (true)
	if (forward_chats_)
		*flag1 |= (1 << 5);
	//parse argument groups (true)
	if (groups_)
		*flag1 |= (1 << 10);
	//parse argument channels (true)
	if (channels_)
		*flag1 |= (1 << 15);
	//parse argument bots_app (true)
	if (bots_app_)
		*flag1 |= (1 << 16);
	//parse argument offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_contacts_resetTopPeerRating(TopPeerCategory *category_, InputPeer *peer_)
{
	buf_t buf = buf_add_ui32(0x1ae373ac);
	//parse argument category (TopPeerCategory)
	{
		buf = buf_cat(buf, *category_);
	}
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_contacts_resetSaved()
{
	buf_t buf = buf_add_ui32(0x879537f1);
	return buf;
}

buf_t tl_contacts_getSaved()
{
	buf_t buf = buf_add_ui32(0x82f1e39f);
	return buf;
}

buf_t tl_contacts_toggleTopPeers(Bool *enabled_)
{
	buf_t buf = buf_add_ui32(0x8514bdda);
	//parse argument enabled (Bool)
	{
		buf = buf_cat(buf, *enabled_);
	}
	return buf;
}

buf_t tl_contacts_addContact(bool add_phone_privacy_exception_, InputUser *id_, const char * first_name_, const char * last_name_, const char * phone_)
{
	buf_t buf = buf_add_ui32(0xe8f463d0);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument add_phone_privacy_exception (true)
	if (add_phone_privacy_exception_)
		*flag1 |= (1 << 0);
	//parse argument id (InputUser)
	{
		buf = buf_cat(buf, *id_);
	}
	//parse argument first_name (string)
	{
		buf = buf_cat(buf, serialize_string(first_name_));
	}
	//parse argument last_name (string)
	{
		buf = buf_cat(buf, serialize_string(last_name_));
	}
	//parse argument phone (string)
	{
		buf = buf_cat(buf, serialize_string(phone_));
	}
	return buf;
}

buf_t tl_contacts_acceptContact(InputUser *id_)
{
	buf_t buf = buf_add_ui32(0xf831a20f);
	//parse argument id (InputUser)
	{
		buf = buf_cat(buf, *id_);
	}
	return buf;
}

buf_t tl_contacts_getLocated(bool background_, InputGeoPoint *geo_point_, int self_expires_)
{
	buf_t buf = buf_add_ui32(0xd348bc44);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument background (true)
	if (background_)
		*flag1 |= (1 << 1);
	//parse argument geo_point (InputGeoPoint)
	{
		buf = buf_cat(buf, *geo_point_);
	}
	//parse argument self_expires (int)
	if (self_expires_)
	{
		buf = buf_cat(buf, buf_add_ui32(self_expires_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_contacts_blockFromReplies(bool delete_message_, bool delete_history_, bool report_spam_, int msg_id_)
{
	buf_t buf = buf_add_ui32(0x29a8962c);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument delete_message (true)
	if (delete_message_)
		*flag1 |= (1 << 0);
	//parse argument delete_history (true)
	if (delete_history_)
		*flag1 |= (1 << 1);
	//parse argument report_spam (true)
	if (report_spam_)
		*flag1 |= (1 << 2);
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	return buf;
}

buf_t tl_contacts_resolvePhone(const char * phone_)
{
	buf_t buf = buf_add_ui32(0x8af94344);
	//parse argument phone (string)
	{
		buf = buf_cat(buf, serialize_string(phone_));
	}
	return buf;
}

buf_t tl_contacts_exportContactToken()
{
	buf_t buf = buf_add_ui32(0xf8654027);
	return buf;
}

buf_t tl_contacts_importContactToken(const char * token_)
{
	buf_t buf = buf_add_ui32(0x13005788);
	//parse argument token (string)
	{
		buf = buf_cat(buf, serialize_string(token_));
	}
	return buf;
}

buf_t tl_contacts_editCloseFriends(long *id_, int id_len)
{
	buf_t buf = buf_add_ui32(0xba6705f0);
	//parse argument id (Vector<long>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(id_[i]));
		}
	}
	return buf;
}

buf_t tl_contacts_setBlocked(bool my_stories_from_, InputPeer *id_, int id_len, int limit_)
{
	buf_t buf = buf_add_ui32(0x94c65c76);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument my_stories_from (true)
	if (my_stories_from_)
		*flag1 |= (1 << 0);
	//parse argument id (Vector<InputPeer>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, id_[i]);
		}
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	return buf;
}

buf_t tl_contacts_getBirthdays()
{
	buf_t buf = buf_add_ui32(0xdaeda864);
	return buf;
}

buf_t tl_messages_getMessages(InputMessage *id_, int id_len)
{
	buf_t buf = buf_add_ui32(0x63c66506);
	//parse argument id (Vector<InputMessage>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, id_[i]);
		}
	}
	return buf;
}

buf_t tl_messages_getDialogs(bool exclude_pinned_, int folder_id_, int offset_date_, int offset_id_, InputPeer *offset_peer_, int limit_, long hash_)
{
	buf_t buf = buf_add_ui32(0xa0f4cb4f);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument exclude_pinned (true)
	if (exclude_pinned_)
		*flag1 |= (1 << 0);
	//parse argument folder_id (int)
	if (folder_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(folder_id_));
		*flag1 |= (1 << 1);
	}
	//parse argument offset_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_date_));
	}
	//parse argument offset_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_id_));
	}
	//parse argument offset_peer (InputPeer)
	{
		buf = buf_cat(buf, *offset_peer_);
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_messages_getHistory(InputPeer *peer_, int offset_id_, int offset_date_, int add_offset_, int limit_, int max_id_, int min_id_, long hash_)
{
	buf_t buf = buf_add_ui32(0x4423e6c5);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument offset_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_id_));
	}
	//parse argument offset_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_date_));
	}
	//parse argument add_offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(add_offset_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	//parse argument max_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(max_id_));
	}
	//parse argument min_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(min_id_));
	}
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_messages_search(InputPeer *peer_, const char * q_, InputPeer *from_id_, InputPeer *saved_peer_id_, Reaction *saved_reaction_, int saved_reaction_len, int top_msg_id_, MessagesFilter *filter_, int min_date_, int max_date_, int offset_id_, int add_offset_, int limit_, int max_id_, int min_id_, long hash_)
{
	buf_t buf = buf_add_ui32(0x29ee847a);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument q (string)
	{
		buf = buf_cat(buf, serialize_string(q_));
	}
	//parse argument from_id (InputPeer)
	if (from_id_)
	{
		buf = buf_cat(buf, *from_id_);
		*flag1 |= (1 << 0);
	}
	//parse argument saved_peer_id (InputPeer)
	if (saved_peer_id_)
	{
		buf = buf_cat(buf, *saved_peer_id_);
		*flag1 |= (1 << 2);
	}
	//parse argument saved_reaction (Vector<Reaction>)
	if (saved_reaction_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(saved_reaction_len));
		int i;
		for (i=0; i<saved_reaction_len; ++i){
			buf = buf_cat(buf, saved_reaction_[i]);
		}
		*flag1 |= (1 << 3);
	}
	//parse argument top_msg_id (int)
	if (top_msg_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(top_msg_id_));
		*flag1 |= (1 << 1);
	}
	//parse argument filter (MessagesFilter)
	{
		buf = buf_cat(buf, *filter_);
	}
	//parse argument min_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(min_date_));
	}
	//parse argument max_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(max_date_));
	}
	//parse argument offset_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_id_));
	}
	//parse argument add_offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(add_offset_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	//parse argument max_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(max_id_));
	}
	//parse argument min_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(min_id_));
	}
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_messages_readHistory(InputPeer *peer_, int max_id_)
{
	buf_t buf = buf_add_ui32(0x0e306d3a);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument max_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(max_id_));
	}
	return buf;
}

buf_t tl_messages_deleteHistory(bool just_clear_, bool revoke_, InputPeer *peer_, int max_id_, int min_date_, int max_date_)
{
	buf_t buf = buf_add_ui32(0xb08f922a);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument just_clear (true)
	if (just_clear_)
		*flag1 |= (1 << 0);
	//parse argument revoke (true)
	if (revoke_)
		*flag1 |= (1 << 1);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument max_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(max_id_));
	}
	//parse argument min_date (int)
	if (min_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(min_date_));
		*flag1 |= (1 << 2);
	}
	//parse argument max_date (int)
	if (max_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(max_date_));
		*flag1 |= (1 << 3);
	}
	return buf;
}

buf_t tl_messages_deleteMessages(bool revoke_, int *id_, int id_len)
{
	buf_t buf = buf_add_ui32(0xe58e95d2);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument revoke (true)
	if (revoke_)
		*flag1 |= (1 << 0);
	//parse argument id (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(id_[i]));
		}
	}
	return buf;
}

buf_t tl_messages_receivedMessages(int max_id_)
{
	buf_t buf = buf_add_ui32(0x05a954c0);
	//parse argument max_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(max_id_));
	}
	return buf;
}

buf_t tl_messages_setTyping(InputPeer *peer_, int top_msg_id_, SendMessageAction *action_)
{
	buf_t buf = buf_add_ui32(0x58943ee2);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument top_msg_id (int)
	if (top_msg_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(top_msg_id_));
		*flag1 |= (1 << 0);
	}
	//parse argument action (SendMessageAction)
	{
		buf = buf_cat(buf, *action_);
	}
	return buf;
}

buf_t tl_messages_sendMessage(bool no_webpage_, bool silent_, bool background_, bool clear_draft_, bool noforwards_, bool update_stickersets_order_, bool invert_media_, InputPeer *peer_, InputReplyTo *reply_to_, const char * message_, long random_id_, ReplyMarkup *reply_markup_, MessageEntity *entities_, int entities_len, int schedule_date_, InputPeer *send_as_, InputQuickReplyShortcut *quick_reply_shortcut_, long effect_)
{
	buf_t buf = buf_add_ui32(0x983f9745);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument no_webpage (true)
	if (no_webpage_)
		*flag1 |= (1 << 1);
	//parse argument silent (true)
	if (silent_)
		*flag1 |= (1 << 5);
	//parse argument background (true)
	if (background_)
		*flag1 |= (1 << 6);
	//parse argument clear_draft (true)
	if (clear_draft_)
		*flag1 |= (1 << 7);
	//parse argument noforwards (true)
	if (noforwards_)
		*flag1 |= (1 << 14);
	//parse argument update_stickersets_order (true)
	if (update_stickersets_order_)
		*flag1 |= (1 << 15);
	//parse argument invert_media (true)
	if (invert_media_)
		*flag1 |= (1 << 16);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument reply_to (InputReplyTo)
	if (reply_to_)
	{
		buf = buf_cat(buf, *reply_to_);
		*flag1 |= (1 << 0);
	}
	//parse argument message (string)
	{
		buf = buf_cat(buf, serialize_string(message_));
	}
	//parse argument random_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(random_id_));
	}
	//parse argument reply_markup (ReplyMarkup)
	if (reply_markup_)
	{
		buf = buf_cat(buf, *reply_markup_);
		*flag1 |= (1 << 2);
	}
	//parse argument entities (Vector<MessageEntity>)
	if (entities_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(entities_len));
		int i;
		for (i=0; i<entities_len; ++i){
			buf = buf_cat(buf, entities_[i]);
		}
		*flag1 |= (1 << 3);
	}
	//parse argument schedule_date (int)
	if (schedule_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(schedule_date_));
		*flag1 |= (1 << 10);
	}
	//parse argument send_as (InputPeer)
	if (send_as_)
	{
		buf = buf_cat(buf, *send_as_);
		*flag1 |= (1 << 13);
	}
	//parse argument quick_reply_shortcut (InputQuickReplyShortcut)
	if (quick_reply_shortcut_)
	{
		buf = buf_cat(buf, *quick_reply_shortcut_);
		*flag1 |= (1 << 17);
	}
	//parse argument effect (long)
	if (effect_)
	{
		buf = buf_cat(buf, buf_add_ui64(effect_));
		*flag1 |= (1 << 18);
	}
	return buf;
}

buf_t tl_messages_sendMedia(bool silent_, bool background_, bool clear_draft_, bool noforwards_, bool update_stickersets_order_, bool invert_media_, InputPeer *peer_, InputReplyTo *reply_to_, InputMedia *media_, const char * message_, long random_id_, ReplyMarkup *reply_markup_, MessageEntity *entities_, int entities_len, int schedule_date_, InputPeer *send_as_, InputQuickReplyShortcut *quick_reply_shortcut_, long effect_)
{
	buf_t buf = buf_add_ui32(0x7852834e);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument silent (true)
	if (silent_)
		*flag1 |= (1 << 5);
	//parse argument background (true)
	if (background_)
		*flag1 |= (1 << 6);
	//parse argument clear_draft (true)
	if (clear_draft_)
		*flag1 |= (1 << 7);
	//parse argument noforwards (true)
	if (noforwards_)
		*flag1 |= (1 << 14);
	//parse argument update_stickersets_order (true)
	if (update_stickersets_order_)
		*flag1 |= (1 << 15);
	//parse argument invert_media (true)
	if (invert_media_)
		*flag1 |= (1 << 16);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument reply_to (InputReplyTo)
	if (reply_to_)
	{
		buf = buf_cat(buf, *reply_to_);
		*flag1 |= (1 << 0);
	}
	//parse argument media (InputMedia)
	{
		buf = buf_cat(buf, *media_);
	}
	//parse argument message (string)
	{
		buf = buf_cat(buf, serialize_string(message_));
	}
	//parse argument random_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(random_id_));
	}
	//parse argument reply_markup (ReplyMarkup)
	if (reply_markup_)
	{
		buf = buf_cat(buf, *reply_markup_);
		*flag1 |= (1 << 2);
	}
	//parse argument entities (Vector<MessageEntity>)
	if (entities_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(entities_len));
		int i;
		for (i=0; i<entities_len; ++i){
			buf = buf_cat(buf, entities_[i]);
		}
		*flag1 |= (1 << 3);
	}
	//parse argument schedule_date (int)
	if (schedule_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(schedule_date_));
		*flag1 |= (1 << 10);
	}
	//parse argument send_as (InputPeer)
	if (send_as_)
	{
		buf = buf_cat(buf, *send_as_);
		*flag1 |= (1 << 13);
	}
	//parse argument quick_reply_shortcut (InputQuickReplyShortcut)
	if (quick_reply_shortcut_)
	{
		buf = buf_cat(buf, *quick_reply_shortcut_);
		*flag1 |= (1 << 17);
	}
	//parse argument effect (long)
	if (effect_)
	{
		buf = buf_cat(buf, buf_add_ui64(effect_));
		*flag1 |= (1 << 18);
	}
	return buf;
}

buf_t tl_messages_forwardMessages(bool silent_, bool background_, bool with_my_score_, bool drop_author_, bool drop_media_captions_, bool noforwards_, InputPeer *from_peer_, int *id_, int id_len, long *random_id_, int random_id_len, InputPeer *to_peer_, int top_msg_id_, int schedule_date_, InputPeer *send_as_, InputQuickReplyShortcut *quick_reply_shortcut_)
{
	buf_t buf = buf_add_ui32(0xd5039208);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument silent (true)
	if (silent_)
		*flag1 |= (1 << 5);
	//parse argument background (true)
	if (background_)
		*flag1 |= (1 << 6);
	//parse argument with_my_score (true)
	if (with_my_score_)
		*flag1 |= (1 << 8);
	//parse argument drop_author (true)
	if (drop_author_)
		*flag1 |= (1 << 11);
	//parse argument drop_media_captions (true)
	if (drop_media_captions_)
		*flag1 |= (1 << 12);
	//parse argument noforwards (true)
	if (noforwards_)
		*flag1 |= (1 << 14);
	//parse argument from_peer (InputPeer)
	{
		buf = buf_cat(buf, *from_peer_);
	}
	//parse argument id (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(id_[i]));
		}
	}
	//parse argument random_id (Vector<long>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(random_id_len));
		int i;
		for (i=0; i<random_id_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(random_id_[i]));
		}
	}
	//parse argument to_peer (InputPeer)
	{
		buf = buf_cat(buf, *to_peer_);
	}
	//parse argument top_msg_id (int)
	if (top_msg_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(top_msg_id_));
		*flag1 |= (1 << 9);
	}
	//parse argument schedule_date (int)
	if (schedule_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(schedule_date_));
		*flag1 |= (1 << 10);
	}
	//parse argument send_as (InputPeer)
	if (send_as_)
	{
		buf = buf_cat(buf, *send_as_);
		*flag1 |= (1 << 13);
	}
	//parse argument quick_reply_shortcut (InputQuickReplyShortcut)
	if (quick_reply_shortcut_)
	{
		buf = buf_cat(buf, *quick_reply_shortcut_);
		*flag1 |= (1 << 17);
	}
	return buf;
}

buf_t tl_messages_reportSpam(InputPeer *peer_)
{
	buf_t buf = buf_add_ui32(0xcf1592db);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_messages_getPeerSettings(InputPeer *peer_)
{
	buf_t buf = buf_add_ui32(0xefd9a6a2);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_messages_report(InputPeer *peer_, int *id_, int id_len, buf_t *option_, const char * message_)
{
	buf_t buf = buf_add_ui32(0xfc78af9b);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument id (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(id_[i]));
		}
	}
	//parse argument option (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(option_->data, option_->size));
	}
	//parse argument message (string)
	{
		buf = buf_cat(buf, serialize_string(message_));
	}
	return buf;
}

buf_t tl_messages_getChats(long *id_, int id_len)
{
	buf_t buf = buf_add_ui32(0x49e9528f);
	//parse argument id (Vector<long>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(id_[i]));
		}
	}
	return buf;
}

buf_t tl_messages_getFullChat(long chat_id_)
{
	buf_t buf = buf_add_ui32(0xaeb00b34);
	//parse argument chat_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(chat_id_));
	}
	return buf;
}

buf_t tl_messages_editChatTitle(long chat_id_, const char * title_)
{
	buf_t buf = buf_add_ui32(0x73783ffd);
	//parse argument chat_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(chat_id_));
	}
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	return buf;
}

buf_t tl_messages_editChatPhoto(long chat_id_, InputChatPhoto *photo_)
{
	buf_t buf = buf_add_ui32(0x35ddd674);
	//parse argument chat_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(chat_id_));
	}
	//parse argument photo (InputChatPhoto)
	{
		buf = buf_cat(buf, *photo_);
	}
	return buf;
}

buf_t tl_messages_addChatUser(long chat_id_, InputUser *user_id_, int fwd_limit_)
{
	buf_t buf = buf_add_ui32(0xcbc6d107);
	//parse argument chat_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(chat_id_));
	}
	//parse argument user_id (InputUser)
	{
		buf = buf_cat(buf, *user_id_);
	}
	//parse argument fwd_limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(fwd_limit_));
	}
	return buf;
}

buf_t tl_messages_deleteChatUser(bool revoke_history_, long chat_id_, InputUser *user_id_)
{
	buf_t buf = buf_add_ui32(0xa2185cab);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument revoke_history (true)
	if (revoke_history_)
		*flag1 |= (1 << 0);
	//parse argument chat_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(chat_id_));
	}
	//parse argument user_id (InputUser)
	{
		buf = buf_cat(buf, *user_id_);
	}
	return buf;
}

buf_t tl_messages_createChat(InputUser *users_, int users_len, const char * title_, int ttl_period_)
{
	buf_t buf = buf_add_ui32(0x92ceddd4);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument users (Vector<InputUser>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument ttl_period (int)
	if (ttl_period_)
	{
		buf = buf_cat(buf, buf_add_ui32(ttl_period_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_messages_getDhConfig(int version_, int random_length_)
{
	buf_t buf = buf_add_ui32(0x26cf8950);
	//parse argument version (int)
	{
		buf = buf_cat(buf, buf_add_ui32(version_));
	}
	//parse argument random_length (int)
	{
		buf = buf_cat(buf, buf_add_ui32(random_length_));
	}
	return buf;
}

buf_t tl_messages_requestEncryption(InputUser *user_id_, int random_id_, buf_t *g_a_)
{
	buf_t buf = buf_add_ui32(0xf64daf43);
	//parse argument user_id (InputUser)
	{
		buf = buf_cat(buf, *user_id_);
	}
	//parse argument random_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(random_id_));
	}
	//parse argument g_a (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(g_a_->data, g_a_->size));
	}
	return buf;
}

buf_t tl_messages_acceptEncryption(InputEncryptedChat *peer_, buf_t *g_b_, long key_fingerprint_)
{
	buf_t buf = buf_add_ui32(0x3dbc0415);
	//parse argument peer (InputEncryptedChat)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument g_b (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(g_b_->data, g_b_->size));
	}
	//parse argument key_fingerprint (long)
	{
		buf = buf_cat(buf, buf_add_ui64(key_fingerprint_));
	}
	return buf;
}

buf_t tl_messages_discardEncryption(bool delete_history_, int chat_id_)
{
	buf_t buf = buf_add_ui32(0xf393aea0);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument delete_history (true)
	if (delete_history_)
		*flag1 |= (1 << 0);
	//parse argument chat_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(chat_id_));
	}
	return buf;
}

buf_t tl_messages_setEncryptedTyping(InputEncryptedChat *peer_, Bool *typing_)
{
	buf_t buf = buf_add_ui32(0x791451ed);
	//parse argument peer (InputEncryptedChat)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument typing (Bool)
	{
		buf = buf_cat(buf, *typing_);
	}
	return buf;
}

buf_t tl_messages_readEncryptedHistory(InputEncryptedChat *peer_, int max_date_)
{
	buf_t buf = buf_add_ui32(0x7f4b690a);
	//parse argument peer (InputEncryptedChat)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument max_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(max_date_));
	}
	return buf;
}

buf_t tl_messages_sendEncrypted(bool silent_, InputEncryptedChat *peer_, long random_id_, buf_t *data_)
{
	buf_t buf = buf_add_ui32(0x44fa7a15);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument silent (true)
	if (silent_)
		*flag1 |= (1 << 0);
	//parse argument peer (InputEncryptedChat)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument random_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(random_id_));
	}
	//parse argument data (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(data_->data, data_->size));
	}
	return buf;
}

buf_t tl_messages_sendEncryptedFile(bool silent_, InputEncryptedChat *peer_, long random_id_, buf_t *data_, InputEncryptedFile *file_)
{
	buf_t buf = buf_add_ui32(0x5559481d);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument silent (true)
	if (silent_)
		*flag1 |= (1 << 0);
	//parse argument peer (InputEncryptedChat)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument random_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(random_id_));
	}
	//parse argument data (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(data_->data, data_->size));
	}
	//parse argument file (InputEncryptedFile)
	{
		buf = buf_cat(buf, *file_);
	}
	return buf;
}

buf_t tl_messages_sendEncryptedService(InputEncryptedChat *peer_, long random_id_, buf_t *data_)
{
	buf_t buf = buf_add_ui32(0x32d439a4);
	//parse argument peer (InputEncryptedChat)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument random_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(random_id_));
	}
	//parse argument data (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(data_->data, data_->size));
	}
	return buf;
}

buf_t tl_messages_receivedQueue(int max_qts_)
{
	buf_t buf = buf_add_ui32(0x55a5bb66);
	//parse argument max_qts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(max_qts_));
	}
	return buf;
}

buf_t tl_messages_reportEncryptedSpam(InputEncryptedChat *peer_)
{
	buf_t buf = buf_add_ui32(0x4b0c8c0f);
	//parse argument peer (InputEncryptedChat)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_messages_readMessageContents(int *id_, int id_len)
{
	buf_t buf = buf_add_ui32(0x36a73f77);
	//parse argument id (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(id_[i]));
		}
	}
	return buf;
}

buf_t tl_messages_getStickers(const char * emoticon_, long hash_)
{
	buf_t buf = buf_add_ui32(0xd5a5d3a1);
	//parse argument emoticon (string)
	{
		buf = buf_cat(buf, serialize_string(emoticon_));
	}
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_messages_getAllStickers(long hash_)
{
	buf_t buf = buf_add_ui32(0xb8a0a1a8);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_messages_getWebPagePreview(const char * message_, MessageEntity *entities_, int entities_len)
{
	buf_t buf = buf_add_ui32(0x8b68b0cc);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument message (string)
	{
		buf = buf_cat(buf, serialize_string(message_));
	}
	//parse argument entities (Vector<MessageEntity>)
	if (entities_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(entities_len));
		int i;
		for (i=0; i<entities_len; ++i){
			buf = buf_cat(buf, entities_[i]);
		}
		*flag1 |= (1 << 3);
	}
	return buf;
}

buf_t tl_messages_exportChatInvite(bool legacy_revoke_permanent_, bool request_needed_, InputPeer *peer_, int expire_date_, int usage_limit_, const char * title_, StarsSubscriptionPricing *subscription_pricing_)
{
	buf_t buf = buf_add_ui32(0xa455de90);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument legacy_revoke_permanent (true)
	if (legacy_revoke_permanent_)
		*flag1 |= (1 << 2);
	//parse argument request_needed (true)
	if (request_needed_)
		*flag1 |= (1 << 3);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument expire_date (int)
	if (expire_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(expire_date_));
		*flag1 |= (1 << 0);
	}
	//parse argument usage_limit (int)
	if (usage_limit_)
	{
		buf = buf_cat(buf, buf_add_ui32(usage_limit_));
		*flag1 |= (1 << 1);
	}
	//parse argument title (string)
	if (title_)
	{
		buf = buf_cat(buf, serialize_string(title_));
		*flag1 |= (1 << 4);
	}
	//parse argument subscription_pricing (StarsSubscriptionPricing)
	if (subscription_pricing_)
	{
		buf = buf_cat(buf, *subscription_pricing_);
		*flag1 |= (1 << 5);
	}
	return buf;
}

buf_t tl_messages_checkChatInvite(const char * hash_)
{
	buf_t buf = buf_add_ui32(0x3eadb1bb);
	//parse argument hash (string)
	{
		buf = buf_cat(buf, serialize_string(hash_));
	}
	return buf;
}

buf_t tl_messages_importChatInvite(const char * hash_)
{
	buf_t buf = buf_add_ui32(0x6c50051c);
	//parse argument hash (string)
	{
		buf = buf_cat(buf, serialize_string(hash_));
	}
	return buf;
}

buf_t tl_messages_getStickerSet(InputStickerSet *stickerset_, int hash_)
{
	buf_t buf = buf_add_ui32(0xc8a0ec74);
	//parse argument stickerset (InputStickerSet)
	{
		buf = buf_cat(buf, *stickerset_);
	}
	//parse argument hash (int)
	{
		buf = buf_cat(buf, buf_add_ui32(hash_));
	}
	return buf;
}

buf_t tl_messages_installStickerSet(InputStickerSet *stickerset_, Bool *archived_)
{
	buf_t buf = buf_add_ui32(0xc78fe460);
	//parse argument stickerset (InputStickerSet)
	{
		buf = buf_cat(buf, *stickerset_);
	}
	//parse argument archived (Bool)
	{
		buf = buf_cat(buf, *archived_);
	}
	return buf;
}

buf_t tl_messages_uninstallStickerSet(InputStickerSet *stickerset_)
{
	buf_t buf = buf_add_ui32(0xf96e55de);
	//parse argument stickerset (InputStickerSet)
	{
		buf = buf_cat(buf, *stickerset_);
	}
	return buf;
}

buf_t tl_messages_startBot(InputUser *bot_, InputPeer *peer_, long random_id_, const char * start_param_)
{
	buf_t buf = buf_add_ui32(0xe6df7378);
	//parse argument bot (InputUser)
	{
		buf = buf_cat(buf, *bot_);
	}
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument random_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(random_id_));
	}
	//parse argument start_param (string)
	{
		buf = buf_cat(buf, serialize_string(start_param_));
	}
	return buf;
}

buf_t tl_messages_getMessagesViews(InputPeer *peer_, int *id_, int id_len, Bool *increment_)
{
	buf_t buf = buf_add_ui32(0x5784d3e1);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument id (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(id_[i]));
		}
	}
	//parse argument increment (Bool)
	{
		buf = buf_cat(buf, *increment_);
	}
	return buf;
}

buf_t tl_messages_editChatAdmin(long chat_id_, InputUser *user_id_, Bool *is_admin_)
{
	buf_t buf = buf_add_ui32(0xa85bd1c2);
	//parse argument chat_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(chat_id_));
	}
	//parse argument user_id (InputUser)
	{
		buf = buf_cat(buf, *user_id_);
	}
	//parse argument is_admin (Bool)
	{
		buf = buf_cat(buf, *is_admin_);
	}
	return buf;
}

buf_t tl_messages_migrateChat(long chat_id_)
{
	buf_t buf = buf_add_ui32(0xa2875319);
	//parse argument chat_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(chat_id_));
	}
	return buf;
}

buf_t tl_messages_searchGlobal(bool broadcasts_only_, int folder_id_, const char * q_, MessagesFilter *filter_, int min_date_, int max_date_, int offset_rate_, InputPeer *offset_peer_, int offset_id_, int limit_)
{
	buf_t buf = buf_add_ui32(0x4bc6589a);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument broadcasts_only (true)
	if (broadcasts_only_)
		*flag1 |= (1 << 1);
	//parse argument folder_id (int)
	if (folder_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(folder_id_));
		*flag1 |= (1 << 0);
	}
	//parse argument q (string)
	{
		buf = buf_cat(buf, serialize_string(q_));
	}
	//parse argument filter (MessagesFilter)
	{
		buf = buf_cat(buf, *filter_);
	}
	//parse argument min_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(min_date_));
	}
	//parse argument max_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(max_date_));
	}
	//parse argument offset_rate (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_rate_));
	}
	//parse argument offset_peer (InputPeer)
	{
		buf = buf_cat(buf, *offset_peer_);
	}
	//parse argument offset_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_id_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	return buf;
}

buf_t tl_messages_reorderStickerSets(bool masks_, bool emojis_, long *order_, int order_len)
{
	buf_t buf = buf_add_ui32(0x78337739);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument masks (true)
	if (masks_)
		*flag1 |= (1 << 0);
	//parse argument emojis (true)
	if (emojis_)
		*flag1 |= (1 << 1);
	//parse argument order (Vector<long>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(order_len));
		int i;
		for (i=0; i<order_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(order_[i]));
		}
	}
	return buf;
}

buf_t tl_messages_getDocumentByHash(buf_t *sha256_, long size_, const char * mime_type_)
{
	buf_t buf = buf_add_ui32(0xb1f2061f);
	//parse argument sha256 (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(sha256_->data, sha256_->size));
	}
	//parse argument size (long)
	{
		buf = buf_cat(buf, buf_add_ui64(size_));
	}
	//parse argument mime_type (string)
	{
		buf = buf_cat(buf, serialize_string(mime_type_));
	}
	return buf;
}

buf_t tl_messages_getSavedGifs(long hash_)
{
	buf_t buf = buf_add_ui32(0x5cf09635);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_messages_saveGif(InputDocument *id_, Bool *unsave_)
{
	buf_t buf = buf_add_ui32(0x327a30cb);
	//parse argument id (InputDocument)
	{
		buf = buf_cat(buf, *id_);
	}
	//parse argument unsave (Bool)
	{
		buf = buf_cat(buf, *unsave_);
	}
	return buf;
}

buf_t tl_messages_getInlineBotResults(InputUser *bot_, InputPeer *peer_, InputGeoPoint *geo_point_, const char * query_, const char * offset_)
{
	buf_t buf = buf_add_ui32(0x514e999d);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument bot (InputUser)
	{
		buf = buf_cat(buf, *bot_);
	}
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument geo_point (InputGeoPoint)
	if (geo_point_)
	{
		buf = buf_cat(buf, *geo_point_);
		*flag1 |= (1 << 0);
	}
	//parse argument query (string)
	{
		buf = buf_cat(buf, serialize_string(query_));
	}
	//parse argument offset (string)
	{
		buf = buf_cat(buf, serialize_string(offset_));
	}
	return buf;
}

buf_t tl_messages_setInlineBotResults(bool gallery_, bool private_, long query_id_, InputBotInlineResult *results_, int results_len, int cache_time_, const char * next_offset_, InlineBotSwitchPM *switch_pm_, InlineBotWebView *switch_webview_)
{
	buf_t buf = buf_add_ui32(0xbb12a419);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument gallery (true)
	if (gallery_)
		*flag1 |= (1 << 0);
	//parse argument private (true)
	if (private_)
		*flag1 |= (1 << 1);
	//parse argument query_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(query_id_));
	}
	//parse argument results (Vector<InputBotInlineResult>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(results_len));
		int i;
		for (i=0; i<results_len; ++i){
			buf = buf_cat(buf, results_[i]);
		}
	}
	//parse argument cache_time (int)
	{
		buf = buf_cat(buf, buf_add_ui32(cache_time_));
	}
	//parse argument next_offset (string)
	if (next_offset_)
	{
		buf = buf_cat(buf, serialize_string(next_offset_));
		*flag1 |= (1 << 2);
	}
	//parse argument switch_pm (InlineBotSwitchPM)
	if (switch_pm_)
	{
		buf = buf_cat(buf, *switch_pm_);
		*flag1 |= (1 << 3);
	}
	//parse argument switch_webview (InlineBotWebView)
	if (switch_webview_)
	{
		buf = buf_cat(buf, *switch_webview_);
		*flag1 |= (1 << 4);
	}
	return buf;
}

buf_t tl_messages_sendInlineBotResult(bool silent_, bool background_, bool clear_draft_, bool hide_via_, InputPeer *peer_, InputReplyTo *reply_to_, long random_id_, long query_id_, const char * id_, int schedule_date_, InputPeer *send_as_, InputQuickReplyShortcut *quick_reply_shortcut_)
{
	buf_t buf = buf_add_ui32(0x3ebee86a);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument silent (true)
	if (silent_)
		*flag1 |= (1 << 5);
	//parse argument background (true)
	if (background_)
		*flag1 |= (1 << 6);
	//parse argument clear_draft (true)
	if (clear_draft_)
		*flag1 |= (1 << 7);
	//parse argument hide_via (true)
	if (hide_via_)
		*flag1 |= (1 << 11);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument reply_to (InputReplyTo)
	if (reply_to_)
	{
		buf = buf_cat(buf, *reply_to_);
		*flag1 |= (1 << 0);
	}
	//parse argument random_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(random_id_));
	}
	//parse argument query_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(query_id_));
	}
	//parse argument id (string)
	{
		buf = buf_cat(buf, serialize_string(id_));
	}
	//parse argument schedule_date (int)
	if (schedule_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(schedule_date_));
		*flag1 |= (1 << 10);
	}
	//parse argument send_as (InputPeer)
	if (send_as_)
	{
		buf = buf_cat(buf, *send_as_);
		*flag1 |= (1 << 13);
	}
	//parse argument quick_reply_shortcut (InputQuickReplyShortcut)
	if (quick_reply_shortcut_)
	{
		buf = buf_cat(buf, *quick_reply_shortcut_);
		*flag1 |= (1 << 17);
	}
	return buf;
}

buf_t tl_messages_getMessageEditData(InputPeer *peer_, int id_)
{
	buf_t buf = buf_add_ui32(0xfda68d36);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	return buf;
}

buf_t tl_messages_editMessage(bool no_webpage_, bool invert_media_, InputPeer *peer_, int id_, const char * message_, InputMedia *media_, ReplyMarkup *reply_markup_, MessageEntity *entities_, int entities_len, int schedule_date_, int quick_reply_shortcut_id_)
{
	buf_t buf = buf_add_ui32(0xdfd14005);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument no_webpage (true)
	if (no_webpage_)
		*flag1 |= (1 << 1);
	//parse argument invert_media (true)
	if (invert_media_)
		*flag1 |= (1 << 16);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument message (string)
	if (message_)
	{
		buf = buf_cat(buf, serialize_string(message_));
		*flag1 |= (1 << 11);
	}
	//parse argument media (InputMedia)
	if (media_)
	{
		buf = buf_cat(buf, *media_);
		*flag1 |= (1 << 14);
	}
	//parse argument reply_markup (ReplyMarkup)
	if (reply_markup_)
	{
		buf = buf_cat(buf, *reply_markup_);
		*flag1 |= (1 << 2);
	}
	//parse argument entities (Vector<MessageEntity>)
	if (entities_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(entities_len));
		int i;
		for (i=0; i<entities_len; ++i){
			buf = buf_cat(buf, entities_[i]);
		}
		*flag1 |= (1 << 3);
	}
	//parse argument schedule_date (int)
	if (schedule_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(schedule_date_));
		*flag1 |= (1 << 15);
	}
	//parse argument quick_reply_shortcut_id (int)
	if (quick_reply_shortcut_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(quick_reply_shortcut_id_));
		*flag1 |= (1 << 17);
	}
	return buf;
}

buf_t tl_messages_editInlineBotMessage(bool no_webpage_, bool invert_media_, InputBotInlineMessageID *id_, const char * message_, InputMedia *media_, ReplyMarkup *reply_markup_, MessageEntity *entities_, int entities_len)
{
	buf_t buf = buf_add_ui32(0x83557dba);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument no_webpage (true)
	if (no_webpage_)
		*flag1 |= (1 << 1);
	//parse argument invert_media (true)
	if (invert_media_)
		*flag1 |= (1 << 16);
	//parse argument id (InputBotInlineMessageID)
	{
		buf = buf_cat(buf, *id_);
	}
	//parse argument message (string)
	if (message_)
	{
		buf = buf_cat(buf, serialize_string(message_));
		*flag1 |= (1 << 11);
	}
	//parse argument media (InputMedia)
	if (media_)
	{
		buf = buf_cat(buf, *media_);
		*flag1 |= (1 << 14);
	}
	//parse argument reply_markup (ReplyMarkup)
	if (reply_markup_)
	{
		buf = buf_cat(buf, *reply_markup_);
		*flag1 |= (1 << 2);
	}
	//parse argument entities (Vector<MessageEntity>)
	if (entities_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(entities_len));
		int i;
		for (i=0; i<entities_len; ++i){
			buf = buf_cat(buf, entities_[i]);
		}
		*flag1 |= (1 << 3);
	}
	return buf;
}

buf_t tl_messages_getBotCallbackAnswer(bool game_, InputPeer *peer_, int msg_id_, buf_t *data_, InputCheckPasswordSRP *password_)
{
	buf_t buf = buf_add_ui32(0x9342ca07);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument game (true)
	if (game_)
		*flag1 |= (1 << 1);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	//parse argument data (bytes)
	if (data_)
	{
		buf = buf_cat(buf, serialize_bytes(data_->data, data_->size));
		*flag1 |= (1 << 0);
	}
	//parse argument password (InputCheckPasswordSRP)
	if (password_)
	{
		buf = buf_cat(buf, *password_);
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_messages_setBotCallbackAnswer(bool alert_, long query_id_, const char * message_, const char * url_, int cache_time_)
{
	buf_t buf = buf_add_ui32(0xd58f130a);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument alert (true)
	if (alert_)
		*flag1 |= (1 << 1);
	//parse argument query_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(query_id_));
	}
	//parse argument message (string)
	if (message_)
	{
		buf = buf_cat(buf, serialize_string(message_));
		*flag1 |= (1 << 0);
	}
	//parse argument url (string)
	if (url_)
	{
		buf = buf_cat(buf, serialize_string(url_));
		*flag1 |= (1 << 2);
	}
	//parse argument cache_time (int)
	{
		buf = buf_cat(buf, buf_add_ui32(cache_time_));
	}
	return buf;
}

buf_t tl_messages_getPeerDialogs(InputDialogPeer *peers_, int peers_len)
{
	buf_t buf = buf_add_ui32(0xe470bcfd);
	//parse argument peers (Vector<InputDialogPeer>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(peers_len));
		int i;
		for (i=0; i<peers_len; ++i){
			buf = buf_cat(buf, peers_[i]);
		}
	}
	return buf;
}

buf_t tl_messages_saveDraft(bool no_webpage_, bool invert_media_, InputReplyTo *reply_to_, InputPeer *peer_, const char * message_, MessageEntity *entities_, int entities_len, InputMedia *media_, long effect_)
{
	buf_t buf = buf_add_ui32(0xd372c5ce);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument no_webpage (true)
	if (no_webpage_)
		*flag1 |= (1 << 1);
	//parse argument invert_media (true)
	if (invert_media_)
		*flag1 |= (1 << 6);
	//parse argument reply_to (InputReplyTo)
	if (reply_to_)
	{
		buf = buf_cat(buf, *reply_to_);
		*flag1 |= (1 << 4);
	}
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument message (string)
	{
		buf = buf_cat(buf, serialize_string(message_));
	}
	//parse argument entities (Vector<MessageEntity>)
	if (entities_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(entities_len));
		int i;
		for (i=0; i<entities_len; ++i){
			buf = buf_cat(buf, entities_[i]);
		}
		*flag1 |= (1 << 3);
	}
	//parse argument media (InputMedia)
	if (media_)
	{
		buf = buf_cat(buf, *media_);
		*flag1 |= (1 << 5);
	}
	//parse argument effect (long)
	if (effect_)
	{
		buf = buf_cat(buf, buf_add_ui64(effect_));
		*flag1 |= (1 << 7);
	}
	return buf;
}

buf_t tl_messages_getAllDrafts()
{
	buf_t buf = buf_add_ui32(0x6a3f8d65);
	return buf;
}

buf_t tl_messages_getFeaturedStickers(long hash_)
{
	buf_t buf = buf_add_ui32(0x64780b14);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_messages_readFeaturedStickers(long *id_, int id_len)
{
	buf_t buf = buf_add_ui32(0x5b118126);
	//parse argument id (Vector<long>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(id_[i]));
		}
	}
	return buf;
}

buf_t tl_messages_getRecentStickers(bool attached_, long hash_)
{
	buf_t buf = buf_add_ui32(0x9da9403b);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument attached (true)
	if (attached_)
		*flag1 |= (1 << 0);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_messages_saveRecentSticker(bool attached_, InputDocument *id_, Bool *unsave_)
{
	buf_t buf = buf_add_ui32(0x392718f8);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument attached (true)
	if (attached_)
		*flag1 |= (1 << 0);
	//parse argument id (InputDocument)
	{
		buf = buf_cat(buf, *id_);
	}
	//parse argument unsave (Bool)
	{
		buf = buf_cat(buf, *unsave_);
	}
	return buf;
}

buf_t tl_messages_clearRecentStickers(bool attached_)
{
	buf_t buf = buf_add_ui32(0x8999602d);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument attached (true)
	if (attached_)
		*flag1 |= (1 << 0);
	return buf;
}

buf_t tl_messages_getArchivedStickers(bool masks_, bool emojis_, long offset_id_, int limit_)
{
	buf_t buf = buf_add_ui32(0x57f17692);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument masks (true)
	if (masks_)
		*flag1 |= (1 << 0);
	//parse argument emojis (true)
	if (emojis_)
		*flag1 |= (1 << 1);
	//parse argument offset_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(offset_id_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	return buf;
}

buf_t tl_messages_getMaskStickers(long hash_)
{
	buf_t buf = buf_add_ui32(0x640f82b8);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_messages_getAttachedStickers(InputStickeredMedia *media_)
{
	buf_t buf = buf_add_ui32(0xcc5b67cc);
	//parse argument media (InputStickeredMedia)
	{
		buf = buf_cat(buf, *media_);
	}
	return buf;
}

buf_t tl_messages_setGameScore(bool edit_message_, bool force_, InputPeer *peer_, int id_, InputUser *user_id_, int score_)
{
	buf_t buf = buf_add_ui32(0x8ef8ecc0);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument edit_message (true)
	if (edit_message_)
		*flag1 |= (1 << 0);
	//parse argument force (true)
	if (force_)
		*flag1 |= (1 << 1);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument user_id (InputUser)
	{
		buf = buf_cat(buf, *user_id_);
	}
	//parse argument score (int)
	{
		buf = buf_cat(buf, buf_add_ui32(score_));
	}
	return buf;
}

buf_t tl_messages_setInlineGameScore(bool edit_message_, bool force_, InputBotInlineMessageID *id_, InputUser *user_id_, int score_)
{
	buf_t buf = buf_add_ui32(0x15ad9f64);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument edit_message (true)
	if (edit_message_)
		*flag1 |= (1 << 0);
	//parse argument force (true)
	if (force_)
		*flag1 |= (1 << 1);
	//parse argument id (InputBotInlineMessageID)
	{
		buf = buf_cat(buf, *id_);
	}
	//parse argument user_id (InputUser)
	{
		buf = buf_cat(buf, *user_id_);
	}
	//parse argument score (int)
	{
		buf = buf_cat(buf, buf_add_ui32(score_));
	}
	return buf;
}

buf_t tl_messages_getGameHighScores(InputPeer *peer_, int id_, InputUser *user_id_)
{
	buf_t buf = buf_add_ui32(0xe822649d);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument user_id (InputUser)
	{
		buf = buf_cat(buf, *user_id_);
	}
	return buf;
}

buf_t tl_messages_getInlineGameHighScores(InputBotInlineMessageID *id_, InputUser *user_id_)
{
	buf_t buf = buf_add_ui32(0x0f635e1b);
	//parse argument id (InputBotInlineMessageID)
	{
		buf = buf_cat(buf, *id_);
	}
	//parse argument user_id (InputUser)
	{
		buf = buf_cat(buf, *user_id_);
	}
	return buf;
}

buf_t tl_messages_getCommonChats(InputUser *user_id_, long max_id_, int limit_)
{
	buf_t buf = buf_add_ui32(0xe40ca104);
	//parse argument user_id (InputUser)
	{
		buf = buf_cat(buf, *user_id_);
	}
	//parse argument max_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(max_id_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	return buf;
}

buf_t tl_messages_getWebPage(const char * url_, int hash_)
{
	buf_t buf = buf_add_ui32(0x8d9692a3);
	//parse argument url (string)
	{
		buf = buf_cat(buf, serialize_string(url_));
	}
	//parse argument hash (int)
	{
		buf = buf_cat(buf, buf_add_ui32(hash_));
	}
	return buf;
}

buf_t tl_messages_toggleDialogPin(bool pinned_, InputDialogPeer *peer_)
{
	buf_t buf = buf_add_ui32(0xa731e257);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument pinned (true)
	if (pinned_)
		*flag1 |= (1 << 0);
	//parse argument peer (InputDialogPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_messages_reorderPinnedDialogs(bool force_, int folder_id_, InputDialogPeer *order_, int order_len)
{
	buf_t buf = buf_add_ui32(0x3b1adf37);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument force (true)
	if (force_)
		*flag1 |= (1 << 0);
	//parse argument folder_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(folder_id_));
	}
	//parse argument order (Vector<InputDialogPeer>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(order_len));
		int i;
		for (i=0; i<order_len; ++i){
			buf = buf_cat(buf, order_[i]);
		}
	}
	return buf;
}

buf_t tl_messages_getPinnedDialogs(int folder_id_)
{
	buf_t buf = buf_add_ui32(0xd6b94df2);
	//parse argument folder_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(folder_id_));
	}
	return buf;
}

buf_t tl_messages_setBotShippingResults(long query_id_, const char * error_, ShippingOption *shipping_options_, int shipping_options_len)
{
	buf_t buf = buf_add_ui32(0xe5f672fa);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument query_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(query_id_));
	}
	//parse argument error (string)
	if (error_)
	{
		buf = buf_cat(buf, serialize_string(error_));
		*flag1 |= (1 << 0);
	}
	//parse argument shipping_options (Vector<ShippingOption>)
	if (shipping_options_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(shipping_options_len));
		int i;
		for (i=0; i<shipping_options_len; ++i){
			buf = buf_cat(buf, shipping_options_[i]);
		}
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_messages_setBotPrecheckoutResults(bool success_, long query_id_, const char * error_)
{
	buf_t buf = buf_add_ui32(0x09c2dd95);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument success (true)
	if (success_)
		*flag1 |= (1 << 1);
	//parse argument query_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(query_id_));
	}
	//parse argument error (string)
	if (error_)
	{
		buf = buf_cat(buf, serialize_string(error_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_messages_uploadMedia(const char * business_connection_id_, InputPeer *peer_, InputMedia *media_)
{
	buf_t buf = buf_add_ui32(0x14967978);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument business_connection_id (string)
	if (business_connection_id_)
	{
		buf = buf_cat(buf, serialize_string(business_connection_id_));
		*flag1 |= (1 << 0);
	}
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument media (InputMedia)
	{
		buf = buf_cat(buf, *media_);
	}
	return buf;
}

buf_t tl_messages_sendScreenshotNotification(InputPeer *peer_, InputReplyTo *reply_to_, long random_id_)
{
	buf_t buf = buf_add_ui32(0xa1405817);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument reply_to (InputReplyTo)
	{
		buf = buf_cat(buf, *reply_to_);
	}
	//parse argument random_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(random_id_));
	}
	return buf;
}

buf_t tl_messages_getFavedStickers(long hash_)
{
	buf_t buf = buf_add_ui32(0x04f1aaa9);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_messages_faveSticker(InputDocument *id_, Bool *unfave_)
{
	buf_t buf = buf_add_ui32(0xb9ffc55b);
	//parse argument id (InputDocument)
	{
		buf = buf_cat(buf, *id_);
	}
	//parse argument unfave (Bool)
	{
		buf = buf_cat(buf, *unfave_);
	}
	return buf;
}

buf_t tl_messages_getUnreadMentions(InputPeer *peer_, int top_msg_id_, int offset_id_, int add_offset_, int limit_, int max_id_, int min_id_)
{
	buf_t buf = buf_add_ui32(0xf107e790);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument top_msg_id (int)
	if (top_msg_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(top_msg_id_));
		*flag1 |= (1 << 0);
	}
	//parse argument offset_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_id_));
	}
	//parse argument add_offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(add_offset_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	//parse argument max_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(max_id_));
	}
	//parse argument min_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(min_id_));
	}
	return buf;
}

buf_t tl_messages_readMentions(InputPeer *peer_, int top_msg_id_)
{
	buf_t buf = buf_add_ui32(0x36e5bf4d);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument top_msg_id (int)
	if (top_msg_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(top_msg_id_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_messages_getRecentLocations(InputPeer *peer_, int limit_, long hash_)
{
	buf_t buf = buf_add_ui32(0x702a40e0);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_messages_sendMultiMedia(bool silent_, bool background_, bool clear_draft_, bool noforwards_, bool update_stickersets_order_, bool invert_media_, InputPeer *peer_, InputReplyTo *reply_to_, InputSingleMedia *multi_media_, int multi_media_len, int schedule_date_, InputPeer *send_as_, InputQuickReplyShortcut *quick_reply_shortcut_, long effect_)
{
	buf_t buf = buf_add_ui32(0x37b74355);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument silent (true)
	if (silent_)
		*flag1 |= (1 << 5);
	//parse argument background (true)
	if (background_)
		*flag1 |= (1 << 6);
	//parse argument clear_draft (true)
	if (clear_draft_)
		*flag1 |= (1 << 7);
	//parse argument noforwards (true)
	if (noforwards_)
		*flag1 |= (1 << 14);
	//parse argument update_stickersets_order (true)
	if (update_stickersets_order_)
		*flag1 |= (1 << 15);
	//parse argument invert_media (true)
	if (invert_media_)
		*flag1 |= (1 << 16);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument reply_to (InputReplyTo)
	if (reply_to_)
	{
		buf = buf_cat(buf, *reply_to_);
		*flag1 |= (1 << 0);
	}
	//parse argument multi_media (Vector<InputSingleMedia>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(multi_media_len));
		int i;
		for (i=0; i<multi_media_len; ++i){
			buf = buf_cat(buf, multi_media_[i]);
		}
	}
	//parse argument schedule_date (int)
	if (schedule_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(schedule_date_));
		*flag1 |= (1 << 10);
	}
	//parse argument send_as (InputPeer)
	if (send_as_)
	{
		buf = buf_cat(buf, *send_as_);
		*flag1 |= (1 << 13);
	}
	//parse argument quick_reply_shortcut (InputQuickReplyShortcut)
	if (quick_reply_shortcut_)
	{
		buf = buf_cat(buf, *quick_reply_shortcut_);
		*flag1 |= (1 << 17);
	}
	//parse argument effect (long)
	if (effect_)
	{
		buf = buf_cat(buf, buf_add_ui64(effect_));
		*flag1 |= (1 << 18);
	}
	return buf;
}

buf_t tl_messages_uploadEncryptedFile(InputEncryptedChat *peer_, InputEncryptedFile *file_)
{
	buf_t buf = buf_add_ui32(0x5057c497);
	//parse argument peer (InputEncryptedChat)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument file (InputEncryptedFile)
	{
		buf = buf_cat(buf, *file_);
	}
	return buf;
}

buf_t tl_messages_searchStickerSets(bool exclude_featured_, const char * q_, long hash_)
{
	buf_t buf = buf_add_ui32(0x35705b8a);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument exclude_featured (true)
	if (exclude_featured_)
		*flag1 |= (1 << 0);
	//parse argument q (string)
	{
		buf = buf_cat(buf, serialize_string(q_));
	}
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_messages_getSplitRanges()
{
	buf_t buf = buf_add_ui32(0x1cff7e08);
	return buf;
}

buf_t tl_messages_markDialogUnread(bool unread_, InputDialogPeer *peer_)
{
	buf_t buf = buf_add_ui32(0xc286d98f);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument unread (true)
	if (unread_)
		*flag1 |= (1 << 0);
	//parse argument peer (InputDialogPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_messages_getDialogUnreadMarks()
{
	buf_t buf = buf_add_ui32(0x22e24e22);
	return buf;
}

buf_t tl_messages_clearAllDrafts()
{
	buf_t buf = buf_add_ui32(0x7e58ee9c);
	return buf;
}

buf_t tl_messages_updatePinnedMessage(bool silent_, bool unpin_, bool pm_oneside_, InputPeer *peer_, int id_)
{
	buf_t buf = buf_add_ui32(0xd2aaf7ec);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument silent (true)
	if (silent_)
		*flag1 |= (1 << 0);
	//parse argument unpin (true)
	if (unpin_)
		*flag1 |= (1 << 1);
	//parse argument pm_oneside (true)
	if (pm_oneside_)
		*flag1 |= (1 << 2);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	return buf;
}

buf_t tl_messages_sendVote(InputPeer *peer_, int msg_id_, buf_t *options_, int options_len)
{
	buf_t buf = buf_add_ui32(0x10ea6184);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	//parse argument options (Vector<bytes>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(options_len));
		int i;
		for (i=0; i<options_len; ++i){
			buf = buf_cat(buf, serialize_bytes(options_[i].data, options_[i].size));
		}
	}
	return buf;
}

buf_t tl_messages_getPollResults(InputPeer *peer_, int msg_id_)
{
	buf_t buf = buf_add_ui32(0x73bb643b);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	return buf;
}

buf_t tl_messages_getOnlines(InputPeer *peer_)
{
	buf_t buf = buf_add_ui32(0x6e2be050);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_messages_editChatAbout(InputPeer *peer_, const char * about_)
{
	buf_t buf = buf_add_ui32(0xdef60797);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument about (string)
	{
		buf = buf_cat(buf, serialize_string(about_));
	}
	return buf;
}

buf_t tl_messages_editChatDefaultBannedRights(InputPeer *peer_, ChatBannedRights *banned_rights_)
{
	buf_t buf = buf_add_ui32(0xa5866b41);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument banned_rights (ChatBannedRights)
	{
		buf = buf_cat(buf, *banned_rights_);
	}
	return buf;
}

buf_t tl_messages_getEmojiKeywords(const char * lang_code_)
{
	buf_t buf = buf_add_ui32(0x35a0e062);
	//parse argument lang_code (string)
	{
		buf = buf_cat(buf, serialize_string(lang_code_));
	}
	return buf;
}

buf_t tl_messages_getEmojiKeywordsDifference(const char * lang_code_, int from_version_)
{
	buf_t buf = buf_add_ui32(0x1508b6af);
	//parse argument lang_code (string)
	{
		buf = buf_cat(buf, serialize_string(lang_code_));
	}
	//parse argument from_version (int)
	{
		buf = buf_cat(buf, buf_add_ui32(from_version_));
	}
	return buf;
}

buf_t tl_messages_getEmojiKeywordsLanguages(const char * *lang_codes_, int lang_codes_len)
{
	buf_t buf = buf_add_ui32(0x4e9963b2);
	//parse argument lang_codes (Vector<string>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(lang_codes_len));
		int i;
		for (i=0; i<lang_codes_len; ++i){
			buf = buf_cat(buf, serialize_string(lang_codes_[i]));
		}
	}
	return buf;
}

buf_t tl_messages_getEmojiURL(const char * lang_code_)
{
	buf_t buf = buf_add_ui32(0xd5b10c26);
	//parse argument lang_code (string)
	{
		buf = buf_cat(buf, serialize_string(lang_code_));
	}
	return buf;
}

buf_t tl_messages_getSearchCounters(InputPeer *peer_, InputPeer *saved_peer_id_, int top_msg_id_, MessagesFilter *filters_, int filters_len)
{
	buf_t buf = buf_add_ui32(0x1bbcf300);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument saved_peer_id (InputPeer)
	if (saved_peer_id_)
	{
		buf = buf_cat(buf, *saved_peer_id_);
		*flag1 |= (1 << 2);
	}
	//parse argument top_msg_id (int)
	if (top_msg_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(top_msg_id_));
		*flag1 |= (1 << 0);
	}
	//parse argument filters (Vector<MessagesFilter>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(filters_len));
		int i;
		for (i=0; i<filters_len; ++i){
			buf = buf_cat(buf, filters_[i]);
		}
	}
	return buf;
}

buf_t tl_messages_requestUrlAuth(InputPeer *peer_, int msg_id_, int button_id_, const char * url_)
{
	buf_t buf = buf_add_ui32(0x198fb446);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument peer (InputPeer)
	if (peer_)
	{
		buf = buf_cat(buf, *peer_);
		*flag1 |= (1 << 1);
	}
	//parse argument msg_id (int)
	if (msg_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
		*flag1 |= (1 << 1);
	}
	//parse argument button_id (int)
	if (button_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(button_id_));
		*flag1 |= (1 << 1);
	}
	//parse argument url (string)
	if (url_)
	{
		buf = buf_cat(buf, serialize_string(url_));
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_messages_acceptUrlAuth(bool write_allowed_, InputPeer *peer_, int msg_id_, int button_id_, const char * url_)
{
	buf_t buf = buf_add_ui32(0xb12c7125);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument write_allowed (true)
	if (write_allowed_)
		*flag1 |= (1 << 0);
	//parse argument peer (InputPeer)
	if (peer_)
	{
		buf = buf_cat(buf, *peer_);
		*flag1 |= (1 << 1);
	}
	//parse argument msg_id (int)
	if (msg_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
		*flag1 |= (1 << 1);
	}
	//parse argument button_id (int)
	if (button_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(button_id_));
		*flag1 |= (1 << 1);
	}
	//parse argument url (string)
	if (url_)
	{
		buf = buf_cat(buf, serialize_string(url_));
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_messages_hidePeerSettingsBar(InputPeer *peer_)
{
	buf_t buf = buf_add_ui32(0x4facb138);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_messages_getScheduledHistory(InputPeer *peer_, long hash_)
{
	buf_t buf = buf_add_ui32(0xf516760b);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_messages_getScheduledMessages(InputPeer *peer_, int *id_, int id_len)
{
	buf_t buf = buf_add_ui32(0xbdbb0464);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument id (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(id_[i]));
		}
	}
	return buf;
}

buf_t tl_messages_sendScheduledMessages(InputPeer *peer_, int *id_, int id_len)
{
	buf_t buf = buf_add_ui32(0xbd38850a);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument id (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(id_[i]));
		}
	}
	return buf;
}

buf_t tl_messages_deleteScheduledMessages(InputPeer *peer_, int *id_, int id_len)
{
	buf_t buf = buf_add_ui32(0x59ae2b16);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument id (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(id_[i]));
		}
	}
	return buf;
}

buf_t tl_messages_getPollVotes(InputPeer *peer_, int id_, buf_t *option_, const char * offset_, int limit_)
{
	buf_t buf = buf_add_ui32(0xb86e380e);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument option (bytes)
	if (option_)
	{
		buf = buf_cat(buf, serialize_bytes(option_->data, option_->size));
		*flag1 |= (1 << 0);
	}
	//parse argument offset (string)
	if (offset_)
	{
		buf = buf_cat(buf, serialize_string(offset_));
		*flag1 |= (1 << 1);
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	return buf;
}

buf_t tl_messages_toggleStickerSets(bool uninstall_, bool archive_, bool unarchive_, InputStickerSet *stickersets_, int stickersets_len)
{
	buf_t buf = buf_add_ui32(0xb5052fea);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument uninstall (true)
	if (uninstall_)
		*flag1 |= (1 << 0);
	//parse argument archive (true)
	if (archive_)
		*flag1 |= (1 << 1);
	//parse argument unarchive (true)
	if (unarchive_)
		*flag1 |= (1 << 2);
	//parse argument stickersets (Vector<InputStickerSet>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(stickersets_len));
		int i;
		for (i=0; i<stickersets_len; ++i){
			buf = buf_cat(buf, stickersets_[i]);
		}
	}
	return buf;
}

buf_t tl_messages_getDialogFilters()
{
	buf_t buf = buf_add_ui32(0xefd48c89);
	return buf;
}

buf_t tl_messages_getSuggestedDialogFilters()
{
	buf_t buf = buf_add_ui32(0xa29cd42c);
	return buf;
}

buf_t tl_messages_updateDialogFilter(int id_, DialogFilter *filter_)
{
	buf_t buf = buf_add_ui32(0x1ad4a04a);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument filter (DialogFilter)
	if (filter_)
	{
		buf = buf_cat(buf, *filter_);
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_messages_updateDialogFiltersOrder(int *order_, int order_len)
{
	buf_t buf = buf_add_ui32(0xc563c1e4);
	//parse argument order (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(order_len));
		int i;
		for (i=0; i<order_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(order_[i]));
		}
	}
	return buf;
}

buf_t tl_messages_getOldFeaturedStickers(int offset_, int limit_, long hash_)
{
	buf_t buf = buf_add_ui32(0x7ed094a1);
	//parse argument offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_messages_getReplies(InputPeer *peer_, int msg_id_, int offset_id_, int offset_date_, int add_offset_, int limit_, int max_id_, int min_id_, long hash_)
{
	buf_t buf = buf_add_ui32(0x22ddd30c);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	//parse argument offset_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_id_));
	}
	//parse argument offset_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_date_));
	}
	//parse argument add_offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(add_offset_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	//parse argument max_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(max_id_));
	}
	//parse argument min_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(min_id_));
	}
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_messages_getDiscussionMessage(InputPeer *peer_, int msg_id_)
{
	buf_t buf = buf_add_ui32(0x446972fd);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	return buf;
}

buf_t tl_messages_readDiscussion(InputPeer *peer_, int msg_id_, int read_max_id_)
{
	buf_t buf = buf_add_ui32(0xf731a9f4);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	//parse argument read_max_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(read_max_id_));
	}
	return buf;
}

buf_t tl_messages_unpinAllMessages(InputPeer *peer_, int top_msg_id_)
{
	buf_t buf = buf_add_ui32(0xee22b9a8);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument top_msg_id (int)
	if (top_msg_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(top_msg_id_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_messages_deleteChat(long chat_id_)
{
	buf_t buf = buf_add_ui32(0x5bd0ee50);
	//parse argument chat_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(chat_id_));
	}
	return buf;
}

buf_t tl_messages_deletePhoneCallHistory(bool revoke_)
{
	buf_t buf = buf_add_ui32(0xf9cbe409);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument revoke (true)
	if (revoke_)
		*flag1 |= (1 << 0);
	return buf;
}

buf_t tl_messages_checkHistoryImport(const char * import_head_)
{
	buf_t buf = buf_add_ui32(0x43fe19f3);
	//parse argument import_head (string)
	{
		buf = buf_cat(buf, serialize_string(import_head_));
	}
	return buf;
}

buf_t tl_messages_initHistoryImport(InputPeer *peer_, InputFile *file_, int media_count_)
{
	buf_t buf = buf_add_ui32(0x34090c3b);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument file (InputFile)
	{
		buf = buf_cat(buf, *file_);
	}
	//parse argument media_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(media_count_));
	}
	return buf;
}

buf_t tl_messages_uploadImportedMedia(InputPeer *peer_, long import_id_, const char * file_name_, InputMedia *media_)
{
	buf_t buf = buf_add_ui32(0x2a862092);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument import_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(import_id_));
	}
	//parse argument file_name (string)
	{
		buf = buf_cat(buf, serialize_string(file_name_));
	}
	//parse argument media (InputMedia)
	{
		buf = buf_cat(buf, *media_);
	}
	return buf;
}

buf_t tl_messages_startHistoryImport(InputPeer *peer_, long import_id_)
{
	buf_t buf = buf_add_ui32(0xb43df344);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument import_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(import_id_));
	}
	return buf;
}

buf_t tl_messages_getExportedChatInvites(bool revoked_, InputPeer *peer_, InputUser *admin_id_, int offset_date_, const char * offset_link_, int limit_)
{
	buf_t buf = buf_add_ui32(0xa2b5a3f6);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument revoked (true)
	if (revoked_)
		*flag1 |= (1 << 3);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument admin_id (InputUser)
	{
		buf = buf_cat(buf, *admin_id_);
	}
	//parse argument offset_date (int)
	if (offset_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_date_));
		*flag1 |= (1 << 2);
	}
	//parse argument offset_link (string)
	if (offset_link_)
	{
		buf = buf_cat(buf, serialize_string(offset_link_));
		*flag1 |= (1 << 2);
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	return buf;
}

buf_t tl_messages_getExportedChatInvite(InputPeer *peer_, const char * link_)
{
	buf_t buf = buf_add_ui32(0x73746f5c);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument link (string)
	{
		buf = buf_cat(buf, serialize_string(link_));
	}
	return buf;
}

buf_t tl_messages_editExportedChatInvite(bool revoked_, InputPeer *peer_, const char * link_, int expire_date_, int usage_limit_, Bool *request_needed_, const char * title_)
{
	buf_t buf = buf_add_ui32(0xbdca2f75);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument revoked (true)
	if (revoked_)
		*flag1 |= (1 << 2);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument link (string)
	{
		buf = buf_cat(buf, serialize_string(link_));
	}
	//parse argument expire_date (int)
	if (expire_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(expire_date_));
		*flag1 |= (1 << 0);
	}
	//parse argument usage_limit (int)
	if (usage_limit_)
	{
		buf = buf_cat(buf, buf_add_ui32(usage_limit_));
		*flag1 |= (1 << 1);
	}
	//parse argument request_needed (Bool)
	if (request_needed_)
	{
		buf = buf_cat(buf, *request_needed_);
		*flag1 |= (1 << 3);
	}
	//parse argument title (string)
	if (title_)
	{
		buf = buf_cat(buf, serialize_string(title_));
		*flag1 |= (1 << 4);
	}
	return buf;
}

buf_t tl_messages_deleteRevokedExportedChatInvites(InputPeer *peer_, InputUser *admin_id_)
{
	buf_t buf = buf_add_ui32(0x56987bd5);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument admin_id (InputUser)
	{
		buf = buf_cat(buf, *admin_id_);
	}
	return buf;
}

buf_t tl_messages_deleteExportedChatInvite(InputPeer *peer_, const char * link_)
{
	buf_t buf = buf_add_ui32(0xd464a42b);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument link (string)
	{
		buf = buf_cat(buf, serialize_string(link_));
	}
	return buf;
}

buf_t tl_messages_getAdminsWithInvites(InputPeer *peer_)
{
	buf_t buf = buf_add_ui32(0x3920e6ef);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_messages_getChatInviteImporters(bool requested_, bool subscription_expired_, InputPeer *peer_, const char * link_, const char * q_, int offset_date_, InputUser *offset_user_, int limit_)
{
	buf_t buf = buf_add_ui32(0xdf04dd4e);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument requested (true)
	if (requested_)
		*flag1 |= (1 << 0);
	//parse argument subscription_expired (true)
	if (subscription_expired_)
		*flag1 |= (1 << 3);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument link (string)
	if (link_)
	{
		buf = buf_cat(buf, serialize_string(link_));
		*flag1 |= (1 << 1);
	}
	//parse argument q (string)
	if (q_)
	{
		buf = buf_cat(buf, serialize_string(q_));
		*flag1 |= (1 << 2);
	}
	//parse argument offset_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_date_));
	}
	//parse argument offset_user (InputUser)
	{
		buf = buf_cat(buf, *offset_user_);
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	return buf;
}

buf_t tl_messages_setHistoryTTL(InputPeer *peer_, int period_)
{
	buf_t buf = buf_add_ui32(0xb80e5fe4);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument period (int)
	{
		buf = buf_cat(buf, buf_add_ui32(period_));
	}
	return buf;
}

buf_t tl_messages_checkHistoryImportPeer(InputPeer *peer_)
{
	buf_t buf = buf_add_ui32(0x5dc60f03);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_messages_setChatTheme(InputPeer *peer_, const char * emoticon_)
{
	buf_t buf = buf_add_ui32(0xe63be13f);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument emoticon (string)
	{
		buf = buf_cat(buf, serialize_string(emoticon_));
	}
	return buf;
}

buf_t tl_messages_getMessageReadParticipants(InputPeer *peer_, int msg_id_)
{
	buf_t buf = buf_add_ui32(0x31c1c44f);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	return buf;
}

buf_t tl_messages_getSearchResultsCalendar(InputPeer *peer_, InputPeer *saved_peer_id_, MessagesFilter *filter_, int offset_id_, int offset_date_)
{
	buf_t buf = buf_add_ui32(0x6aa3f6bd);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument saved_peer_id (InputPeer)
	if (saved_peer_id_)
	{
		buf = buf_cat(buf, *saved_peer_id_);
		*flag1 |= (1 << 2);
	}
	//parse argument filter (MessagesFilter)
	{
		buf = buf_cat(buf, *filter_);
	}
	//parse argument offset_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_id_));
	}
	//parse argument offset_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_date_));
	}
	return buf;
}

buf_t tl_messages_getSearchResultsPositions(InputPeer *peer_, InputPeer *saved_peer_id_, MessagesFilter *filter_, int offset_id_, int limit_)
{
	buf_t buf = buf_add_ui32(0x9c7f2f10);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument saved_peer_id (InputPeer)
	if (saved_peer_id_)
	{
		buf = buf_cat(buf, *saved_peer_id_);
		*flag1 |= (1 << 2);
	}
	//parse argument filter (MessagesFilter)
	{
		buf = buf_cat(buf, *filter_);
	}
	//parse argument offset_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_id_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	return buf;
}

buf_t tl_messages_hideChatJoinRequest(bool approved_, InputPeer *peer_, InputUser *user_id_)
{
	buf_t buf = buf_add_ui32(0x7fe7e815);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument approved (true)
	if (approved_)
		*flag1 |= (1 << 0);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument user_id (InputUser)
	{
		buf = buf_cat(buf, *user_id_);
	}
	return buf;
}

buf_t tl_messages_hideAllChatJoinRequests(bool approved_, InputPeer *peer_, const char * link_)
{
	buf_t buf = buf_add_ui32(0xe085f4ea);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument approved (true)
	if (approved_)
		*flag1 |= (1 << 0);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument link (string)
	if (link_)
	{
		buf = buf_cat(buf, serialize_string(link_));
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_messages_toggleNoForwards(InputPeer *peer_, Bool *enabled_)
{
	buf_t buf = buf_add_ui32(0xb11eafa2);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument enabled (Bool)
	{
		buf = buf_cat(buf, *enabled_);
	}
	return buf;
}

buf_t tl_messages_saveDefaultSendAs(InputPeer *peer_, InputPeer *send_as_)
{
	buf_t buf = buf_add_ui32(0xccfddf96);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument send_as (InputPeer)
	{
		buf = buf_cat(buf, *send_as_);
	}
	return buf;
}

buf_t tl_messages_sendReaction(bool big_, bool add_to_recent_, InputPeer *peer_, int msg_id_, Reaction *reaction_, int reaction_len)
{
	buf_t buf = buf_add_ui32(0xd30d78d4);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument big (true)
	if (big_)
		*flag1 |= (1 << 1);
	//parse argument add_to_recent (true)
	if (add_to_recent_)
		*flag1 |= (1 << 2);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	//parse argument reaction (Vector<Reaction>)
	if (reaction_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(reaction_len));
		int i;
		for (i=0; i<reaction_len; ++i){
			buf = buf_cat(buf, reaction_[i]);
		}
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_messages_getMessagesReactions(InputPeer *peer_, int *id_, int id_len)
{
	buf_t buf = buf_add_ui32(0x8bba90e6);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument id (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(id_[i]));
		}
	}
	return buf;
}

buf_t tl_messages_getMessageReactionsList(InputPeer *peer_, int id_, Reaction *reaction_, const char * offset_, int limit_)
{
	buf_t buf = buf_add_ui32(0x461b3f48);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument reaction (Reaction)
	if (reaction_)
	{
		buf = buf_cat(buf, *reaction_);
		*flag1 |= (1 << 0);
	}
	//parse argument offset (string)
	if (offset_)
	{
		buf = buf_cat(buf, serialize_string(offset_));
		*flag1 |= (1 << 1);
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	return buf;
}

buf_t tl_messages_setChatAvailableReactions(InputPeer *peer_, ChatReactions *available_reactions_, int reactions_limit_, Bool *paid_enabled_)
{
	buf_t buf = buf_add_ui32(0x864b2581);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument available_reactions (ChatReactions)
	{
		buf = buf_cat(buf, *available_reactions_);
	}
	//parse argument reactions_limit (int)
	if (reactions_limit_)
	{
		buf = buf_cat(buf, buf_add_ui32(reactions_limit_));
		*flag1 |= (1 << 0);
	}
	//parse argument paid_enabled (Bool)
	if (paid_enabled_)
	{
		buf = buf_cat(buf, *paid_enabled_);
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_messages_getAvailableReactions(int hash_)
{
	buf_t buf = buf_add_ui32(0x18dea0ac);
	//parse argument hash (int)
	{
		buf = buf_cat(buf, buf_add_ui32(hash_));
	}
	return buf;
}

buf_t tl_messages_setDefaultReaction(Reaction *reaction_)
{
	buf_t buf = buf_add_ui32(0x4f47a016);
	//parse argument reaction (Reaction)
	{
		buf = buf_cat(buf, *reaction_);
	}
	return buf;
}

buf_t tl_messages_translateText(InputPeer *peer_, int *id_, int id_len, TextWithEntities *text_, int text_len, const char * to_lang_)
{
	buf_t buf = buf_add_ui32(0x63183030);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument peer (InputPeer)
	if (peer_)
	{
		buf = buf_cat(buf, *peer_);
		*flag1 |= (1 << 0);
	}
	//parse argument id (Vector<int>)
	if (id_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(id_[i]));
		}
		*flag1 |= (1 << 0);
	}
	//parse argument text (Vector<TextWithEntities>)
	if (text_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(text_len));
		int i;
		for (i=0; i<text_len; ++i){
			buf = buf_cat(buf, text_[i]);
		}
		*flag1 |= (1 << 1);
	}
	//parse argument to_lang (string)
	{
		buf = buf_cat(buf, serialize_string(to_lang_));
	}
	return buf;
}

buf_t tl_messages_getUnreadReactions(InputPeer *peer_, int top_msg_id_, int offset_id_, int add_offset_, int limit_, int max_id_, int min_id_)
{
	buf_t buf = buf_add_ui32(0x3223495b);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument top_msg_id (int)
	if (top_msg_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(top_msg_id_));
		*flag1 |= (1 << 0);
	}
	//parse argument offset_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_id_));
	}
	//parse argument add_offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(add_offset_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	//parse argument max_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(max_id_));
	}
	//parse argument min_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(min_id_));
	}
	return buf;
}

buf_t tl_messages_readReactions(InputPeer *peer_, int top_msg_id_)
{
	buf_t buf = buf_add_ui32(0x54aa7f8e);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument top_msg_id (int)
	if (top_msg_id_)
	{
		buf = buf_cat(buf, buf_add_ui32(top_msg_id_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_messages_searchSentMedia(const char * q_, MessagesFilter *filter_, int limit_)
{
	buf_t buf = buf_add_ui32(0x107e31a0);
	//parse argument q (string)
	{
		buf = buf_cat(buf, serialize_string(q_));
	}
	//parse argument filter (MessagesFilter)
	{
		buf = buf_cat(buf, *filter_);
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	return buf;
}

buf_t tl_messages_getAttachMenuBots(long hash_)
{
	buf_t buf = buf_add_ui32(0x16fcc2cb);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_messages_getAttachMenuBot(InputUser *bot_)
{
	buf_t buf = buf_add_ui32(0x77216192);
	//parse argument bot (InputUser)
	{
		buf = buf_cat(buf, *bot_);
	}
	return buf;
}

buf_t tl_messages_toggleBotInAttachMenu(bool write_allowed_, InputUser *bot_, Bool *enabled_)
{
	buf_t buf = buf_add_ui32(0x69f59d69);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument write_allowed (true)
	if (write_allowed_)
		*flag1 |= (1 << 0);
	//parse argument bot (InputUser)
	{
		buf = buf_cat(buf, *bot_);
	}
	//parse argument enabled (Bool)
	{
		buf = buf_cat(buf, *enabled_);
	}
	return buf;
}

buf_t tl_messages_requestWebView(bool from_bot_menu_, bool silent_, bool compact_, InputPeer *peer_, InputUser *bot_, const char * url_, const char * start_param_, DataJSON *theme_params_, const char * platform_, InputReplyTo *reply_to_, InputPeer *send_as_)
{
	buf_t buf = buf_add_ui32(0x269dc2c1);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument from_bot_menu (true)
	if (from_bot_menu_)
		*flag1 |= (1 << 4);
	//parse argument silent (true)
	if (silent_)
		*flag1 |= (1 << 5);
	//parse argument compact (true)
	if (compact_)
		*flag1 |= (1 << 7);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument bot (InputUser)
	{
		buf = buf_cat(buf, *bot_);
	}
	//parse argument url (string)
	if (url_)
	{
		buf = buf_cat(buf, serialize_string(url_));
		*flag1 |= (1 << 1);
	}
	//parse argument start_param (string)
	if (start_param_)
	{
		buf = buf_cat(buf, serialize_string(start_param_));
		*flag1 |= (1 << 3);
	}
	//parse argument theme_params (DataJSON)
	if (theme_params_)
	{
		buf = buf_cat(buf, *theme_params_);
		*flag1 |= (1 << 2);
	}
	//parse argument platform (string)
	{
		buf = buf_cat(buf, serialize_string(platform_));
	}
	//parse argument reply_to (InputReplyTo)
	if (reply_to_)
	{
		buf = buf_cat(buf, *reply_to_);
		*flag1 |= (1 << 0);
	}
	//parse argument send_as (InputPeer)
	if (send_as_)
	{
		buf = buf_cat(buf, *send_as_);
		*flag1 |= (1 << 13);
	}
	return buf;
}

buf_t tl_messages_prolongWebView(bool silent_, InputPeer *peer_, InputUser *bot_, long query_id_, InputReplyTo *reply_to_, InputPeer *send_as_)
{
	buf_t buf = buf_add_ui32(0xb0d81a83);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument silent (true)
	if (silent_)
		*flag1 |= (1 << 5);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument bot (InputUser)
	{
		buf = buf_cat(buf, *bot_);
	}
	//parse argument query_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(query_id_));
	}
	//parse argument reply_to (InputReplyTo)
	if (reply_to_)
	{
		buf = buf_cat(buf, *reply_to_);
		*flag1 |= (1 << 0);
	}
	//parse argument send_as (InputPeer)
	if (send_as_)
	{
		buf = buf_cat(buf, *send_as_);
		*flag1 |= (1 << 13);
	}
	return buf;
}

buf_t tl_messages_requestSimpleWebView(bool from_switch_webview_, bool from_side_menu_, bool compact_, InputUser *bot_, const char * url_, const char * start_param_, DataJSON *theme_params_, const char * platform_)
{
	buf_t buf = buf_add_ui32(0x413a3e73);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument from_switch_webview (true)
	if (from_switch_webview_)
		*flag1 |= (1 << 1);
	//parse argument from_side_menu (true)
	if (from_side_menu_)
		*flag1 |= (1 << 2);
	//parse argument compact (true)
	if (compact_)
		*flag1 |= (1 << 7);
	//parse argument bot (InputUser)
	{
		buf = buf_cat(buf, *bot_);
	}
	//parse argument url (string)
	if (url_)
	{
		buf = buf_cat(buf, serialize_string(url_));
		*flag1 |= (1 << 3);
	}
	//parse argument start_param (string)
	if (start_param_)
	{
		buf = buf_cat(buf, serialize_string(start_param_));
		*flag1 |= (1 << 4);
	}
	//parse argument theme_params (DataJSON)
	if (theme_params_)
	{
		buf = buf_cat(buf, *theme_params_);
		*flag1 |= (1 << 0);
	}
	//parse argument platform (string)
	{
		buf = buf_cat(buf, serialize_string(platform_));
	}
	return buf;
}

buf_t tl_messages_sendWebViewResultMessage(const char * bot_query_id_, InputBotInlineResult *result_)
{
	buf_t buf = buf_add_ui32(0x0a4314f5);
	//parse argument bot_query_id (string)
	{
		buf = buf_cat(buf, serialize_string(bot_query_id_));
	}
	//parse argument result (InputBotInlineResult)
	{
		buf = buf_cat(buf, *result_);
	}
	return buf;
}

buf_t tl_messages_sendWebViewData(InputUser *bot_, long random_id_, const char * button_text_, const char * data_)
{
	buf_t buf = buf_add_ui32(0xdc0242c8);
	//parse argument bot (InputUser)
	{
		buf = buf_cat(buf, *bot_);
	}
	//parse argument random_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(random_id_));
	}
	//parse argument button_text (string)
	{
		buf = buf_cat(buf, serialize_string(button_text_));
	}
	//parse argument data (string)
	{
		buf = buf_cat(buf, serialize_string(data_));
	}
	return buf;
}

buf_t tl_messages_transcribeAudio(InputPeer *peer_, int msg_id_)
{
	buf_t buf = buf_add_ui32(0x269e9a49);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	return buf;
}

buf_t tl_messages_rateTranscribedAudio(InputPeer *peer_, int msg_id_, long transcription_id_, Bool *good_)
{
	buf_t buf = buf_add_ui32(0x7f1d072f);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	//parse argument transcription_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(transcription_id_));
	}
	//parse argument good (Bool)
	{
		buf = buf_cat(buf, *good_);
	}
	return buf;
}

buf_t tl_messages_getCustomEmojiDocuments(long *document_id_, int document_id_len)
{
	buf_t buf = buf_add_ui32(0xd9ab0f54);
	//parse argument document_id (Vector<long>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(document_id_len));
		int i;
		for (i=0; i<document_id_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(document_id_[i]));
		}
	}
	return buf;
}

buf_t tl_messages_getEmojiStickers(long hash_)
{
	buf_t buf = buf_add_ui32(0xfbfca18f);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_messages_getFeaturedEmojiStickers(long hash_)
{
	buf_t buf = buf_add_ui32(0x0ecf6736);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_messages_reportReaction(InputPeer *peer_, int id_, InputPeer *reaction_peer_)
{
	buf_t buf = buf_add_ui32(0x3f64c076);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument reaction_peer (InputPeer)
	{
		buf = buf_cat(buf, *reaction_peer_);
	}
	return buf;
}

buf_t tl_messages_getTopReactions(int limit_, long hash_)
{
	buf_t buf = buf_add_ui32(0xbb8125ba);
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_messages_getRecentReactions(int limit_, long hash_)
{
	buf_t buf = buf_add_ui32(0x39461db2);
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_messages_clearRecentReactions()
{
	buf_t buf = buf_add_ui32(0x9dfeefb4);
	return buf;
}

buf_t tl_messages_getExtendedMedia(InputPeer *peer_, int *id_, int id_len)
{
	buf_t buf = buf_add_ui32(0x84f80814);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument id (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(id_[i]));
		}
	}
	return buf;
}

buf_t tl_messages_setDefaultHistoryTTL(int period_)
{
	buf_t buf = buf_add_ui32(0x9eb51445);
	//parse argument period (int)
	{
		buf = buf_cat(buf, buf_add_ui32(period_));
	}
	return buf;
}

buf_t tl_messages_getDefaultHistoryTTL()
{
	buf_t buf = buf_add_ui32(0x658b7188);
	return buf;
}

buf_t tl_messages_sendBotRequestedPeer(InputPeer *peer_, int msg_id_, int button_id_, InputPeer *requested_peers_, int requested_peers_len)
{
	buf_t buf = buf_add_ui32(0x91b2d060);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	//parse argument button_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(button_id_));
	}
	//parse argument requested_peers (Vector<InputPeer>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(requested_peers_len));
		int i;
		for (i=0; i<requested_peers_len; ++i){
			buf = buf_cat(buf, requested_peers_[i]);
		}
	}
	return buf;
}

buf_t tl_messages_getEmojiGroups(int hash_)
{
	buf_t buf = buf_add_ui32(0x7488ce5b);
	//parse argument hash (int)
	{
		buf = buf_cat(buf, buf_add_ui32(hash_));
	}
	return buf;
}

buf_t tl_messages_getEmojiStatusGroups(int hash_)
{
	buf_t buf = buf_add_ui32(0x2ecd56cd);
	//parse argument hash (int)
	{
		buf = buf_cat(buf, buf_add_ui32(hash_));
	}
	return buf;
}

buf_t tl_messages_getEmojiProfilePhotoGroups(int hash_)
{
	buf_t buf = buf_add_ui32(0x21a548f3);
	//parse argument hash (int)
	{
		buf = buf_cat(buf, buf_add_ui32(hash_));
	}
	return buf;
}

buf_t tl_messages_searchCustomEmoji(const char * emoticon_, long hash_)
{
	buf_t buf = buf_add_ui32(0x2c11c0d7);
	//parse argument emoticon (string)
	{
		buf = buf_cat(buf, serialize_string(emoticon_));
	}
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_messages_togglePeerTranslations(bool disabled_, InputPeer *peer_)
{
	buf_t buf = buf_add_ui32(0xe47cb579);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument disabled (true)
	if (disabled_)
		*flag1 |= (1 << 0);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_messages_getBotApp(InputBotApp *app_, long hash_)
{
	buf_t buf = buf_add_ui32(0x34fdc5c3);
	//parse argument app (InputBotApp)
	{
		buf = buf_cat(buf, *app_);
	}
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_messages_requestAppWebView(bool write_allowed_, bool compact_, InputPeer *peer_, InputBotApp *app_, const char * start_param_, DataJSON *theme_params_, const char * platform_)
{
	buf_t buf = buf_add_ui32(0x53618bce);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument write_allowed (true)
	if (write_allowed_)
		*flag1 |= (1 << 0);
	//parse argument compact (true)
	if (compact_)
		*flag1 |= (1 << 7);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument app (InputBotApp)
	{
		buf = buf_cat(buf, *app_);
	}
	//parse argument start_param (string)
	if (start_param_)
	{
		buf = buf_cat(buf, serialize_string(start_param_));
		*flag1 |= (1 << 1);
	}
	//parse argument theme_params (DataJSON)
	if (theme_params_)
	{
		buf = buf_cat(buf, *theme_params_);
		*flag1 |= (1 << 2);
	}
	//parse argument platform (string)
	{
		buf = buf_cat(buf, serialize_string(platform_));
	}
	return buf;
}

buf_t tl_messages_setChatWallPaper(bool for_both_, bool revert_, InputPeer *peer_, InputWallPaper *wallpaper_, WallPaperSettings *settings_, int id_)
{
	buf_t buf = buf_add_ui32(0x8ffacae1);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument for_both (true)
	if (for_both_)
		*flag1 |= (1 << 3);
	//parse argument revert (true)
	if (revert_)
		*flag1 |= (1 << 4);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument wallpaper (InputWallPaper)
	if (wallpaper_)
	{
		buf = buf_cat(buf, *wallpaper_);
		*flag1 |= (1 << 0);
	}
	//parse argument settings (WallPaperSettings)
	if (settings_)
	{
		buf = buf_cat(buf, *settings_);
		*flag1 |= (1 << 2);
	}
	//parse argument id (int)
	if (id_)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_messages_searchEmojiStickerSets(bool exclude_featured_, const char * q_, long hash_)
{
	buf_t buf = buf_add_ui32(0x92b4494c);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument exclude_featured (true)
	if (exclude_featured_)
		*flag1 |= (1 << 0);
	//parse argument q (string)
	{
		buf = buf_cat(buf, serialize_string(q_));
	}
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_messages_getSavedDialogs(bool exclude_pinned_, int offset_date_, int offset_id_, InputPeer *offset_peer_, int limit_, long hash_)
{
	buf_t buf = buf_add_ui32(0x5381d21a);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument exclude_pinned (true)
	if (exclude_pinned_)
		*flag1 |= (1 << 0);
	//parse argument offset_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_date_));
	}
	//parse argument offset_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_id_));
	}
	//parse argument offset_peer (InputPeer)
	{
		buf = buf_cat(buf, *offset_peer_);
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_messages_getSavedHistory(InputPeer *peer_, int offset_id_, int offset_date_, int add_offset_, int limit_, int max_id_, int min_id_, long hash_)
{
	buf_t buf = buf_add_ui32(0x3d9a414d);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument offset_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_id_));
	}
	//parse argument offset_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_date_));
	}
	//parse argument add_offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(add_offset_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	//parse argument max_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(max_id_));
	}
	//parse argument min_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(min_id_));
	}
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_messages_deleteSavedHistory(InputPeer *peer_, int max_id_, int min_date_, int max_date_)
{
	buf_t buf = buf_add_ui32(0x6e98102b);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument max_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(max_id_));
	}
	//parse argument min_date (int)
	if (min_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(min_date_));
		*flag1 |= (1 << 2);
	}
	//parse argument max_date (int)
	if (max_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(max_date_));
		*flag1 |= (1 << 3);
	}
	return buf;
}

buf_t tl_messages_getPinnedSavedDialogs()
{
	buf_t buf = buf_add_ui32(0xd63d94e0);
	return buf;
}

buf_t tl_messages_toggleSavedDialogPin(bool pinned_, InputDialogPeer *peer_)
{
	buf_t buf = buf_add_ui32(0xac81bbde);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument pinned (true)
	if (pinned_)
		*flag1 |= (1 << 0);
	//parse argument peer (InputDialogPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_messages_reorderPinnedSavedDialogs(bool force_, InputDialogPeer *order_, int order_len)
{
	buf_t buf = buf_add_ui32(0x8b716587);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument force (true)
	if (force_)
		*flag1 |= (1 << 0);
	//parse argument order (Vector<InputDialogPeer>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(order_len));
		int i;
		for (i=0; i<order_len; ++i){
			buf = buf_cat(buf, order_[i]);
		}
	}
	return buf;
}

buf_t tl_messages_getSavedReactionTags(InputPeer *peer_, long hash_)
{
	buf_t buf = buf_add_ui32(0x3637e05b);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument peer (InputPeer)
	if (peer_)
	{
		buf = buf_cat(buf, *peer_);
		*flag1 |= (1 << 0);
	}
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_messages_updateSavedReactionTag(Reaction *reaction_, const char * title_)
{
	buf_t buf = buf_add_ui32(0x60297dec);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument reaction (Reaction)
	{
		buf = buf_cat(buf, *reaction_);
	}
	//parse argument title (string)
	if (title_)
	{
		buf = buf_cat(buf, serialize_string(title_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_messages_getDefaultTagReactions(long hash_)
{
	buf_t buf = buf_add_ui32(0xbdf93428);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_messages_getOutboxReadDate(InputPeer *peer_, int msg_id_)
{
	buf_t buf = buf_add_ui32(0x8c4bfe5d);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	return buf;
}

buf_t tl_messages_getQuickReplies(long hash_)
{
	buf_t buf = buf_add_ui32(0xd483f2a8);
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_messages_reorderQuickReplies(int *order_, int order_len)
{
	buf_t buf = buf_add_ui32(0x60331907);
	//parse argument order (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(order_len));
		int i;
		for (i=0; i<order_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(order_[i]));
		}
	}
	return buf;
}

buf_t tl_messages_checkQuickReplyShortcut(const char * shortcut_)
{
	buf_t buf = buf_add_ui32(0xf1d0fbd3);
	//parse argument shortcut (string)
	{
		buf = buf_cat(buf, serialize_string(shortcut_));
	}
	return buf;
}

buf_t tl_messages_editQuickReplyShortcut(int shortcut_id_, const char * shortcut_)
{
	buf_t buf = buf_add_ui32(0x5c003cef);
	//parse argument shortcut_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(shortcut_id_));
	}
	//parse argument shortcut (string)
	{
		buf = buf_cat(buf, serialize_string(shortcut_));
	}
	return buf;
}

buf_t tl_messages_deleteQuickReplyShortcut(int shortcut_id_)
{
	buf_t buf = buf_add_ui32(0x3cc04740);
	//parse argument shortcut_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(shortcut_id_));
	}
	return buf;
}

buf_t tl_messages_getQuickReplyMessages(int shortcut_id_, int *id_, int id_len, long hash_)
{
	buf_t buf = buf_add_ui32(0x94a495c3);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument shortcut_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(shortcut_id_));
	}
	//parse argument id (Vector<int>)
	if (id_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(id_[i]));
		}
		*flag1 |= (1 << 0);
	}
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_messages_sendQuickReplyMessages(InputPeer *peer_, int shortcut_id_, int *id_, int id_len, long *random_id_, int random_id_len)
{
	buf_t buf = buf_add_ui32(0x6c750de1);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument shortcut_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(shortcut_id_));
	}
	//parse argument id (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(id_[i]));
		}
	}
	//parse argument random_id (Vector<long>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(random_id_len));
		int i;
		for (i=0; i<random_id_len; ++i){
			buf = buf_cat(buf, buf_add_ui64(random_id_[i]));
		}
	}
	return buf;
}

buf_t tl_messages_deleteQuickReplyMessages(int shortcut_id_, int *id_, int id_len)
{
	buf_t buf = buf_add_ui32(0xe105e910);
	//parse argument shortcut_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(shortcut_id_));
	}
	//parse argument id (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(id_[i]));
		}
	}
	return buf;
}

buf_t tl_messages_toggleDialogFilterTags(Bool *enabled_)
{
	buf_t buf = buf_add_ui32(0xfd2dda49);
	//parse argument enabled (Bool)
	{
		buf = buf_cat(buf, *enabled_);
	}
	return buf;
}

buf_t tl_messages_getMyStickers(long offset_id_, int limit_)
{
	buf_t buf = buf_add_ui32(0xd0b5e1fc);
	//parse argument offset_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(offset_id_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	return buf;
}

buf_t tl_messages_getEmojiStickerGroups(int hash_)
{
	buf_t buf = buf_add_ui32(0x1dd840f5);
	//parse argument hash (int)
	{
		buf = buf_cat(buf, buf_add_ui32(hash_));
	}
	return buf;
}

buf_t tl_messages_getAvailableEffects(int hash_)
{
	buf_t buf = buf_add_ui32(0xdea20a39);
	//parse argument hash (int)
	{
		buf = buf_cat(buf, buf_add_ui32(hash_));
	}
	return buf;
}

buf_t tl_messages_editFactCheck(InputPeer *peer_, int msg_id_, TextWithEntities *text_)
{
	buf_t buf = buf_add_ui32(0x0589ee75);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	//parse argument text (TextWithEntities)
	{
		buf = buf_cat(buf, *text_);
	}
	return buf;
}

buf_t tl_messages_deleteFactCheck(InputPeer *peer_, int msg_id_)
{
	buf_t buf = buf_add_ui32(0xd1da940c);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	return buf;
}

buf_t tl_messages_getFactCheck(InputPeer *peer_, int *msg_id_, int msg_id_len)
{
	buf_t buf = buf_add_ui32(0xb9cdc5ee);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument msg_id (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(msg_id_len));
		int i;
		for (i=0; i<msg_id_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(msg_id_[i]));
		}
	}
	return buf;
}

buf_t tl_messages_requestMainWebView(bool compact_, InputPeer *peer_, InputUser *bot_, const char * start_param_, DataJSON *theme_params_, const char * platform_)
{
	buf_t buf = buf_add_ui32(0xc9e01e7b);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument compact (true)
	if (compact_)
		*flag1 |= (1 << 7);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument bot (InputUser)
	{
		buf = buf_cat(buf, *bot_);
	}
	//parse argument start_param (string)
	if (start_param_)
	{
		buf = buf_cat(buf, serialize_string(start_param_));
		*flag1 |= (1 << 1);
	}
	//parse argument theme_params (DataJSON)
	if (theme_params_)
	{
		buf = buf_cat(buf, *theme_params_);
		*flag1 |= (1 << 0);
	}
	//parse argument platform (string)
	{
		buf = buf_cat(buf, serialize_string(platform_));
	}
	return buf;
}

buf_t tl_messages_sendPaidReaction(InputPeer *peer_, int msg_id_, int count_, long random_id_, Bool *private_)
{
	buf_t buf = buf_add_ui32(0x9dd6a67b);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	//parse argument count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(count_));
	}
	//parse argument random_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(random_id_));
	}
	//parse argument private (Bool)
	if (private_)
	{
		buf = buf_cat(buf, *private_);
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_messages_togglePaidReactionPrivacy(InputPeer *peer_, int msg_id_, Bool *private_)
{
	buf_t buf = buf_add_ui32(0x849ad397);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	//parse argument private (Bool)
	{
		buf = buf_cat(buf, *private_);
	}
	return buf;
}

buf_t tl_messages_getPaidReactionPrivacy()
{
	buf_t buf = buf_add_ui32(0x472455aa);
	return buf;
}

buf_t tl_updates_getState()
{
	buf_t buf = buf_add_ui32(0xedd4882a);
	return buf;
}

buf_t tl_updates_getDifference(int pts_, int pts_limit_, int pts_total_limit_, int date_, int qts_, int qts_limit_)
{
	buf_t buf = buf_add_ui32(0x19c2f763);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument pts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_));
	}
	//parse argument pts_limit (int)
	if (pts_limit_)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_limit_));
		*flag1 |= (1 << 1);
	}
	//parse argument pts_total_limit (int)
	if (pts_total_limit_)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_total_limit_));
		*flag1 |= (1 << 0);
	}
	//parse argument date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(date_));
	}
	//parse argument qts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(qts_));
	}
	//parse argument qts_limit (int)
	if (qts_limit_)
	{
		buf = buf_cat(buf, buf_add_ui32(qts_limit_));
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_updates_getChannelDifference(bool force_, InputChannel *channel_, ChannelMessagesFilter *filter_, int pts_, int limit_)
{
	buf_t buf = buf_add_ui32(0x03173d78);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument force (true)
	if (force_)
		*flag1 |= (1 << 0);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument filter (ChannelMessagesFilter)
	{
		buf = buf_cat(buf, *filter_);
	}
	//parse argument pts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pts_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	return buf;
}

buf_t tl_photos_updateProfilePhoto(bool fallback_, InputUser *bot_, InputPhoto *id_)
{
	buf_t buf = buf_add_ui32(0x09e82039);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument fallback (true)
	if (fallback_)
		*flag1 |= (1 << 0);
	//parse argument bot (InputUser)
	if (bot_)
	{
		buf = buf_cat(buf, *bot_);
		*flag1 |= (1 << 1);
	}
	//parse argument id (InputPhoto)
	{
		buf = buf_cat(buf, *id_);
	}
	return buf;
}

buf_t tl_photos_uploadProfilePhoto(bool fallback_, InputUser *bot_, InputFile *file_, InputFile *video_, double video_start_ts_, VideoSize *video_emoji_markup_)
{
	buf_t buf = buf_add_ui32(0x0388a3b5);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument fallback (true)
	if (fallback_)
		*flag1 |= (1 << 3);
	//parse argument bot (InputUser)
	if (bot_)
	{
		buf = buf_cat(buf, *bot_);
		*flag1 |= (1 << 5);
	}
	//parse argument file (InputFile)
	if (file_)
	{
		buf = buf_cat(buf, *file_);
		*flag1 |= (1 << 0);
	}
	//parse argument video (InputFile)
	if (video_)
	{
		buf = buf_cat(buf, *video_);
		*flag1 |= (1 << 1);
	}
	//parse argument video_start_ts (double)
	if (video_start_ts_)
	{
		buf = buf_cat(buf, buf_add_ui64(video_start_ts_));
		*flag1 |= (1 << 2);
	}
	//parse argument video_emoji_markup (VideoSize)
	if (video_emoji_markup_)
	{
		buf = buf_cat(buf, *video_emoji_markup_);
		*flag1 |= (1 << 4);
	}
	return buf;
}

buf_t tl_photos_deletePhotos(InputPhoto *id_, int id_len)
{
	buf_t buf = buf_add_ui32(0x87cf7f2f);
	//parse argument id (Vector<InputPhoto>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, id_[i]);
		}
	}
	return buf;
}

buf_t tl_photos_getUserPhotos(InputUser *user_id_, int offset_, long max_id_, int limit_)
{
	buf_t buf = buf_add_ui32(0x91cd32a8);
	//parse argument user_id (InputUser)
	{
		buf = buf_cat(buf, *user_id_);
	}
	//parse argument offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_));
	}
	//parse argument max_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(max_id_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	return buf;
}

buf_t tl_photos_uploadContactProfilePhoto(bool suggest_, bool save_, InputUser *user_id_, InputFile *file_, InputFile *video_, double video_start_ts_, VideoSize *video_emoji_markup_)
{
	buf_t buf = buf_add_ui32(0xe14c4a71);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument suggest (true)
	if (suggest_)
		*flag1 |= (1 << 3);
	//parse argument save (true)
	if (save_)
		*flag1 |= (1 << 4);
	//parse argument user_id (InputUser)
	{
		buf = buf_cat(buf, *user_id_);
	}
	//parse argument file (InputFile)
	if (file_)
	{
		buf = buf_cat(buf, *file_);
		*flag1 |= (1 << 0);
	}
	//parse argument video (InputFile)
	if (video_)
	{
		buf = buf_cat(buf, *video_);
		*flag1 |= (1 << 1);
	}
	//parse argument video_start_ts (double)
	if (video_start_ts_)
	{
		buf = buf_cat(buf, buf_add_ui64(video_start_ts_));
		*flag1 |= (1 << 2);
	}
	//parse argument video_emoji_markup (VideoSize)
	if (video_emoji_markup_)
	{
		buf = buf_cat(buf, *video_emoji_markup_);
		*flag1 |= (1 << 5);
	}
	return buf;
}

buf_t tl_upload_saveFilePart(long file_id_, int file_part_, buf_t *bytes_)
{
	buf_t buf = buf_add_ui32(0xb304a621);
	//parse argument file_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(file_id_));
	}
	//parse argument file_part (int)
	{
		buf = buf_cat(buf, buf_add_ui32(file_part_));
	}
	//parse argument bytes (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(bytes_->data, bytes_->size));
	}
	return buf;
}

buf_t tl_upload_getFile(bool precise_, bool cdn_supported_, InputFileLocation *location_, long offset_, int limit_)
{
	buf_t buf = buf_add_ui32(0xbe5335be);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument precise (true)
	if (precise_)
		*flag1 |= (1 << 0);
	//parse argument cdn_supported (true)
	if (cdn_supported_)
		*flag1 |= (1 << 1);
	//parse argument location (InputFileLocation)
	{
		buf = buf_cat(buf, *location_);
	}
	//parse argument offset (long)
	{
		buf = buf_cat(buf, buf_add_ui64(offset_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	return buf;
}

buf_t tl_upload_saveBigFilePart(long file_id_, int file_part_, int file_total_parts_, buf_t *bytes_)
{
	buf_t buf = buf_add_ui32(0xde7b673d);
	//parse argument file_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(file_id_));
	}
	//parse argument file_part (int)
	{
		buf = buf_cat(buf, buf_add_ui32(file_part_));
	}
	//parse argument file_total_parts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(file_total_parts_));
	}
	//parse argument bytes (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(bytes_->data, bytes_->size));
	}
	return buf;
}

buf_t tl_upload_getWebFile(InputWebFileLocation *location_, int offset_, int limit_)
{
	buf_t buf = buf_add_ui32(0x24e6818d);
	//parse argument location (InputWebFileLocation)
	{
		buf = buf_cat(buf, *location_);
	}
	//parse argument offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	return buf;
}

buf_t tl_upload_getCdnFile(buf_t *file_token_, long offset_, int limit_)
{
	buf_t buf = buf_add_ui32(0x395f69da);
	//parse argument file_token (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(file_token_->data, file_token_->size));
	}
	//parse argument offset (long)
	{
		buf = buf_cat(buf, buf_add_ui64(offset_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	return buf;
}

buf_t tl_upload_reuploadCdnFile(buf_t *file_token_, buf_t *request_token_)
{
	buf_t buf = buf_add_ui32(0x9b2754a8);
	//parse argument file_token (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(file_token_->data, file_token_->size));
	}
	//parse argument request_token (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(request_token_->data, request_token_->size));
	}
	return buf;
}

buf_t tl_upload_getCdnFileHashes(buf_t *file_token_, long offset_)
{
	buf_t buf = buf_add_ui32(0x91dc3f31);
	//parse argument file_token (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(file_token_->data, file_token_->size));
	}
	//parse argument offset (long)
	{
		buf = buf_cat(buf, buf_add_ui64(offset_));
	}
	return buf;
}

buf_t tl_upload_getFileHashes(InputFileLocation *location_, long offset_)
{
	buf_t buf = buf_add_ui32(0x9156982a);
	//parse argument location (InputFileLocation)
	{
		buf = buf_cat(buf, *location_);
	}
	//parse argument offset (long)
	{
		buf = buf_cat(buf, buf_add_ui64(offset_));
	}
	return buf;
}

buf_t tl_help_getConfig()
{
	buf_t buf = buf_add_ui32(0xc4f9186b);
	return buf;
}

buf_t tl_help_getNearestDc()
{
	buf_t buf = buf_add_ui32(0x1fb33026);
	return buf;
}

buf_t tl_help_getAppUpdate(const char * source_)
{
	buf_t buf = buf_add_ui32(0x522d5a7d);
	//parse argument source (string)
	{
		buf = buf_cat(buf, serialize_string(source_));
	}
	return buf;
}

buf_t tl_help_getInviteText()
{
	buf_t buf = buf_add_ui32(0x4d392343);
	return buf;
}

buf_t tl_help_getSupport()
{
	buf_t buf = buf_add_ui32(0x9cdf08cd);
	return buf;
}

buf_t tl_help_setBotUpdatesStatus(int pending_updates_count_, const char * message_)
{
	buf_t buf = buf_add_ui32(0xec22cfcd);
	//parse argument pending_updates_count (int)
	{
		buf = buf_cat(buf, buf_add_ui32(pending_updates_count_));
	}
	//parse argument message (string)
	{
		buf = buf_cat(buf, serialize_string(message_));
	}
	return buf;
}

buf_t tl_help_getCdnConfig()
{
	buf_t buf = buf_add_ui32(0x52029342);
	return buf;
}

buf_t tl_help_getRecentMeUrls(const char * referer_)
{
	buf_t buf = buf_add_ui32(0x3dc0f114);
	//parse argument referer (string)
	{
		buf = buf_cat(buf, serialize_string(referer_));
	}
	return buf;
}

buf_t tl_help_getTermsOfServiceUpdate()
{
	buf_t buf = buf_add_ui32(0x2ca51fd1);
	return buf;
}

buf_t tl_help_acceptTermsOfService(DataJSON *id_)
{
	buf_t buf = buf_add_ui32(0xee72f79a);
	//parse argument id (DataJSON)
	{
		buf = buf_cat(buf, *id_);
	}
	return buf;
}

buf_t tl_help_getDeepLinkInfo(const char * path_)
{
	buf_t buf = buf_add_ui32(0x3fedc75f);
	//parse argument path (string)
	{
		buf = buf_cat(buf, serialize_string(path_));
	}
	return buf;
}

buf_t tl_help_getAppConfig(int hash_)
{
	buf_t buf = buf_add_ui32(0x61e3f854);
	//parse argument hash (int)
	{
		buf = buf_cat(buf, buf_add_ui32(hash_));
	}
	return buf;
}

buf_t tl_help_saveAppLog(InputAppEvent *events_, int events_len)
{
	buf_t buf = buf_add_ui32(0x6f02f748);
	//parse argument events (Vector<InputAppEvent>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(events_len));
		int i;
		for (i=0; i<events_len; ++i){
			buf = buf_cat(buf, events_[i]);
		}
	}
	return buf;
}

buf_t tl_help_getPassportConfig(int hash_)
{
	buf_t buf = buf_add_ui32(0xc661ad08);
	//parse argument hash (int)
	{
		buf = buf_cat(buf, buf_add_ui32(hash_));
	}
	return buf;
}

buf_t tl_help_getSupportName()
{
	buf_t buf = buf_add_ui32(0xd360e72c);
	return buf;
}

buf_t tl_help_getUserInfo(InputUser *user_id_)
{
	buf_t buf = buf_add_ui32(0x038a08d3);
	//parse argument user_id (InputUser)
	{
		buf = buf_cat(buf, *user_id_);
	}
	return buf;
}

buf_t tl_help_editUserInfo(InputUser *user_id_, const char * message_, MessageEntity *entities_, int entities_len)
{
	buf_t buf = buf_add_ui32(0x66b91b70);
	//parse argument user_id (InputUser)
	{
		buf = buf_cat(buf, *user_id_);
	}
	//parse argument message (string)
	{
		buf = buf_cat(buf, serialize_string(message_));
	}
	//parse argument entities (Vector<MessageEntity>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(entities_len));
		int i;
		for (i=0; i<entities_len; ++i){
			buf = buf_cat(buf, entities_[i]);
		}
	}
	return buf;
}

buf_t tl_help_getPromoData()
{
	buf_t buf = buf_add_ui32(0xc0977421);
	return buf;
}

buf_t tl_help_hidePromoData(InputPeer *peer_)
{
	buf_t buf = buf_add_ui32(0x1e251c95);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_help_dismissSuggestion(InputPeer *peer_, const char * suggestion_)
{
	buf_t buf = buf_add_ui32(0xf50dbaa1);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument suggestion (string)
	{
		buf = buf_cat(buf, serialize_string(suggestion_));
	}
	return buf;
}

buf_t tl_help_getCountriesList(const char * lang_code_, int hash_)
{
	buf_t buf = buf_add_ui32(0x735787a8);
	//parse argument lang_code (string)
	{
		buf = buf_cat(buf, serialize_string(lang_code_));
	}
	//parse argument hash (int)
	{
		buf = buf_cat(buf, buf_add_ui32(hash_));
	}
	return buf;
}

buf_t tl_help_getPremiumPromo()
{
	buf_t buf = buf_add_ui32(0xb81b93d4);
	return buf;
}

buf_t tl_help_getPeerColors(int hash_)
{
	buf_t buf = buf_add_ui32(0xda80f42f);
	//parse argument hash (int)
	{
		buf = buf_cat(buf, buf_add_ui32(hash_));
	}
	return buf;
}

buf_t tl_help_getPeerProfileColors(int hash_)
{
	buf_t buf = buf_add_ui32(0xabcfa9fd);
	//parse argument hash (int)
	{
		buf = buf_cat(buf, buf_add_ui32(hash_));
	}
	return buf;
}

buf_t tl_help_getTimezonesList(int hash_)
{
	buf_t buf = buf_add_ui32(0x49b30240);
	//parse argument hash (int)
	{
		buf = buf_cat(buf, buf_add_ui32(hash_));
	}
	return buf;
}

buf_t tl_channels_readHistory(InputChannel *channel_, int max_id_)
{
	buf_t buf = buf_add_ui32(0xcc104937);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument max_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(max_id_));
	}
	return buf;
}

buf_t tl_channels_deleteMessages(InputChannel *channel_, int *id_, int id_len)
{
	buf_t buf = buf_add_ui32(0x84c1fd4e);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument id (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(id_[i]));
		}
	}
	return buf;
}

buf_t tl_channels_reportSpam(InputChannel *channel_, InputPeer *participant_, int *id_, int id_len)
{
	buf_t buf = buf_add_ui32(0xf44a8315);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument participant (InputPeer)
	{
		buf = buf_cat(buf, *participant_);
	}
	//parse argument id (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(id_[i]));
		}
	}
	return buf;
}

buf_t tl_channels_getMessages(InputChannel *channel_, InputMessage *id_, int id_len)
{
	buf_t buf = buf_add_ui32(0xad8c9a23);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument id (Vector<InputMessage>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, id_[i]);
		}
	}
	return buf;
}

buf_t tl_channels_getParticipants(InputChannel *channel_, ChannelParticipantsFilter *filter_, int offset_, int limit_, long hash_)
{
	buf_t buf = buf_add_ui32(0x77ced9d0);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument filter (ChannelParticipantsFilter)
	{
		buf = buf_cat(buf, *filter_);
	}
	//parse argument offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	//parse argument hash (long)
	{
		buf = buf_cat(buf, buf_add_ui64(hash_));
	}
	return buf;
}

buf_t tl_channels_getParticipant(InputChannel *channel_, InputPeer *participant_)
{
	buf_t buf = buf_add_ui32(0xa0ab6cc6);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument participant (InputPeer)
	{
		buf = buf_cat(buf, *participant_);
	}
	return buf;
}

buf_t tl_channels_getChannels(InputChannel *id_, int id_len)
{
	buf_t buf = buf_add_ui32(0x0a7f6bbb);
	//parse argument id (Vector<InputChannel>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, id_[i]);
		}
	}
	return buf;
}

buf_t tl_channels_getFullChannel(InputChannel *channel_)
{
	buf_t buf = buf_add_ui32(0x08736a09);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	return buf;
}

buf_t tl_channels_createChannel(bool broadcast_, bool megagroup_, bool for_import_, bool forum_, const char * title_, const char * about_, InputGeoPoint *geo_point_, const char * address_, int ttl_period_)
{
	buf_t buf = buf_add_ui32(0x91006707);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument broadcast (true)
	if (broadcast_)
		*flag1 |= (1 << 0);
	//parse argument megagroup (true)
	if (megagroup_)
		*flag1 |= (1 << 1);
	//parse argument for_import (true)
	if (for_import_)
		*flag1 |= (1 << 3);
	//parse argument forum (true)
	if (forum_)
		*flag1 |= (1 << 5);
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument about (string)
	{
		buf = buf_cat(buf, serialize_string(about_));
	}
	//parse argument geo_point (InputGeoPoint)
	if (geo_point_)
	{
		buf = buf_cat(buf, *geo_point_);
		*flag1 |= (1 << 2);
	}
	//parse argument address (string)
	if (address_)
	{
		buf = buf_cat(buf, serialize_string(address_));
		*flag1 |= (1 << 2);
	}
	//parse argument ttl_period (int)
	if (ttl_period_)
	{
		buf = buf_cat(buf, buf_add_ui32(ttl_period_));
		*flag1 |= (1 << 4);
	}
	return buf;
}

buf_t tl_channels_editAdmin(InputChannel *channel_, InputUser *user_id_, ChatAdminRights *admin_rights_, const char * rank_)
{
	buf_t buf = buf_add_ui32(0xd33c8902);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument user_id (InputUser)
	{
		buf = buf_cat(buf, *user_id_);
	}
	//parse argument admin_rights (ChatAdminRights)
	{
		buf = buf_cat(buf, *admin_rights_);
	}
	//parse argument rank (string)
	{
		buf = buf_cat(buf, serialize_string(rank_));
	}
	return buf;
}

buf_t tl_channels_editTitle(InputChannel *channel_, const char * title_)
{
	buf_t buf = buf_add_ui32(0x566decd0);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	return buf;
}

buf_t tl_channels_editPhoto(InputChannel *channel_, InputChatPhoto *photo_)
{
	buf_t buf = buf_add_ui32(0xf12e57c9);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument photo (InputChatPhoto)
	{
		buf = buf_cat(buf, *photo_);
	}
	return buf;
}

buf_t tl_channels_checkUsername(InputChannel *channel_, const char * username_)
{
	buf_t buf = buf_add_ui32(0x10e6bd2c);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument username (string)
	{
		buf = buf_cat(buf, serialize_string(username_));
	}
	return buf;
}

buf_t tl_channels_updateUsername(InputChannel *channel_, const char * username_)
{
	buf_t buf = buf_add_ui32(0x3514b3de);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument username (string)
	{
		buf = buf_cat(buf, serialize_string(username_));
	}
	return buf;
}

buf_t tl_channels_joinChannel(InputChannel *channel_)
{
	buf_t buf = buf_add_ui32(0x24b524c5);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	return buf;
}

buf_t tl_channels_leaveChannel(InputChannel *channel_)
{
	buf_t buf = buf_add_ui32(0xf836aa95);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	return buf;
}

buf_t tl_channels_inviteToChannel(InputChannel *channel_, InputUser *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0xc9e33d54);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument users (Vector<InputUser>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_channels_deleteChannel(InputChannel *channel_)
{
	buf_t buf = buf_add_ui32(0xc0111fe3);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	return buf;
}

buf_t tl_channels_exportMessageLink(bool grouped_, bool thread_, InputChannel *channel_, int id_)
{
	buf_t buf = buf_add_ui32(0xe63fadeb);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument grouped (true)
	if (grouped_)
		*flag1 |= (1 << 0);
	//parse argument thread (true)
	if (thread_)
		*flag1 |= (1 << 1);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	return buf;
}

buf_t tl_channels_toggleSignatures(bool signatures_enabled_, bool profiles_enabled_, InputChannel *channel_)
{
	buf_t buf = buf_add_ui32(0x418d549c);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument signatures_enabled (true)
	if (signatures_enabled_)
		*flag1 |= (1 << 0);
	//parse argument profiles_enabled (true)
	if (profiles_enabled_)
		*flag1 |= (1 << 1);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	return buf;
}

buf_t tl_channels_getAdminedPublicChannels(bool by_location_, bool check_limit_, bool for_personal_)
{
	buf_t buf = buf_add_ui32(0xf8b036af);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument by_location (true)
	if (by_location_)
		*flag1 |= (1 << 0);
	//parse argument check_limit (true)
	if (check_limit_)
		*flag1 |= (1 << 1);
	//parse argument for_personal (true)
	if (for_personal_)
		*flag1 |= (1 << 2);
	return buf;
}

buf_t tl_channels_editBanned(InputChannel *channel_, InputPeer *participant_, ChatBannedRights *banned_rights_)
{
	buf_t buf = buf_add_ui32(0x96e6cd81);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument participant (InputPeer)
	{
		buf = buf_cat(buf, *participant_);
	}
	//parse argument banned_rights (ChatBannedRights)
	{
		buf = buf_cat(buf, *banned_rights_);
	}
	return buf;
}

buf_t tl_channels_getAdminLog(InputChannel *channel_, const char * q_, ChannelAdminLogEventsFilter *events_filter_, InputUser *admins_, int admins_len, long max_id_, long min_id_, int limit_)
{
	buf_t buf = buf_add_ui32(0x33ddf480);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument q (string)
	{
		buf = buf_cat(buf, serialize_string(q_));
	}
	//parse argument events_filter (ChannelAdminLogEventsFilter)
	if (events_filter_)
	{
		buf = buf_cat(buf, *events_filter_);
		*flag1 |= (1 << 0);
	}
	//parse argument admins (Vector<InputUser>)
	if (admins_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(admins_len));
		int i;
		for (i=0; i<admins_len; ++i){
			buf = buf_cat(buf, admins_[i]);
		}
		*flag1 |= (1 << 1);
	}
	//parse argument max_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(max_id_));
	}
	//parse argument min_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(min_id_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	return buf;
}

buf_t tl_channels_setStickers(InputChannel *channel_, InputStickerSet *stickerset_)
{
	buf_t buf = buf_add_ui32(0xea8ca4f9);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument stickerset (InputStickerSet)
	{
		buf = buf_cat(buf, *stickerset_);
	}
	return buf;
}

buf_t tl_channels_readMessageContents(InputChannel *channel_, int *id_, int id_len)
{
	buf_t buf = buf_add_ui32(0xeab5dc38);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument id (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(id_[i]));
		}
	}
	return buf;
}

buf_t tl_channels_deleteHistory(bool for_everyone_, InputChannel *channel_, int max_id_)
{
	buf_t buf = buf_add_ui32(0x9baa9647);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument for_everyone (true)
	if (for_everyone_)
		*flag1 |= (1 << 0);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument max_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(max_id_));
	}
	return buf;
}

buf_t tl_channels_togglePreHistoryHidden(InputChannel *channel_, Bool *enabled_)
{
	buf_t buf = buf_add_ui32(0xeabbb94c);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument enabled (Bool)
	{
		buf = buf_cat(buf, *enabled_);
	}
	return buf;
}

buf_t tl_channels_getLeftChannels(int offset_)
{
	buf_t buf = buf_add_ui32(0x8341ecc0);
	//parse argument offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_));
	}
	return buf;
}

buf_t tl_channels_getGroupsForDiscussion()
{
	buf_t buf = buf_add_ui32(0xf5dad378);
	return buf;
}

buf_t tl_channels_setDiscussionGroup(InputChannel *broadcast_, InputChannel *group_)
{
	buf_t buf = buf_add_ui32(0x40582bb2);
	//parse argument broadcast (InputChannel)
	{
		buf = buf_cat(buf, *broadcast_);
	}
	//parse argument group (InputChannel)
	{
		buf = buf_cat(buf, *group_);
	}
	return buf;
}

buf_t tl_channels_editCreator(InputChannel *channel_, InputUser *user_id_, InputCheckPasswordSRP *password_)
{
	buf_t buf = buf_add_ui32(0x8f38cd1f);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument user_id (InputUser)
	{
		buf = buf_cat(buf, *user_id_);
	}
	//parse argument password (InputCheckPasswordSRP)
	{
		buf = buf_cat(buf, *password_);
	}
	return buf;
}

buf_t tl_channels_editLocation(InputChannel *channel_, InputGeoPoint *geo_point_, const char * address_)
{
	buf_t buf = buf_add_ui32(0x58e63f6d);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument geo_point (InputGeoPoint)
	{
		buf = buf_cat(buf, *geo_point_);
	}
	//parse argument address (string)
	{
		buf = buf_cat(buf, serialize_string(address_));
	}
	return buf;
}

buf_t tl_channels_toggleSlowMode(InputChannel *channel_, int seconds_)
{
	buf_t buf = buf_add_ui32(0xedd49ef0);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument seconds (int)
	{
		buf = buf_cat(buf, buf_add_ui32(seconds_));
	}
	return buf;
}

buf_t tl_channels_getInactiveChannels()
{
	buf_t buf = buf_add_ui32(0x11e831ee);
	return buf;
}

buf_t tl_channels_convertToGigagroup(InputChannel *channel_)
{
	buf_t buf = buf_add_ui32(0x0b290c69);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	return buf;
}

buf_t tl_channels_viewSponsoredMessage(InputChannel *channel_, buf_t *random_id_)
{
	buf_t buf = buf_add_ui32(0xbeaedb94);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument random_id (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(random_id_->data, random_id_->size));
	}
	return buf;
}

buf_t tl_channels_getSponsoredMessages(InputChannel *channel_)
{
	buf_t buf = buf_add_ui32(0xec210fbf);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	return buf;
}

buf_t tl_channels_getSendAs(InputPeer *peer_)
{
	buf_t buf = buf_add_ui32(0x0dc770ee);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_channels_deleteParticipantHistory(InputChannel *channel_, InputPeer *participant_)
{
	buf_t buf = buf_add_ui32(0x367544db);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument participant (InputPeer)
	{
		buf = buf_cat(buf, *participant_);
	}
	return buf;
}

buf_t tl_channels_toggleJoinToSend(InputChannel *channel_, Bool *enabled_)
{
	buf_t buf = buf_add_ui32(0xe4cb9580);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument enabled (Bool)
	{
		buf = buf_cat(buf, *enabled_);
	}
	return buf;
}

buf_t tl_channels_toggleJoinRequest(InputChannel *channel_, Bool *enabled_)
{
	buf_t buf = buf_add_ui32(0x4c2985b6);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument enabled (Bool)
	{
		buf = buf_cat(buf, *enabled_);
	}
	return buf;
}

buf_t tl_channels_reorderUsernames(InputChannel *channel_, const char * *order_, int order_len)
{
	buf_t buf = buf_add_ui32(0xb45ced1d);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument order (Vector<string>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(order_len));
		int i;
		for (i=0; i<order_len; ++i){
			buf = buf_cat(buf, serialize_string(order_[i]));
		}
	}
	return buf;
}

buf_t tl_channels_toggleUsername(InputChannel *channel_, const char * username_, Bool *active_)
{
	buf_t buf = buf_add_ui32(0x50f24105);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument username (string)
	{
		buf = buf_cat(buf, serialize_string(username_));
	}
	//parse argument active (Bool)
	{
		buf = buf_cat(buf, *active_);
	}
	return buf;
}

buf_t tl_channels_deactivateAllUsernames(InputChannel *channel_)
{
	buf_t buf = buf_add_ui32(0x0a245dd3);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	return buf;
}

buf_t tl_channels_toggleForum(InputChannel *channel_, Bool *enabled_)
{
	buf_t buf = buf_add_ui32(0xa4298b29);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument enabled (Bool)
	{
		buf = buf_cat(buf, *enabled_);
	}
	return buf;
}

buf_t tl_channels_createForumTopic(InputChannel *channel_, const char * title_, int icon_color_, long icon_emoji_id_, long random_id_, InputPeer *send_as_)
{
	buf_t buf = buf_add_ui32(0xf40c0224);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument icon_color (int)
	if (icon_color_)
	{
		buf = buf_cat(buf, buf_add_ui32(icon_color_));
		*flag1 |= (1 << 0);
	}
	//parse argument icon_emoji_id (long)
	if (icon_emoji_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(icon_emoji_id_));
		*flag1 |= (1 << 3);
	}
	//parse argument random_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(random_id_));
	}
	//parse argument send_as (InputPeer)
	if (send_as_)
	{
		buf = buf_cat(buf, *send_as_);
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_channels_getForumTopics(InputChannel *channel_, const char * q_, int offset_date_, int offset_id_, int offset_topic_, int limit_)
{
	buf_t buf = buf_add_ui32(0x0de560d1);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument q (string)
	if (q_)
	{
		buf = buf_cat(buf, serialize_string(q_));
		*flag1 |= (1 << 0);
	}
	//parse argument offset_date (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_date_));
	}
	//parse argument offset_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_id_));
	}
	//parse argument offset_topic (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_topic_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	return buf;
}

buf_t tl_channels_getForumTopicsByID(InputChannel *channel_, int *topics_, int topics_len)
{
	buf_t buf = buf_add_ui32(0xb0831eb9);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument topics (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(topics_len));
		int i;
		for (i=0; i<topics_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(topics_[i]));
		}
	}
	return buf;
}

buf_t tl_channels_editForumTopic(InputChannel *channel_, int topic_id_, const char * title_, long icon_emoji_id_, Bool *closed_, Bool *hidden_)
{
	buf_t buf = buf_add_ui32(0xf4dfa185);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument topic_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(topic_id_));
	}
	//parse argument title (string)
	if (title_)
	{
		buf = buf_cat(buf, serialize_string(title_));
		*flag1 |= (1 << 0);
	}
	//parse argument icon_emoji_id (long)
	if (icon_emoji_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(icon_emoji_id_));
		*flag1 |= (1 << 1);
	}
	//parse argument closed (Bool)
	if (closed_)
	{
		buf = buf_cat(buf, *closed_);
		*flag1 |= (1 << 2);
	}
	//parse argument hidden (Bool)
	if (hidden_)
	{
		buf = buf_cat(buf, *hidden_);
		*flag1 |= (1 << 3);
	}
	return buf;
}

buf_t tl_channels_updatePinnedForumTopic(InputChannel *channel_, int topic_id_, Bool *pinned_)
{
	buf_t buf = buf_add_ui32(0x6c2d9026);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument topic_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(topic_id_));
	}
	//parse argument pinned (Bool)
	{
		buf = buf_cat(buf, *pinned_);
	}
	return buf;
}

buf_t tl_channels_deleteTopicHistory(InputChannel *channel_, int top_msg_id_)
{
	buf_t buf = buf_add_ui32(0x34435f2d);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument top_msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(top_msg_id_));
	}
	return buf;
}

buf_t tl_channels_reorderPinnedForumTopics(bool force_, InputChannel *channel_, int *order_, int order_len)
{
	buf_t buf = buf_add_ui32(0x2950a18f);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument force (true)
	if (force_)
		*flag1 |= (1 << 0);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument order (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(order_len));
		int i;
		for (i=0; i<order_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(order_[i]));
		}
	}
	return buf;
}

buf_t tl_channels_toggleAntiSpam(InputChannel *channel_, Bool *enabled_)
{
	buf_t buf = buf_add_ui32(0x68f3e4eb);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument enabled (Bool)
	{
		buf = buf_cat(buf, *enabled_);
	}
	return buf;
}

buf_t tl_channels_reportAntiSpamFalsePositive(InputChannel *channel_, int msg_id_)
{
	buf_t buf = buf_add_ui32(0xa850a693);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	return buf;
}

buf_t tl_channels_toggleParticipantsHidden(InputChannel *channel_, Bool *enabled_)
{
	buf_t buf = buf_add_ui32(0x6a6e7854);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument enabled (Bool)
	{
		buf = buf_cat(buf, *enabled_);
	}
	return buf;
}

buf_t tl_channels_clickSponsoredMessage(bool media_, bool fullscreen_, InputChannel *channel_, buf_t *random_id_)
{
	buf_t buf = buf_add_ui32(0x01445d75);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument media (true)
	if (media_)
		*flag1 |= (1 << 0);
	//parse argument fullscreen (true)
	if (fullscreen_)
		*flag1 |= (1 << 1);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument random_id (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(random_id_->data, random_id_->size));
	}
	return buf;
}

buf_t tl_channels_updateColor(bool for_profile_, InputChannel *channel_, int color_, long background_emoji_id_)
{
	buf_t buf = buf_add_ui32(0xd8aa3671);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument for_profile (true)
	if (for_profile_)
		*flag1 |= (1 << 1);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument color (int)
	if (color_)
	{
		buf = buf_cat(buf, buf_add_ui32(color_));
		*flag1 |= (1 << 2);
	}
	//parse argument background_emoji_id (long)
	if (background_emoji_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(background_emoji_id_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_channels_toggleViewForumAsMessages(InputChannel *channel_, Bool *enabled_)
{
	buf_t buf = buf_add_ui32(0x9738bb15);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument enabled (Bool)
	{
		buf = buf_cat(buf, *enabled_);
	}
	return buf;
}

buf_t tl_channels_getChannelRecommendations(InputChannel *channel_)
{
	buf_t buf = buf_add_ui32(0x25a71742);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument channel (InputChannel)
	if (channel_)
	{
		buf = buf_cat(buf, *channel_);
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_channels_updateEmojiStatus(InputChannel *channel_, EmojiStatus *emoji_status_)
{
	buf_t buf = buf_add_ui32(0xf0d3e6a8);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument emoji_status (EmojiStatus)
	{
		buf = buf_cat(buf, *emoji_status_);
	}
	return buf;
}

buf_t tl_channels_setBoostsToUnblockRestrictions(InputChannel *channel_, int boosts_)
{
	buf_t buf = buf_add_ui32(0xad399cee);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument boosts (int)
	{
		buf = buf_cat(buf, buf_add_ui32(boosts_));
	}
	return buf;
}

buf_t tl_channels_setEmojiStickers(InputChannel *channel_, InputStickerSet *stickerset_)
{
	buf_t buf = buf_add_ui32(0x3cd930b7);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument stickerset (InputStickerSet)
	{
		buf = buf_cat(buf, *stickerset_);
	}
	return buf;
}

buf_t tl_channels_reportSponsoredMessage(InputChannel *channel_, buf_t *random_id_, buf_t *option_)
{
	buf_t buf = buf_add_ui32(0xaf8ff6b9);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument random_id (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(random_id_->data, random_id_->size));
	}
	//parse argument option (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(option_->data, option_->size));
	}
	return buf;
}

buf_t tl_channels_restrictSponsoredMessages(InputChannel *channel_, Bool *restricted_)
{
	buf_t buf = buf_add_ui32(0x9ae91519);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument restricted (Bool)
	{
		buf = buf_cat(buf, *restricted_);
	}
	return buf;
}

buf_t tl_channels_searchPosts(const char * hashtag_, int offset_rate_, InputPeer *offset_peer_, int offset_id_, int limit_)
{
	buf_t buf = buf_add_ui32(0xd19f987b);
	//parse argument hashtag (string)
	{
		buf = buf_cat(buf, serialize_string(hashtag_));
	}
	//parse argument offset_rate (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_rate_));
	}
	//parse argument offset_peer (InputPeer)
	{
		buf = buf_cat(buf, *offset_peer_);
	}
	//parse argument offset_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_id_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	return buf;
}

buf_t tl_bots_sendCustomRequest(const char * custom_method_, DataJSON *params_)
{
	buf_t buf = buf_add_ui32(0xaa2769ed);
	//parse argument custom_method (string)
	{
		buf = buf_cat(buf, serialize_string(custom_method_));
	}
	//parse argument params (DataJSON)
	{
		buf = buf_cat(buf, *params_);
	}
	return buf;
}

buf_t tl_bots_answerWebhookJSONQuery(long query_id_, DataJSON *data_)
{
	buf_t buf = buf_add_ui32(0xe6213f4d);
	//parse argument query_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(query_id_));
	}
	//parse argument data (DataJSON)
	{
		buf = buf_cat(buf, *data_);
	}
	return buf;
}

buf_t tl_bots_setBotCommands(BotCommandScope *scope_, const char * lang_code_, BotCommand *commands_, int commands_len)
{
	buf_t buf = buf_add_ui32(0x0517165a);
	//parse argument scope (BotCommandScope)
	{
		buf = buf_cat(buf, *scope_);
	}
	//parse argument lang_code (string)
	{
		buf = buf_cat(buf, serialize_string(lang_code_));
	}
	//parse argument commands (Vector<BotCommand>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(commands_len));
		int i;
		for (i=0; i<commands_len; ++i){
			buf = buf_cat(buf, commands_[i]);
		}
	}
	return buf;
}

buf_t tl_bots_resetBotCommands(BotCommandScope *scope_, const char * lang_code_)
{
	buf_t buf = buf_add_ui32(0x3d8de0f9);
	//parse argument scope (BotCommandScope)
	{
		buf = buf_cat(buf, *scope_);
	}
	//parse argument lang_code (string)
	{
		buf = buf_cat(buf, serialize_string(lang_code_));
	}
	return buf;
}

buf_t tl_bots_getBotCommands(BotCommandScope *scope_, const char * lang_code_)
{
	buf_t buf = buf_add_ui32(0xe34c0dd6);
	//parse argument scope (BotCommandScope)
	{
		buf = buf_cat(buf, *scope_);
	}
	//parse argument lang_code (string)
	{
		buf = buf_cat(buf, serialize_string(lang_code_));
	}
	return buf;
}

buf_t tl_bots_setBotMenuButton(InputUser *user_id_, BotMenuButton *button_)
{
	buf_t buf = buf_add_ui32(0x4504d54f);
	//parse argument user_id (InputUser)
	{
		buf = buf_cat(buf, *user_id_);
	}
	//parse argument button (BotMenuButton)
	{
		buf = buf_cat(buf, *button_);
	}
	return buf;
}

buf_t tl_bots_getBotMenuButton(InputUser *user_id_)
{
	buf_t buf = buf_add_ui32(0x9c60eb28);
	//parse argument user_id (InputUser)
	{
		buf = buf_cat(buf, *user_id_);
	}
	return buf;
}

buf_t tl_bots_setBotBroadcastDefaultAdminRights(ChatAdminRights *admin_rights_)
{
	buf_t buf = buf_add_ui32(0x788464e1);
	//parse argument admin_rights (ChatAdminRights)
	{
		buf = buf_cat(buf, *admin_rights_);
	}
	return buf;
}

buf_t tl_bots_setBotGroupDefaultAdminRights(ChatAdminRights *admin_rights_)
{
	buf_t buf = buf_add_ui32(0x925ec9ea);
	//parse argument admin_rights (ChatAdminRights)
	{
		buf = buf_cat(buf, *admin_rights_);
	}
	return buf;
}

buf_t tl_bots_setBotInfo(InputUser *bot_, const char * lang_code_, const char * name_, const char * about_, const char * description_)
{
	buf_t buf = buf_add_ui32(0x10cf3123);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument bot (InputUser)
	if (bot_)
	{
		buf = buf_cat(buf, *bot_);
		*flag1 |= (1 << 2);
	}
	//parse argument lang_code (string)
	{
		buf = buf_cat(buf, serialize_string(lang_code_));
	}
	//parse argument name (string)
	if (name_)
	{
		buf = buf_cat(buf, serialize_string(name_));
		*flag1 |= (1 << 3);
	}
	//parse argument about (string)
	if (about_)
	{
		buf = buf_cat(buf, serialize_string(about_));
		*flag1 |= (1 << 0);
	}
	//parse argument description (string)
	if (description_)
	{
		buf = buf_cat(buf, serialize_string(description_));
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_bots_getBotInfo(InputUser *bot_, const char * lang_code_)
{
	buf_t buf = buf_add_ui32(0xdcd914fd);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument bot (InputUser)
	if (bot_)
	{
		buf = buf_cat(buf, *bot_);
		*flag1 |= (1 << 0);
	}
	//parse argument lang_code (string)
	{
		buf = buf_cat(buf, serialize_string(lang_code_));
	}
	return buf;
}

buf_t tl_bots_reorderUsernames(InputUser *bot_, const char * *order_, int order_len)
{
	buf_t buf = buf_add_ui32(0x9709b1c2);
	//parse argument bot (InputUser)
	{
		buf = buf_cat(buf, *bot_);
	}
	//parse argument order (Vector<string>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(order_len));
		int i;
		for (i=0; i<order_len; ++i){
			buf = buf_cat(buf, serialize_string(order_[i]));
		}
	}
	return buf;
}

buf_t tl_bots_toggleUsername(InputUser *bot_, const char * username_, Bool *active_)
{
	buf_t buf = buf_add_ui32(0x053ca973);
	//parse argument bot (InputUser)
	{
		buf = buf_cat(buf, *bot_);
	}
	//parse argument username (string)
	{
		buf = buf_cat(buf, serialize_string(username_));
	}
	//parse argument active (Bool)
	{
		buf = buf_cat(buf, *active_);
	}
	return buf;
}

buf_t tl_bots_canSendMessage(InputUser *bot_)
{
	buf_t buf = buf_add_ui32(0x1359f4e6);
	//parse argument bot (InputUser)
	{
		buf = buf_cat(buf, *bot_);
	}
	return buf;
}

buf_t tl_bots_allowSendMessage(InputUser *bot_)
{
	buf_t buf = buf_add_ui32(0xf132e3ef);
	//parse argument bot (InputUser)
	{
		buf = buf_cat(buf, *bot_);
	}
	return buf;
}

buf_t tl_bots_invokeWebViewCustomMethod(InputUser *bot_, const char * custom_method_, DataJSON *params_)
{
	buf_t buf = buf_add_ui32(0x087fc5e7);
	//parse argument bot (InputUser)
	{
		buf = buf_cat(buf, *bot_);
	}
	//parse argument custom_method (string)
	{
		buf = buf_cat(buf, serialize_string(custom_method_));
	}
	//parse argument params (DataJSON)
	{
		buf = buf_cat(buf, *params_);
	}
	return buf;
}

buf_t tl_bots_getPopularAppBots(const char * offset_, int limit_)
{
	buf_t buf = buf_add_ui32(0xc2510192);
	//parse argument offset (string)
	{
		buf = buf_cat(buf, serialize_string(offset_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	return buf;
}

buf_t tl_bots_addPreviewMedia(InputUser *bot_, const char * lang_code_, InputMedia *media_)
{
	buf_t buf = buf_add_ui32(0x17aeb75a);
	//parse argument bot (InputUser)
	{
		buf = buf_cat(buf, *bot_);
	}
	//parse argument lang_code (string)
	{
		buf = buf_cat(buf, serialize_string(lang_code_));
	}
	//parse argument media (InputMedia)
	{
		buf = buf_cat(buf, *media_);
	}
	return buf;
}

buf_t tl_bots_editPreviewMedia(InputUser *bot_, const char * lang_code_, InputMedia *media_, InputMedia *new_media_)
{
	buf_t buf = buf_add_ui32(0x8525606f);
	//parse argument bot (InputUser)
	{
		buf = buf_cat(buf, *bot_);
	}
	//parse argument lang_code (string)
	{
		buf = buf_cat(buf, serialize_string(lang_code_));
	}
	//parse argument media (InputMedia)
	{
		buf = buf_cat(buf, *media_);
	}
	//parse argument new_media (InputMedia)
	{
		buf = buf_cat(buf, *new_media_);
	}
	return buf;
}

buf_t tl_bots_deletePreviewMedia(InputUser *bot_, const char * lang_code_, InputMedia *media_, int media_len)
{
	buf_t buf = buf_add_ui32(0x2d0135b3);
	//parse argument bot (InputUser)
	{
		buf = buf_cat(buf, *bot_);
	}
	//parse argument lang_code (string)
	{
		buf = buf_cat(buf, serialize_string(lang_code_));
	}
	//parse argument media (Vector<InputMedia>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(media_len));
		int i;
		for (i=0; i<media_len; ++i){
			buf = buf_cat(buf, media_[i]);
		}
	}
	return buf;
}

buf_t tl_bots_reorderPreviewMedias(InputUser *bot_, const char * lang_code_, InputMedia *order_, int order_len)
{
	buf_t buf = buf_add_ui32(0xb627f3aa);
	//parse argument bot (InputUser)
	{
		buf = buf_cat(buf, *bot_);
	}
	//parse argument lang_code (string)
	{
		buf = buf_cat(buf, serialize_string(lang_code_));
	}
	//parse argument order (Vector<InputMedia>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(order_len));
		int i;
		for (i=0; i<order_len; ++i){
			buf = buf_cat(buf, order_[i]);
		}
	}
	return buf;
}

buf_t tl_bots_getPreviewInfo(InputUser *bot_, const char * lang_code_)
{
	buf_t buf = buf_add_ui32(0x423ab3ad);
	//parse argument bot (InputUser)
	{
		buf = buf_cat(buf, *bot_);
	}
	//parse argument lang_code (string)
	{
		buf = buf_cat(buf, serialize_string(lang_code_));
	}
	return buf;
}

buf_t tl_bots_getPreviewMedias(InputUser *bot_)
{
	buf_t buf = buf_add_ui32(0xa2a5594d);
	//parse argument bot (InputUser)
	{
		buf = buf_cat(buf, *bot_);
	}
	return buf;
}

buf_t tl_payments_getPaymentForm(InputInvoice *invoice_, DataJSON *theme_params_)
{
	buf_t buf = buf_add_ui32(0x37148dbb);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument invoice (InputInvoice)
	{
		buf = buf_cat(buf, *invoice_);
	}
	//parse argument theme_params (DataJSON)
	if (theme_params_)
	{
		buf = buf_cat(buf, *theme_params_);
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_payments_getPaymentReceipt(InputPeer *peer_, int msg_id_)
{
	buf_t buf = buf_add_ui32(0x2478d1cc);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	return buf;
}

buf_t tl_payments_validateRequestedInfo(bool save_, InputInvoice *invoice_, PaymentRequestedInfo *info_)
{
	buf_t buf = buf_add_ui32(0xb6c8f12b);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument save (true)
	if (save_)
		*flag1 |= (1 << 0);
	//parse argument invoice (InputInvoice)
	{
		buf = buf_cat(buf, *invoice_);
	}
	//parse argument info (PaymentRequestedInfo)
	{
		buf = buf_cat(buf, *info_);
	}
	return buf;
}

buf_t tl_payments_sendPaymentForm(long form_id_, InputInvoice *invoice_, const char * requested_info_id_, const char * shipping_option_id_, InputPaymentCredentials *credentials_, long tip_amount_)
{
	buf_t buf = buf_add_ui32(0x2d03522f);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument form_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(form_id_));
	}
	//parse argument invoice (InputInvoice)
	{
		buf = buf_cat(buf, *invoice_);
	}
	//parse argument requested_info_id (string)
	if (requested_info_id_)
	{
		buf = buf_cat(buf, serialize_string(requested_info_id_));
		*flag1 |= (1 << 0);
	}
	//parse argument shipping_option_id (string)
	if (shipping_option_id_)
	{
		buf = buf_cat(buf, serialize_string(shipping_option_id_));
		*flag1 |= (1 << 1);
	}
	//parse argument credentials (InputPaymentCredentials)
	{
		buf = buf_cat(buf, *credentials_);
	}
	//parse argument tip_amount (long)
	if (tip_amount_)
	{
		buf = buf_cat(buf, buf_add_ui64(tip_amount_));
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_payments_getSavedInfo()
{
	buf_t buf = buf_add_ui32(0x227d824b);
	return buf;
}

buf_t tl_payments_clearSavedInfo(bool credentials_, bool info_)
{
	buf_t buf = buf_add_ui32(0xd83d70c1);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument credentials (true)
	if (credentials_)
		*flag1 |= (1 << 0);
	//parse argument info (true)
	if (info_)
		*flag1 |= (1 << 1);
	return buf;
}

buf_t tl_payments_getBankCardData(const char * number_)
{
	buf_t buf = buf_add_ui32(0x2e79d779);
	//parse argument number (string)
	{
		buf = buf_cat(buf, serialize_string(number_));
	}
	return buf;
}

buf_t tl_payments_exportInvoice(InputMedia *invoice_media_)
{
	buf_t buf = buf_add_ui32(0x0f91b065);
	//parse argument invoice_media (InputMedia)
	{
		buf = buf_cat(buf, *invoice_media_);
	}
	return buf;
}

buf_t tl_payments_assignAppStoreTransaction(buf_t *receipt_, InputStorePaymentPurpose *purpose_)
{
	buf_t buf = buf_add_ui32(0x80ed747d);
	//parse argument receipt (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(receipt_->data, receipt_->size));
	}
	//parse argument purpose (InputStorePaymentPurpose)
	{
		buf = buf_cat(buf, *purpose_);
	}
	return buf;
}

buf_t tl_payments_assignPlayMarketTransaction(DataJSON *receipt_, InputStorePaymentPurpose *purpose_)
{
	buf_t buf = buf_add_ui32(0xdffd50d3);
	//parse argument receipt (DataJSON)
	{
		buf = buf_cat(buf, *receipt_);
	}
	//parse argument purpose (InputStorePaymentPurpose)
	{
		buf = buf_cat(buf, *purpose_);
	}
	return buf;
}

buf_t tl_payments_canPurchasePremium(InputStorePaymentPurpose *purpose_)
{
	buf_t buf = buf_add_ui32(0x9fc19eb6);
	//parse argument purpose (InputStorePaymentPurpose)
	{
		buf = buf_cat(buf, *purpose_);
	}
	return buf;
}

buf_t tl_payments_getPremiumGiftCodeOptions(InputPeer *boost_peer_)
{
	buf_t buf = buf_add_ui32(0x2757ba54);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument boost_peer (InputPeer)
	if (boost_peer_)
	{
		buf = buf_cat(buf, *boost_peer_);
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_payments_checkGiftCode(const char * slug_)
{
	buf_t buf = buf_add_ui32(0x8e51b4c1);
	//parse argument slug (string)
	{
		buf = buf_cat(buf, serialize_string(slug_));
	}
	return buf;
}

buf_t tl_payments_applyGiftCode(const char * slug_)
{
	buf_t buf = buf_add_ui32(0xf6e26854);
	//parse argument slug (string)
	{
		buf = buf_cat(buf, serialize_string(slug_));
	}
	return buf;
}

buf_t tl_payments_getGiveawayInfo(InputPeer *peer_, int msg_id_)
{
	buf_t buf = buf_add_ui32(0xf4239425);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	return buf;
}

buf_t tl_payments_launchPrepaidGiveaway(InputPeer *peer_, long giveaway_id_, InputStorePaymentPurpose *purpose_)
{
	buf_t buf = buf_add_ui32(0x5ff58f20);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument giveaway_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(giveaway_id_));
	}
	//parse argument purpose (InputStorePaymentPurpose)
	{
		buf = buf_cat(buf, *purpose_);
	}
	return buf;
}

buf_t tl_payments_getStarsTopupOptions()
{
	buf_t buf = buf_add_ui32(0xc00ec7d3);
	return buf;
}

buf_t tl_payments_getStarsStatus(InputPeer *peer_)
{
	buf_t buf = buf_add_ui32(0x104fcfa7);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_payments_getStarsTransactions(bool inbound_, bool outbound_, bool ascending_, const char * subscription_id_, InputPeer *peer_, const char * offset_, int limit_)
{
	buf_t buf = buf_add_ui32(0x69da4557);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument inbound (true)
	if (inbound_)
		*flag1 |= (1 << 0);
	//parse argument outbound (true)
	if (outbound_)
		*flag1 |= (1 << 1);
	//parse argument ascending (true)
	if (ascending_)
		*flag1 |= (1 << 2);
	//parse argument subscription_id (string)
	if (subscription_id_)
	{
		buf = buf_cat(buf, serialize_string(subscription_id_));
		*flag1 |= (1 << 3);
	}
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument offset (string)
	{
		buf = buf_cat(buf, serialize_string(offset_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	return buf;
}

buf_t tl_payments_sendStarsForm(long form_id_, InputInvoice *invoice_)
{
	buf_t buf = buf_add_ui32(0x7998c914);
	//parse argument form_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(form_id_));
	}
	//parse argument invoice (InputInvoice)
	{
		buf = buf_cat(buf, *invoice_);
	}
	return buf;
}

buf_t tl_payments_refundStarsCharge(InputUser *user_id_, const char * charge_id_)
{
	buf_t buf = buf_add_ui32(0x25ae8f4a);
	//parse argument user_id (InputUser)
	{
		buf = buf_cat(buf, *user_id_);
	}
	//parse argument charge_id (string)
	{
		buf = buf_cat(buf, serialize_string(charge_id_));
	}
	return buf;
}

buf_t tl_payments_getStarsRevenueStats(bool dark_, InputPeer *peer_)
{
	buf_t buf = buf_add_ui32(0xd91ffad6);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument dark (true)
	if (dark_)
		*flag1 |= (1 << 0);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_payments_getStarsRevenueWithdrawalUrl(InputPeer *peer_, long stars_, InputCheckPasswordSRP *password_)
{
	buf_t buf = buf_add_ui32(0x13bbe8b3);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument stars (long)
	{
		buf = buf_cat(buf, buf_add_ui64(stars_));
	}
	//parse argument password (InputCheckPasswordSRP)
	{
		buf = buf_cat(buf, *password_);
	}
	return buf;
}

buf_t tl_payments_getStarsRevenueAdsAccountUrl(InputPeer *peer_)
{
	buf_t buf = buf_add_ui32(0xd1d7efc5);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_payments_getStarsTransactionsByID(InputPeer *peer_, InputStarsTransaction *id_, int id_len)
{
	buf_t buf = buf_add_ui32(0x27842d2e);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument id (Vector<InputStarsTransaction>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, id_[i]);
		}
	}
	return buf;
}

buf_t tl_payments_getStarsGiftOptions(InputUser *user_id_)
{
	buf_t buf = buf_add_ui32(0xd3c96bc8);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument user_id (InputUser)
	if (user_id_)
	{
		buf = buf_cat(buf, *user_id_);
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_payments_getStarsSubscriptions(bool missing_balance_, InputPeer *peer_, const char * offset_)
{
	buf_t buf = buf_add_ui32(0x032512c5);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument missing_balance (true)
	if (missing_balance_)
		*flag1 |= (1 << 0);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument offset (string)
	{
		buf = buf_cat(buf, serialize_string(offset_));
	}
	return buf;
}

buf_t tl_payments_changeStarsSubscription(InputPeer *peer_, const char * subscription_id_, Bool *canceled_)
{
	buf_t buf = buf_add_ui32(0xc7770878);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument subscription_id (string)
	{
		buf = buf_cat(buf, serialize_string(subscription_id_));
	}
	//parse argument canceled (Bool)
	if (canceled_)
	{
		buf = buf_cat(buf, *canceled_);
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_payments_fulfillStarsSubscription(InputPeer *peer_, const char * subscription_id_)
{
	buf_t buf = buf_add_ui32(0xcc5bebb3);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument subscription_id (string)
	{
		buf = buf_cat(buf, serialize_string(subscription_id_));
	}
	return buf;
}

buf_t tl_payments_getStarsGiveawayOptions()
{
	buf_t buf = buf_add_ui32(0xbd1efd3e);
	return buf;
}

buf_t tl_payments_getStarGifts(int hash_)
{
	buf_t buf = buf_add_ui32(0xc4563590);
	//parse argument hash (int)
	{
		buf = buf_cat(buf, buf_add_ui32(hash_));
	}
	return buf;
}

buf_t tl_payments_getUserStarGifts(InputUser *user_id_, const char * offset_, int limit_)
{
	buf_t buf = buf_add_ui32(0x5e72c7e1);
	//parse argument user_id (InputUser)
	{
		buf = buf_cat(buf, *user_id_);
	}
	//parse argument offset (string)
	{
		buf = buf_cat(buf, serialize_string(offset_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	return buf;
}

buf_t tl_payments_saveStarGift(bool unsave_, InputUser *user_id_, int msg_id_)
{
	buf_t buf = buf_add_ui32(0x87acf08e);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument unsave (true)
	if (unsave_)
		*flag1 |= (1 << 0);
	//parse argument user_id (InputUser)
	{
		buf = buf_cat(buf, *user_id_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	return buf;
}

buf_t tl_payments_convertStarGift(InputUser *user_id_, int msg_id_)
{
	buf_t buf = buf_add_ui32(0x0421e027);
	//parse argument user_id (InputUser)
	{
		buf = buf_cat(buf, *user_id_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	return buf;
}

buf_t tl_stickers_createStickerSet(bool masks_, bool emojis_, bool text_color_, InputUser *user_id_, const char * title_, const char * short_name_, InputDocument *thumb_, InputStickerSetItem *stickers_, int stickers_len, const char * software_)
{
	buf_t buf = buf_add_ui32(0x9021ab67);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument masks (true)
	if (masks_)
		*flag1 |= (1 << 0);
	//parse argument emojis (true)
	if (emojis_)
		*flag1 |= (1 << 5);
	//parse argument text_color (true)
	if (text_color_)
		*flag1 |= (1 << 6);
	//parse argument user_id (InputUser)
	{
		buf = buf_cat(buf, *user_id_);
	}
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument short_name (string)
	{
		buf = buf_cat(buf, serialize_string(short_name_));
	}
	//parse argument thumb (InputDocument)
	if (thumb_)
	{
		buf = buf_cat(buf, *thumb_);
		*flag1 |= (1 << 2);
	}
	//parse argument stickers (Vector<InputStickerSetItem>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(stickers_len));
		int i;
		for (i=0; i<stickers_len; ++i){
			buf = buf_cat(buf, stickers_[i]);
		}
	}
	//parse argument software (string)
	if (software_)
	{
		buf = buf_cat(buf, serialize_string(software_));
		*flag1 |= (1 << 3);
	}
	return buf;
}

buf_t tl_stickers_removeStickerFromSet(InputDocument *sticker_)
{
	buf_t buf = buf_add_ui32(0xf7760f51);
	//parse argument sticker (InputDocument)
	{
		buf = buf_cat(buf, *sticker_);
	}
	return buf;
}

buf_t tl_stickers_changeStickerPosition(InputDocument *sticker_, int position_)
{
	buf_t buf = buf_add_ui32(0xffb6d4ca);
	//parse argument sticker (InputDocument)
	{
		buf = buf_cat(buf, *sticker_);
	}
	//parse argument position (int)
	{
		buf = buf_cat(buf, buf_add_ui32(position_));
	}
	return buf;
}

buf_t tl_stickers_addStickerToSet(InputStickerSet *stickerset_, InputStickerSetItem *sticker_)
{
	buf_t buf = buf_add_ui32(0x8653febe);
	//parse argument stickerset (InputStickerSet)
	{
		buf = buf_cat(buf, *stickerset_);
	}
	//parse argument sticker (InputStickerSetItem)
	{
		buf = buf_cat(buf, *sticker_);
	}
	return buf;
}

buf_t tl_stickers_setStickerSetThumb(InputStickerSet *stickerset_, InputDocument *thumb_, long thumb_document_id_)
{
	buf_t buf = buf_add_ui32(0xa76a5392);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument stickerset (InputStickerSet)
	{
		buf = buf_cat(buf, *stickerset_);
	}
	//parse argument thumb (InputDocument)
	if (thumb_)
	{
		buf = buf_cat(buf, *thumb_);
		*flag1 |= (1 << 0);
	}
	//parse argument thumb_document_id (long)
	if (thumb_document_id_)
	{
		buf = buf_cat(buf, buf_add_ui64(thumb_document_id_));
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_stickers_checkShortName(const char * short_name_)
{
	buf_t buf = buf_add_ui32(0x284b3639);
	//parse argument short_name (string)
	{
		buf = buf_cat(buf, serialize_string(short_name_));
	}
	return buf;
}

buf_t tl_stickers_suggestShortName(const char * title_)
{
	buf_t buf = buf_add_ui32(0x4dafc503);
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	return buf;
}

buf_t tl_stickers_changeSticker(InputDocument *sticker_, const char * emoji_, MaskCoords *mask_coords_, const char * keywords_)
{
	buf_t buf = buf_add_ui32(0xf5537ebc);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument sticker (InputDocument)
	{
		buf = buf_cat(buf, *sticker_);
	}
	//parse argument emoji (string)
	if (emoji_)
	{
		buf = buf_cat(buf, serialize_string(emoji_));
		*flag1 |= (1 << 0);
	}
	//parse argument mask_coords (MaskCoords)
	if (mask_coords_)
	{
		buf = buf_cat(buf, *mask_coords_);
		*flag1 |= (1 << 1);
	}
	//parse argument keywords (string)
	if (keywords_)
	{
		buf = buf_cat(buf, serialize_string(keywords_));
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_stickers_renameStickerSet(InputStickerSet *stickerset_, const char * title_)
{
	buf_t buf = buf_add_ui32(0x124b1c00);
	//parse argument stickerset (InputStickerSet)
	{
		buf = buf_cat(buf, *stickerset_);
	}
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	return buf;
}

buf_t tl_stickers_deleteStickerSet(InputStickerSet *stickerset_)
{
	buf_t buf = buf_add_ui32(0x87704394);
	//parse argument stickerset (InputStickerSet)
	{
		buf = buf_cat(buf, *stickerset_);
	}
	return buf;
}

buf_t tl_stickers_replaceSticker(InputDocument *sticker_, InputStickerSetItem *new_sticker_)
{
	buf_t buf = buf_add_ui32(0x4696459a);
	//parse argument sticker (InputDocument)
	{
		buf = buf_cat(buf, *sticker_);
	}
	//parse argument new_sticker (InputStickerSetItem)
	{
		buf = buf_cat(buf, *new_sticker_);
	}
	return buf;
}

buf_t tl_phone_getCallConfig()
{
	buf_t buf = buf_add_ui32(0x55451fa9);
	return buf;
}

buf_t tl_phone_requestCall(bool video_, InputUser *user_id_, int random_id_, buf_t *g_a_hash_, PhoneCallProtocol *protocol_)
{
	buf_t buf = buf_add_ui32(0x42ff96ed);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument video (true)
	if (video_)
		*flag1 |= (1 << 0);
	//parse argument user_id (InputUser)
	{
		buf = buf_cat(buf, *user_id_);
	}
	//parse argument random_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(random_id_));
	}
	//parse argument g_a_hash (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(g_a_hash_->data, g_a_hash_->size));
	}
	//parse argument protocol (PhoneCallProtocol)
	{
		buf = buf_cat(buf, *protocol_);
	}
	return buf;
}

buf_t tl_phone_acceptCall(InputPhoneCall *peer_, buf_t *g_b_, PhoneCallProtocol *protocol_)
{
	buf_t buf = buf_add_ui32(0x3bd2b4a0);
	//parse argument peer (InputPhoneCall)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument g_b (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(g_b_->data, g_b_->size));
	}
	//parse argument protocol (PhoneCallProtocol)
	{
		buf = buf_cat(buf, *protocol_);
	}
	return buf;
}

buf_t tl_phone_confirmCall(InputPhoneCall *peer_, buf_t *g_a_, long key_fingerprint_, PhoneCallProtocol *protocol_)
{
	buf_t buf = buf_add_ui32(0x2efe1722);
	//parse argument peer (InputPhoneCall)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument g_a (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(g_a_->data, g_a_->size));
	}
	//parse argument key_fingerprint (long)
	{
		buf = buf_cat(buf, buf_add_ui64(key_fingerprint_));
	}
	//parse argument protocol (PhoneCallProtocol)
	{
		buf = buf_cat(buf, *protocol_);
	}
	return buf;
}

buf_t tl_phone_receivedCall(InputPhoneCall *peer_)
{
	buf_t buf = buf_add_ui32(0x17d54f61);
	//parse argument peer (InputPhoneCall)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_phone_discardCall(bool video_, InputPhoneCall *peer_, int duration_, PhoneCallDiscardReason *reason_, long connection_id_)
{
	buf_t buf = buf_add_ui32(0xb2cbc1c0);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument video (true)
	if (video_)
		*flag1 |= (1 << 0);
	//parse argument peer (InputPhoneCall)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument duration (int)
	{
		buf = buf_cat(buf, buf_add_ui32(duration_));
	}
	//parse argument reason (PhoneCallDiscardReason)
	{
		buf = buf_cat(buf, *reason_);
	}
	//parse argument connection_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(connection_id_));
	}
	return buf;
}

buf_t tl_phone_setCallRating(bool user_initiative_, InputPhoneCall *peer_, int rating_, const char * comment_)
{
	buf_t buf = buf_add_ui32(0x59ead627);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument user_initiative (true)
	if (user_initiative_)
		*flag1 |= (1 << 0);
	//parse argument peer (InputPhoneCall)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument rating (int)
	{
		buf = buf_cat(buf, buf_add_ui32(rating_));
	}
	//parse argument comment (string)
	{
		buf = buf_cat(buf, serialize_string(comment_));
	}
	return buf;
}

buf_t tl_phone_saveCallDebug(InputPhoneCall *peer_, DataJSON *debug_)
{
	buf_t buf = buf_add_ui32(0x277add7e);
	//parse argument peer (InputPhoneCall)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument debug (DataJSON)
	{
		buf = buf_cat(buf, *debug_);
	}
	return buf;
}

buf_t tl_phone_sendSignalingData(InputPhoneCall *peer_, buf_t *data_)
{
	buf_t buf = buf_add_ui32(0xff7a9383);
	//parse argument peer (InputPhoneCall)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument data (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(data_->data, data_->size));
	}
	return buf;
}

buf_t tl_phone_createGroupCall(bool rtmp_stream_, InputPeer *peer_, int random_id_, const char * title_, int schedule_date_)
{
	buf_t buf = buf_add_ui32(0x48cdc6d8);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument rtmp_stream (true)
	if (rtmp_stream_)
		*flag1 |= (1 << 2);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument random_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(random_id_));
	}
	//parse argument title (string)
	if (title_)
	{
		buf = buf_cat(buf, serialize_string(title_));
		*flag1 |= (1 << 0);
	}
	//parse argument schedule_date (int)
	if (schedule_date_)
	{
		buf = buf_cat(buf, buf_add_ui32(schedule_date_));
		*flag1 |= (1 << 1);
	}
	return buf;
}

buf_t tl_phone_joinGroupCall(bool muted_, bool video_stopped_, InputGroupCall *call_, InputPeer *join_as_, const char * invite_hash_, DataJSON *params_)
{
	buf_t buf = buf_add_ui32(0xb132ff7b);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument muted (true)
	if (muted_)
		*flag1 |= (1 << 0);
	//parse argument video_stopped (true)
	if (video_stopped_)
		*flag1 |= (1 << 2);
	//parse argument call (InputGroupCall)
	{
		buf = buf_cat(buf, *call_);
	}
	//parse argument join_as (InputPeer)
	{
		buf = buf_cat(buf, *join_as_);
	}
	//parse argument invite_hash (string)
	if (invite_hash_)
	{
		buf = buf_cat(buf, serialize_string(invite_hash_));
		*flag1 |= (1 << 1);
	}
	//parse argument params (DataJSON)
	{
		buf = buf_cat(buf, *params_);
	}
	return buf;
}

buf_t tl_phone_leaveGroupCall(InputGroupCall *call_, int source_)
{
	buf_t buf = buf_add_ui32(0x500377f9);
	//parse argument call (InputGroupCall)
	{
		buf = buf_cat(buf, *call_);
	}
	//parse argument source (int)
	{
		buf = buf_cat(buf, buf_add_ui32(source_));
	}
	return buf;
}

buf_t tl_phone_inviteToGroupCall(InputGroupCall *call_, InputUser *users_, int users_len)
{
	buf_t buf = buf_add_ui32(0x7b393160);
	//parse argument call (InputGroupCall)
	{
		buf = buf_cat(buf, *call_);
	}
	//parse argument users (Vector<InputUser>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(users_len));
		int i;
		for (i=0; i<users_len; ++i){
			buf = buf_cat(buf, users_[i]);
		}
	}
	return buf;
}

buf_t tl_phone_discardGroupCall(InputGroupCall *call_)
{
	buf_t buf = buf_add_ui32(0x7a777135);
	//parse argument call (InputGroupCall)
	{
		buf = buf_cat(buf, *call_);
	}
	return buf;
}

buf_t tl_phone_toggleGroupCallSettings(bool reset_invite_hash_, InputGroupCall *call_, Bool *join_muted_)
{
	buf_t buf = buf_add_ui32(0x74bbb43d);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument reset_invite_hash (true)
	if (reset_invite_hash_)
		*flag1 |= (1 << 1);
	//parse argument call (InputGroupCall)
	{
		buf = buf_cat(buf, *call_);
	}
	//parse argument join_muted (Bool)
	if (join_muted_)
	{
		buf = buf_cat(buf, *join_muted_);
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_phone_getGroupCall(InputGroupCall *call_, int limit_)
{
	buf_t buf = buf_add_ui32(0x041845db);
	//parse argument call (InputGroupCall)
	{
		buf = buf_cat(buf, *call_);
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	return buf;
}

buf_t tl_phone_getGroupParticipants(InputGroupCall *call_, InputPeer *ids_, int ids_len, int *sources_, int sources_len, const char * offset_, int limit_)
{
	buf_t buf = buf_add_ui32(0xc558d8ab);
	//parse argument call (InputGroupCall)
	{
		buf = buf_cat(buf, *call_);
	}
	//parse argument ids (Vector<InputPeer>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(ids_len));
		int i;
		for (i=0; i<ids_len; ++i){
			buf = buf_cat(buf, ids_[i]);
		}
	}
	//parse argument sources (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(sources_len));
		int i;
		for (i=0; i<sources_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(sources_[i]));
		}
	}
	//parse argument offset (string)
	{
		buf = buf_cat(buf, serialize_string(offset_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	return buf;
}

buf_t tl_phone_checkGroupCall(InputGroupCall *call_, int *sources_, int sources_len)
{
	buf_t buf = buf_add_ui32(0xb59cf977);
	//parse argument call (InputGroupCall)
	{
		buf = buf_cat(buf, *call_);
	}
	//parse argument sources (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(sources_len));
		int i;
		for (i=0; i<sources_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(sources_[i]));
		}
	}
	return buf;
}

buf_t tl_phone_toggleGroupCallRecord(bool start_, bool video_, InputGroupCall *call_, const char * title_, Bool *video_portrait_)
{
	buf_t buf = buf_add_ui32(0xf128c708);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument start (true)
	if (start_)
		*flag1 |= (1 << 0);
	//parse argument video (true)
	if (video_)
		*flag1 |= (1 << 2);
	//parse argument call (InputGroupCall)
	{
		buf = buf_cat(buf, *call_);
	}
	//parse argument title (string)
	if (title_)
	{
		buf = buf_cat(buf, serialize_string(title_));
		*flag1 |= (1 << 1);
	}
	//parse argument video_portrait (Bool)
	if (video_portrait_)
	{
		buf = buf_cat(buf, *video_portrait_);
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_phone_editGroupCallParticipant(InputGroupCall *call_, InputPeer *participant_, Bool *muted_, int volume_, Bool *raise_hand_, Bool *video_stopped_, Bool *video_paused_, Bool *presentation_paused_)
{
	buf_t buf = buf_add_ui32(0xa5273abf);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument call (InputGroupCall)
	{
		buf = buf_cat(buf, *call_);
	}
	//parse argument participant (InputPeer)
	{
		buf = buf_cat(buf, *participant_);
	}
	//parse argument muted (Bool)
	if (muted_)
	{
		buf = buf_cat(buf, *muted_);
		*flag1 |= (1 << 0);
	}
	//parse argument volume (int)
	if (volume_)
	{
		buf = buf_cat(buf, buf_add_ui32(volume_));
		*flag1 |= (1 << 1);
	}
	//parse argument raise_hand (Bool)
	if (raise_hand_)
	{
		buf = buf_cat(buf, *raise_hand_);
		*flag1 |= (1 << 2);
	}
	//parse argument video_stopped (Bool)
	if (video_stopped_)
	{
		buf = buf_cat(buf, *video_stopped_);
		*flag1 |= (1 << 3);
	}
	//parse argument video_paused (Bool)
	if (video_paused_)
	{
		buf = buf_cat(buf, *video_paused_);
		*flag1 |= (1 << 4);
	}
	//parse argument presentation_paused (Bool)
	if (presentation_paused_)
	{
		buf = buf_cat(buf, *presentation_paused_);
		*flag1 |= (1 << 5);
	}
	return buf;
}

buf_t tl_phone_editGroupCallTitle(InputGroupCall *call_, const char * title_)
{
	buf_t buf = buf_add_ui32(0x1ca6ac0a);
	//parse argument call (InputGroupCall)
	{
		buf = buf_cat(buf, *call_);
	}
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	return buf;
}

buf_t tl_phone_getGroupCallJoinAs(InputPeer *peer_)
{
	buf_t buf = buf_add_ui32(0xef7c213a);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_phone_exportGroupCallInvite(bool can_self_unmute_, InputGroupCall *call_)
{
	buf_t buf = buf_add_ui32(0xe6aa647f);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument can_self_unmute (true)
	if (can_self_unmute_)
		*flag1 |= (1 << 0);
	//parse argument call (InputGroupCall)
	{
		buf = buf_cat(buf, *call_);
	}
	return buf;
}

buf_t tl_phone_toggleGroupCallStartSubscription(InputGroupCall *call_, Bool *subscribed_)
{
	buf_t buf = buf_add_ui32(0x219c34e6);
	//parse argument call (InputGroupCall)
	{
		buf = buf_cat(buf, *call_);
	}
	//parse argument subscribed (Bool)
	{
		buf = buf_cat(buf, *subscribed_);
	}
	return buf;
}

buf_t tl_phone_startScheduledGroupCall(InputGroupCall *call_)
{
	buf_t buf = buf_add_ui32(0x5680e342);
	//parse argument call (InputGroupCall)
	{
		buf = buf_cat(buf, *call_);
	}
	return buf;
}

buf_t tl_phone_saveDefaultGroupCallJoinAs(InputPeer *peer_, InputPeer *join_as_)
{
	buf_t buf = buf_add_ui32(0x575e1f8c);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument join_as (InputPeer)
	{
		buf = buf_cat(buf, *join_as_);
	}
	return buf;
}

buf_t tl_phone_joinGroupCallPresentation(InputGroupCall *call_, DataJSON *params_)
{
	buf_t buf = buf_add_ui32(0xcbea6bc4);
	//parse argument call (InputGroupCall)
	{
		buf = buf_cat(buf, *call_);
	}
	//parse argument params (DataJSON)
	{
		buf = buf_cat(buf, *params_);
	}
	return buf;
}

buf_t tl_phone_leaveGroupCallPresentation(InputGroupCall *call_)
{
	buf_t buf = buf_add_ui32(0x1c50d144);
	//parse argument call (InputGroupCall)
	{
		buf = buf_cat(buf, *call_);
	}
	return buf;
}

buf_t tl_phone_getGroupCallStreamChannels(InputGroupCall *call_)
{
	buf_t buf = buf_add_ui32(0x1ab21940);
	//parse argument call (InputGroupCall)
	{
		buf = buf_cat(buf, *call_);
	}
	return buf;
}

buf_t tl_phone_getGroupCallStreamRtmpUrl(InputPeer *peer_, Bool *revoke_)
{
	buf_t buf = buf_add_ui32(0xdeb3abbf);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument revoke (Bool)
	{
		buf = buf_cat(buf, *revoke_);
	}
	return buf;
}

buf_t tl_phone_saveCallLog(InputPhoneCall *peer_, InputFile *file_)
{
	buf_t buf = buf_add_ui32(0x41248786);
	//parse argument peer (InputPhoneCall)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument file (InputFile)
	{
		buf = buf_cat(buf, *file_);
	}
	return buf;
}

buf_t tl_langpack_getLangPack(const char * lang_pack_, const char * lang_code_)
{
	buf_t buf = buf_add_ui32(0xf2f2330a);
	//parse argument lang_pack (string)
	{
		buf = buf_cat(buf, serialize_string(lang_pack_));
	}
	//parse argument lang_code (string)
	{
		buf = buf_cat(buf, serialize_string(lang_code_));
	}
	return buf;
}

buf_t tl_langpack_getStrings(const char * lang_pack_, const char * lang_code_, const char * *keys_, int keys_len)
{
	buf_t buf = buf_add_ui32(0xefea3803);
	//parse argument lang_pack (string)
	{
		buf = buf_cat(buf, serialize_string(lang_pack_));
	}
	//parse argument lang_code (string)
	{
		buf = buf_cat(buf, serialize_string(lang_code_));
	}
	//parse argument keys (Vector<string>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(keys_len));
		int i;
		for (i=0; i<keys_len; ++i){
			buf = buf_cat(buf, serialize_string(keys_[i]));
		}
	}
	return buf;
}

buf_t tl_langpack_getDifference(const char * lang_pack_, const char * lang_code_, int from_version_)
{
	buf_t buf = buf_add_ui32(0xcd984aa5);
	//parse argument lang_pack (string)
	{
		buf = buf_cat(buf, serialize_string(lang_pack_));
	}
	//parse argument lang_code (string)
	{
		buf = buf_cat(buf, serialize_string(lang_code_));
	}
	//parse argument from_version (int)
	{
		buf = buf_cat(buf, buf_add_ui32(from_version_));
	}
	return buf;
}

buf_t tl_langpack_getLanguages(const char * lang_pack_)
{
	buf_t buf = buf_add_ui32(0x42c6978f);
	//parse argument lang_pack (string)
	{
		buf = buf_cat(buf, serialize_string(lang_pack_));
	}
	return buf;
}

buf_t tl_langpack_getLanguage(const char * lang_pack_, const char * lang_code_)
{
	buf_t buf = buf_add_ui32(0x6a596502);
	//parse argument lang_pack (string)
	{
		buf = buf_cat(buf, serialize_string(lang_pack_));
	}
	//parse argument lang_code (string)
	{
		buf = buf_cat(buf, serialize_string(lang_code_));
	}
	return buf;
}

buf_t tl_folders_editPeerFolders(InputFolderPeer *folder_peers_, int folder_peers_len)
{
	buf_t buf = buf_add_ui32(0x6847d0ab);
	//parse argument folder_peers (Vector<InputFolderPeer>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(folder_peers_len));
		int i;
		for (i=0; i<folder_peers_len; ++i){
			buf = buf_cat(buf, folder_peers_[i]);
		}
	}
	return buf;
}

buf_t tl_stats_getBroadcastStats(bool dark_, InputChannel *channel_)
{
	buf_t buf = buf_add_ui32(0xab42441a);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument dark (true)
	if (dark_)
		*flag1 |= (1 << 0);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	return buf;
}

buf_t tl_stats_loadAsyncGraph(const char * token_, long x_)
{
	buf_t buf = buf_add_ui32(0x621d5fa0);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument token (string)
	{
		buf = buf_cat(buf, serialize_string(token_));
	}
	//parse argument x (long)
	if (x_)
	{
		buf = buf_cat(buf, buf_add_ui64(x_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_stats_getMegagroupStats(bool dark_, InputChannel *channel_)
{
	buf_t buf = buf_add_ui32(0xdcdf8607);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument dark (true)
	if (dark_)
		*flag1 |= (1 << 0);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	return buf;
}

buf_t tl_stats_getMessagePublicForwards(InputChannel *channel_, int msg_id_, const char * offset_, int limit_)
{
	buf_t buf = buf_add_ui32(0x5f150144);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	//parse argument offset (string)
	{
		buf = buf_cat(buf, serialize_string(offset_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	return buf;
}

buf_t tl_stats_getMessageStats(bool dark_, InputChannel *channel_, int msg_id_)
{
	buf_t buf = buf_add_ui32(0xb6e0a3f5);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument dark (true)
	if (dark_)
		*flag1 |= (1 << 0);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument msg_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(msg_id_));
	}
	return buf;
}

buf_t tl_stats_getStoryStats(bool dark_, InputPeer *peer_, int id_)
{
	buf_t buf = buf_add_ui32(0x374fef40);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument dark (true)
	if (dark_)
		*flag1 |= (1 << 0);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	return buf;
}

buf_t tl_stats_getStoryPublicForwards(InputPeer *peer_, int id_, const char * offset_, int limit_)
{
	buf_t buf = buf_add_ui32(0xa6437ef6);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument offset (string)
	{
		buf = buf_cat(buf, serialize_string(offset_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	return buf;
}

buf_t tl_stats_getBroadcastRevenueStats(bool dark_, InputChannel *channel_)
{
	buf_t buf = buf_add_ui32(0x75dfb671);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument dark (true)
	if (dark_)
		*flag1 |= (1 << 0);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	return buf;
}

buf_t tl_stats_getBroadcastRevenueWithdrawalUrl(InputChannel *channel_, InputCheckPasswordSRP *password_)
{
	buf_t buf = buf_add_ui32(0x2a65ef73);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument password (InputCheckPasswordSRP)
	{
		buf = buf_cat(buf, *password_);
	}
	return buf;
}

buf_t tl_stats_getBroadcastRevenueTransactions(InputChannel *channel_, int offset_, int limit_)
{
	buf_t buf = buf_add_ui32(0x0069280f);
	//parse argument channel (InputChannel)
	{
		buf = buf_cat(buf, *channel_);
	}
	//parse argument offset (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	return buf;
}

buf_t tl_chatlists_exportChatlistInvite(InputChatlist *chatlist_, const char * title_, InputPeer *peers_, int peers_len)
{
	buf_t buf = buf_add_ui32(0x8472478e);
	//parse argument chatlist (InputChatlist)
	{
		buf = buf_cat(buf, *chatlist_);
	}
	//parse argument title (string)
	{
		buf = buf_cat(buf, serialize_string(title_));
	}
	//parse argument peers (Vector<InputPeer>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(peers_len));
		int i;
		for (i=0; i<peers_len; ++i){
			buf = buf_cat(buf, peers_[i]);
		}
	}
	return buf;
}

buf_t tl_chatlists_deleteExportedInvite(InputChatlist *chatlist_, const char * slug_)
{
	buf_t buf = buf_add_ui32(0x719c5c5e);
	//parse argument chatlist (InputChatlist)
	{
		buf = buf_cat(buf, *chatlist_);
	}
	//parse argument slug (string)
	{
		buf = buf_cat(buf, serialize_string(slug_));
	}
	return buf;
}

buf_t tl_chatlists_editExportedInvite(InputChatlist *chatlist_, const char * slug_, const char * title_, InputPeer *peers_, int peers_len)
{
	buf_t buf = buf_add_ui32(0x653db63d);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument chatlist (InputChatlist)
	{
		buf = buf_cat(buf, *chatlist_);
	}
	//parse argument slug (string)
	{
		buf = buf_cat(buf, serialize_string(slug_));
	}
	//parse argument title (string)
	if (title_)
	{
		buf = buf_cat(buf, serialize_string(title_));
		*flag1 |= (1 << 1);
	}
	//parse argument peers (Vector<InputPeer>)
	if (peers_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(peers_len));
		int i;
		for (i=0; i<peers_len; ++i){
			buf = buf_cat(buf, peers_[i]);
		}
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_chatlists_getExportedInvites(InputChatlist *chatlist_)
{
	buf_t buf = buf_add_ui32(0xce03da83);
	//parse argument chatlist (InputChatlist)
	{
		buf = buf_cat(buf, *chatlist_);
	}
	return buf;
}

buf_t tl_chatlists_checkChatlistInvite(const char * slug_)
{
	buf_t buf = buf_add_ui32(0x41c10fff);
	//parse argument slug (string)
	{
		buf = buf_cat(buf, serialize_string(slug_));
	}
	return buf;
}

buf_t tl_chatlists_joinChatlistInvite(const char * slug_, InputPeer *peers_, int peers_len)
{
	buf_t buf = buf_add_ui32(0xa6b1e39a);
	//parse argument slug (string)
	{
		buf = buf_cat(buf, serialize_string(slug_));
	}
	//parse argument peers (Vector<InputPeer>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(peers_len));
		int i;
		for (i=0; i<peers_len; ++i){
			buf = buf_cat(buf, peers_[i]);
		}
	}
	return buf;
}

buf_t tl_chatlists_getChatlistUpdates(InputChatlist *chatlist_)
{
	buf_t buf = buf_add_ui32(0x89419521);
	//parse argument chatlist (InputChatlist)
	{
		buf = buf_cat(buf, *chatlist_);
	}
	return buf;
}

buf_t tl_chatlists_joinChatlistUpdates(InputChatlist *chatlist_, InputPeer *peers_, int peers_len)
{
	buf_t buf = buf_add_ui32(0xe089f8f5);
	//parse argument chatlist (InputChatlist)
	{
		buf = buf_cat(buf, *chatlist_);
	}
	//parse argument peers (Vector<InputPeer>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(peers_len));
		int i;
		for (i=0; i<peers_len; ++i){
			buf = buf_cat(buf, peers_[i]);
		}
	}
	return buf;
}

buf_t tl_chatlists_hideChatlistUpdates(InputChatlist *chatlist_)
{
	buf_t buf = buf_add_ui32(0x66e486fb);
	//parse argument chatlist (InputChatlist)
	{
		buf = buf_cat(buf, *chatlist_);
	}
	return buf;
}

buf_t tl_chatlists_getLeaveChatlistSuggestions(InputChatlist *chatlist_)
{
	buf_t buf = buf_add_ui32(0xfdbcd714);
	//parse argument chatlist (InputChatlist)
	{
		buf = buf_cat(buf, *chatlist_);
	}
	return buf;
}

buf_t tl_chatlists_leaveChatlist(InputChatlist *chatlist_, InputPeer *peers_, int peers_len)
{
	buf_t buf = buf_add_ui32(0x74fae13a);
	//parse argument chatlist (InputChatlist)
	{
		buf = buf_cat(buf, *chatlist_);
	}
	//parse argument peers (Vector<InputPeer>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(peers_len));
		int i;
		for (i=0; i<peers_len; ++i){
			buf = buf_cat(buf, peers_[i]);
		}
	}
	return buf;
}

buf_t tl_stories_canSendStory(InputPeer *peer_)
{
	buf_t buf = buf_add_ui32(0xc7dfdfdd);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_stories_sendStory(bool pinned_, bool noforwards_, bool fwd_modified_, InputPeer *peer_, InputMedia *media_, MediaArea *media_areas_, int media_areas_len, const char * caption_, MessageEntity *entities_, int entities_len, InputPrivacyRule *privacy_rules_, int privacy_rules_len, long random_id_, int period_, InputPeer *fwd_from_id_, int fwd_from_story_)
{
	buf_t buf = buf_add_ui32(0xe4e6694b);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument pinned (true)
	if (pinned_)
		*flag1 |= (1 << 2);
	//parse argument noforwards (true)
	if (noforwards_)
		*flag1 |= (1 << 4);
	//parse argument fwd_modified (true)
	if (fwd_modified_)
		*flag1 |= (1 << 7);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument media (InputMedia)
	{
		buf = buf_cat(buf, *media_);
	}
	//parse argument media_areas (Vector<MediaArea>)
	if (media_areas_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(media_areas_len));
		int i;
		for (i=0; i<media_areas_len; ++i){
			buf = buf_cat(buf, media_areas_[i]);
		}
		*flag1 |= (1 << 5);
	}
	//parse argument caption (string)
	if (caption_)
	{
		buf = buf_cat(buf, serialize_string(caption_));
		*flag1 |= (1 << 0);
	}
	//parse argument entities (Vector<MessageEntity>)
	if (entities_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(entities_len));
		int i;
		for (i=0; i<entities_len; ++i){
			buf = buf_cat(buf, entities_[i]);
		}
		*flag1 |= (1 << 1);
	}
	//parse argument privacy_rules (Vector<InputPrivacyRule>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(privacy_rules_len));
		int i;
		for (i=0; i<privacy_rules_len; ++i){
			buf = buf_cat(buf, privacy_rules_[i]);
		}
	}
	//parse argument random_id (long)
	{
		buf = buf_cat(buf, buf_add_ui64(random_id_));
	}
	//parse argument period (int)
	if (period_)
	{
		buf = buf_cat(buf, buf_add_ui32(period_));
		*flag1 |= (1 << 3);
	}
	//parse argument fwd_from_id (InputPeer)
	if (fwd_from_id_)
	{
		buf = buf_cat(buf, *fwd_from_id_);
		*flag1 |= (1 << 6);
	}
	//parse argument fwd_from_story (int)
	if (fwd_from_story_)
	{
		buf = buf_cat(buf, buf_add_ui32(fwd_from_story_));
		*flag1 |= (1 << 6);
	}
	return buf;
}

buf_t tl_stories_editStory(InputPeer *peer_, int id_, InputMedia *media_, MediaArea *media_areas_, int media_areas_len, const char * caption_, MessageEntity *entities_, int entities_len, InputPrivacyRule *privacy_rules_, int privacy_rules_len)
{
	buf_t buf = buf_add_ui32(0xb583ba46);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument media (InputMedia)
	if (media_)
	{
		buf = buf_cat(buf, *media_);
		*flag1 |= (1 << 0);
	}
	//parse argument media_areas (Vector<MediaArea>)
	if (media_areas_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(media_areas_len));
		int i;
		for (i=0; i<media_areas_len; ++i){
			buf = buf_cat(buf, media_areas_[i]);
		}
		*flag1 |= (1 << 3);
	}
	//parse argument caption (string)
	if (caption_)
	{
		buf = buf_cat(buf, serialize_string(caption_));
		*flag1 |= (1 << 1);
	}
	//parse argument entities (Vector<MessageEntity>)
	if (entities_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(entities_len));
		int i;
		for (i=0; i<entities_len; ++i){
			buf = buf_cat(buf, entities_[i]);
		}
		*flag1 |= (1 << 1);
	}
	//parse argument privacy_rules (Vector<InputPrivacyRule>)
	if (privacy_rules_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(privacy_rules_len));
		int i;
		for (i=0; i<privacy_rules_len; ++i){
			buf = buf_cat(buf, privacy_rules_[i]);
		}
		*flag1 |= (1 << 2);
	}
	return buf;
}

buf_t tl_stories_deleteStories(InputPeer *peer_, int *id_, int id_len)
{
	buf_t buf = buf_add_ui32(0xae59db5f);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument id (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(id_[i]));
		}
	}
	return buf;
}

buf_t tl_stories_togglePinned(InputPeer *peer_, int *id_, int id_len, Bool *pinned_)
{
	buf_t buf = buf_add_ui32(0x9a75a1ef);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument id (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(id_[i]));
		}
	}
	//parse argument pinned (Bool)
	{
		buf = buf_cat(buf, *pinned_);
	}
	return buf;
}

buf_t tl_stories_getAllStories(bool next_, bool hidden_, const char * state_)
{
	buf_t buf = buf_add_ui32(0xeeb0d625);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument next (true)
	if (next_)
		*flag1 |= (1 << 1);
	//parse argument hidden (true)
	if (hidden_)
		*flag1 |= (1 << 2);
	//parse argument state (string)
	if (state_)
	{
		buf = buf_cat(buf, serialize_string(state_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_stories_getPinnedStories(InputPeer *peer_, int offset_id_, int limit_)
{
	buf_t buf = buf_add_ui32(0x5821a5dc);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument offset_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_id_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	return buf;
}

buf_t tl_stories_getStoriesArchive(InputPeer *peer_, int offset_id_, int limit_)
{
	buf_t buf = buf_add_ui32(0xb4352016);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument offset_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(offset_id_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	return buf;
}

buf_t tl_stories_getStoriesByID(InputPeer *peer_, int *id_, int id_len)
{
	buf_t buf = buf_add_ui32(0x5774ca74);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument id (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(id_[i]));
		}
	}
	return buf;
}

buf_t tl_stories_toggleAllStoriesHidden(Bool *hidden_)
{
	buf_t buf = buf_add_ui32(0x7c2557c4);
	//parse argument hidden (Bool)
	{
		buf = buf_cat(buf, *hidden_);
	}
	return buf;
}

buf_t tl_stories_readStories(InputPeer *peer_, int max_id_)
{
	buf_t buf = buf_add_ui32(0xa556dac8);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument max_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(max_id_));
	}
	return buf;
}

buf_t tl_stories_incrementStoryViews(InputPeer *peer_, int *id_, int id_len)
{
	buf_t buf = buf_add_ui32(0xb2028afb);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument id (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(id_[i]));
		}
	}
	return buf;
}

buf_t tl_stories_getStoryViewsList(bool just_contacts_, bool reactions_first_, bool forwards_first_, InputPeer *peer_, const char * q_, int id_, const char * offset_, int limit_)
{
	buf_t buf = buf_add_ui32(0x7ed23c57);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument just_contacts (true)
	if (just_contacts_)
		*flag1 |= (1 << 0);
	//parse argument reactions_first (true)
	if (reactions_first_)
		*flag1 |= (1 << 2);
	//parse argument forwards_first (true)
	if (forwards_first_)
		*flag1 |= (1 << 3);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument q (string)
	if (q_)
	{
		buf = buf_cat(buf, serialize_string(q_));
		*flag1 |= (1 << 1);
	}
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument offset (string)
	{
		buf = buf_cat(buf, serialize_string(offset_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	return buf;
}

buf_t tl_stories_getStoriesViews(InputPeer *peer_, int *id_, int id_len)
{
	buf_t buf = buf_add_ui32(0x28e16cc8);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument id (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(id_[i]));
		}
	}
	return buf;
}

buf_t tl_stories_exportStoryLink(InputPeer *peer_, int id_)
{
	buf_t buf = buf_add_ui32(0x7b8def20);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	return buf;
}

buf_t tl_stories_report(InputPeer *peer_, int *id_, int id_len, buf_t *option_, const char * message_)
{
	buf_t buf = buf_add_ui32(0x19d8eb45);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument id (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(id_[i]));
		}
	}
	//parse argument option (bytes)
	{
		buf = buf_cat(buf, serialize_bytes(option_->data, option_->size));
	}
	//parse argument message (string)
	{
		buf = buf_cat(buf, serialize_string(message_));
	}
	return buf;
}

buf_t tl_stories_activateStealthMode(bool past_, bool future_)
{
	buf_t buf = buf_add_ui32(0x57bbd166);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument past (true)
	if (past_)
		*flag1 |= (1 << 0);
	//parse argument future (true)
	if (future_)
		*flag1 |= (1 << 1);
	return buf;
}

buf_t tl_stories_sendReaction(bool add_to_recent_, InputPeer *peer_, int story_id_, Reaction *reaction_)
{
	buf_t buf = buf_add_ui32(0x7fd736b2);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument add_to_recent (true)
	if (add_to_recent_)
		*flag1 |= (1 << 0);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument story_id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(story_id_));
	}
	//parse argument reaction (Reaction)
	{
		buf = buf_cat(buf, *reaction_);
	}
	return buf;
}

buf_t tl_stories_getPeerStories(InputPeer *peer_)
{
	buf_t buf = buf_add_ui32(0x2c4ada50);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_stories_getAllReadPeerStories()
{
	buf_t buf = buf_add_ui32(0x9b5ae7f9);
	return buf;
}

buf_t tl_stories_getPeerMaxIDs(InputPeer *id_, int id_len)
{
	buf_t buf = buf_add_ui32(0x535983c3);
	//parse argument id (Vector<InputPeer>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, id_[i]);
		}
	}
	return buf;
}

buf_t tl_stories_getChatsToSend()
{
	buf_t buf = buf_add_ui32(0xa56a8b60);
	return buf;
}

buf_t tl_stories_togglePeerStoriesHidden(InputPeer *peer_, Bool *hidden_)
{
	buf_t buf = buf_add_ui32(0xbd0415c4);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument hidden (Bool)
	{
		buf = buf_cat(buf, *hidden_);
	}
	return buf;
}

buf_t tl_stories_getStoryReactionsList(bool forwards_first_, InputPeer *peer_, int id_, Reaction *reaction_, const char * offset_, int limit_)
{
	buf_t buf = buf_add_ui32(0xb9b2881f);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument forwards_first (true)
	if (forwards_first_)
		*flag1 |= (1 << 2);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument id (int)
	{
		buf = buf_cat(buf, buf_add_ui32(id_));
	}
	//parse argument reaction (Reaction)
	if (reaction_)
	{
		buf = buf_cat(buf, *reaction_);
		*flag1 |= (1 << 0);
	}
	//parse argument offset (string)
	if (offset_)
	{
		buf = buf_cat(buf, serialize_string(offset_));
		*flag1 |= (1 << 1);
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	return buf;
}

buf_t tl_stories_togglePinnedToTop(InputPeer *peer_, int *id_, int id_len)
{
	buf_t buf = buf_add_ui32(0x0b297e9b);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument id (Vector<int>)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(id_len));
		int i;
		for (i=0; i<id_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(id_[i]));
		}
	}
	return buf;
}

buf_t tl_stories_searchPosts(const char * hashtag_, MediaArea *area_, const char * offset_, int limit_)
{
	buf_t buf = buf_add_ui32(0x6cea116a);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument hashtag (string)
	if (hashtag_)
	{
		buf = buf_cat(buf, serialize_string(hashtag_));
		*flag1 |= (1 << 0);
	}
	//parse argument area (MediaArea)
	if (area_)
	{
		buf = buf_cat(buf, *area_);
		*flag1 |= (1 << 1);
	}
	//parse argument offset (string)
	{
		buf = buf_cat(buf, serialize_string(offset_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	return buf;
}

buf_t tl_premium_getBoostsList(bool gifts_, InputPeer *peer_, const char * offset_, int limit_)
{
	buf_t buf = buf_add_ui32(0x60f67660);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument gifts (true)
	if (gifts_)
		*flag1 |= (1 << 0);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument offset (string)
	{
		buf = buf_cat(buf, serialize_string(offset_));
	}
	//parse argument limit (int)
	{
		buf = buf_cat(buf, buf_add_ui32(limit_));
	}
	return buf;
}

buf_t tl_premium_getMyBoosts()
{
	buf_t buf = buf_add_ui32(0x0be77b4a);
	return buf;
}

buf_t tl_premium_applyBoost(int *slots_, int slots_len, InputPeer *peer_)
{
	buf_t buf = buf_add_ui32(0x6b7da746);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument slots (Vector<int>)
	if (slots_)
	{
		buf = buf_cat(buf, tl_vector());
		buf = buf_cat(buf, buf_add_ui32(slots_len));
		int i;
		for (i=0; i<slots_len; ++i){
			buf = buf_cat(buf, buf_add_ui32(slots_[i]));
		}
		*flag1 |= (1 << 0);
	}
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_premium_getBoostsStatus(InputPeer *peer_)
{
	buf_t buf = buf_add_ui32(0x042f1f61);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	return buf;
}

buf_t tl_premium_getUserBoosts(InputPeer *peer_, InputUser *user_id_)
{
	buf_t buf = buf_add_ui32(0x39854d1f);
	//parse argument peer (InputPeer)
	{
		buf = buf_cat(buf, *peer_);
	}
	//parse argument user_id (InputUser)
	{
		buf = buf_cat(buf, *user_id_);
	}
	return buf;
}

buf_t tl_smsjobs_isEligibleToJoin()
{
	buf_t buf = buf_add_ui32(0x0edc39d0);
	return buf;
}

buf_t tl_smsjobs_join()
{
	buf_t buf = buf_add_ui32(0xa74ece2d);
	return buf;
}

buf_t tl_smsjobs_leave()
{
	buf_t buf = buf_add_ui32(0x9898ad73);
	return buf;
}

buf_t tl_smsjobs_updateSettings(bool allow_international_)
{
	buf_t buf = buf_add_ui32(0x093fa0bf);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument allow_international (true)
	if (allow_international_)
		*flag1 |= (1 << 0);
	return buf;
}

buf_t tl_smsjobs_getStatus()
{
	buf_t buf = buf_add_ui32(0x10a698e8);
	return buf;
}

buf_t tl_smsjobs_getSmsJob(const char * job_id_)
{
	buf_t buf = buf_add_ui32(0x778d902f);
	//parse argument job_id (string)
	{
		buf = buf_cat(buf, serialize_string(job_id_));
	}
	return buf;
}

buf_t tl_smsjobs_finishJob(const char * job_id_, const char * error_)
{
	buf_t buf = buf_add_ui32(0x4f1ebf24);
	//parse argument flags ((null))
	ui32_t *flag1 = (ui32_t *)(&buf.data[buf.size]);
	buf = buf_cat(buf, buf_add_ui32(0));
	//parse argument job_id (string)
	{
		buf = buf_cat(buf, serialize_string(job_id_));
	}
	//parse argument error (string)
	if (error_)
	{
		buf = buf_cat(buf, serialize_string(error_));
		*flag1 |= (1 << 0);
	}
	return buf;
}

buf_t tl_fragment_getCollectibleInfo(InputCollectible *collectible_)
{
	buf_t buf = buf_add_ui32(0xbe1e85ba);
	//parse argument collectible (InputCollectible)
	{
		buf = buf_cat(buf, *collectible_);
	}
	return buf;
}

