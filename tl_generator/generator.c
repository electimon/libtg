#include "tl_parser.h"
#include "array.h"
#include <err.h>
#include <stdio.h>
#include <string.h>

#define BLEN 512 

#define STR(buf, len, ...) \
	({snprintf(buf, len-1, __VA_ARGS__); buf[len-1]=0; buf;})

#define METHODS_H "../tg/methods.h"
#define TYPES_H "../tg/types.h"

typedef struct generator_ {
	FILE *methods_h;
	FILE *types_h;
	array_t *type_names;
} generator_t;


int change_dots_to_underline(char *s, int len)
{
	if (!s)
		return 1;
	
	int i;
	char *dot = NULL;
	for (dot = strrchr(s, '.'), i=0;
			 dot && i < len;
			 dot = strrchr(s, '.'), i++)
	{
		*dot = '_';
	}

	return 0;
}

int method_change_dots_to_underline(
		const struct method_t *m)
{
	int i;
	change_dots_to_underline(m->name, BLEN);
	change_dots_to_underline(m->ret, BLEN);
	for (i = 0; i < m->argc; ++i) {
		change_dots_to_underline(m->args[i].name, BLEN);
		change_dots_to_underline(m->args[i].type, BLEN);
	}	

	return 0;
}

int open_types_header(generator_t *g)
{
	g->type_names = 
		array_new(char*, perror("array_new"); return 1);	

	g->types_h = fopen(TYPES_H, "w");
	if (!g->types_h)
		err(1, "can't write to: %s", TYPES_H);	

	fputs("/* generated by tl_generator */\n\n",
		 	g->types_h);
	fputs("#include \"tl_object.h\"\n\n",
		 	g->types_h);
	
	return 0;
}
int append_types_header(
		generator_t *g, const struct method_t *m)
{
	int has_type = 0;
	array_t *a = g->type_names;
	array_for_each(a, char*, name){
		if (strcmp(name, m->ret) == 0){
			has_type = 1;
			break;
		}
	}
	if (!has_type)
		array_append(a, char*, strdup(m->ret), 
				perror("array_append"); return 1);
	
	return 0;
}

int close_types_header(generator_t *g)
{
	char buf[BLEN];
	array_t *a = g->type_names;
	array_for_each(a, char*, name){
		char *p = strstr(name, "Vector<");
		if (p){
			// change Vector to pointer
			p += strlen("Vector<");
			STR(buf, BLEN, "typedef tlo_t * Vector%s;\n", p);
		} else
			STR(buf, BLEN, "typedef tlo_t %s;\n", name);

		fputs(buf, g->types_h);
		free(name);
	}
	fclose(g->types_h);
	return 0;
}


int open_methods_header(generator_t *g)
{
	g->methods_h = fopen(METHODS_H, "w");
	if (!g->methods_h)
		err(1, "can't write to: %s", METHODS_H);	

	fputs("/* generated by tl_generator */\n\n",
		 	g->methods_h);
	fputs("#include \"types.h\"\n\n",
		 	g->methods_h);
	fputs("#define DECL_0() void\n"
			"#define DECL_1(type1, arg1) type1 arg1\n"
			"#define DECL_2(type1, arg1, type2, arg2) "
			"type1 arg1, type2 arg2\n"
			"#define DECL_3(type1, arg1, type2, arg2, type3, arg3) "
			"type1 arg1, type2 arg2, type3 arg3\n"
			"#define DECL_4(type1, arg1, type2, arg2, type3, arg3, type4, arg4) "
			"type1 arg1, type2 arg2, type3 arg3, type4 arg4\n\n"
			, g->methods_h);

	fputs("#define TL_METHODS \\\n", g->methods_h);
	
	return 0;
}

int append_methods_header(
		generator_t *g, const struct method_t *m)
{
	int i;
	char buf[BLEN];
	fputs("\tTL_METHOD(", g->methods_h);
	
	//name
	fputs(STR(buf, BLEN, "%s, ", m->name),
		  	g->methods_h);
	//id
	fputs(STR(buf, BLEN, "0x%.8x, ", m->id),
		  	g->methods_h);
	
	//return
	char *p = strstr(m->ret, "Vector<");
	if (p){
		// change Vector to pointer
		p += strlen("Vector<");
		p[strnlen(p, BLEN)-1] = 0;
		STR(buf, BLEN, "%s*, ", p);
	} else{
		STR(buf, BLEN, "%s, ", m->ret);
	}
	fputs(buf, g->methods_h);
	
	// number of arg
	fputs(STR(buf, BLEN, "%d", m->argc),
		  	g->methods_h);
	
	// arguments
	for (i = 0; i < m->argc; ++i) {
		fputs(", ", g->methods_h);
		char *type = m->args[i].type;
		char *name = m->args[i].name;
		if (!type)
			type = "int";
		if (strcmp(type, "bytes") == 0)
			type = "unsigned char *";
		if (strcmp(type, "string") == 0)
			type = "const char *";
		if (strcmp(type, "Vector<string>") == 0)
			type = "const char **";
		if (strcmp(type, "true") == 0)
			type = "char";
		if (strcmp(name, "private") == 0)
			name = "private_";
		if (strcmp(name, "default") == 0)
			name = "default_";
		char *p = strstr(type, "Vector<");
		if (p){
			// change Vector to pointer
			p += strlen("Vector<");
			p[strnlen(p, BLEN)-1] = 0;
			fputs(STR(buf, BLEN, "%s, ", p),
					g->methods_h);
			fputs(STR(buf, BLEN, "*%s", name),
					g->methods_h);
		} else{
			fputs(STR(buf, BLEN, "%s, ", type),
					g->methods_h);
			fputs(STR(buf, BLEN, "%s", name),
		  	g->methods_h);
		}
	}

	fputs(")\\\n", g->methods_h);
	return 0;
}

int close_methods_header(generator_t *g)
{
	char buf[BLEN];
	// create enum
	fputs("\n\n/* method enumeration */\n",
		 	g->methods_h);
	fputs("enum {\n", g->methods_h);
	fputs("#define TL_METHOD(name, mid, ret, ...) ",
		 	g->methods_h);
	fputs(STR(buf,BLEN, "TL_METHOD_##name = mid,\n"), 
			g->methods_h);
	fputs("\tTL_METHODS\n",	g->methods_h);
	fputs("#undef TL_METHOD\n",	g->methods_h);
	fputs("};\n", g->methods_h);

	// create methods
	fputs("\n\n/* method declaration */\n",
		 	g->methods_h);
	fputs("#define TL_METHOD(name, mid, ret, nargs, ...) ",
		 	g->methods_h);
	fputs(STR(buf,BLEN, "ret tl_method_##name ( DECL_##nargs(__VA_ARGS__) );\n"), 
			g->methods_h);
	fputs("\tTL_METHODS\n",	g->methods_h);
	fputs("#undef TL_METHOD\n",	g->methods_h);
	
	fclose(g->methods_h);
	return 0;
}

int callback(
		void *userdata,
		const struct method_t *m,
		const char *error)
{
	if (error){
		warn("%s", error);
		return 0;
	}

	generator_t *g = userdata;

	printf("generate method: ");
	printf("%.8x: ", m->id);
	printf("%s: ", m->name);
	int i;
	for (i = 0; i < m->argc; ++i) {
		printf("%s:%s ", 
				m->args[i].name, m->args[i].type);
	}
	printf("-> %s\n", m->ret);

	method_change_dots_to_underline(m);
	
	append_methods_header(g, m);
	append_types_header(g, m);

	return 0;
}

int main(int argc, char *argv[])
{
	generator_t g;
	
	if (open_methods_header(&g))
		return 1;
	if (open_types_header(&g))
		return 1;

	tl_parse("telegram_api.tl", &g, callback);

	close_methods_header(&g);
	close_types_header(&g);
	return 0;
}
